import {
  require_jsx_runtime
} from "./chunk-RLMGAKMB.js";
import {
  require_react_dom
} from "./chunk-QSNGHKXR.js";
import {
  ArrowDownRegular,
  ArrowUpRegular,
  Checkmark12Filled,
  Checkmark16Filled,
  CheckmarkCircle12Filled,
  CheckmarkCircleFilled,
  CheckmarkFilled,
  ChevronDown16Regular,
  ChevronDown20Regular,
  ChevronDownRegular,
  ChevronLeftFilled,
  ChevronLeftRegular,
  ChevronRight12Regular,
  ChevronRightFilled,
  ChevronRightRegular,
  ChevronUp16Regular,
  CircleFilled,
  Dismiss12Regular,
  Dismiss20Regular,
  DismissCircleFilled,
  DismissFilled,
  DismissRegular,
  ErrorCircle12Filled,
  IconDirectionContextProvider,
  Info12Filled,
  Info12Regular,
  Info16Filled,
  Info16Regular,
  Info20Filled,
  Info20Regular,
  InfoFilled,
  Lightbulb16Regular,
  MoreHorizontalFilled,
  MoreHorizontalRegular,
  Navigation20Filled,
  PauseCircleRegular,
  PersonRegular,
  Pin20Regular,
  PlayCircleRegular,
  PresenceAvailable10Filled,
  PresenceAvailable10Regular,
  PresenceAvailable12Filled,
  PresenceAvailable12Regular,
  PresenceAvailable16Filled,
  PresenceAvailable16Regular,
  PresenceAvailable20Filled,
  PresenceAvailable20Regular,
  PresenceAway10Filled,
  PresenceAway10Regular,
  PresenceAway12Filled,
  PresenceAway12Regular,
  PresenceAway16Filled,
  PresenceAway16Regular,
  PresenceAway20Filled,
  PresenceAway20Regular,
  PresenceBlocked10Regular,
  PresenceBlocked12Regular,
  PresenceBlocked16Regular,
  PresenceBlocked20Regular,
  PresenceBusy10Filled,
  PresenceBusy12Filled,
  PresenceBusy16Filled,
  PresenceBusy20Filled,
  PresenceDnd10Filled,
  PresenceDnd10Regular,
  PresenceDnd12Filled,
  PresenceDnd12Regular,
  PresenceDnd16Filled,
  PresenceDnd16Regular,
  PresenceDnd20Filled,
  PresenceDnd20Regular,
  PresenceOffline10Regular,
  PresenceOffline12Regular,
  PresenceOffline16Regular,
  PresenceOffline20Regular,
  PresenceOof10Regular,
  PresenceOof12Regular,
  PresenceOof16Regular,
  PresenceOof20Regular,
  PresenceUnknown10Regular,
  PresenceUnknown12Regular,
  PresenceUnknown16Regular,
  PresenceUnknown20Regular,
  ProhibitedFilled,
  RendererProvider,
  SearchRegular,
  Square12Filled,
  Square16Filled,
  StarFilled,
  StarRegular,
  TextDirectionProvider,
  Warning12Filled,
  WarningFilled,
  __css,
  __resetCSS,
  __resetStyles,
  __styles,
  __styles2,
  bundleIcon_default,
  createDOMRenderer,
  iconFilledClassName,
  iconRegularClassName,
  makeResetStyles,
  makeStaticStyles,
  makeStyles,
  mergeClasses,
  renderToStyleElements,
  shorthands,
  useRenderer
} from "./chunk-PHGJ5F44.js";
import {
  __commonJS,
  __export,
  __toESM,
  require_react
} from "./chunk-2YIMICFJ.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var enableScopeAPI = false;
        function isValidElementType2(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment11 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment11;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType2;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          siftUp(heap, node, index);
        }
        function peek(heap) {
          return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
          if (heap.length === 0) {
            return null;
          }
          var first = heap[0];
          var last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            siftDown(heap, last, 0);
          }
          return first;
        }
        function siftUp(heap, node, i) {
          var index = i;
          while (index > 0) {
            var parentIndex = index - 1 >>> 1;
            var parent2 = heap[parentIndex];
            if (compare(parent2, node) > 0) {
              heap[parentIndex] = node;
              heap[index] = parent2;
              index = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node, i) {
          var index = i;
          var length = heap.length;
          var halfLength = length >>> 1;
          while (index < halfLength) {
            var leftIndex = (index + 1) * 2 - 1;
            var left2 = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right2 = heap[rightIndex];
            if (compare(left2, node) < 0) {
              if (rightIndex < length && compare(right2, left2) < 0) {
                heap[index] = right2;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                heap[index] = left2;
                heap[leftIndex] = node;
                index = leftIndex;
              }
            } else if (rightIndex < length && compare(right2, node) < 0) {
              heap[index] = right2;
              heap[rightIndex] = node;
              index = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return diff !== 0 ? diff : a.id - b.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority2 = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms) {
        }
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority2;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
        var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error) {
                if (currentTask !== null) {
                  var currentTime = exports.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority2:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority2;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority2:
              priorityLevel = NormalPriority2;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime2;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime2 = currentTime + delay;
            } else {
              startTime2 = currentTime;
            }
          } else {
            startTime2 = currentTime;
          }
          var timeout2;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout2 = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout2 = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout2 = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout2 = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority2:
            default:
              timeout2 = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime2 + timeout2;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime2,
            expirationTime,
            sortIndex: -1
          };
          if (startTime2 > currentTime) {
            newTask.sortIndex = startTime2;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime2 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
          var timeElapsed = exports.unstable_now() - startTime;
          if (timeElapsed < frameInterval) {
            return false;
          }
          return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
          if (fps < 0 || fps > 125) {
            console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          if (fps > 0) {
            frameInterval = Math.floor(1e3 / fps);
          } else {
            frameInterval = frameYieldMs;
          }
        }
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasTimeRemaining = true;
            var hasMoreWork = true;
            try {
              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
              if (hasMoreWork) {
                schedulePerformWorkUntilDeadline();
              } else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
              }
            }
          } else {
            isMessageLoopRunning = false;
          }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === "function") {
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else {
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        }
        function requestHostCallback(callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
          }
        }
        function requestHostTimeout(callback, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms);
        }
        function cancelHostTimeout() {
          localClearTimeout(taskTimeoutID);
          taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority2;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_scheduler_development();
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React668.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState40({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect3(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect60(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React668 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState40 = React668.useState, useEffect60 = React668.useEffect, useLayoutEffect3 = React668.useLayoutEffect, useDebugValue = React668.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React668.useSyncExternalStore ? React668.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development2 = __commonJS({
  "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType2(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment11 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment11;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType2;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/prop-types/node_modules/react-is/index.js
var require_react_is2 = __commonJS({
  "node_modules/prop-types/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development2();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values2, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is2();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement10, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement10(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName2(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode2(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode2(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode2);
            }
            if (propValue === null || isValidElement10(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode2(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode2(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName2(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is2();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/createCSSRuleFromTheme.js
function createCSSRuleFromTheme(selector, theme) {
  if (theme) {
    const cssVarsAsString = Object.keys(theme).reduce((cssVarRule, cssVar) => {
      return `${cssVarRule}--${cssVar}: ${theme[cssVar]}; `;
    }, "");
    return `${selector} { ${cssVarsAsString} }`;
  }
  return `${selector} {}`;
}

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/FluentProvider.js
var React58 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/compose/slot.js
var slot_exports = {};
__export(slot_exports, {
  always: () => always,
  optional: () => optional,
  resolveShorthand: () => resolveShorthand
});
var React = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/compose/constants.js
var SLOT_RENDER_FUNCTION_SYMBOL = Symbol.for("fui.slotRenderFunction");
var SLOT_ELEMENT_TYPE_SYMBOL = Symbol.for("fui.slotElementType");
var SLOT_CLASS_NAME_PROP_SYMBOL = Symbol.for("fui.slotClassNameProp");

// node_modules/@fluentui/react-utilities/lib/compose/slot.js
function always(value, options) {
  const { defaultProps: defaultProps2, elementType } = options;
  const props = resolveShorthand(value);
  const propsWithMetadata = {
    ...defaultProps2,
    ...props,
    [SLOT_ELEMENT_TYPE_SYMBOL]: elementType,
    [SLOT_CLASS_NAME_PROP_SYMBOL]: props === null || props === void 0 ? void 0 : props.className
  };
  if (props && typeof props.children === "function") {
    propsWithMetadata[SLOT_RENDER_FUNCTION_SYMBOL] = props.children;
    propsWithMetadata.children = defaultProps2 === null || defaultProps2 === void 0 ? void 0 : defaultProps2.children;
  }
  return propsWithMetadata;
}
function optional(value, options) {
  if (value === null || value === void 0 && !options.renderByDefault) {
    return void 0;
  }
  return always(value, options);
}
function resolveShorthand(value) {
  if (typeof value === "string" || typeof value === "number" || isIterable(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
  React.isValidElement(value)) {
    return {
      children: value
    };
  }
  if (value && typeof value !== "object" && true) {
    console.error(`@fluentui/react-utilities [slot.${resolveShorthand.name}]:
A slot got an invalid value "${value}" (${typeof value}).
A valid value for a slot is a slot shorthand or slot properties object.
Slot shorthands can be strings, numbers, arrays or JSX elements`);
  }
  return value;
}
var isIterable = (value) => typeof value === "object" && value !== null && Symbol.iterator in value;

// node_modules/@fluentui/react-utilities/lib/compose/isResolvedShorthand.js
var React2 = __toESM(require_react());
function isResolvedShorthand(shorthand) {
  return shorthand !== null && typeof shorthand === "object" && !Array.isArray(shorthand) && !React2.isValidElement(shorthand);
}

// node_modules/@fluentui/react-utilities/lib/compose/isSlot.js
function isSlot(element) {
  return Boolean(element === null || element === void 0 ? void 0 : element.hasOwnProperty(SLOT_ELEMENT_TYPE_SYMBOL));
}

// node_modules/@fluentui/react-utilities/lib/compose/assertSlots.js
var React3 = __toESM(require_react());
function assertSlots(state) {
  if (true) {
    const typedState = state;
    for (const slotName of Object.keys(typedState.components)) {
      const slotElement = typedState[slotName];
      if (slotElement === void 0) {
        continue;
      }
      if (!isSlot(slotElement)) {
        typedState[slotName] = always(slotElement, {
          // eslint-disable-next-line @typescript-eslint/no-deprecated
          elementType: typedState.components[slotName]
        });
        console.warn(`@fluentui/react-utilities [${assertSlots.name}]:
"state.${slotName}" is not a slot!
Be sure to create slots properly by using "slot.always" or "slot.optional".`);
      } else {
        const { [SLOT_ELEMENT_TYPE_SYMBOL]: elementType } = slotElement;
        if (elementType !== typedState.components[slotName]) {
          slotElement[SLOT_ELEMENT_TYPE_SYMBOL] = typedState.components[slotName];
          console.warn(`@fluentui/react-utilities [${assertSlots.name}]:
"state.${slotName}" element type differs from "state.components.${slotName}",
${elementType} !== ${typedState.components[slotName]}.
Be sure to create slots properly by using "slot.always" or "slot.optional" with the correct elementType.`);
        }
      }
    }
  }
}

// node_modules/@fluentui/react-utilities/lib/compose/getIntrinsicElementProps.js
var React5 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/utils/getNativeElementProps.js
var React4 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/utils/properties.js
var toObjectMap = (...items) => {
  const result = {};
  for (const item of items) {
    const keys = Array.isArray(item) ? item : Object.keys(item);
    for (const key of keys) {
      result[key] = 1;
    }
  }
  return result;
};
var baseElementEvents = toObjectMap([
  "onAuxClick",
  "onAnimationEnd",
  "onAnimationStart",
  "onCopy",
  "onCut",
  "onPaste",
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate",
  "onFocus",
  "onFocusCapture",
  "onBlur",
  "onBlurCapture",
  "onChange",
  "onInput",
  "onSubmit",
  "onLoad",
  "onError",
  "onKeyDown",
  "onKeyDownCapture",
  "onKeyPress",
  "onKeyUp",
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting",
  "onClick",
  "onClickCapture",
  "onContextMenu",
  "onDoubleClick",
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop",
  "onMouseDown",
  "onMouseDownCapture",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  "onMouseUpCapture",
  "onSelect",
  "onTouchCancel",
  "onTouchEnd",
  "onTouchMove",
  "onTouchStart",
  "onScroll",
  "onWheel",
  "onPointerCancel",
  "onPointerDown",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerMove",
  "onPointerOut",
  "onPointerOver",
  "onPointerUp",
  "onGotPointerCapture",
  "onLostPointerCapture"
]);
var baseElementProperties = toObjectMap([
  "accessKey",
  "children",
  "className",
  "contentEditable",
  "dir",
  "draggable",
  "hidden",
  "htmlFor",
  "id",
  "lang",
  "ref",
  "role",
  "style",
  "tabIndex",
  "title",
  "translate",
  "spellCheck",
  "name"
]);
var microdataProperties = toObjectMap([
  "itemID",
  "itemProp",
  "itemRef",
  "itemScope",
  "itemType"
]);
var htmlElementProperties = toObjectMap(baseElementProperties, baseElementEvents, microdataProperties);
var labelProperties = toObjectMap(htmlElementProperties, [
  "form"
]);
var audioProperties = toObjectMap(htmlElementProperties, [
  "height",
  "loop",
  "muted",
  "preload",
  "src",
  "width"
]);
var videoProperties = toObjectMap(audioProperties, [
  "poster"
]);
var olProperties = toObjectMap(htmlElementProperties, [
  "start"
]);
var liProperties = toObjectMap(htmlElementProperties, [
  "value"
]);
var anchorProperties = toObjectMap(htmlElementProperties, [
  "download",
  "href",
  "hrefLang",
  "media",
  "rel",
  "target",
  "type"
]);
var timeProperties = toObjectMap(htmlElementProperties, [
  "dateTime"
]);
var buttonProperties = toObjectMap(htmlElementProperties, [
  "autoFocus",
  "disabled",
  "form",
  "formAction",
  "formEncType",
  "formMethod",
  "formNoValidate",
  "formTarget",
  "type",
  "value"
]);
var inputProperties = toObjectMap(buttonProperties, [
  "accept",
  "alt",
  "autoCorrect",
  "autoCapitalize",
  "autoComplete",
  "checked",
  "dirname",
  "form",
  "height",
  "inputMode",
  "list",
  "max",
  "maxLength",
  "min",
  "minLength",
  "multiple",
  "pattern",
  "placeholder",
  "readOnly",
  "required",
  "src",
  "step",
  "size",
  "type",
  "value",
  "width"
]);
var textAreaProperties = toObjectMap(buttonProperties, [
  "autoCapitalize",
  "cols",
  "dirname",
  "form",
  "maxLength",
  "placeholder",
  "readOnly",
  "required",
  "rows",
  "wrap"
]);
var selectProperties = toObjectMap(buttonProperties, [
  "form",
  "multiple",
  "required"
]);
var optionProperties = toObjectMap(htmlElementProperties, [
  "selected",
  "value"
]);
var tableProperties = toObjectMap(htmlElementProperties, [
  "cellPadding",
  "cellSpacing"
]);
var trProperties = htmlElementProperties;
var thProperties = toObjectMap(htmlElementProperties, [
  "colSpan",
  "rowSpan",
  "scope"
]);
var tdProperties = toObjectMap(htmlElementProperties, [
  "colSpan",
  "headers",
  "rowSpan",
  "scope"
]);
var colGroupProperties = toObjectMap(htmlElementProperties, [
  "span"
]);
var colProperties = toObjectMap(htmlElementProperties, [
  "span"
]);
var fieldsetProperties = toObjectMap(htmlElementProperties, [
  "disabled",
  "form"
]);
var formProperties = toObjectMap(htmlElementProperties, [
  "acceptCharset",
  "action",
  "encType",
  "encType",
  "method",
  "noValidate",
  "target"
]);
var iframeProperties = toObjectMap(htmlElementProperties, [
  "allow",
  "allowFullScreen",
  "allowPaymentRequest",
  "allowTransparency",
  "csp",
  "height",
  "importance",
  "referrerPolicy",
  "sandbox",
  "src",
  "srcDoc",
  "width"
]);
var imgProperties = toObjectMap(htmlElementProperties, [
  "alt",
  "crossOrigin",
  "height",
  "src",
  "srcSet",
  "useMap",
  "width"
]);
var dialogProperties = toObjectMap(htmlElementProperties, [
  "open",
  "onCancel",
  "onClose"
]);
function getNativeProps(props, allowedPropNames, excludedPropNames) {
  const isArray = Array.isArray(allowedPropNames);
  const result = {};
  const keys = Object.keys(props);
  for (const key of keys) {
    const isNativeProp = !isArray && allowedPropNames[key] || isArray && allowedPropNames.indexOf(key) >= 0 || key.indexOf("data-") === 0 || key.indexOf("aria-") === 0;
    if (isNativeProp && (!excludedPropNames || (excludedPropNames === null || excludedPropNames === void 0 ? void 0 : excludedPropNames.indexOf(key)) === -1)) {
      result[key] = props[key];
    }
  }
  return result;
}

// node_modules/@fluentui/react-utilities/lib/utils/getNativeElementProps.js
var nativeElementMap = {
  label: labelProperties,
  audio: audioProperties,
  video: videoProperties,
  ol: olProperties,
  li: liProperties,
  a: anchorProperties,
  button: buttonProperties,
  input: inputProperties,
  textarea: textAreaProperties,
  select: selectProperties,
  option: optionProperties,
  table: tableProperties,
  tr: trProperties,
  th: thProperties,
  td: tdProperties,
  colGroup: colGroupProperties,
  col: colProperties,
  fieldset: fieldsetProperties,
  form: formProperties,
  iframe: iframeProperties,
  img: imgProperties,
  time: timeProperties,
  dialog: dialogProperties
};
function getNativeElementProps(tagName, props, excludedPropNames) {
  const allowedPropNames = tagName && nativeElementMap[tagName] || htmlElementProperties;
  allowedPropNames.as = 1;
  return getNativeProps(props, allowedPropNames, excludedPropNames);
}
var getPartitionedNativeProps = ({ primarySlotTagName, props, excludedPropNames }) => {
  return {
    root: {
      style: props.style,
      className: props.className
    },
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    primary: getNativeElementProps(primarySlotTagName, props, [
      ...excludedPropNames || [],
      "style",
      "className"
    ])
  };
};

// node_modules/@fluentui/react-utilities/lib/compose/getIntrinsicElementProps.js
var getIntrinsicElementProps = (tagName, props, excludedPropNames) => {
  var _props_as;
  return getNativeElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : tagName, props, excludedPropNames);
};

// node_modules/@fluentui/react-utilities/lib/compose/getSlotClassNameProp.js
var getSlotClassNameProp = (slot) => {
  if (SLOT_CLASS_NAME_PROP_SYMBOL in slot && typeof slot[SLOT_CLASS_NAME_PROP_SYMBOL] === "string") {
    return slot[SLOT_CLASS_NAME_PROP_SYMBOL];
  }
  return void 0;
};

// node_modules/@fluentui/react-utilities/lib/compose/deprecated/getSlots.js
var React6 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/utils/omit.js
function omit(obj, exclusions) {
  const result = {};
  for (const key in obj) {
    if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) {
      result[key] = obj[key];
    }
  }
  return result;
}

// node_modules/@fluentui/react-utilities/lib/compose/deprecated/getSlots.js
function getSlots(state) {
  const typeState = state;
  const slots = {};
  const slotProps = {};
  const slotNames = Object.keys(typeState.components);
  for (const slotName of slotNames) {
    const [slot, props] = getSlot(typeState, slotName);
    slots[slotName] = slot;
    slotProps[slotName] = props;
  }
  return {
    slots,
    slotProps
  };
}
function getSlot(state, slotName) {
  var _state_components, _state_components1;
  const props = state[slotName];
  if (props === void 0) {
    return [
      null,
      void 0
    ];
  }
  const { as: asProp, children: children2, ...rest } = props;
  const renderFunction = isSlot(props) ? props[SLOT_RENDER_FUNCTION_SYMBOL] : void 0;
  const slot = ((_state_components = state.components) === null || _state_components === void 0 ? void 0 : _state_components[slotName]) === void 0 || // eslint-disable-line @typescript-eslint/no-deprecated
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  typeof state.components[slotName] === "string" ? asProp || ((_state_components1 = state.components) === null || _state_components1 === void 0 ? void 0 : _state_components1[slotName]) || "div" : state.components[slotName];
  const asserted = slot;
  if (renderFunction || typeof children2 === "function") {
    const render = renderFunction || children2;
    return [
      React6.Fragment,
      {
        children: render(asserted, rest)
      }
    ];
  }
  const shouldOmitAsProp = typeof slot === "string" && asProp;
  const slotProps = shouldOmitAsProp ? omit(props, [
    "as"
  ]) : props;
  return [
    asserted,
    slotProps
  ];
}

// node_modules/@fluentui/react-utilities/lib/compose/deprecated/resolveShorthand.js
var resolveShorthand2 = (value, options) => optional(value, {
  ...options,
  renderByDefault: options === null || options === void 0 ? void 0 : options.required,
  // elementType as undefined is the way to identify between a slot and a resolveShorthand call
  // in the case elementType is undefined assertSlots will fail, ensuring it'll only work with slot method.
  elementType: void 0
});

// node_modules/@fluentui/react-utilities/lib/compose/deprecated/getSlotsNext.js
var React7 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/hooks/useBrowserTimer.js
var React8 = __toESM(require_react());
function useBrowserTimer(setTimer, cancelTimer) {
  const id = React8.useRef(void 0);
  const set = React8.useCallback((fn, delay) => {
    if (id.current !== void 0) {
      cancelTimer(id.current);
    }
    id.current = setTimer(fn, delay);
    return id.current;
  }, [
    cancelTimer,
    setTimer
  ]);
  const cancel = React8.useCallback(() => {
    if (id.current !== void 0) {
      cancelTimer(id.current);
      id.current = void 0;
    }
  }, [
    cancelTimer
  ]);
  React8.useEffect(() => cancel, [
    cancel
  ]);
  return [
    set,
    cancel
  ];
}

// node_modules/@fluentui/react-shared-contexts/lib/ThemeContext/ThemeContext.js
var React9 = __toESM(require_react());
var ThemeContext = React9.createContext(void 0);
var ThemeProvider = ThemeContext.Provider;

// node_modules/@fluentui/react-shared-contexts/lib/ThemeClassNameContext/ThemeClassNameContext.js
var React10 = __toESM(require_react());
var ThemeClassNameContext = React10.createContext(void 0);
var themeClassNameContextDefaultVaue = "";
var ThemeClassNameProvider = ThemeClassNameContext.Provider;
function useThemeClassName() {
  var _React_useContext;
  return (_React_useContext = React10.useContext(ThemeClassNameContext)) !== null && _React_useContext !== void 0 ? _React_useContext : themeClassNameContextDefaultVaue;
}

// node_modules/@fluentui/react-shared-contexts/lib/TooltipVisibilityContext/TooltipContext.js
var React11 = __toESM(require_react());
var TooltipVisibilityContext = React11.createContext(void 0);
var tooltipVisibilityContextDefaultValue = {};
var TooltipVisibilityProvider = TooltipVisibilityContext.Provider;
function useTooltipVisibility() {
  var _React_useContext;
  return (_React_useContext = React11.useContext(TooltipVisibilityContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tooltipVisibilityContextDefaultValue;
}

// node_modules/@fluentui/react-shared-contexts/lib/ProviderContext/ProviderContext.js
var React12 = __toESM(require_react());
var ProviderContext = React12.createContext(void 0);
var providerContextDefaultValue = {
  // eslint-disable-next-line @nx/workspace-no-restricted-globals -- expected ignore ( SSR friendly acquisition of globals )
  targetDocument: typeof document === "object" ? document : void 0,
  dir: "ltr"
};
var Provider = ProviderContext.Provider;
function useFluent() {
  var _React_useContext;
  return (_React_useContext = React12.useContext(ProviderContext)) !== null && _React_useContext !== void 0 ? _React_useContext : providerContextDefaultValue;
}

// node_modules/@fluentui/react-shared-contexts/lib/OverridesContext/OverridesContext.js
var React13 = __toESM(require_react());
var OverridesContext = React13.createContext(void 0);
var OverridesProvider = OverridesContext.Provider;
function useOverrides() {
  var _React_useContext;
  return (_React_useContext = React13.useContext(OverridesContext)) !== null && _React_useContext !== void 0 ? _React_useContext : {};
}

// node_modules/@fluentui/react-shared-contexts/lib/CustomStyleHooksContext/CustomStyleHooksContext.js
var React14 = __toESM(require_react());
var CustomStyleHooksContext = React14.createContext(void 0);
var noop = () => {
};
var CustomStyleHooksProvider = CustomStyleHooksContext.Provider;
var useCustomStyleHook = (hook) => {
  var _React_useContext;
  var _React_useContext_hook;
  return (_React_useContext_hook = (_React_useContext = React14.useContext(CustomStyleHooksContext)) === null || _React_useContext === void 0 ? void 0 : _React_useContext[hook]) !== null && _React_useContext_hook !== void 0 ? _React_useContext_hook : noop;
};

// node_modules/@fluentui/react-shared-contexts/lib/BackgroundAppearanceContext/BackgroundAppearanceContext.js
var React15 = __toESM(require_react());
var BackgroundAppearanceContext = React15.createContext(void 0);
var BackgroundAppearanceProvider = BackgroundAppearanceContext.Provider;
function useBackgroundAppearance() {
  return React15.useContext(BackgroundAppearanceContext);
}

// node_modules/@fluentui/react-shared-contexts/lib/PortalMountNodeContext.js
var React16 = __toESM(require_react());
var PortalMountNodeContext = React16.createContext(void 0);
var PortalMountNodeProvider = PortalMountNodeContext.Provider;
function usePortalMountNode() {
  return React16.useContext(PortalMountNodeContext);
}

// node_modules/@fluentui/react-shared-contexts/lib/AnnounceContext/AnnounceContext.js
var React17 = __toESM(require_react());
var AnnounceContext = React17.createContext(void 0);
var AnnounceProvider = AnnounceContext.Provider;
function useAnnounce() {
  var _React_useContext;
  return (_React_useContext = React17.useContext(AnnounceContext)) !== null && _React_useContext !== void 0 ? _React_useContext : {
    announce: () => void 0
  };
}

// node_modules/@fluentui/react-utilities/lib/hooks/useAnimationFrame.js
var setAnimationFrameNoop = (callback) => {
  callback(0);
  return 0;
};
var cancelAnimationFrameNoop = (handle) => handle;
function useAnimationFrame() {
  const { targetDocument } = useFluent();
  const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
  const setAnimationFrame = win ? win.requestAnimationFrame : setAnimationFrameNoop;
  const clearAnimationFrame = win ? win.cancelAnimationFrame : cancelAnimationFrameNoop;
  return useBrowserTimer(setAnimationFrame, clearAnimationFrame);
}

// node_modules/@fluentui/react-utilities/lib/hooks/useControllableState.js
var React18 = __toESM(require_react());
function isFactoryDispatch(newState) {
  return typeof newState === "function";
}
var useControllableState = (options) => {
  "use no memo";
  if (true) {
    if (options.state !== void 0 && options.defaultState !== void 0) {
      console.error(`@fluentui/react-utilities [useControllableState]:
A component must be either controlled or uncontrolled (specify either the state or the defaultState, but not both).
Decide between using a controlled or uncontrolled component and remove one of this props.
More info: https://reactjs.org/link/controlled-components
${new Error().stack}`);
    }
  }
  const [internalState, setInternalState] = React18.useState(() => {
    if (options.defaultState === void 0) {
      return options.initialState;
    }
    return isInitializer(options.defaultState) ? options.defaultState() : options.defaultState;
  });
  const stateValueRef = React18.useRef(options.state);
  React18.useEffect(() => {
    stateValueRef.current = options.state;
  }, [
    options.state
  ]);
  const setControlledState = React18.useCallback((newState) => {
    if (isFactoryDispatch(newState)) {
      newState(stateValueRef.current);
    }
  }, []);
  return useIsControlled(options.state) ? [
    options.state,
    setControlledState
  ] : [
    internalState,
    setInternalState
  ];
};
function isInitializer(value) {
  return typeof value === "function";
}
var useIsControlled = (controlledValue) => {
  "use no memo";
  const [isControlled] = React18.useState(() => controlledValue !== void 0);
  if (true) {
    React18.useEffect(() => {
      if (isControlled !== (controlledValue !== void 0)) {
        const error = new Error();
        const controlWarning = isControlled ? "a controlled value to be uncontrolled" : "an uncontrolled value to be controlled";
        const undefinedWarning = isControlled ? "defined to an undefined" : "undefined to a defined";
        console.error(`@fluentui/react-utilities [useControllableState]:
A component is changing ${controlWarning}. This is likely caused by the value changing from ${undefinedWarning} value, which should not happen.
Decide between using a controlled or uncontrolled input element for the lifetime of the component.
More info: https://reactjs.org/link/controlled-components
${error.stack}`);
      }
    }, [
      isControlled,
      controlledValue
    ]);
  }
  return isControlled;
};

// node_modules/@fluentui/react-utilities/lib/hooks/useEventCallback.js
var React21 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js
var React20 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/ssr/canUseDOM.js
function canUseDOM() {
  return (
    /* eslint-disable @nx/workspace-no-restricted-globals -- expected ignore ( SSR friendly acquisition of globals )*/
    typeof window !== "undefined" && !!(window.document && // eslint-disable-next-line @typescript-eslint/no-deprecated
    window.document.createElement)
  );
}

// node_modules/@fluentui/react-utilities/lib/ssr/SSRContext.js
var React19 = __toESM(require_react());
var defaultSSRContextValue = {
  current: 0
};
var SSRContext = React19.createContext(void 0);
function useSSRContext() {
  var _React_useContext;
  return (_React_useContext = React19.useContext(SSRContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultSSRContextValue;
}
var SSRProvider = (props) => {
  const [value] = React19.useState(() => ({
    current: 0
  }));
  return React19.createElement(SSRContext.Provider, {
    value
  }, props.children);
};
function useIsSSR() {
  const isInSSRContext = useSSRContext() !== defaultSSRContextValue;
  const [isSSR, setIsSSR] = React19.useState(isInSSRContext);
  if (true) {
    if (!isInSSRContext && !canUseDOM()) {
      console.error(`@fluentui/react-components [${useIsSSR.name}]:
When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.


Check documentation at https://aka.ms/fluentui-ssr.`);
    }
  }
  if (canUseDOM() && isInSSRContext) {
    React19.useLayoutEffect(() => {
      setIsSSR(false);
    }, []);
  }
  return isSSR;
}

// node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js
var useIsomorphicLayoutEffect = canUseDOM() ? React20.useLayoutEffect : React20.useEffect;

// node_modules/@fluentui/react-utilities/lib/hooks/useEventCallback.js
var useEventCallback = (fn) => {
  const callbackRef = React21.useRef(() => {
    throw new Error("Cannot call an event handler while rendering");
  });
  useIsomorphicLayoutEffect(() => {
    callbackRef.current = fn;
  }, [
    fn
  ]);
  return React21.useCallback((...args) => {
    const callback = callbackRef.current;
    return callback(...args);
  }, [
    callbackRef
  ]);
};

// node_modules/@fluentui/react-utilities/lib/hooks/useFirstMount.js
var React22 = __toESM(require_react());
function useFirstMount() {
  const isFirst = React22.useRef(true);
  React22.useEffect(() => {
    if (isFirst.current) {
      isFirst.current = false;
    }
  }, []);
  return isFirst.current;
}

// node_modules/@fluentui/react-utilities/lib/hooks/useForceUpdate.js
var React23 = __toESM(require_react());
function useForceUpdate() {
  return React23.useReducer((x) => x + 1, 0)[1];
}

// node_modules/@fluentui/react-utilities/lib/hooks/useId.js
var React24 = __toESM(require_react());
var IdPrefixContext = React24.createContext(void 0);
var IdPrefixProvider = IdPrefixContext.Provider;
function useIdPrefix() {
  return React24.useContext(IdPrefixContext) || "";
}
function resetIdsForTests() {
  defaultSSRContextValue.current = 0;
}
function useId2(prefix = "fui-", providedId) {
  "use no memo";
  const contextValue = useSSRContext();
  const idPrefix = useIdPrefix();
  const _useId = React24["useId"];
  if (_useId) {
    const generatedId = _useId();
    const escapedId = React24.useMemo(() => generatedId.replace(/:/g, ""), [
      generatedId
    ]);
    return providedId || `${idPrefix}${prefix}${escapedId}`;
  }
  return React24.useMemo(() => {
    if (providedId) {
      return providedId;
    }
    return `${idPrefix}${prefix}${++contextValue.current}`;
  }, [
    idPrefix,
    prefix,
    providedId,
    contextValue
  ]);
}

// node_modules/@fluentui/react-utilities/lib/hooks/useMergedRefs.js
var React25 = __toESM(require_react());
function useMergedRefs(...refs) {
  "use no memo";
  const mergedCallback = React25.useCallback(
    (value) => {
      mergedCallback.current = value;
      for (const ref of refs) {
        if (typeof ref === "string" && true) {
          console.error(`@fluentui/react-utilities [useMergedRefs]:
This hook does not support the usage of string refs. Please use React.useRef instead.

For more info on 'React.useRef', see https://react.dev/reference/react/useRef.
For more info on string refs, see https://react.dev/blog/2024/04/25/react-19-upgrade-guide#removed-string-refs.`);
        }
        if (typeof ref === "function") {
          ref(value);
        } else if (ref) {
          ref.current = value;
        }
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps -- already exhaustive
    [
      ...refs
    ]
  );
  return mergedCallback;
}

// node_modules/@fluentui/react-utilities/lib/hooks/useOnClickOutside.js
var React26 = __toESM(require_react());
var DEFAULT_CONTAINS = (parent2, child) => !!(parent2 === null || parent2 === void 0 ? void 0 : parent2.contains(child));
var useOnClickOutside = (options) => {
  const { targetDocument } = useFluent();
  const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
  const { refs, callback, element, disabled, disabledFocusOnIframe, contains = DEFAULT_CONTAINS } = options;
  const timeoutId = React26.useRef(void 0);
  useIFrameFocus({
    element,
    disabled: disabledFocusOnIframe || disabled,
    callback,
    refs,
    contains
  });
  const isMouseDownInsideRef = React26.useRef(false);
  const listener = useEventCallback((ev) => {
    if (isMouseDownInsideRef.current) {
      isMouseDownInsideRef.current = false;
      return;
    }
    const target = ev.composedPath()[0];
    const isOutside = refs.every((ref) => !contains(ref.current || null, target));
    if (isOutside && !disabled) {
      callback(ev);
    }
  });
  const handleMouseDown = useEventCallback((ev) => {
    isMouseDownInsideRef.current = refs.some((ref) => contains(ref.current || null, ev.target));
  });
  React26.useEffect(() => {
    if (disabled) {
      return;
    }
    let currentEvent = getWindowEvent(win);
    const conditionalHandler = (event) => {
      if (event === currentEvent) {
        currentEvent = void 0;
        return;
      }
      listener(event);
    };
    element === null || element === void 0 ? void 0 : element.addEventListener("click", conditionalHandler, true);
    element === null || element === void 0 ? void 0 : element.addEventListener("touchstart", conditionalHandler, true);
    element === null || element === void 0 ? void 0 : element.addEventListener("contextmenu", conditionalHandler, true);
    element === null || element === void 0 ? void 0 : element.addEventListener("mousedown", handleMouseDown, true);
    timeoutId.current = win === null || win === void 0 ? void 0 : win.setTimeout(() => {
      currentEvent = void 0;
    }, 1);
    return () => {
      element === null || element === void 0 ? void 0 : element.removeEventListener("click", conditionalHandler, true);
      element === null || element === void 0 ? void 0 : element.removeEventListener("touchstart", conditionalHandler, true);
      element === null || element === void 0 ? void 0 : element.removeEventListener("contextmenu", conditionalHandler, true);
      element === null || element === void 0 ? void 0 : element.removeEventListener("mousedown", handleMouseDown, true);
      win === null || win === void 0 ? void 0 : win.clearTimeout(timeoutId.current);
      currentEvent = void 0;
    };
  }, [
    listener,
    element,
    disabled,
    handleMouseDown,
    win
  ]);
};
var getWindowEvent = (target) => {
  if (target) {
    var _target_ownerDocument_defaultView, _target_ownerDocument;
    if (typeof target.window === "object" && target.window === target) {
      return target.event;
    }
    var _target_ownerDocument_defaultView_event;
    return (_target_ownerDocument_defaultView_event = (_target_ownerDocument = target.ownerDocument) === null || _target_ownerDocument === void 0 ? void 0 : (_target_ownerDocument_defaultView = _target_ownerDocument.defaultView) === null || _target_ownerDocument_defaultView === void 0 ? void 0 : _target_ownerDocument_defaultView.event) !== null && _target_ownerDocument_defaultView_event !== void 0 ? _target_ownerDocument_defaultView_event : void 0;
  }
  return void 0;
};
var FUI_FRAME_EVENT = "fuiframefocus";
var useIFrameFocus = (options) => {
  const { disabled, element: targetDocument, callback, contains = DEFAULT_CONTAINS, pollDuration = 100, refs } = options;
  const timeoutRef = React26.useRef();
  const listener = useEventCallback((e) => {
    const isOutside = refs.every((ref) => !contains(ref.current || null, e.target));
    if (isOutside && !disabled) {
      callback(e);
    }
  });
  React26.useEffect(() => {
    if (disabled) {
      return;
    }
    targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener(FUI_FRAME_EVENT, listener, true);
    return () => {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener(FUI_FRAME_EVENT, listener, true);
    };
  }, [
    targetDocument,
    disabled,
    listener
  ]);
  React26.useEffect(() => {
    var _targetDocument_defaultView;
    if (disabled) {
      return;
    }
    timeoutRef.current = targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.setInterval(() => {
      const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
      if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "IFRAME" || (activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "WEBVIEW") {
        const event = new CustomEvent(FUI_FRAME_EVENT, {
          bubbles: true
        });
        activeElement.dispatchEvent(event);
      }
    }, pollDuration);
    return () => {
      var _targetDocument_defaultView2;
      targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView2 = targetDocument.defaultView) === null || _targetDocument_defaultView2 === void 0 ? void 0 : _targetDocument_defaultView2.clearTimeout(timeoutRef.current);
    };
  }, [
    targetDocument,
    disabled,
    pollDuration
  ]);
};

// node_modules/@fluentui/react-utilities/lib/hooks/useOnScrollOutside.js
var React27 = __toESM(require_react());
var useOnScrollOutside = (options) => {
  const { refs, callback, element, disabled, contains: containsProp } = options;
  const listener = useEventCallback((ev) => {
    const contains = containsProp || ((parent2, child) => !!(parent2 === null || parent2 === void 0 ? void 0 : parent2.contains(child)));
    const target = ev.composedPath()[0];
    const isOutside = refs.every((ref) => !contains(ref.current || null, target));
    if (isOutside && !disabled) {
      callback(ev);
    }
  });
  React27.useEffect(() => {
    if (disabled) {
      return;
    }
    element === null || element === void 0 ? void 0 : element.addEventListener("wheel", listener);
    element === null || element === void 0 ? void 0 : element.addEventListener("touchmove", listener);
    return () => {
      element === null || element === void 0 ? void 0 : element.removeEventListener("wheel", listener);
      element === null || element === void 0 ? void 0 : element.removeEventListener("touchmove", listener);
    };
  }, [
    listener,
    element,
    disabled
  ]);
};

// node_modules/@fluentui/react-utilities/lib/hooks/usePrevious.js
var React28 = __toESM(require_react());
var usePrevious = (value) => {
  const ref = React28.useRef(null);
  React28.useEffect(() => {
    ref.current = value;
  }, [
    value
  ]);
  return ref.current;
};

// node_modules/@fluentui/react-utilities/lib/hooks/useScrollbarWidth.js
var React29 = __toESM(require_react());
var cache = /* @__PURE__ */ new WeakMap();
function useScrollbarWidth(options) {
  const { targetDocument, force } = options;
  return React29.useMemo(() => {
    if (!targetDocument) {
      return 0;
    }
    if (!force && cache.has(targetDocument)) {
      return cache.get(targetDocument);
    }
    const outer = targetDocument.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.overflow = "scroll";
    const inner = targetDocument.createElement("div");
    outer.appendChild(inner);
    targetDocument.body.appendChild(outer);
    const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
    outer.remove();
    cache.set(targetDocument, scrollbarWidth);
    return scrollbarWidth;
  }, [
    targetDocument,
    force
  ]);
}

// node_modules/@fluentui/react-utilities/lib/hooks/useTimeout.js
var setTimeoutNoop = (_callback) => -1;
var clearTimeoutNoop = (_handle) => void 0;
function useTimeout() {
  const { targetDocument } = useFluent();
  const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
  const setTimerFn = win ? win.setTimeout : setTimeoutNoop;
  const clearTimerFn = win ? win.clearTimeout : clearTimeoutNoop;
  return useBrowserTimer(setTimerFn, clearTimerFn);
}

// node_modules/@fluentui/react-utilities/lib/utils/clamp.js
var clamp = (value, min2, max2) => Math.max(min2, Math.min(max2, value || 0));

// node_modules/@fluentui/react-utilities/lib/utils/getReactElementRef.js
var React30 = __toESM(require_react());
var IS_REACT_19_OR_HIGHER = parseInt(React30.version, 10) >= 19;
function getReactElementRef(element) {
  if (!element) {
    return void 0;
  }
  if (IS_REACT_19_OR_HIGHER) {
    return element.props.ref;
  }
  return element.ref;
}

// node_modules/@fluentui/react-utilities/lib/utils/getRTLSafeKey.js
var getRTLSafeKey = (key, dir) => {
  if (dir === "rtl") {
    switch (key) {
      case "ArrowLeft": {
        return "ArrowRight";
      }
      case "ArrowRight": {
        return "ArrowLeft";
      }
    }
  }
  return key;
};

// node_modules/@fluentui/react-utilities/lib/utils/mergeCallbacks.js
function mergeCallbacks(callback1, callback2) {
  return (...args) => {
    callback1 === null || callback1 === void 0 ? void 0 : callback1(...args);
    callback2 === null || callback2 === void 0 ? void 0 : callback2(...args);
  };
}

// node_modules/@fluentui/react-utilities/lib/utils/isHTMLElement.js
function isHTMLElement(element, options) {
  var _typedElement_ownerDocument;
  const typedElement = element;
  var _options_constructorName;
  return Boolean((typedElement === null || typedElement === void 0 ? void 0 : (_typedElement_ownerDocument = typedElement.ownerDocument) === null || _typedElement_ownerDocument === void 0 ? void 0 : _typedElement_ownerDocument.defaultView) && typedElement instanceof typedElement.ownerDocument.defaultView[(_options_constructorName = options === null || options === void 0 ? void 0 : options.constructorName) !== null && _options_constructorName !== void 0 ? _options_constructorName : "HTMLElement"]);
}

// node_modules/@fluentui/react-utilities/lib/utils/isInteractiveHTMLElement.js
function isInteractiveHTMLElement(element) {
  if (!isHTMLElement(element)) {
    return false;
  }
  const { tagName } = element;
  switch (tagName) {
    case "BUTTON":
    case "A":
    case "INPUT":
    case "TEXTAREA":
      return true;
  }
  return element.isContentEditable;
}

// node_modules/@fluentui/react-utilities/lib/utils/priorityQueue.js
function createPriorityQueue(compare) {
  const arr = [];
  let size3 = 0;
  const swap = (a, b) => {
    const tmp = arr[a];
    arr[a] = arr[b];
    arr[b] = tmp;
  };
  const heapify = (i) => {
    let smallest = i;
    const l = left(i);
    const r = right(i);
    if (l < size3 && compare(arr[l], arr[smallest]) < 0) {
      smallest = l;
    }
    if (r < size3 && compare(arr[r], arr[smallest]) < 0) {
      smallest = r;
    }
    if (smallest !== i) {
      swap(smallest, i);
      heapify(smallest);
    }
  };
  const dequeue = () => {
    if (size3 === 0) {
      throw new Error("Priority queue empty");
    }
    const res = arr[0];
    arr[0] = arr[--size3];
    heapify(0);
    return res;
  };
  const peek = () => {
    if (size3 === 0) {
      return null;
    }
    return arr[0];
  };
  const enqueue = (item) => {
    arr[size3++] = item;
    let i = size3 - 1;
    let p = parent(i);
    while (i > 0 && compare(arr[p], arr[i]) > 0) {
      swap(p, i);
      i = p;
      p = parent(i);
    }
  };
  const contains = (item) => {
    const index = arr.indexOf(item);
    return index >= 0 && index < size3;
  };
  const remove = (item) => {
    const i = arr.indexOf(item);
    if (i === -1 || i >= size3) {
      return;
    }
    arr[i] = arr[--size3];
    heapify(i);
  };
  const clear = () => {
    size3 = 0;
  };
  const all = () => {
    return arr.slice(0, size3);
  };
  return {
    all,
    clear,
    contains,
    dequeue,
    enqueue,
    peek,
    remove,
    size: () => size3
  };
}
var left = (i) => {
  return 2 * i + 1;
};
var right = (i) => {
  return 2 * i + 2;
};
var parent = (i) => {
  return Math.floor((i - 1) / 2);
};

// node_modules/@fluentui/react-utilities/lib/trigger/applyTriggerPropsToChildren.js
var React32 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/trigger/isFluentTrigger.js
var React31 = __toESM(require_react());
function isFluentTrigger(element) {
  return Boolean(element.type.isFluentTriggerComponent);
}

// node_modules/@fluentui/react-utilities/lib/trigger/applyTriggerPropsToChildren.js
function applyTriggerPropsToChildren(children2, triggerChildProps) {
  if (typeof children2 === "function") {
    return children2(triggerChildProps);
  } else if (children2) {
    return cloneTriggerTree(children2, triggerChildProps);
  }
  return children2 || null;
}
function cloneTriggerTree(child, triggerProps) {
  if (!React32.isValidElement(child) || child.type === React32.Fragment) {
    throw new Error("A trigger element must be a single element for this component. Please ensure that you're not using React Fragments.");
  }
  if (isFluentTrigger(child)) {
    const grandchild = cloneTriggerTree(child.props.children, triggerProps);
    return React32.cloneElement(child, void 0, grandchild);
  } else {
    return React32.cloneElement(child, triggerProps);
  }
}

// node_modules/@fluentui/react-utilities/lib/trigger/getTriggerChild.js
var React33 = __toESM(require_react());
function getTriggerChild(children2) {
  if (!React33.isValidElement(children2)) {
    return null;
  }
  return isFluentTrigger(children2) ? getTriggerChild(
    // FIXME: This casting should be unnecessary as isFluentTrigger is a guard type method,
    // but for some reason it's failing on build
    children2.props.children
  ) : children2;
}

// node_modules/@fluentui/react-utilities/lib/events/mouseTouchHelpers.js
var React34 = __toESM(require_react());
function isTouchEvent(event) {
  return event.type.startsWith("touch");
}
function isMouseEvent(event) {
  return event.type.startsWith("mouse") || [
    "click",
    "contextmenu",
    "dblclick"
  ].indexOf(event.type) > -1;
}
function getEventClientCoords(event) {
  if (isMouseEvent(event)) {
    return {
      clientX: event.clientX,
      clientY: event.clientY
    };
  } else if (isTouchEvent(event)) {
    return {
      clientX: event.touches[0].clientX,
      clientY: event.touches[0].clientY
    };
  } else {
    if (true) {
      throw new Error("@fluentui/react-utilities]: Unable to get clientX. Unknown event type.");
    }
    return {
      clientX: 0,
      clientY: 0
    };
  }
}

// node_modules/@fluentui/react-utilities/lib/selection/useSelection.js
var React35 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/utils/createSetFromIterable.js
function createSetFromIterable(iterable) {
  return iterable instanceof Set ? iterable : new Set(iterable);
}

// node_modules/@fluentui/react-utilities/lib/selection/useSelection.js
function useSelectionState(params) {
  const [selected, setSelected] = useControllableState({
    initialState: /* @__PURE__ */ new Set(),
    defaultState: React35.useMemo(() => params.defaultSelectedItems && createSetFromIterable(params.defaultSelectedItems), [
      params.defaultSelectedItems
    ]),
    state: React35.useMemo(() => params.selectedItems && createSetFromIterable(params.selectedItems), [
      params.selectedItems
    ])
  });
  const changeSelection = (event, nextSelectedItems) => {
    var _params_onSelectionChange;
    (_params_onSelectionChange = params.onSelectionChange) === null || _params_onSelectionChange === void 0 ? void 0 : _params_onSelectionChange.call(params, event, {
      selectedItems: nextSelectedItems
    });
    setSelected(nextSelectedItems);
  };
  return [
    selected,
    changeSelection
  ];
}
function useSingleSelection(params) {
  const [selected, changeSelection] = useSelectionState(params);
  const methods = {
    deselectItem: (event) => changeSelection(event, /* @__PURE__ */ new Set()),
    selectItem: (event, itemId) => changeSelection(event, /* @__PURE__ */ new Set([
      itemId
    ])),
    toggleAllItems: () => {
      if (true) {
        throw new Error("[react-utilities]: `toggleAllItems` should not be used in single selection mode");
      }
    },
    toggleItem: (event, itemId) => changeSelection(event, /* @__PURE__ */ new Set([
      itemId
    ])),
    clearItems: (event) => changeSelection(event, /* @__PURE__ */ new Set()),
    isSelected: (itemId) => {
      var _selected_has;
      return (_selected_has = selected.has(itemId)) !== null && _selected_has !== void 0 ? _selected_has : false;
    }
  };
  return [
    selected,
    methods
  ];
}
function useMultipleSelection(params) {
  const [selected, changeSelection] = useSelectionState(params);
  const methods = {
    toggleItem: (event, itemId) => {
      const nextSelectedItems = new Set(selected);
      if (selected.has(itemId)) {
        nextSelectedItems.delete(itemId);
      } else {
        nextSelectedItems.add(itemId);
      }
      changeSelection(event, nextSelectedItems);
    },
    selectItem: (event, itemId) => {
      const nextSelectedItems = new Set(selected);
      nextSelectedItems.add(itemId);
      changeSelection(event, nextSelectedItems);
    },
    deselectItem: (event, itemId) => {
      const nextSelectedItems = new Set(selected);
      nextSelectedItems.delete(itemId);
      changeSelection(event, nextSelectedItems);
    },
    clearItems: (event) => {
      changeSelection(event, /* @__PURE__ */ new Set());
    },
    isSelected: (itemId) => selected.has(itemId),
    toggleAllItems: (event, itemIds) => {
      const allItemsSelected = itemIds.every((itemId) => selected.has(itemId));
      const nextSelectedItems = new Set(selected);
      if (allItemsSelected) {
        nextSelectedItems.clear();
      } else {
        itemIds.forEach((itemId) => nextSelectedItems.add(itemId));
      }
      changeSelection(event, nextSelectedItems);
    }
  };
  return [
    selected,
    methods
  ];
}
function useSelection(params) {
  "use no memo";
  if (params.selectionMode === "multiselect") {
    return useMultipleSelection(params);
  }
  return useSingleSelection(params);
}

// node_modules/@fluentui/react-utilities/lib/virtualParent/isVirtualElement.js
function isVirtualElement(element) {
  return element && !!element._virtual;
}

// node_modules/@fluentui/react-utilities/lib/virtualParent/getParent.js
function getVirtualParent(child) {
  return isVirtualElement(child) ? child._virtual.parent || null : null;
}
function getParent(child, options = {}) {
  if (!child) {
    return null;
  }
  if (!options.skipVirtual) {
    const virtualParent = getVirtualParent(child);
    if (virtualParent) {
      return virtualParent;
    }
  }
  const parent2 = child.parentNode;
  if (parent2 && parent2.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    return parent2.host;
  }
  return parent2;
}

// node_modules/@fluentui/react-utilities/lib/virtualParent/elementContains.js
function elementContains(parent2, child) {
  if (!parent2 || !child) {
    return false;
  }
  if (parent2 === child) {
    return true;
  } else {
    const set = /* @__PURE__ */ new WeakSet();
    while (child) {
      const nextParent = getParent(child, {
        skipVirtual: set.has(child)
      });
      set.add(child);
      if (nextParent === parent2) {
        return true;
      }
      child = nextParent;
    }
  }
  return false;
}

// node_modules/@fluentui/react-utilities/lib/virtualParent/setVirtualParent.js
function setVirtualParent(child, parent2) {
  if (!child) {
    return;
  }
  Object.assign(child, {
    _virtual: {
      parent: parent2
    }
  });
}

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/createJSX.js
var React38 = __toESM(require_react());

// node_modules/@fluentui/react-jsx-runtime/lib/utils/createCompatSlotComponent.js
var React36 = __toESM(require_react());
function createCompatSlotComponent(type, props) {
  return {
    ...props,
    [SLOT_ELEMENT_TYPE_SYMBOL]: type
  };
}

// node_modules/@fluentui/react-jsx-runtime/lib/utils/warnIfElementTypeIsInvalid.js
var React37 = __toESM(require_react());
var import_react_is = __toESM(require_react_is());
function warnIfElementTypeIsInvalid(type) {
  if (typeof type === "object" && !(0, import_react_is.isValidElementType)(type)) {
    console.error(`@fluentui/react-jsx-runtime:
Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: ${type}.

If this happened in a slot of Fluent UI component, you might be facing package resolution issues.
Please make sure you don't have multiple versions of "@fluentui/react-utilities" installed in your dependencies or sub-dependencies.
You can check this by searching up for matching entries in a lockfile produced by your package manager (yarn.lock, pnpm-lock.yaml or package-lock.json).`);
  }
}

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/createJSX.js
function createJSX(runtime, slotRuntime) {
  return function jsx2(type, overrideProps, key, source, self) {
    if (isSlot(overrideProps)) {
      return slotRuntime(createCompatSlotComponent(type, overrideProps), null, key, source, self);
    }
    if (isSlot(type)) {
      return slotRuntime(type, overrideProps, key, source, self);
    }
    warnIfElementTypeIsInvalid(type);
    return runtime(type, overrideProps, key, source, self);
  };
}

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxSlot.js
var React39 = __toESM(require_react());

// node_modules/@fluentui/react-jsx-runtime/lib/utils/getMetadataFromSlotComponent.js
function getMetadataFromSlotComponent(type) {
  const { as, [SLOT_CLASS_NAME_PROP_SYMBOL]: _classNameProp, [SLOT_ELEMENT_TYPE_SYMBOL]: baseElementType, [SLOT_RENDER_FUNCTION_SYMBOL]: renderFunction, ...propsWithoutMetadata } = type;
  const props = propsWithoutMetadata;
  const elementType = typeof baseElementType === "string" ? as !== null && as !== void 0 ? as : baseElementType : baseElementType;
  if (typeof elementType !== "string" && as) {
    props.as = as;
  }
  return {
    elementType,
    props,
    renderFunction
  };
}

// node_modules/@fluentui/react-jsx-runtime/lib/utils/Runtime.js
var ReactRuntime = __toESM(require_jsx_runtime());
var Runtime = ReactRuntime;

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxSlot.js
var jsxSlot = (type, overrideProps, key) => {
  const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
  const props = {
    ...slotProps,
    ...overrideProps
  };
  if (renderFunction) {
    return Runtime.jsx(React39.Fragment, {
      children: renderFunction(elementType, props)
    }, key);
  }
  return Runtime.jsx(elementType, props, key);
};

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxsSlot.js
var React40 = __toESM(require_react());
var jsxsSlot = (type, overrideProps, key) => {
  const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
  const props = {
    ...slotProps,
    ...overrideProps
  };
  if (renderFunction) {
    return Runtime.jsx(React40.Fragment, {
      children: renderFunction(elementType, {
        ...props,
        children: Runtime.jsxs(React40.Fragment, {
          children: props.children
        }, void 0)
      })
    }, key);
  }
  return Runtime.jsxs(elementType, props, key);
};

// node_modules/@fluentui/react-jsx-runtime/lib/jsx-runtime.js
var import_react = __toESM(require_react());
var jsx = createJSX(Runtime.jsx, jsxSlot);
var jsxs = createJSX(Runtime.jsxs, jsxsSlot);

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/renderFluentProvider.js
var renderFluentProvider_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(Provider, {
    value: contextValues.provider,
    children: jsx(ThemeProvider, {
      value: contextValues.theme,
      children: jsx(ThemeClassNameProvider, {
        value: contextValues.themeClassName,
        children: jsx(CustomStyleHooksProvider, {
          value: contextValues.customStyleHooks_unstable,
          children: jsx(TooltipVisibilityProvider, {
            value: contextValues.tooltip,
            children: jsx(TextDirectionProvider, {
              dir: contextValues.textDirection,
              children: jsx(IconDirectionContextProvider, {
                value: contextValues.iconDirection,
                children: jsx(OverridesProvider, {
                  value: contextValues.overrides_unstable,
                  children: jsxs(state.root, {
                    children: [
                      canUseDOM() ? null : jsx("style", {
                        // Using dangerous HTML because react can escape characters
                        // which can lead to invalid CSS.
                        // eslint-disable-next-line react/no-danger
                        dangerouslySetInnerHTML: {
                          __html: state.serverStyleProps.cssRule
                        },
                        ...state.serverStyleProps.attributes
                      }),
                      state.root.children
                    ]
                  })
                })
              })
            })
          })
        })
      })
    })
  });
};

// node_modules/keyborg/dist/esm/index.js
var _canUseWeakRef = typeof WeakRef !== "undefined";
var WeakRefInstance = class {
  constructor(instance) {
    if (_canUseWeakRef && typeof instance === "object") {
      this._weakRef = new WeakRef(instance);
    } else {
      this._instance = instance;
    }
  }
  /**
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref}
   */
  deref() {
    var _a, _b;
    let instance;
    if (this._weakRef) {
      instance = (_a = this._weakRef) == null ? void 0 : _a.deref();
      if (!instance) {
        delete this._weakRef;
      }
    } else {
      instance = this._instance;
      if ((_b = instance == null ? void 0 : instance.isDisposed) == null ? void 0 : _b.call(instance)) {
        delete this._instance;
      }
    }
    return instance;
  }
};
var KEYBORG_FOCUSIN = "keyborg:focusin";
var KEYBORG_FOCUSOUT = "keyborg:focusout";
function canOverrideNativeFocus(win) {
  const HTMLElement2 = win.HTMLElement;
  const origFocus = HTMLElement2.prototype.focus;
  let isCustomFocusCalled = false;
  HTMLElement2.prototype.focus = function focus() {
    isCustomFocusCalled = true;
  };
  const btn = win.document.createElement("button");
  btn.focus();
  HTMLElement2.prototype.focus = origFocus;
  return isCustomFocusCalled;
}
var _canOverrideNativeFocus = false;
function nativeFocus(element) {
  const focus = element.focus;
  if (focus.__keyborgNativeFocus) {
    focus.__keyborgNativeFocus.call(element);
  } else {
    element.focus();
  }
}
function setupFocusEvent(win) {
  const kwin = win;
  if (!_canOverrideNativeFocus) {
    _canOverrideNativeFocus = canOverrideNativeFocus(kwin);
  }
  const origFocus = kwin.HTMLElement.prototype.focus;
  if (origFocus.__keyborgNativeFocus) {
    return;
  }
  kwin.HTMLElement.prototype.focus = focus;
  const shadowTargets = /* @__PURE__ */ new Set();
  const focusOutHandler = (e) => {
    const target = e.target;
    if (!target) {
      return;
    }
    const event = new CustomEvent(KEYBORG_FOCUSOUT, {
      cancelable: true,
      bubbles: true,
      // Allows the event to bubble past an open shadow root
      composed: true,
      detail: {
        originalEvent: e
      }
    });
    target.dispatchEvent(event);
  };
  const focusInHandler = (e) => {
    const target = e.target;
    if (!target) {
      return;
    }
    let node = e.composedPath()[0];
    const currentShadows = /* @__PURE__ */ new Set();
    while (node) {
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        currentShadows.add(node);
        node = node.host;
      } else {
        node = node.parentNode;
      }
    }
    for (const shadowRootWeakRef of shadowTargets) {
      const shadowRoot = shadowRootWeakRef.deref();
      if (!shadowRoot || !currentShadows.has(shadowRoot)) {
        shadowTargets.delete(shadowRootWeakRef);
        if (shadowRoot) {
          shadowRoot.removeEventListener("focusin", focusInHandler, true);
          shadowRoot.removeEventListener("focusout", focusOutHandler, true);
        }
      }
    }
    onFocusIn(target, e.relatedTarget || void 0);
  };
  const onFocusIn = (target, relatedTarget, originalEvent) => {
    var _a;
    const shadowRoot = target.shadowRoot;
    if (shadowRoot) {
      for (const shadowRootWeakRef of shadowTargets) {
        if (shadowRootWeakRef.deref() === shadowRoot) {
          return;
        }
      }
      shadowRoot.addEventListener("focusin", focusInHandler, true);
      shadowRoot.addEventListener("focusout", focusOutHandler, true);
      shadowTargets.add(new WeakRefInstance(shadowRoot));
      return;
    }
    const details = {
      relatedTarget,
      originalEvent
    };
    const event = new CustomEvent(KEYBORG_FOCUSIN, {
      cancelable: true,
      bubbles: true,
      // Allows the event to bubble past an open shadow root
      composed: true,
      detail: details
    });
    event.details = details;
    if (_canOverrideNativeFocus || data.lastFocusedProgrammatically) {
      details.isFocusedProgrammatically = target === ((_a = data.lastFocusedProgrammatically) == null ? void 0 : _a.deref());
      data.lastFocusedProgrammatically = void 0;
    }
    target.dispatchEvent(event);
  };
  const data = kwin.__keyborgData = {
    focusInHandler,
    focusOutHandler,
    shadowTargets
  };
  kwin.document.addEventListener(
    "focusin",
    kwin.__keyborgData.focusInHandler,
    true
  );
  kwin.document.addEventListener(
    "focusout",
    kwin.__keyborgData.focusOutHandler,
    true
  );
  function focus() {
    const keyborgNativeFocusEvent = kwin.__keyborgData;
    if (keyborgNativeFocusEvent) {
      keyborgNativeFocusEvent.lastFocusedProgrammatically = new WeakRefInstance(
        this
      );
    }
    return origFocus.apply(this, arguments);
  }
  let activeElement = kwin.document.activeElement;
  while (activeElement && activeElement.shadowRoot) {
    onFocusIn(activeElement);
    activeElement = activeElement.shadowRoot.activeElement;
  }
  focus.__keyborgNativeFocus = origFocus;
}
function disposeFocusEvent(win) {
  const kwin = win;
  const proto = kwin.HTMLElement.prototype;
  const origFocus = proto.focus.__keyborgNativeFocus;
  const keyborgNativeFocusEvent = kwin.__keyborgData;
  if (keyborgNativeFocusEvent) {
    kwin.document.removeEventListener(
      "focusin",
      keyborgNativeFocusEvent.focusInHandler,
      true
    );
    kwin.document.removeEventListener(
      "focusout",
      keyborgNativeFocusEvent.focusOutHandler,
      true
    );
    for (const shadowRootWeakRef of keyborgNativeFocusEvent.shadowTargets) {
      const shadowRoot = shadowRootWeakRef.deref();
      if (shadowRoot) {
        shadowRoot.removeEventListener(
          "focusin",
          keyborgNativeFocusEvent.focusInHandler,
          true
        );
        shadowRoot.removeEventListener(
          "focusout",
          keyborgNativeFocusEvent.focusOutHandler,
          true
        );
      }
    }
    keyborgNativeFocusEvent.shadowTargets.clear();
    delete kwin.__keyborgData;
  }
  if (origFocus) {
    proto.focus = origFocus;
  }
}
var _dismissTimeout = 500;
var _lastId = 0;
var KeyborgCore = class {
  constructor(win, props) {
    this._isNavigatingWithKeyboard_DO_NOT_USE = false;
    this._onFocusIn = (e) => {
      if (this._isMouseOrTouchUsedTimer) {
        return;
      }
      if (this.isNavigatingWithKeyboard) {
        return;
      }
      const details = e.detail;
      if (!details.relatedTarget) {
        return;
      }
      if (details.isFocusedProgrammatically || details.isFocusedProgrammatically === void 0) {
        return;
      }
      this.isNavigatingWithKeyboard = true;
    };
    this._onMouseDown = (e) => {
      if (e.buttons === 0 || e.clientX === 0 && e.clientY === 0 && e.screenX === 0 && e.screenY === 0) {
        return;
      }
      this._onMouseOrTouch();
    };
    this._onMouseOrTouch = () => {
      const win2 = this._win;
      if (win2) {
        if (this._isMouseOrTouchUsedTimer) {
          win2.clearTimeout(this._isMouseOrTouchUsedTimer);
        }
        this._isMouseOrTouchUsedTimer = win2.setTimeout(() => {
          delete this._isMouseOrTouchUsedTimer;
        }, 1e3);
      }
      this.isNavigatingWithKeyboard = false;
    };
    this._onKeyDown = (e) => {
      const isNavigatingWithKeyboard = this.isNavigatingWithKeyboard;
      if (isNavigatingWithKeyboard) {
        if (this._shouldDismissKeyboardNavigation(e)) {
          this._scheduleDismiss();
        }
      } else {
        if (this._shouldTriggerKeyboardNavigation(e)) {
          this.isNavigatingWithKeyboard = true;
        }
      }
    };
    this.id = "c" + ++_lastId;
    this._win = win;
    const doc = win.document;
    if (props) {
      const triggerKeys = props.triggerKeys;
      const dismissKeys = props.dismissKeys;
      if (triggerKeys == null ? void 0 : triggerKeys.length) {
        this._triggerKeys = new Set(triggerKeys);
      }
      if (dismissKeys == null ? void 0 : dismissKeys.length) {
        this._dismissKeys = new Set(dismissKeys);
      }
    }
    doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
    doc.addEventListener("mousedown", this._onMouseDown, true);
    win.addEventListener("keydown", this._onKeyDown, true);
    doc.addEventListener("touchstart", this._onMouseOrTouch, true);
    doc.addEventListener("touchend", this._onMouseOrTouch, true);
    doc.addEventListener("touchcancel", this._onMouseOrTouch, true);
    setupFocusEvent(win);
  }
  get isNavigatingWithKeyboard() {
    return this._isNavigatingWithKeyboard_DO_NOT_USE;
  }
  set isNavigatingWithKeyboard(val) {
    if (this._isNavigatingWithKeyboard_DO_NOT_USE !== val) {
      this._isNavigatingWithKeyboard_DO_NOT_USE = val;
      this.update();
    }
  }
  dispose() {
    const win = this._win;
    if (win) {
      if (this._isMouseOrTouchUsedTimer) {
        win.clearTimeout(this._isMouseOrTouchUsedTimer);
        this._isMouseOrTouchUsedTimer = void 0;
      }
      if (this._dismissTimer) {
        win.clearTimeout(this._dismissTimer);
        this._dismissTimer = void 0;
      }
      disposeFocusEvent(win);
      const doc = win.document;
      doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
      doc.removeEventListener("mousedown", this._onMouseDown, true);
      win.removeEventListener("keydown", this._onKeyDown, true);
      doc.removeEventListener("touchstart", this._onMouseOrTouch, true);
      doc.removeEventListener("touchend", this._onMouseOrTouch, true);
      doc.removeEventListener("touchcancel", this._onMouseOrTouch, true);
      delete this._win;
    }
  }
  isDisposed() {
    return !!this._win;
  }
  /**
   * Updates all keyborg instances with the keyboard navigation state
   */
  update() {
    var _a, _b;
    const keyborgs = (_b = (_a = this._win) == null ? void 0 : _a.__keyborg) == null ? void 0 : _b.refs;
    if (keyborgs) {
      for (const id of Object.keys(keyborgs)) {
        Keyborg.update(keyborgs[id], this.isNavigatingWithKeyboard);
      }
    }
  }
  /**
   * @returns whether the keyboard event should trigger keyboard navigation mode
   */
  _shouldTriggerKeyboardNavigation(e) {
    var _a;
    if (e.key === "Tab") {
      return true;
    }
    const activeElement = (_a = this._win) == null ? void 0 : _a.document.activeElement;
    const isTriggerKey = !this._triggerKeys || this._triggerKeys.has(e.keyCode);
    const isEditable = activeElement && (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA" || activeElement.isContentEditable);
    return isTriggerKey && !isEditable;
  }
  /**
   * @returns whether the keyboard event should dismiss keyboard navigation mode
   */
  _shouldDismissKeyboardNavigation(e) {
    var _a;
    return (_a = this._dismissKeys) == null ? void 0 : _a.has(e.keyCode);
  }
  _scheduleDismiss() {
    const win = this._win;
    if (win) {
      if (this._dismissTimer) {
        win.clearTimeout(this._dismissTimer);
        this._dismissTimer = void 0;
      }
      const was = win.document.activeElement;
      this._dismissTimer = win.setTimeout(() => {
        this._dismissTimer = void 0;
        const cur = win.document.activeElement;
        if (was && cur && was === cur) {
          this.isNavigatingWithKeyboard = false;
        }
      }, _dismissTimeout);
    }
  }
};
var Keyborg = class _Keyborg {
  constructor(win, props) {
    this._cb = [];
    this._id = "k" + ++_lastId;
    this._win = win;
    const current = win.__keyborg;
    if (current) {
      this._core = current.core;
      current.refs[this._id] = this;
    } else {
      this._core = new KeyborgCore(win, props);
      win.__keyborg = {
        core: this._core,
        refs: { [this._id]: this }
      };
    }
  }
  static create(win, props) {
    return new _Keyborg(win, props);
  }
  static dispose(instance) {
    instance.dispose();
  }
  /**
   * Updates all subscribed callbacks with the keyboard navigation state
   */
  static update(instance, isNavigatingWithKeyboard) {
    instance._cb.forEach((callback) => callback(isNavigatingWithKeyboard));
  }
  dispose() {
    var _a;
    const current = (_a = this._win) == null ? void 0 : _a.__keyborg;
    if (current == null ? void 0 : current.refs[this._id]) {
      delete current.refs[this._id];
      if (Object.keys(current.refs).length === 0) {
        current.core.dispose();
        delete this._win.__keyborg;
      }
    } else if (true) {
      console.error(
        `Keyborg instance ${this._id} is being disposed incorrectly.`
      );
    }
    this._cb = [];
    delete this._core;
    delete this._win;
  }
  /**
   * @returns Whether the user is navigating with keyboard
   */
  isNavigatingWithKeyboard() {
    var _a;
    return !!((_a = this._core) == null ? void 0 : _a.isNavigatingWithKeyboard);
  }
  /**
   * @param callback - Called when the keyboard navigation state changes
   */
  subscribe(callback) {
    this._cb.push(callback);
  }
  /**
   * @param callback - Registered with subscribe
   */
  unsubscribe(callback) {
    const index = this._cb.indexOf(callback);
    if (index >= 0) {
      this._cb.splice(index, 1);
    }
  }
  /**
   * Manually set the keyboard navigtion state
   */
  setVal(isNavigatingWithKeyboard) {
    if (this._core) {
      this._core.isNavigatingWithKeyboard = isNavigatingWithKeyboard;
    }
  }
};
function createKeyborg(win, props) {
  return Keyborg.create(win, props);
}
function disposeKeyborg(instance) {
  Keyborg.dispose(instance);
}

// node_modules/tabster/dist/tabster.esm.js
var TABSTER_ATTRIBUTE_NAME = "data-tabster";
var TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME = "data-tabster-dummy";
var FOCUSABLE_SELECTOR = ["a[href]", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "*[tabindex]", "*[contenteditable]", "details > summary", "audio[controls]", "video[controls]"].join(", ");
var AsyncFocusSources = {
  EscapeGroupper: 1,
  Restorer: 2,
  Deloser: 3
};
var ObservedElementAccessibilities = {
  Any: 0,
  Accessible: 1,
  Focusable: 2
};
var ObservedElementRequestStatuses = {
  Waiting: 0,
  Succeeded: 1,
  Canceled: 2,
  TimedOut: 3
};
var Visibilities = {
  Invisible: 0,
  PartiallyVisible: 1,
  Visible: 2
};
var RestorerTypes = {
  Source: 0,
  Target: 1
};
var MoverDirections = {
  Both: 0,
  // Default, both left/up keys move to the previous, right/down move to the next.
  Vertical: 1,
  // Only up/down arrows move to the next/previous.
  Horizontal: 2,
  // Only left/right arrows move to the next/previous.
  Grid: 3,
  // Two-dimentional movement depending on the visual placement.
  GridLinear: 4
  // Two-dimentional movement depending on the visual placement. Allows linear movement.
};
var MoverKeys = {
  ArrowUp: 1,
  ArrowDown: 2,
  ArrowLeft: 3,
  ArrowRight: 4,
  PageUp: 5,
  PageDown: 6,
  Home: 7,
  End: 8
};
var GroupperTabbabilities = {
  Unlimited: 0,
  Limited: 1,
  // The tabbability is limited to the container and explicit Enter is needed to go inside.
  LimitedTrapFocus: 2
  // The focus is limited as above, plus trapped when inside.
};
var GroupperMoveFocusActions = {
  Enter: 1,
  Escape: 2
};
var SysDummyInputsPositions = {
  Auto: 0,
  // Tabster will place dummy inputs depending on the container tag name and on the default behaviour.
  Inside: 1,
  // Tabster will always place dummy inputs inside the container.
  Outside: 2
  // Tabster will always place dummy inputs outside of the container.
};
function getTabsterOnElement(tabster, element) {
  var _a;
  return (_a = tabster.storageEntry(element)) === null || _a === void 0 ? void 0 : _a.tabster;
}
function updateTabsterByAttribute(tabster, element, dispose) {
  var _a, _b;
  const newAttrValue = dispose || tabster._noop ? void 0 : element.getAttribute(TABSTER_ATTRIBUTE_NAME);
  let entry = tabster.storageEntry(element);
  let newAttr;
  if (newAttrValue) {
    if (newAttrValue !== ((_a = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a === void 0 ? void 0 : _a.string)) {
      try {
        const newValue = JSON.parse(newAttrValue);
        if (typeof newValue !== "object") {
          throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);
        }
        newAttr = {
          string: newAttrValue,
          object: newValue
        };
      } catch (e) {
        if (true) {
          console.error(`data-tabster attribute error: ${e}`, element);
        }
      }
    } else {
      return;
    }
  } else if (!entry) {
    return;
  }
  if (!entry) {
    entry = tabster.storageEntry(element, true);
  }
  if (!entry.tabster) {
    entry.tabster = {};
  }
  const tabsterOnElement = entry.tabster || {};
  const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};
  const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};
  for (const key of Object.keys(oldTabsterProps)) {
    if (!newTabsterProps[key]) {
      if (key === "root") {
        const root = tabsterOnElement[key];
        if (root) {
          tabster.root.onRoot(root, true);
        }
      }
      switch (key) {
        case "deloser":
        case "root":
        case "groupper":
        case "modalizer":
        case "restorer":
        case "mover":
          const part = tabsterOnElement[key];
          if (part) {
            part.dispose();
            delete tabsterOnElement[key];
          }
          break;
        case "observed":
          delete tabsterOnElement[key];
          if (tabster.observedElement) {
            tabster.observedElement.onObservedElementUpdate(element);
          }
          break;
        case "focusable":
        case "outline":
        case "uncontrolled":
        case "sys":
          delete tabsterOnElement[key];
          break;
      }
    }
  }
  for (const key of Object.keys(newTabsterProps)) {
    const sys = newTabsterProps.sys;
    switch (key) {
      case "deloser":
        if (tabsterOnElement.deloser) {
          tabsterOnElement.deloser.setProps(newTabsterProps.deloser);
        } else {
          if (tabster.deloser) {
            tabsterOnElement.deloser = tabster.deloser.createDeloser(element, newTabsterProps.deloser);
          } else if (true) {
            console.error("Deloser API used before initialization, please call `getDeloser()`");
          }
        }
        break;
      case "root":
        if (tabsterOnElement.root) {
          tabsterOnElement.root.setProps(newTabsterProps.root);
        } else {
          tabsterOnElement.root = tabster.root.createRoot(element, newTabsterProps.root, sys);
        }
        tabster.root.onRoot(tabsterOnElement.root);
        break;
      case "modalizer":
        if (tabsterOnElement.modalizer) {
          tabsterOnElement.modalizer.setProps(newTabsterProps.modalizer);
        } else {
          if (tabster.modalizer) {
            tabsterOnElement.modalizer = tabster.modalizer.createModalizer(element, newTabsterProps.modalizer, sys);
          } else if (true) {
            console.error("Modalizer API used before initialization, please call `getModalizer()`");
          }
        }
        break;
      case "restorer":
        if (tabsterOnElement.restorer) {
          tabsterOnElement.restorer.setProps(newTabsterProps.restorer);
        } else {
          if (tabster.restorer) {
            if (newTabsterProps.restorer) {
              tabsterOnElement.restorer = tabster.restorer.createRestorer(element, newTabsterProps.restorer);
            }
          } else if (true) {
            console.error("Restorer API used before initialization, please call `getRestorer()`");
          }
        }
        break;
      case "focusable":
        tabsterOnElement.focusable = newTabsterProps.focusable;
        break;
      case "groupper":
        if (tabsterOnElement.groupper) {
          tabsterOnElement.groupper.setProps(newTabsterProps.groupper);
        } else {
          if (tabster.groupper) {
            tabsterOnElement.groupper = tabster.groupper.createGroupper(element, newTabsterProps.groupper, sys);
          } else if (true) {
            console.error("Groupper API used before initialization, please call `getGroupper()`");
          }
        }
        break;
      case "mover":
        if (tabsterOnElement.mover) {
          tabsterOnElement.mover.setProps(newTabsterProps.mover);
        } else {
          if (tabster.mover) {
            tabsterOnElement.mover = tabster.mover.createMover(element, newTabsterProps.mover, sys);
          } else if (true) {
            console.error("Mover API used before initialization, please call `getMover()`");
          }
        }
        break;
      case "observed":
        if (tabster.observedElement) {
          tabsterOnElement.observed = newTabsterProps.observed;
          tabster.observedElement.onObservedElementUpdate(element);
        } else if (true) {
          console.error("ObservedElement API used before initialization, please call `getObservedElement()`");
        }
        break;
      case "uncontrolled":
        tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;
        break;
      case "outline":
        if (tabster.outline) {
          tabsterOnElement.outline = newTabsterProps.outline;
        } else if (true) {
          console.error("Outline API used before initialization, please call `getOutline()`");
        }
        break;
      case "sys":
        tabsterOnElement.sys = newTabsterProps.sys;
        break;
      default:
        console.error(`Unknown key '${key}' in data-tabster attribute value.`);
    }
  }
  if (newAttr) {
    entry.attr = newAttr;
  } else {
    if (Object.keys(tabsterOnElement).length === 0) {
      delete entry.tabster;
      delete entry.attr;
    }
    tabster.storageEntry(element, false);
  }
}
var TabsterFocusInEventName = "tabster:focusin";
var TabsterFocusOutEventName = "tabster:focusout";
var TabsterMoveFocusEventName = "tabster:movefocus";
var ModalizerActiveEventName = "tabster:modalizer:active";
var ModalizerInactiveEventName = "tabster:modalizer:inactive";
var MoverStateEventName = "tabster:mover:state";
var MoverMoveFocusEventName = "tabster:mover:movefocus";
var MoverMemorizedElementEventName = "tabster:mover:memorized-element";
var GroupperMoveFocusEventName = "tabster:groupper:movefocus";
var RestorerRestoreFocusEventName = "tabster:restorer:restore-focus";
var RootFocusEventName = "tabster:root:focus";
var RootBlurEventName = "tabster:root:blur";
var CustomEvent_ = typeof CustomEvent !== "undefined" ? CustomEvent : function() {
};
var TabsterCustomEvent = class extends CustomEvent_ {
  constructor(type, detail) {
    super(type, {
      bubbles: true,
      cancelable: true,
      composed: true,
      detail
    });
    this.details = detail;
  }
};
var TabsterFocusInEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(TabsterFocusInEventName, detail);
  }
};
var TabsterFocusOutEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(TabsterFocusOutEventName, detail);
  }
};
var TabsterMoveFocusEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(TabsterMoveFocusEventName, detail);
  }
};
var MoverStateEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(MoverStateEventName, detail);
  }
};
var MoverMoveFocusEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(MoverMoveFocusEventName, detail);
  }
};
var GroupperMoveFocusEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(GroupperMoveFocusEventName, detail);
  }
};
var ModalizerActiveEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(ModalizerActiveEventName, detail);
  }
};
var ModalizerInactiveEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(ModalizerInactiveEventName, detail);
  }
};
var RestorerRestoreFocusEvent = class extends TabsterCustomEvent {
  constructor() {
    super(RestorerRestoreFocusEventName);
  }
};
var RootFocusEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(RootFocusEventName, detail);
  }
};
var RootBlurEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(RootBlurEventName, detail);
  }
};
var _createMutationObserver = (callback) => new MutationObserver(callback);
var _createTreeWalker = (doc, root, whatToShow, filter) => doc.createTreeWalker(root, whatToShow, filter);
var _getParentNode = (node) => node ? node.parentNode : null;
var _getParentElement = (element) => element ? element.parentElement : null;
var _nodeContains = (parent2, child) => !!(child && (parent2 === null || parent2 === void 0 ? void 0 : parent2.contains(child)));
var _getActiveElement = (doc) => doc.activeElement;
var _querySelector = (element, selector) => element.querySelector(selector);
var _querySelectorAll = (element, selector) => Array.prototype.slice.call(element.querySelectorAll(selector), 0);
var _getElementById = (doc, id) => doc.getElementById(id);
var _getFirstChild = (node) => (node === null || node === void 0 ? void 0 : node.firstChild) || null;
var _getLastChild = (node) => (node === null || node === void 0 ? void 0 : node.lastChild) || null;
var _getNextSibling = (node) => (node === null || node === void 0 ? void 0 : node.nextSibling) || null;
var _getPreviousSibling = (node) => (node === null || node === void 0 ? void 0 : node.previousSibling) || null;
var _getFirstElementChild = (element) => (element === null || element === void 0 ? void 0 : element.firstElementChild) || null;
var _getLastElementChild = (element) => (element === null || element === void 0 ? void 0 : element.lastElementChild) || null;
var _getNextElementSibling = (element) => (element === null || element === void 0 ? void 0 : element.nextElementSibling) || null;
var _getPreviousElementSibling = (element) => (element === null || element === void 0 ? void 0 : element.previousElementSibling) || null;
var _appendChild = (parent2, child) => parent2.appendChild(child);
var _insertBefore = (parent2, child, referenceChild) => parent2.insertBefore(child, referenceChild);
var _getSelection = (ref) => {
  var _a;
  return ((_a = ref.ownerDocument) === null || _a === void 0 ? void 0 : _a.getSelection()) || null;
};
var _getElementsByName = (referenceElement, name) => referenceElement.ownerDocument.getElementsByName(name);
var dom = {
  createMutationObserver: _createMutationObserver,
  createTreeWalker: _createTreeWalker,
  getParentNode: _getParentNode,
  getParentElement: _getParentElement,
  nodeContains: _nodeContains,
  getActiveElement: _getActiveElement,
  querySelector: _querySelector,
  querySelectorAll: _querySelectorAll,
  getElementById: _getElementById,
  getFirstChild: _getFirstChild,
  getLastChild: _getLastChild,
  getNextSibling: _getNextSibling,
  getPreviousSibling: _getPreviousSibling,
  getFirstElementChild: _getFirstElementChild,
  getLastElementChild: _getLastElementChild,
  getNextElementSibling: _getNextElementSibling,
  getPreviousElementSibling: _getPreviousElementSibling,
  appendChild: _appendChild,
  insertBefore: _insertBefore,
  getSelection: _getSelection,
  getElementsByName: _getElementsByName
};
function setDOMAPI(domapi) {
  for (const key of Object.keys(domapi)) {
    dom[key] = domapi[key];
  }
}
var _isBrokenIE11;
var _DOMRect = typeof DOMRect !== "undefined" ? DOMRect : class {
  constructor(x, y, width, height) {
    this.left = x || 0;
    this.top = y || 0;
    this.right = (x || 0) + (width || 0);
    this.bottom = (y || 0) + (height || 0);
  }
};
var _uidCounter = 0;
try {
  document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);
  _isBrokenIE11 = false;
} catch (e) {
  _isBrokenIE11 = true;
}
var _updateDummyInputsTimeout = 100;
function getInstanceContext(getWindow2) {
  const win = getWindow2();
  let ctx = win.__tabsterInstanceContext;
  if (!ctx) {
    ctx = {
      elementByUId: {},
      basics: {
        Promise: win.Promise || void 0,
        WeakRef: win.WeakRef || void 0
      },
      containerBoundingRectCache: {},
      lastContainerBoundingRectCacheId: 0,
      fakeWeakRefs: [],
      fakeWeakRefsStarted: false
    };
    win.__tabsterInstanceContext = ctx;
  }
  return ctx;
}
function disposeInstanceContext(win) {
  const ctx = win.__tabsterInstanceContext;
  if (ctx) {
    ctx.elementByUId = {};
    delete ctx.WeakRef;
    ctx.containerBoundingRectCache = {};
    if (ctx.containerBoundingRectCacheTimer) {
      win.clearTimeout(ctx.containerBoundingRectCacheTimer);
    }
    if (ctx.fakeWeakRefsTimer) {
      win.clearTimeout(ctx.fakeWeakRefsTimer);
    }
    ctx.fakeWeakRefs = [];
    delete win.__tabsterInstanceContext;
  }
}
function createWeakMap(win) {
  const ctx = win.__tabsterInstanceContext;
  return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();
}
function hasSubFocusable(element) {
  return !!element.querySelector(FOCUSABLE_SELECTOR);
}
var FakeWeakRef = class {
  constructor(target) {
    this._target = target;
  }
  deref() {
    return this._target;
  }
  static cleanup(fwr, forceRemove) {
    if (!fwr._target) {
      return true;
    }
    if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {
      delete fwr._target;
      return true;
    }
    return false;
  }
};
var WeakHTMLElement = class {
  constructor(getWindow2, element, data) {
    const context = getInstanceContext(getWindow2);
    let ref;
    if (context.WeakRef) {
      ref = new context.WeakRef(element);
    } else {
      ref = new FakeWeakRef(element);
      context.fakeWeakRefs.push(ref);
    }
    this._ref = ref;
    this._data = data;
  }
  get() {
    const ref = this._ref;
    let element;
    if (ref) {
      element = ref.deref();
      if (!element) {
        delete this._ref;
      }
    }
    return element;
  }
  getData() {
    return this._data;
  }
};
function cleanupFakeWeakRefs(getWindow2, forceRemove) {
  const context = getInstanceContext(getWindow2);
  context.fakeWeakRefs = context.fakeWeakRefs.filter((e) => !FakeWeakRef.cleanup(e, forceRemove));
}
function startFakeWeakRefsCleanup(getWindow2) {
  const context = getInstanceContext(getWindow2);
  if (!context.fakeWeakRefsStarted) {
    context.fakeWeakRefsStarted = true;
    context.WeakRef = getWeakRef(context);
  }
  if (!context.fakeWeakRefsTimer) {
    context.fakeWeakRefsTimer = getWindow2().setTimeout(() => {
      context.fakeWeakRefsTimer = void 0;
      cleanupFakeWeakRefs(getWindow2);
      startFakeWeakRefsCleanup(getWindow2);
    }, 2 * 60 * 1e3);
  }
}
function stopFakeWeakRefsCleanupAndClearStorage(getWindow2) {
  const context = getInstanceContext(getWindow2);
  context.fakeWeakRefsStarted = false;
  if (context.fakeWeakRefsTimer) {
    getWindow2().clearTimeout(context.fakeWeakRefsTimer);
    context.fakeWeakRefsTimer = void 0;
    context.fakeWeakRefs = [];
  }
}
function createElementTreeWalker(doc, root, acceptNode) {
  if (root.nodeType !== Node.ELEMENT_NODE) {
    return void 0;
  }
  const filter = _isBrokenIE11 ? acceptNode : {
    acceptNode
  };
  return dom.createTreeWalker(
    doc,
    root,
    NodeFilter.SHOW_ELEMENT,
    filter,
    // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.
    false
    /* Last argument is not optional for IE11! */
  );
}
function getBoundingRect(getWindow2, element) {
  let cacheId = element.__tabsterCacheId;
  const context = getInstanceContext(getWindow2);
  const cached = cacheId ? context.containerBoundingRectCache[cacheId] : void 0;
  if (cached) {
    return cached.rect;
  }
  const scrollingElement = element.ownerDocument && element.ownerDocument.documentElement;
  if (!scrollingElement) {
    return new _DOMRect();
  }
  let left2 = 0;
  let top = 0;
  let right2 = scrollingElement.clientWidth;
  let bottom = scrollingElement.clientHeight;
  if (element !== scrollingElement) {
    const r = element.getBoundingClientRect();
    left2 = Math.max(left2, r.left);
    top = Math.max(top, r.top);
    right2 = Math.min(right2, r.right);
    bottom = Math.min(bottom, r.bottom);
  }
  const rect = new _DOMRect(left2 < right2 ? left2 : -1, top < bottom ? top : -1, left2 < right2 ? right2 - left2 : 0, top < bottom ? bottom - top : 0);
  if (!cacheId) {
    cacheId = "r-" + ++context.lastContainerBoundingRectCacheId;
    element.__tabsterCacheId = cacheId;
  }
  context.containerBoundingRectCache[cacheId] = {
    rect,
    element
  };
  if (!context.containerBoundingRectCacheTimer) {
    context.containerBoundingRectCacheTimer = window.setTimeout(() => {
      context.containerBoundingRectCacheTimer = void 0;
      for (const cId of Object.keys(context.containerBoundingRectCache)) {
        delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;
      }
      context.containerBoundingRectCache = {};
    }, 50);
  }
  return rect;
}
function isElementVerticallyVisibleInContainer(getWindow2, element, tolerance) {
  const container = getScrollableContainer(element);
  if (!container) {
    return false;
  }
  const containerRect = getBoundingRect(getWindow2, container);
  const elementRect = element.getBoundingClientRect();
  const intersectionTolerance = elementRect.height * (1 - tolerance);
  const topIntersection = Math.max(0, containerRect.top - elementRect.top);
  const bottomIntersection = Math.max(0, elementRect.bottom - containerRect.bottom);
  const totalIntersection = topIntersection + bottomIntersection;
  return totalIntersection === 0 || totalIntersection <= intersectionTolerance;
}
function scrollIntoView(getWindow2, element, alignToTop) {
  const container = getScrollableContainer(element);
  if (container) {
    const containerRect = getBoundingRect(getWindow2, container);
    const elementRect = element.getBoundingClientRect();
    if (alignToTop) {
      container.scrollTop += elementRect.top - containerRect.top;
    } else {
      container.scrollTop += elementRect.bottom - containerRect.bottom;
    }
  }
}
function getScrollableContainer(element) {
  const doc = element.ownerDocument;
  if (doc) {
    for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) {
      if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {
        return el;
      }
    }
    return doc.documentElement;
  }
  return null;
}
function makeFocusIgnored(element) {
  element.__shouldIgnoreFocus = true;
}
function shouldIgnoreFocus(element) {
  return !!element.__shouldIgnoreFocus;
}
function getUId(wnd) {
  const rnd = new Uint32Array(4);
  if (wnd.crypto && wnd.crypto.getRandomValues) {
    wnd.crypto.getRandomValues(rnd);
  } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {
    wnd.msCrypto.getRandomValues(rnd);
  } else {
    for (let i = 0; i < rnd.length; i++) {
      rnd[i] = 4294967295 * Math.random();
    }
  }
  const srnd = [];
  for (let i = 0; i < rnd.length; i++) {
    srnd.push(rnd[i].toString(36));
  }
  srnd.push("|");
  srnd.push((++_uidCounter).toString(36));
  srnd.push("|");
  srnd.push(Date.now().toString(36));
  return srnd.join("");
}
function getElementUId(getWindow2, element) {
  const context = getInstanceContext(getWindow2);
  let uid = element.__tabsterElementUID;
  if (!uid) {
    uid = element.__tabsterElementUID = getUId(getWindow2());
  }
  if (!context.elementByUId[uid] && documentContains(element.ownerDocument, element)) {
    context.elementByUId[uid] = new WeakHTMLElement(getWindow2, element);
  }
  return uid;
}
function clearElementCache(getWindow2, parent2) {
  const context = getInstanceContext(getWindow2);
  for (const key of Object.keys(context.elementByUId)) {
    const wel = context.elementByUId[key];
    const el = wel && wel.get();
    if (el && parent2) {
      if (!dom.nodeContains(parent2, el)) {
        continue;
      }
    }
    delete context.elementByUId[key];
  }
}
function documentContains(doc, element) {
  return dom.nodeContains(doc === null || doc === void 0 ? void 0 : doc.body, element);
}
function matchesSelector(element, selector) {
  const matches = element.matches || element.matchesSelector || element.msMatchesSelector || element.webkitMatchesSelector;
  return matches && matches.call(element, selector);
}
function getPromise(getWindow2) {
  const context = getInstanceContext(getWindow2);
  if (context.basics.Promise) {
    return context.basics.Promise;
  }
  throw new Error("No Promise defined.");
}
function getWeakRef(context) {
  return context.basics.WeakRef;
}
var _lastTabsterPartId = 0;
var TabsterPart = class {
  constructor(tabster, element, props) {
    const getWindow2 = tabster.getWindow;
    this._tabster = tabster;
    this._element = new WeakHTMLElement(getWindow2, element);
    this._props = {
      ...props
    };
    this.id = "i" + ++_lastTabsterPartId;
  }
  getElement() {
    return this._element.get();
  }
  getProps() {
    return this._props;
  }
  setProps(props) {
    this._props = {
      ...props
    };
  }
};
var DummyInput = class {
  constructor(getWindow2, isOutside, props, element, fixedTarget) {
    var _a;
    this._focusIn = (e) => {
      if (this._fixedTarget) {
        const target = this._fixedTarget.get();
        if (target) {
          nativeFocus(target);
        }
        return;
      }
      const input2 = this.input;
      if (this.onFocusIn && input2) {
        const relatedTarget = e.relatedTarget;
        this.onFocusIn(this, this._isBackward(true, input2, relatedTarget), relatedTarget);
      }
    };
    this._focusOut = (e) => {
      if (this._fixedTarget) {
        return;
      }
      this.useDefaultAction = false;
      const input2 = this.input;
      if (this.onFocusOut && input2) {
        const relatedTarget = e.relatedTarget;
        this.onFocusOut(this, this._isBackward(false, input2, relatedTarget), relatedTarget);
      }
    };
    const win = getWindow2();
    const input = win.document.createElement("i");
    input.tabIndex = 0;
    input.setAttribute("role", "none");
    input.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, "");
    input.setAttribute("aria-hidden", "true");
    const style = input.style;
    style.position = "fixed";
    style.width = style.height = "1px";
    style.opacity = "0.001";
    style.zIndex = "-1";
    style.setProperty("content-visibility", "hidden");
    makeFocusIgnored(input);
    this.input = input;
    this.isFirst = props.isFirst;
    this.isOutside = isOutside;
    this._isPhantom = (_a = props.isPhantom) !== null && _a !== void 0 ? _a : false;
    this._fixedTarget = fixedTarget;
    input.addEventListener("focusin", this._focusIn);
    input.addEventListener("focusout", this._focusOut);
    input.__tabsterDummyContainer = element;
    if (this._isPhantom) {
      this._disposeTimer = win.setTimeout(() => {
        delete this._disposeTimer;
        this.dispose();
      }, 0);
      this._clearDisposeTimeout = () => {
        if (this._disposeTimer) {
          win.clearTimeout(this._disposeTimer);
          delete this._disposeTimer;
        }
        delete this._clearDisposeTimeout;
      };
    }
  }
  dispose() {
    var _a;
    if (this._clearDisposeTimeout) {
      this._clearDisposeTimeout();
    }
    const input = this.input;
    if (!input) {
      return;
    }
    delete this._fixedTarget;
    delete this.onFocusIn;
    delete this.onFocusOut;
    delete this.input;
    input.removeEventListener("focusin", this._focusIn);
    input.removeEventListener("focusout", this._focusOut);
    delete input.__tabsterDummyContainer;
    (_a = dom.getParentNode(input)) === null || _a === void 0 ? void 0 : _a.removeChild(input);
  }
  setTopLeft(top, left2) {
    var _a;
    const style = (_a = this.input) === null || _a === void 0 ? void 0 : _a.style;
    if (style) {
      style.top = `${top}px`;
      style.left = `${left2}px`;
    }
  }
  _isBackward(isIn, current, previous) {
    return isIn && !previous ? !this.isFirst : !!(previous && current.compareDocumentPosition(previous) & Node.DOCUMENT_POSITION_FOLLOWING);
  }
};
var DummyInputManagerPriorities = {
  Root: 1,
  Modalizer: 2,
  Mover: 3,
  Groupper: 4
};
var DummyInputManager = class {
  constructor(tabster, element, priority, sys, outsideByDefault, callForDefaultAction) {
    this._element = element;
    this._instance = new DummyInputManagerCore(tabster, element, this, priority, sys, outsideByDefault, callForDefaultAction);
  }
  _setHandlers(onFocusIn, onFocusOut) {
    this._onFocusIn = onFocusIn;
    this._onFocusOut = onFocusOut;
  }
  moveOut(backwards) {
    var _a;
    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOut(backwards);
  }
  moveOutWithDefaultAction(backwards, relatedEvent) {
    var _a;
    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOutWithDefaultAction(backwards, relatedEvent);
  }
  getHandler(isIn) {
    return isIn ? this._onFocusIn : this._onFocusOut;
  }
  setTabbable(tabbable) {
    var _a;
    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.setTabbable(this, tabbable);
  }
  dispose() {
    if (this._instance) {
      this._instance.dispose(this);
      delete this._instance;
    }
    delete this._onFocusIn;
    delete this._onFocusOut;
  }
  static moveWithPhantomDummy(tabster, element, moveOutOfElement, isBackward, relatedEvent) {
    const dummy = new DummyInput(tabster.getWindow, true, {
      isPhantom: true,
      isFirst: true
    });
    const input = dummy.input;
    if (input) {
      let parent2;
      let insertBefore2;
      if (element.tagName === "BODY") {
        parent2 = element;
        insertBefore2 = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getFirstElementChild(element) : null;
      } else {
        if (moveOutOfElement && (!isBackward || isBackward && !tabster.focusable.isFocusable(element, false, true, true))) {
          parent2 = element;
          insertBefore2 = isBackward ? element.firstElementChild : null;
        } else {
          parent2 = dom.getParentElement(element);
          insertBefore2 = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? element : dom.getNextElementSibling(element);
        }
        let potentialDummy;
        let dummyFor;
        do {
          potentialDummy = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getPreviousElementSibling(insertBefore2) : insertBefore2;
          dummyFor = getDummyInputContainer(potentialDummy);
          if (dummyFor === element) {
            insertBefore2 = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? potentialDummy : dom.getNextElementSibling(potentialDummy);
          } else {
            dummyFor = null;
          }
        } while (dummyFor);
      }
      if (parent2 === null || parent2 === void 0 ? void 0 : parent2.dispatchEvent(new TabsterMoveFocusEvent({
        by: "root",
        owner: parent2,
        next: null,
        relatedEvent
      }))) {
        dom.insertBefore(parent2, input, insertBefore2);
        nativeFocus(input);
      }
    }
  }
  static addPhantomDummyWithTarget(tabster, sourceElement, isBackward, targetElement) {
    const dummy = new DummyInput(tabster.getWindow, true, {
      isPhantom: true,
      isFirst: true
    }, void 0, new WeakHTMLElement(tabster.getWindow, targetElement));
    const input = dummy.input;
    if (input) {
      let dummyParent;
      let insertBefore2;
      if (hasSubFocusable(sourceElement) && !isBackward) {
        dummyParent = sourceElement;
        insertBefore2 = dom.getFirstElementChild(sourceElement);
      } else {
        dummyParent = dom.getParentElement(sourceElement);
        insertBefore2 = isBackward ? sourceElement : dom.getNextElementSibling(sourceElement);
      }
      if (dummyParent) {
        dom.insertBefore(dummyParent, input, insertBefore2);
      }
    }
  }
};
function setDummyInputDebugValue(dummy, wrappers) {
  var _a;
  const what = {
    1: "Root",
    2: "Modalizer",
    3: "Mover",
    4: "Groupper"
  };
  (_a = dummy.input) === null || _a === void 0 ? void 0 : _a.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, [`isFirst=${dummy.isFirst}`, `isOutside=${dummy.isOutside}`, ...wrappers.map((w) => `(${what[w.priority]}, tabbable=${w.tabbable})`)].join(", "));
}
var DummyInputObserver = class {
  constructor(win) {
    this._updateQueue = /* @__PURE__ */ new Set();
    this._lastUpdateQueueTime = 0;
    this._changedParents = /* @__PURE__ */ new WeakSet();
    this._dummyElements = [];
    this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
    this._domChanged = (parent2) => {
      var _a;
      if (this._changedParents.has(parent2)) {
        return;
      }
      this._changedParents.add(parent2);
      if (this._updateDummyInputsTimer) {
        return;
      }
      this._updateDummyInputsTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {
        delete this._updateDummyInputsTimer;
        for (const ref of this._dummyElements) {
          const dummyElement = ref.get();
          if (dummyElement) {
            const callback = this._dummyCallbacks.get(dummyElement);
            if (callback) {
              const dummyParent = dom.getParentNode(dummyElement);
              if (!dummyParent || this._changedParents.has(dummyParent)) {
                callback();
              }
            }
          }
        }
        this._changedParents = /* @__PURE__ */ new WeakSet();
      }, _updateDummyInputsTimeout);
    };
    this._win = win;
  }
  add(dummy, callback) {
    if (!this._dummyCallbacks.has(dummy) && this._win) {
      this._dummyElements.push(new WeakHTMLElement(this._win, dummy));
      this._dummyCallbacks.set(dummy, callback);
      this.domChanged = this._domChanged;
    }
  }
  remove(dummy) {
    this._dummyElements = this._dummyElements.filter((ref) => {
      const element = ref.get();
      return element && element !== dummy;
    });
    this._dummyCallbacks.delete(dummy);
    if (this._dummyElements.length === 0) {
      delete this.domChanged;
    }
  }
  dispose() {
    var _a;
    const win = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this);
    if (this._updateTimer) {
      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateTimer);
      delete this._updateTimer;
    }
    if (this._updateDummyInputsTimer) {
      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateDummyInputsTimer);
      delete this._updateDummyInputsTimer;
    }
    this._changedParents = /* @__PURE__ */ new WeakSet();
    this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
    this._dummyElements = [];
    this._updateQueue.clear();
    delete this.domChanged;
    delete this._win;
  }
  updatePositions(compute) {
    if (!this._win) {
      return;
    }
    this._updateQueue.add(compute);
    this._lastUpdateQueueTime = Date.now();
    this._scheduledUpdatePositions();
  }
  _scheduledUpdatePositions() {
    var _a;
    if (this._updateTimer) {
      return;
    }
    this._updateTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {
      delete this._updateTimer;
      if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {
        const scrollTopLeftCache = /* @__PURE__ */ new Map();
        const setTopLeftCallbacks = [];
        for (const compute of this._updateQueue) {
          setTopLeftCallbacks.push(compute(scrollTopLeftCache));
        }
        this._updateQueue.clear();
        for (const setTopLeft of setTopLeftCallbacks) {
          setTopLeft();
        }
        scrollTopLeftCache.clear();
      } else {
        this._scheduledUpdatePositions();
      }
    }, _updateDummyInputsTimeout);
  }
};
var DummyInputManagerCore = class {
  constructor(tabster, element, manager, priority, sys, outsideByDefault, callForDefaultAction) {
    this._wrappers = [];
    this._isOutside = false;
    this._transformElements = /* @__PURE__ */ new Set();
    this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {
      this._onFocus(true, dummyInput, isBackward, relatedTarget);
    };
    this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {
      this._onFocus(false, dummyInput, isBackward, relatedTarget);
    };
    this.moveOut = (backwards) => {
      var _a;
      const first = this._firstDummy;
      const last = this._lastDummy;
      if (first && last) {
        this._ensurePosition();
        const firstInput = first.input;
        const lastInput = last.input;
        const element2 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
        if (firstInput && lastInput && element2) {
          let toFocus;
          if (backwards) {
            firstInput.tabIndex = 0;
            toFocus = firstInput;
          } else {
            lastInput.tabIndex = 0;
            toFocus = lastInput;
          }
          if (toFocus) {
            nativeFocus(toFocus);
          }
        }
      }
    };
    this.moveOutWithDefaultAction = (backwards, relatedEvent) => {
      var _a;
      const first = this._firstDummy;
      const last = this._lastDummy;
      if (first && last) {
        this._ensurePosition();
        const firstInput = first.input;
        const lastInput = last.input;
        const element2 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
        if (firstInput && lastInput && element2) {
          let toFocus;
          if (backwards) {
            if (!first.isOutside && this._tabster.focusable.isFocusable(element2, true, true, true)) {
              toFocus = element2;
            } else {
              first.useDefaultAction = true;
              firstInput.tabIndex = 0;
              toFocus = firstInput;
            }
          } else {
            last.useDefaultAction = true;
            lastInput.tabIndex = 0;
            toFocus = lastInput;
          }
          if (toFocus && element2.dispatchEvent(new TabsterMoveFocusEvent({
            by: "root",
            owner: element2,
            next: null,
            relatedEvent
          }))) {
            nativeFocus(toFocus);
          }
        }
      }
    };
    this.setTabbable = (manager2, tabbable) => {
      var _a, _b;
      for (const w of this._wrappers) {
        if (w.manager === manager2) {
          w.tabbable = tabbable;
          break;
        }
      }
      const wrapper = this._getCurrent();
      if (wrapper) {
        const tabIndex = wrapper.tabbable ? 0 : -1;
        let input = (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input;
        if (input) {
          input.tabIndex = tabIndex;
        }
        input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;
        if (input) {
          input.tabIndex = tabIndex;
        }
      }
      if (true) {
        this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);
        this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);
      }
    };
    this._addDummyInputs = () => {
      if (this._addTimer) {
        return;
      }
      this._addTimer = this._getWindow().setTimeout(() => {
        delete this._addTimer;
        this._ensurePosition();
        if (true) {
          this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);
          this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);
        }
        this._addTransformOffsets();
      }, 0);
    };
    this._addTransformOffsets = () => {
      this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);
    };
    this._computeTransformOffsets = (scrollTopLeftCache) => {
      var _a, _b;
      const from = ((_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);
      const transformElements = this._transformElements;
      const newTransformElements = /* @__PURE__ */ new Set();
      let scrollTop = 0;
      let scrollLeft = 0;
      const win = this._getWindow();
      for (let element2 = from; element2 && element2.nodeType === Node.ELEMENT_NODE; element2 = dom.getParentElement(element2)) {
        let scrollTopLeft = scrollTopLeftCache.get(element2);
        if (scrollTopLeft === void 0) {
          const transform = win.getComputedStyle(element2).transform;
          if (transform && transform !== "none") {
            scrollTopLeft = {
              scrollTop: element2.scrollTop,
              scrollLeft: element2.scrollLeft
            };
          }
          scrollTopLeftCache.set(element2, scrollTopLeft || null);
        }
        if (scrollTopLeft) {
          newTransformElements.add(element2);
          if (!transformElements.has(element2)) {
            element2.addEventListener("scroll", this._addTransformOffsets);
          }
          scrollTop += scrollTopLeft.scrollTop;
          scrollLeft += scrollTopLeft.scrollLeft;
        }
      }
      for (const el2 of transformElements) {
        if (!newTransformElements.has(el2)) {
          el2.removeEventListener("scroll", this._addTransformOffsets);
        }
      }
      this._transformElements = newTransformElements;
      return () => {
        var _a2, _b2;
        (_a2 = this._firstDummy) === null || _a2 === void 0 ? void 0 : _a2.setTopLeft(scrollTop, scrollLeft);
        (_b2 = this._lastDummy) === null || _b2 === void 0 ? void 0 : _b2.setTopLeft(scrollTop, scrollLeft);
      };
    };
    const el = element.get();
    if (!el) {
      throw new Error("No element");
    }
    this._tabster = tabster;
    this._getWindow = tabster.getWindow;
    this._callForDefaultAction = callForDefaultAction;
    const instance = el.__tabsterDummy;
    (instance || this)._wrappers.push({
      manager,
      priority,
      tabbable: true
    });
    if (instance) {
      if (true) {
        this._firstDummy && setDummyInputDebugValue(this._firstDummy, instance._wrappers);
        this._lastDummy && setDummyInputDebugValue(this._lastDummy, instance._wrappers);
      }
      return instance;
    }
    el.__tabsterDummy = this;
    const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;
    const tagName = el.tagName;
    this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === "UL" || tagName === "OL" || tagName === "TABLE") && !(tagName === "LI" || tagName === "TD" || tagName === "TH") : forcedDummyPosition === SysDummyInputsPositions.Outside;
    this._firstDummy = new DummyInput(this._getWindow, this._isOutside, {
      isFirst: true
    }, element);
    this._lastDummy = new DummyInput(this._getWindow, this._isOutside, {
      isFirst: false
    }, element);
    const dummyElement = this._firstDummy.input;
    dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);
    this._firstDummy.onFocusIn = this._onFocusIn;
    this._firstDummy.onFocusOut = this._onFocusOut;
    this._lastDummy.onFocusIn = this._onFocusIn;
    this._lastDummy.onFocusOut = this._onFocusOut;
    this._element = element;
    this._addDummyInputs();
  }
  dispose(manager, force) {
    var _a, _b, _c, _d;
    const wrappers = this._wrappers = this._wrappers.filter((w) => w.manager !== manager && !force);
    if (true) {
      this._firstDummy && setDummyInputDebugValue(this._firstDummy, wrappers);
      this._lastDummy && setDummyInputDebugValue(this._lastDummy, wrappers);
    }
    if (wrappers.length === 0) {
      delete ((_a = this._element) === null || _a === void 0 ? void 0 : _a.get()).__tabsterDummy;
      for (const el of this._transformElements) {
        el.removeEventListener("scroll", this._addTransformOffsets);
      }
      this._transformElements.clear();
      const win = this._getWindow();
      if (this._addTimer) {
        win.clearTimeout(this._addTimer);
        delete this._addTimer;
      }
      const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
      dummyElement && this._tabster._dummyObserver.remove(dummyElement);
      (_c = this._firstDummy) === null || _c === void 0 ? void 0 : _c.dispose();
      (_d = this._lastDummy) === null || _d === void 0 ? void 0 : _d.dispose();
    }
  }
  _onFocus(isIn, dummyInput, isBackward, relatedTarget) {
    var _a;
    const wrapper = this._getCurrent();
    if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) {
      (_a = wrapper.manager.getHandler(isIn)) === null || _a === void 0 ? void 0 : _a(dummyInput, isBackward, relatedTarget);
    }
  }
  _getCurrent() {
    this._wrappers.sort((a, b) => {
      if (a.tabbable !== b.tabbable) {
        return a.tabbable ? -1 : 1;
      }
      return a.priority - b.priority;
    });
    return this._wrappers[0];
  }
  _ensurePosition() {
    var _a, _b, _c;
    const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
    const firstDummyInput = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
    const lastDummyInput = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;
    if (!element || !firstDummyInput || !lastDummyInput) {
      return;
    }
    if (this._isOutside) {
      const elementParent = dom.getParentNode(element);
      if (elementParent) {
        const nextSibling = dom.getNextSibling(element);
        if (nextSibling !== lastDummyInput) {
          dom.insertBefore(elementParent, lastDummyInput, nextSibling);
        }
        if (dom.getPreviousElementSibling(element) !== firstDummyInput) {
          dom.insertBefore(elementParent, firstDummyInput, element);
        }
      }
    } else {
      if (dom.getLastElementChild(element) !== lastDummyInput) {
        dom.appendChild(element, lastDummyInput);
      }
      const firstElementChild = dom.getFirstElementChild(element);
      if (firstElementChild && firstElementChild !== firstDummyInput && firstElementChild.parentNode) {
        dom.insertBefore(firstElementChild.parentNode, firstDummyInput, firstElementChild);
      }
    }
  }
};
function getLastChild$2(container) {
  let lastChild = null;
  for (let i = dom.getLastElementChild(container); i; i = dom.getLastElementChild(i)) {
    lastChild = i;
  }
  return lastChild || void 0;
}
function getAdjacentElement(from, prev) {
  let cur = from;
  let adjacent = null;
  while (cur && !adjacent) {
    adjacent = prev ? dom.getPreviousElementSibling(cur) : dom.getNextElementSibling(cur);
    cur = dom.getParentElement(cur);
  }
  return adjacent || void 0;
}
function augmentAttribute(tabster, element, name, value) {
  const entry = tabster.storageEntry(element, true);
  let ret = false;
  if (!entry.aug) {
    if (value === void 0) {
      return ret;
    }
    entry.aug = {};
  }
  if (value === void 0) {
    if (name in entry.aug) {
      const origVal = entry.aug[name];
      delete entry.aug[name];
      if (origVal === null) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, origVal);
      }
      ret = true;
    }
  } else {
    let origValue;
    if (!(name in entry.aug)) {
      origValue = element.getAttribute(name);
    }
    if (origValue !== void 0 && origValue !== value) {
      entry.aug[name] = origValue;
      if (value === null) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value);
      }
      ret = true;
    }
  }
  if (value === void 0 && Object.keys(entry.aug).length === 0) {
    delete entry.aug;
    tabster.storageEntry(element, false);
  }
  return ret;
}
function isDisplayNone(element) {
  var _a, _b;
  const elementDocument = element.ownerDocument;
  const computedStyle = (_a = elementDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getComputedStyle(element);
  if (element.offsetParent === null && elementDocument.body !== element && (computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) !== "fixed") {
    return true;
  }
  if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.visibility) === "hidden") {
    return true;
  }
  if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) === "fixed") {
    if (computedStyle.display === "none") {
      return true;
    }
    if (((_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.offsetParent) === null && elementDocument.body !== element.parentElement) {
      return true;
    }
  }
  return false;
}
function isRadio(element) {
  return element.tagName === "INPUT" && !!element.name && element.type === "radio";
}
function getRadioButtonGroup(element) {
  if (!isRadio(element)) {
    return;
  }
  const name = element.name;
  let radioButtons = Array.from(dom.getElementsByName(element, name));
  let checked;
  radioButtons = radioButtons.filter((el) => {
    if (isRadio(el)) {
      if (el.checked) {
        checked = el;
      }
      return true;
    }
    return false;
  });
  return {
    name,
    buttons: new Set(radioButtons),
    checked
  };
}
function getDummyInputContainer(element) {
  var _a;
  return ((_a = element === null || element === void 0 ? void 0 : element.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) || null;
}
function getTabsterAttribute(props, plain) {
  const attr = JSON.stringify(props);
  if (plain === true) {
    return attr;
  }
  return {
    [TABSTER_ATTRIBUTE_NAME]: attr
  };
}
function mergeTabsterProps(props, newProps) {
  for (const key of Object.keys(newProps)) {
    const value = newProps[key];
    if (value) {
      props[key] = value;
    } else {
      delete props[key];
    }
  }
}
function setTabsterAttribute(element, newProps, update) {
  let props;
  if (update) {
    const attr = element.getAttribute(TABSTER_ATTRIBUTE_NAME);
    if (attr) {
      try {
        props = JSON.parse(attr);
      } catch (e) {
        if (true) {
          console.error(`data-tabster attribute error: ${e}`, element);
        }
      }
    }
  }
  if (!props) {
    props = {};
  }
  mergeTabsterProps(props, newProps);
  if (Object.keys(props).length > 0) {
    element.setAttribute(TABSTER_ATTRIBUTE_NAME, getTabsterAttribute(props, true));
  } else {
    element.removeAttribute(TABSTER_ATTRIBUTE_NAME);
  }
}
function _setInformativeStyle$3(weakElement, remove, id) {
  if (true) {
    const element = weakElement.get();
    if (element) {
      if (remove) {
        element.style.removeProperty("--tabster-root");
      } else {
        element.style.setProperty("--tabster-root", id + ",");
      }
    }
  }
}
var RootDummyManager = class extends DummyInputManager {
  constructor(tabster, element, setFocused, sys) {
    super(tabster, element, DummyInputManagerPriorities.Root, sys, void 0, true);
    this._onDummyInputFocus = (dummyInput) => {
      var _a;
      if (dummyInput.useDefaultAction) {
        this._setFocused(false);
      } else {
        this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);
        const element2 = this._element.get();
        if (element2) {
          this._setFocused(true);
          const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {
            container: element2,
            ignoreAccessibility: true
          });
          if (toFocus) {
            nativeFocus(toFocus);
            return;
          }
        }
        (_a = dummyInput.input) === null || _a === void 0 ? void 0 : _a.blur();
      }
    };
    this._setHandlers(this._onDummyInputFocus);
    this._tabster = tabster;
    this._setFocused = setFocused;
  }
};
var Root = class extends TabsterPart {
  constructor(tabster, element, onDispose, props, sys) {
    super(tabster, element, props);
    this._isFocused = false;
    this._setFocused = (hasFocused) => {
      var _a;
      if (this._setFocusedTimer) {
        this._tabster.getWindow().clearTimeout(this._setFocusedTimer);
        delete this._setFocusedTimer;
      }
      if (this._isFocused === hasFocused) {
        return;
      }
      const element2 = this._element.get();
      if (element2) {
        if (hasFocused) {
          this._isFocused = true;
          (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(false);
          element2.dispatchEvent(new RootFocusEvent({
            element: element2
          }));
        } else {
          this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {
            var _a2;
            delete this._setFocusedTimer;
            this._isFocused = false;
            (_a2 = this._dummyManager) === null || _a2 === void 0 ? void 0 : _a2.setTabbable(true);
            element2.dispatchEvent(new RootBlurEvent({
              element: element2
            }));
          }, 0);
        }
      }
    };
    this._onFocusIn = (event) => {
      const getParent2 = this._tabster.getParent;
      const rootElement = this._element.get();
      let curElement = event.composedPath()[0];
      do {
        if (curElement === rootElement) {
          this._setFocused(true);
          return;
        }
        curElement = curElement && getParent2(curElement);
      } while (curElement);
    };
    this._onFocusOut = () => {
      this._setFocused(false);
    };
    this._onDispose = onDispose;
    const win = tabster.getWindow;
    this.uid = getElementUId(win, element);
    this._sys = sys;
    if (tabster.controlTab || tabster.rootDummyInputs) {
      this.addDummyInputs();
    }
    const w = win();
    const doc = w.document;
    doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn);
    doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);
    this._add();
  }
  addDummyInputs() {
    if (!this._dummyManager) {
      this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);
    }
  }
  dispose() {
    var _a;
    this._onDispose(this);
    const win = this._tabster.getWindow();
    const doc = win.document;
    doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn);
    doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);
    if (this._setFocusedTimer) {
      win.clearTimeout(this._setFocusedTimer);
      delete this._setFocusedTimer;
    }
    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
    this._remove();
  }
  moveOutWithDefaultAction(isBackward, relatedEvent) {
    const dummyManager = this._dummyManager;
    if (dummyManager) {
      dummyManager.moveOutWithDefaultAction(isBackward, relatedEvent);
    } else {
      const el = this.getElement();
      if (el) {
        RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward, relatedEvent);
      }
    }
  }
  _add() {
    if (true) {
      _setInformativeStyle$3(this._element, false, this.uid);
    }
  }
  _remove() {
    if (true) {
      _setInformativeStyle$3(this._element, true);
    }
  }
};
var RootAPI = class {
  constructor(tabster, autoRoot) {
    this._autoRootWaiting = false;
    this._roots = {};
    this._forceDummy = false;
    this.rootById = {};
    this._autoRootCreate = () => {
      var _a;
      const doc = this._win().document;
      const body = doc.body;
      if (body) {
        this._autoRootUnwait(doc);
        const props = this._autoRoot;
        if (props) {
          setTabsterAttribute(body, {
            root: props
          }, true);
          updateTabsterByAttribute(this._tabster, body);
          return (_a = getTabsterOnElement(this._tabster, body)) === null || _a === void 0 ? void 0 : _a.root;
        }
      } else if (!this._autoRootWaiting) {
        this._autoRootWaiting = true;
        doc.addEventListener("readystatechange", this._autoRootCreate);
      }
      return void 0;
    };
    this._onRootDispose = (root) => {
      delete this._roots[root.id];
    };
    this._tabster = tabster;
    this._win = tabster.getWindow;
    this._autoRoot = autoRoot;
    tabster.queueInit(() => {
      if (this._autoRoot) {
        this._autoRootCreate();
      }
    });
  }
  _autoRootUnwait(doc) {
    doc.removeEventListener("readystatechange", this._autoRootCreate);
    this._autoRootWaiting = false;
  }
  dispose() {
    const win = this._win();
    this._autoRootUnwait(win.document);
    delete this._autoRoot;
    Object.keys(this._roots).forEach((rootId) => {
      if (this._roots[rootId]) {
        this._roots[rootId].dispose();
        delete this._roots[rootId];
      }
    });
    this.rootById = {};
  }
  createRoot(element, props, sys) {
    if (true) ;
    const newRoot = new Root(this._tabster, element, this._onRootDispose, props, sys);
    this._roots[newRoot.id] = newRoot;
    if (this._forceDummy) {
      newRoot.addDummyInputs();
    }
    return newRoot;
  }
  addDummyInputs() {
    this._forceDummy = true;
    const roots = this._roots;
    for (const id of Object.keys(roots)) {
      roots[id].addDummyInputs();
    }
  }
  static getRootByUId(getWindow2, id) {
    const tabster = getWindow2().__tabsterInstance;
    return tabster && tabster.root.rootById[id];
  }
  /**
   * Fetches the tabster context for an element walking up its ancestors
   *
   * @param tabster Tabster instance
   * @param element The element the tabster context should represent
   * @param options Additional options
   * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations
   */
  static getTabsterContext(tabster, element, options) {
    if (options === void 0) {
      options = {};
    }
    var _a, _b, _c, _d;
    if (!element.ownerDocument) {
      return void 0;
    }
    const {
      checkRtl,
      referenceElement
    } = options;
    const getParent2 = tabster.getParent;
    tabster.drainInitQueue();
    let root;
    let modalizer;
    let groupper;
    let mover;
    let excludedFromMover = false;
    let groupperBeforeMover;
    let modalizerInGroupper;
    let dirRightToLeft;
    let uncontrolled;
    let curElement = referenceElement || element;
    const ignoreKeydown = {};
    while (curElement && (!root || checkRtl)) {
      const tabsterOnElement = getTabsterOnElement(tabster, curElement);
      if (checkRtl && dirRightToLeft === void 0) {
        const dir = curElement.dir;
        if (dir) {
          dirRightToLeft = dir.toLowerCase() === "rtl";
        }
      }
      if (!tabsterOnElement) {
        curElement = getParent2(curElement);
        continue;
      }
      const tagName = curElement.tagName;
      if ((tabsterOnElement.uncontrolled || tagName === "IFRAME" || tagName === "WEBVIEW") && tabster.focusable.isVisible(curElement)) {
        uncontrolled = curElement;
      }
      if (!mover && ((_a = tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.excludeFromMover) && !groupper) {
        excludedFromMover = true;
      }
      const curModalizer = tabsterOnElement.modalizer;
      const curGroupper = tabsterOnElement.groupper;
      const curMover = tabsterOnElement.mover;
      if (!modalizer && curModalizer) {
        modalizer = curModalizer;
      }
      if (!groupper && curGroupper && (!modalizer || curModalizer)) {
        if (modalizer) {
          if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
            modalizer = void 0;
            groupper = curGroupper;
          }
          modalizerInGroupper = curGroupper;
        } else {
          groupper = curGroupper;
        }
      }
      if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element) && curElement.contains(element)) {
        mover = curMover;
        groupperBeforeMover = !!groupper && groupper !== curGroupper;
      }
      if (tabsterOnElement.root) {
        root = tabsterOnElement.root;
      }
      if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) {
        Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);
      }
      curElement = getParent2(curElement);
    }
    if (!root) {
      const rootAPI = tabster.root;
      const autoRoot = rootAPI._autoRoot;
      if (autoRoot) {
        if ((_d = element.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) {
          root = rootAPI._autoRootCreate();
        }
      }
    }
    if (groupper && !mover) {
      groupperBeforeMover = true;
    }
    if (!root) {
      if (modalizer || groupper || mover) {
        console.error("Tabster Root is required for Mover, Groupper and Modalizer to work.");
      }
    }
    const shouldIgnoreKeydown = (event) => !!ignoreKeydown[event.key];
    return root ? {
      root,
      modalizer,
      groupper,
      mover,
      groupperBeforeMover,
      modalizerInGroupper,
      rtl: checkRtl ? !!dirRightToLeft : void 0,
      uncontrolled,
      excludedFromMover,
      ignoreKeydown: shouldIgnoreKeydown
    } : void 0;
  }
  static getRoot(tabster, element) {
    var _a;
    const getParent2 = tabster.getParent;
    for (let el = element; el; el = getParent2(el)) {
      const root = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.root;
      if (root) {
        return root;
      }
    }
    return void 0;
  }
  onRoot(root, removed) {
    if (removed) {
      delete this.rootById[root.uid];
    } else {
      this.rootById[root.uid] = root;
    }
  }
};
var Subscribable = class {
  constructor() {
    this._callbacks = [];
  }
  dispose() {
    this._callbacks = [];
    delete this._val;
  }
  subscribe(callback) {
    const callbacks = this._callbacks;
    const index = callbacks.indexOf(callback);
    if (index < 0) {
      callbacks.push(callback);
    }
  }
  subscribeFirst(callback) {
    const callbacks = this._callbacks;
    const index = callbacks.indexOf(callback);
    if (index >= 0) {
      callbacks.splice(index, 1);
    }
    callbacks.unshift(callback);
  }
  unsubscribe(callback) {
    const index = this._callbacks.indexOf(callback);
    if (index >= 0) {
      this._callbacks.splice(index, 1);
    }
  }
  setVal(val, detail) {
    if (this._val === val) {
      return;
    }
    this._val = val;
    this._callCallbacks(val, detail);
  }
  getVal() {
    return this._val;
  }
  trigger(val, detail) {
    this._callCallbacks(val, detail);
  }
  _callCallbacks(val, detail) {
    this._callbacks.forEach((callback) => callback(val, detail));
  }
};
var FocusableAPI = class {
  constructor(tabster) {
    this._tabster = tabster;
  }
  dispose() {
  }
  getProps(element) {
    const tabsterOnElement = getTabsterOnElement(this._tabster, element);
    return tabsterOnElement && tabsterOnElement.focusable || {};
  }
  isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {
    if (matchesSelector(el, FOCUSABLE_SELECTOR) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {
      return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));
    }
    return false;
  }
  isVisible(el) {
    if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {
      return false;
    }
    if (isDisplayNone(el)) {
      return false;
    }
    const rect = el.ownerDocument.body.getBoundingClientRect();
    if (rect.width === 0 && rect.height === 0) {
      return false;
    }
    return true;
  }
  isAccessible(el) {
    var _a;
    for (let e = el; e; e = dom.getParentElement(e)) {
      const tabsterOnElement = getTabsterOnElement(this._tabster, e);
      if (this._isHidden(e)) {
        return false;
      }
      const ignoreDisabled = (_a = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.ignoreAriaDisabled;
      if (!ignoreDisabled && this._isDisabled(e)) {
        return false;
      }
    }
    return true;
  }
  _isDisabled(el) {
    return el.hasAttribute("disabled");
  }
  _isHidden(el) {
    var _a;
    const attrVal = el.getAttribute("aria-hidden");
    if (attrVal && attrVal.toLowerCase() === "true") {
      if (!((_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.isAugmented(el))) {
        return true;
      }
    }
    return false;
  }
  findFirst(options, out) {
    return this.findElement({
      ...options
    }, out);
  }
  findLast(options, out) {
    return this.findElement({
      isBackward: true,
      ...options
    }, out);
  }
  findNext(options, out) {
    return this.findElement({
      ...options
    }, out);
  }
  findPrev(options, out) {
    return this.findElement({
      ...options,
      isBackward: true
    }, out);
  }
  findDefault(options, out) {
    return this.findElement({
      ...options,
      acceptCondition: (el) => this.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault
    }, out) || null;
  }
  findAll(options) {
    return this._findElements(true, options) || [];
  }
  findElement(options, out) {
    const found = this._findElements(false, options, out);
    return found ? found[0] : found;
  }
  _findElements(isFindAll, options, out) {
    var _a, _b, _c;
    const {
      container,
      currentElement = null,
      includeProgrammaticallyFocusable,
      useActiveModalizer,
      ignoreAccessibility,
      modalizerId,
      isBackward,
      onElement
    } = options;
    if (!out) {
      out = {};
    }
    const elements = [];
    let {
      acceptCondition
    } = options;
    const hasCustomCondition = !!acceptCondition;
    if (!container) {
      return null;
    }
    if (!acceptCondition) {
      acceptCondition = (el) => this.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);
    }
    const acceptElementState = {
      container,
      modalizerUserId: modalizerId === void 0 && useActiveModalizer ? (_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),
      from: currentElement || container,
      isBackward,
      isFindAll,
      acceptCondition,
      hasCustomCondition,
      includeProgrammaticallyFocusable,
      ignoreAccessibility,
      cachedGrouppers: {},
      cachedRadioGroups: {}
    };
    const walker = createElementTreeWalker(container.ownerDocument, container, (node) => this._acceptElement(node, acceptElementState));
    if (!walker) {
      return null;
    }
    const prepareForNextElement = (shouldContinueIfNotFound) => {
      var _a2, _b2;
      const foundElement = (_a2 = acceptElementState.foundElement) !== null && _a2 !== void 0 ? _a2 : acceptElementState.foundBackward;
      if (foundElement) {
        elements.push(foundElement);
      }
      if (isFindAll) {
        if (foundElement) {
          acceptElementState.found = false;
          delete acceptElementState.foundElement;
          delete acceptElementState.foundBackward;
          delete acceptElementState.fromCtx;
          acceptElementState.from = foundElement;
          if (onElement && !onElement(foundElement)) {
            return false;
          }
        }
        return !!(foundElement || shouldContinueIfNotFound);
      } else {
        if (foundElement && out) {
          out.uncontrolled = (_b2 = RootAPI.getTabsterContext(this._tabster, foundElement)) === null || _b2 === void 0 ? void 0 : _b2.uncontrolled;
        }
        return !!(shouldContinueIfNotFound && !foundElement);
      }
    };
    if (!currentElement) {
      out.outOfDOMOrder = true;
    }
    if (currentElement && dom.nodeContains(container, currentElement)) {
      walker.currentNode = currentElement;
    } else if (isBackward) {
      const lastChild = getLastChild$2(container);
      if (!lastChild) {
        return null;
      }
      if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {
        if (acceptElementState.skippedFocusable) {
          out.outOfDOMOrder = true;
        }
        return elements;
      }
      walker.currentNode = lastChild;
    }
    do {
      if (isBackward) {
        walker.previousNode();
      } else {
        walker.nextNode();
      }
    } while (prepareForNextElement());
    if (acceptElementState.skippedFocusable) {
      out.outOfDOMOrder = true;
    }
    return elements.length ? elements : null;
  }
  _acceptElement(element, state) {
    var _a, _b, _c;
    if (state.found) {
      return NodeFilter.FILTER_ACCEPT;
    }
    const foundBackward = state.foundBackward;
    if (foundBackward && (element === foundBackward || !dom.nodeContains(foundBackward, element))) {
      state.found = true;
      state.foundElement = foundBackward;
      return NodeFilter.FILTER_ACCEPT;
    }
    const container = state.container;
    if (element === container) {
      return NodeFilter.FILTER_SKIP;
    }
    if (!dom.nodeContains(container, element)) {
      return NodeFilter.FILTER_REJECT;
    }
    if (getDummyInputContainer(element)) {
      return NodeFilter.FILTER_REJECT;
    }
    if (dom.nodeContains(state.rejectElementsFrom, element)) {
      return NodeFilter.FILTER_REJECT;
    }
    const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element);
    if (!ctx) {
      return NodeFilter.FILTER_SKIP;
    }
    if (shouldIgnoreFocus(element)) {
      if (this.isFocusable(element, void 0, true, true)) {
        state.skippedFocusable = true;
      }
      return NodeFilter.FILTER_SKIP;
    }
    if (!state.hasCustomCondition && (element.tagName === "IFRAME" || element.tagName === "WEBVIEW")) {
      if (this.isVisible(element) && ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = this._tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
        state.found = true;
        state.rejectElementsFrom = state.foundElement = element;
        return NodeFilter.FILTER_ACCEPT;
      } else {
        return NodeFilter.FILTER_REJECT;
      }
    }
    if (!state.ignoreAccessibility && !this.isAccessible(element)) {
      if (this.isFocusable(element, false, true, true)) {
        state.skippedFocusable = true;
      }
      return NodeFilter.FILTER_REJECT;
    }
    let result;
    let fromCtx = state.fromCtx;
    if (!fromCtx) {
      fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);
    }
    const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;
    let groupper = ctx.groupper;
    let mover = ctx.mover;
    result = (_c = this._tabster.modalizer) === null || _c === void 0 ? void 0 : _c.acceptElement(element, state);
    if (result !== void 0) {
      state.skippedFocusable = true;
    }
    if (result === void 0 && (groupper || mover || fromMover)) {
      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
      const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();
      let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();
      if (moverElement && dom.nodeContains(fromMoverElement, moverElement) && dom.nodeContains(container, fromMoverElement) && (!groupperElement || !mover || dom.nodeContains(fromMoverElement, groupperElement))) {
        mover = fromMover;
        moverElement = fromMoverElement;
      }
      if (groupperElement) {
        if (groupperElement === container || !dom.nodeContains(container, groupperElement)) {
          groupper = void 0;
        } else if (!dom.nodeContains(groupperElement, element)) {
          return NodeFilter.FILTER_REJECT;
        }
      }
      if (moverElement) {
        if (!dom.nodeContains(container, moverElement)) {
          mover = void 0;
        } else if (!dom.nodeContains(moverElement, element)) {
          return NodeFilter.FILTER_REJECT;
        }
      }
      if (groupper && mover) {
        if (moverElement && groupperElement && !dom.nodeContains(groupperElement, moverElement)) {
          mover = void 0;
        } else {
          groupper = void 0;
        }
      }
      if (groupper) {
        result = groupper.acceptElement(element, state);
      }
      if (mover) {
        result = mover.acceptElement(element, state);
      }
    }
    if (result === void 0) {
      result = state.acceptCondition(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      if (result === NodeFilter.FILTER_SKIP && this.isFocusable(element, false, true, true)) {
        state.skippedFocusable = true;
      }
    }
    if (result === NodeFilter.FILTER_ACCEPT && !state.found) {
      if (!state.isFindAll && isRadio(element) && !element.checked) {
        const radioGroupName = element.name;
        let radioGroup = state.cachedRadioGroups[radioGroupName];
        if (!radioGroup) {
          radioGroup = getRadioButtonGroup(element);
          if (radioGroup) {
            state.cachedRadioGroups[radioGroupName] = radioGroup;
          }
        }
        if ((radioGroup === null || radioGroup === void 0 ? void 0 : radioGroup.checked) && radioGroup.checked !== element) {
          return NodeFilter.FILTER_SKIP;
        }
      }
      if (state.isBackward) {
        state.foundBackward = element;
        result = NodeFilter.FILTER_SKIP;
      } else {
        state.found = true;
        state.foundElement = element;
      }
    }
    return result;
  }
};
var Keys = {
  Tab: "Tab",
  Enter: "Enter",
  Escape: "Escape",
  PageUp: "PageUp",
  PageDown: "PageDown",
  End: "End",
  Home: "Home",
  ArrowLeft: "ArrowLeft",
  ArrowUp: "ArrowUp",
  ArrowRight: "ArrowRight",
  ArrowDown: "ArrowDown"
};
function getUncontrolledCompletelyContainer(tabster, element) {
  var _a;
  const getParent2 = tabster.getParent;
  let el = element;
  do {
    const uncontrolledOnElement = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.uncontrolled;
    if (uncontrolledOnElement && tabster.uncontrolled.isUncontrolledCompletely(el, !!uncontrolledOnElement.completely)) {
      return el;
    }
    el = getParent2(el);
  } while (el);
  return void 0;
}
var AsyncFocusIntentPriorityBySource = {
  [AsyncFocusSources.Restorer]: 0,
  [AsyncFocusSources.Deloser]: 1,
  [AsyncFocusSources.EscapeGroupper]: 2
};
var FocusedElementState = class _FocusedElementState extends Subscribable {
  constructor(tabster, getWindow2) {
    super();
    this._init = () => {
      const win = this._win();
      const doc = win.document;
      doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
      doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);
      win.addEventListener("keydown", this._onKeyDown, true);
      const activeElement = dom.getActiveElement(doc);
      if (activeElement && activeElement !== doc.body) {
        this._setFocusedElement(activeElement);
      }
      this.subscribe(this._onChanged);
    };
    this._onFocusIn = (e) => {
      const target = e.composedPath()[0];
      if (target) {
        this._setFocusedElement(target, e.detail.relatedTarget, e.detail.isFocusedProgrammatically);
      }
    };
    this._onFocusOut = (e) => {
      var _a;
      this._setFocusedElement(void 0, (_a = e.detail) === null || _a === void 0 ? void 0 : _a.originalEvent.relatedTarget);
    };
    this._validateFocusedElement = (element) => {
    };
    this._onKeyDown = (event) => {
      if (event.key !== Keys.Tab || event.ctrlKey) {
        return;
      }
      const currentElement = this.getVal();
      if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === "true") {
        return;
      }
      const tabster2 = this._tabster;
      const controlTab = tabster2.controlTab;
      const ctx = RootAPI.getTabsterContext(tabster2, currentElement);
      if (!ctx || ctx.ignoreKeydown(event)) {
        return;
      }
      const isBackward = event.shiftKey;
      const next = _FocusedElementState.findNextTabbable(tabster2, ctx, void 0, currentElement, void 0, isBackward, true);
      const rootElement = ctx.root.getElement();
      if (!rootElement) {
        return;
      }
      const nextElement = next === null || next === void 0 ? void 0 : next.element;
      const uncontrolledCompletelyContainer = getUncontrolledCompletelyContainer(tabster2, currentElement);
      if (nextElement) {
        const nextUncontrolled = next.uncontrolled;
        if (ctx.uncontrolled || dom.nodeContains(nextUncontrolled, currentElement)) {
          if (!next.outOfDOMOrder && nextUncontrolled === ctx.uncontrolled || uncontrolledCompletelyContainer && !dom.nodeContains(uncontrolledCompletelyContainer, nextElement)) {
            return;
          }
          DummyInputManager.addPhantomDummyWithTarget(tabster2, currentElement, isBackward, nextElement);
          return;
        }
        if (nextUncontrolled && tabster2.focusable.isVisible(nextUncontrolled) || nextElement.tagName === "IFRAME" && tabster2.focusable.isVisible(nextElement)) {
          if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({
            by: "root",
            owner: rootElement,
            next: nextElement,
            relatedEvent: event
          }))) {
            DummyInputManager.moveWithPhantomDummy(tabster2, nextUncontrolled !== null && nextUncontrolled !== void 0 ? nextUncontrolled : nextElement, false, isBackward, event);
          }
          return;
        }
        if (controlTab || (next === null || next === void 0 ? void 0 : next.outOfDOMOrder)) {
          if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({
            by: "root",
            owner: rootElement,
            next: nextElement,
            relatedEvent: event
          }))) {
            event.preventDefault();
            event.stopImmediatePropagation();
            nativeFocus(nextElement);
          }
        }
      } else {
        if (!uncontrolledCompletelyContainer && rootElement.dispatchEvent(new TabsterMoveFocusEvent({
          by: "root",
          owner: rootElement,
          next: null,
          relatedEvent: event
        }))) {
          ctx.root.moveOutWithDefaultAction(isBackward, event);
        }
      }
    };
    this._onChanged = (element, detail) => {
      var _a, _b;
      if (element) {
        element.dispatchEvent(new TabsterFocusInEvent(detail));
      } else {
        const last = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();
        if (last) {
          const d = {
            ...detail
          };
          const lastCtx = RootAPI.getTabsterContext(this._tabster, last);
          const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
          if (modalizerId) {
            d.modalizerId = modalizerId;
          }
          last.dispatchEvent(new TabsterFocusOutEvent(d));
        }
      }
    };
    this._tabster = tabster;
    this._win = getWindow2;
    tabster.queueInit(this._init);
  }
  dispose() {
    super.dispose();
    const win = this._win();
    const doc = win.document;
    doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
    doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);
    win.removeEventListener("keydown", this._onKeyDown, true);
    this.unsubscribe(this._onChanged);
    const asyncFocus = this._asyncFocus;
    if (asyncFocus) {
      win.clearTimeout(asyncFocus.timeout);
      delete this._asyncFocus;
    }
    delete _FocusedElementState._lastResetElement;
    delete this._nextVal;
    delete this._lastVal;
  }
  static forgetMemorized(instance, parent2) {
    var _a, _b;
    let wel = _FocusedElementState._lastResetElement;
    let el = wel && wel.get();
    if (el && dom.nodeContains(parent2, el)) {
      delete _FocusedElementState._lastResetElement;
    }
    el = (_b = (_a = instance._nextVal) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.get();
    if (el && dom.nodeContains(parent2, el)) {
      delete instance._nextVal;
    }
    wel = instance._lastVal;
    el = wel && wel.get();
    if (el && dom.nodeContains(parent2, el)) {
      delete instance._lastVal;
    }
  }
  getFocusedElement() {
    return this.getVal();
  }
  getLastFocusedElement() {
    var _a;
    let el = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();
    if (!el || el && !documentContains(el.ownerDocument, el)) {
      this._lastVal = el = void 0;
    }
    return el;
  }
  focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck, preventScroll) {
    if (!this._tabster.focusable.isFocusable(element, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {
      return false;
    }
    element.focus({
      preventScroll
    });
    return true;
  }
  focusDefault(container) {
    const el = this._tabster.focusable.findDefault({
      container
    });
    if (el) {
      this._tabster.focusedElement.focus(el);
      return true;
    }
    return false;
  }
  getFirstOrLastTabbable(isFirst, props) {
    var _a;
    const {
      container,
      ignoreAccessibility
    } = props;
    let toFocus;
    if (container) {
      const ctx = RootAPI.getTabsterContext(this._tabster, container);
      if (ctx) {
        toFocus = (_a = _FocusedElementState.findNextTabbable(this._tabster, ctx, container, void 0, void 0, !isFirst, ignoreAccessibility)) === null || _a === void 0 ? void 0 : _a.element;
      }
    }
    if (toFocus && !dom.nodeContains(container, toFocus)) {
      toFocus = void 0;
    }
    return toFocus || void 0;
  }
  _focusFirstOrLast(isFirst, props) {
    const toFocus = this.getFirstOrLastTabbable(isFirst, props);
    if (toFocus) {
      this.focus(toFocus, false, true);
      return true;
    }
    return false;
  }
  focusFirst(props) {
    return this._focusFirstOrLast(true, props);
  }
  focusLast(props) {
    return this._focusFirstOrLast(false, props);
  }
  resetFocus(container) {
    if (!this._tabster.focusable.isVisible(container)) {
      return false;
    }
    if (!this._tabster.focusable.isFocusable(container, true, true, true)) {
      const prevTabIndex = container.getAttribute("tabindex");
      const prevAriaHidden = container.getAttribute("aria-hidden");
      container.tabIndex = -1;
      container.setAttribute("aria-hidden", "true");
      _FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container);
      this.focus(container, true, true);
      this._setOrRemoveAttribute(container, "tabindex", prevTabIndex);
      this._setOrRemoveAttribute(container, "aria-hidden", prevAriaHidden);
    } else {
      this.focus(container);
    }
    return true;
  }
  requestAsyncFocus(source, callback, delay) {
    const win = this._tabster.getWindow();
    const currentAsyncFocus = this._asyncFocus;
    if (currentAsyncFocus) {
      if (AsyncFocusIntentPriorityBySource[source] > AsyncFocusIntentPriorityBySource[currentAsyncFocus.source]) {
        return;
      }
      win.clearTimeout(currentAsyncFocus.timeout);
    }
    this._asyncFocus = {
      source,
      callback,
      timeout: win.setTimeout(() => {
        this._asyncFocus = void 0;
        callback();
      }, delay)
    };
  }
  cancelAsyncFocus(source) {
    const asyncFocus = this._asyncFocus;
    if ((asyncFocus === null || asyncFocus === void 0 ? void 0 : asyncFocus.source) === source) {
      this._tabster.getWindow().clearTimeout(asyncFocus.timeout);
      this._asyncFocus = void 0;
    }
  }
  _setOrRemoveAttribute(element, name, value) {
    if (value === null) {
      element.removeAttribute(name);
    } else {
      element.setAttribute(name, value);
    }
  }
  _setFocusedElement(element, relatedTarget, isFocusedProgrammatically) {
    var _a, _b;
    if (this._tabster._noop) {
      return;
    }
    const detail = {
      relatedTarget
    };
    if (element) {
      const lastResetElement = (_a = _FocusedElementState._lastResetElement) === null || _a === void 0 ? void 0 : _a.get();
      _FocusedElementState._lastResetElement = void 0;
      if (lastResetElement === element || shouldIgnoreFocus(element)) {
        return;
      }
      detail.isFocusedProgrammatically = isFocusedProgrammatically;
      const ctx = RootAPI.getTabsterContext(this._tabster, element);
      const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
      if (modalizerId) {
        detail.modalizerId = modalizerId;
      }
    }
    const nextVal = this._nextVal = {
      element: element ? new WeakHTMLElement(this._win, element) : void 0,
      detail
    };
    if (element && element !== this._val) {
      this._validateFocusedElement(element);
    }
    if (this._nextVal === nextVal) {
      this.setVal(element, detail);
    }
    this._nextVal = void 0;
  }
  setVal(val, detail) {
    super.setVal(val, detail);
    if (val) {
      this._lastVal = new WeakHTMLElement(this._win, val);
    }
  }
  static findNextTabbable(tabster, ctx, container, currentElement, referenceElement, isBackward, ignoreAccessibility) {
    const actualContainer = container || ctx.root.getElement();
    if (!actualContainer) {
      return null;
    }
    let next = null;
    const isTabbingTimer = _FocusedElementState._isTabbingTimer;
    const win = tabster.getWindow();
    if (isTabbingTimer) {
      win.clearTimeout(isTabbingTimer);
    }
    _FocusedElementState.isTabbing = true;
    _FocusedElementState._isTabbingTimer = win.setTimeout(() => {
      delete _FocusedElementState._isTabbingTimer;
      _FocusedElementState.isTabbing = false;
    }, 0);
    const modalizer = ctx.modalizer;
    const groupper = ctx.groupper;
    const mover = ctx.mover;
    const callFindNext = (what) => {
      next = what.findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility);
      if (currentElement && !(next === null || next === void 0 ? void 0 : next.element)) {
        const parentElement2 = what !== modalizer && dom.getParentElement(what.getElement());
        if (parentElement2) {
          const parentCtx = RootAPI.getTabsterContext(tabster, currentElement, {
            referenceElement: parentElement2
          });
          if (parentCtx) {
            const currentScopeElement = what.getElement();
            const newCurrent = isBackward ? currentScopeElement : currentScopeElement && getLastChild$2(currentScopeElement) || currentScopeElement;
            if (newCurrent) {
              next = _FocusedElementState.findNextTabbable(tabster, parentCtx, container, newCurrent, parentElement2, isBackward, ignoreAccessibility);
              if (next) {
                next.outOfDOMOrder = true;
              }
            }
          }
        }
      }
    };
    if (groupper && mover) {
      callFindNext(ctx.groupperBeforeMover ? groupper : mover);
    } else if (groupper) {
      callFindNext(groupper);
    } else if (mover) {
      callFindNext(mover);
    } else if (modalizer) {
      callFindNext(modalizer);
    } else {
      const findProps = {
        container: actualContainer,
        currentElement,
        referenceElement,
        ignoreAccessibility,
        useActiveModalizer: true
      };
      const findPropsOut = {};
      const nextElement = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
      next = {
        element: nextElement,
        outOfDOMOrder: findPropsOut.outOfDOMOrder,
        uncontrolled: findPropsOut.uncontrolled
      };
    }
    return next;
  }
};
FocusedElementState.isTabbing = false;
var GroupperDummyManager = class extends DummyInputManager {
  constructor(element, groupper, tabster, sys) {
    super(tabster, element, DummyInputManagerPriorities.Groupper, sys, true);
    this._setHandlers((dummyInput, isBackward, relatedTarget) => {
      var _a, _b;
      const container = element.get();
      const input = dummyInput.input;
      if (container && input) {
        const ctx = RootAPI.getTabsterContext(tabster, input);
        if (ctx) {
          let next;
          next = (_a = groupper.findNextTabbable(relatedTarget || void 0, void 0, isBackward, true)) === null || _a === void 0 ? void 0 : _a.element;
          if (!next) {
            next = (_b = FocusedElementState.findNextTabbable(tabster, ctx, void 0, dummyInput.isOutside ? input : getAdjacentElement(container, !isBackward), void 0, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;
          }
          if (next) {
            nativeFocus(next);
          }
        }
      }
    });
  }
};
var Groupper = class extends TabsterPart {
  constructor(tabster, element, onDispose, props, sys) {
    super(tabster, element, props);
    this._shouldTabInside = false;
    this.makeTabbable(false);
    this._onDispose = onDispose;
    if (!tabster.controlTab) {
      this.dummyManager = new GroupperDummyManager(this._element, this, tabster, sys);
    }
  }
  dispose() {
    var _a;
    this._onDispose(this);
    const element = this._element.get();
    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
    delete this.dummyManager;
    if (element) {
      if (true) {
        _setInformativeStyle$1(this._element, true);
      }
    }
    delete this._first;
  }
  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
    const groupperElement = this.getElement();
    if (!groupperElement) {
      return null;
    }
    const currentIsDummy = getDummyInputContainer(currentElement) === groupperElement;
    if (!this._shouldTabInside && currentElement && dom.nodeContains(groupperElement, currentElement) && !currentIsDummy) {
      return {
        element: void 0,
        outOfDOMOrder: true
      };
    }
    const groupperFirstFocusable = this.getFirst(true);
    if (!currentElement || !dom.nodeContains(groupperElement, currentElement) || currentIsDummy) {
      return {
        element: groupperFirstFocusable,
        outOfDOMOrder: true
      };
    }
    const tabster = this._tabster;
    let next = null;
    let outOfDOMOrder = false;
    let uncontrolled;
    if (this._shouldTabInside && groupperFirstFocusable) {
      const findProps = {
        container: groupperElement,
        currentElement,
        referenceElement,
        ignoreAccessibility,
        useActiveModalizer: true
      };
      const findPropsOut = {};
      next = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
      if (!next && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {
        next = tabster.focusable[isBackward ? "findLast" : "findFirst"]({
          container: groupperElement,
          ignoreAccessibility,
          useActiveModalizer: true
        }, findPropsOut);
        outOfDOMOrder = true;
      }
      uncontrolled = findPropsOut.uncontrolled;
    }
    return {
      element: next,
      uncontrolled,
      outOfDOMOrder
    };
  }
  makeTabbable(isTabbable) {
    this._shouldTabInside = isTabbable || !this._props.tabbability;
    if (true) {
      _setInformativeStyle$1(this._element, !this._shouldTabInside);
    }
  }
  isActive(noIfFirstIsFocused) {
    var _a;
    const element = this.getElement() || null;
    let isParentActive = true;
    for (let e = dom.getParentElement(element); e; e = dom.getParentElement(e)) {
      const g = (_a = getTabsterOnElement(this._tabster, e)) === null || _a === void 0 ? void 0 : _a.groupper;
      if (g) {
        if (!g._shouldTabInside) {
          isParentActive = false;
        }
      }
    }
    let ret = isParentActive ? this._props.tabbability ? this._shouldTabInside : false : void 0;
    if (ret && noIfFirstIsFocused) {
      const focused = this._tabster.focusedElement.getFocusedElement();
      if (focused) {
        ret = focused !== this.getFirst(true);
      }
    }
    return ret;
  }
  getFirst(orContainer) {
    var _a;
    const groupperElement = this.getElement();
    let first;
    if (groupperElement) {
      if (orContainer && this._tabster.focusable.isFocusable(groupperElement)) {
        return groupperElement;
      }
      first = (_a = this._first) === null || _a === void 0 ? void 0 : _a.get();
      if (!first) {
        first = this._tabster.focusable.findFirst({
          container: groupperElement,
          useActiveModalizer: true
        }) || void 0;
        if (first) {
          this.setFirst(first);
        }
      }
    }
    return first;
  }
  setFirst(element) {
    if (element) {
      this._first = new WeakHTMLElement(this._tabster.getWindow, element);
    } else {
      delete this._first;
    }
  }
  acceptElement(element, state) {
    const cachedGrouppers = state.cachedGrouppers;
    const parentElement2 = dom.getParentElement(this.getElement());
    const parentCtx = parentElement2 && RootAPI.getTabsterContext(this._tabster, parentElement2);
    const parentCtxGroupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;
    const parentGroupper = (parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupperBeforeMover) ? parentCtxGroupper : void 0;
    let parentGroupperElement;
    const getIsActive = (groupper) => {
      let cached = cachedGrouppers[groupper.id];
      let isActive2;
      if (cached) {
        isActive2 = cached.isActive;
      } else {
        isActive2 = this.isActive(true);
        cached = cachedGrouppers[groupper.id] = {
          isActive: isActive2
        };
      }
      return isActive2;
    };
    if (parentGroupper) {
      parentGroupperElement = parentGroupper.getElement();
      if (!getIsActive(parentGroupper) && parentGroupperElement && state.container !== parentGroupperElement && dom.nodeContains(state.container, parentGroupperElement)) {
        state.skippedFocusable = true;
        return NodeFilter.FILTER_REJECT;
      }
    }
    const isActive = getIsActive(this);
    const groupperElement = this.getElement();
    if (groupperElement) {
      if (isActive !== true) {
        if (groupperElement === element && parentCtxGroupper) {
          if (!parentGroupperElement) {
            parentGroupperElement = parentCtxGroupper.getElement();
          }
          if (parentGroupperElement && !getIsActive(parentCtxGroupper) && dom.nodeContains(state.container, parentGroupperElement) && parentGroupperElement !== state.container) {
            state.skippedFocusable = true;
            return NodeFilter.FILTER_REJECT;
          }
        }
        if (groupperElement !== element && dom.nodeContains(groupperElement, element)) {
          state.skippedFocusable = true;
          return NodeFilter.FILTER_REJECT;
        }
        const cached = cachedGrouppers[this.id];
        let first;
        if ("first" in cached) {
          first = cached.first;
        } else {
          first = cached.first = this.getFirst(true);
        }
        if (first && state.acceptCondition(first)) {
          state.rejectElementsFrom = groupperElement;
          state.skippedFocusable = true;
          if (first !== state.from) {
            state.found = true;
            state.foundElement = first;
            return NodeFilter.FILTER_ACCEPT;
          } else {
            return NodeFilter.FILTER_REJECT;
          }
        }
      }
    }
    return void 0;
  }
};
var GroupperAPI = class {
  constructor(tabster, getWindow2) {
    this._current = {};
    this._grouppers = {};
    this._init = () => {
      const win = this._win();
      this._tabster.focusedElement.subscribeFirst(this._onFocus);
      const doc = win.document;
      const activeElement = dom.getActiveElement(doc);
      if (activeElement) {
        this._onFocus(activeElement);
      }
      doc.addEventListener("mousedown", this._onMouseDown, true);
      win.addEventListener("keydown", this._onKeyDown, true);
      win.addEventListener(GroupperMoveFocusEventName, this._onMoveFocus);
    };
    this._onGroupperDispose = (groupper) => {
      delete this._grouppers[groupper.id];
    };
    this._onFocus = (element) => {
      if (element) {
        this._updateCurrent(element);
      }
    };
    this._onMouseDown = (e) => {
      let target = e.target;
      while (target && !this._tabster.focusable.isFocusable(target)) {
        target = this._tabster.getParent(target);
      }
      if (target) {
        this._updateCurrent(target);
      }
    };
    this._onKeyDown = (event) => {
      if (event.key !== Keys.Enter && event.key !== Keys.Escape) {
        return;
      }
      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
        return;
      }
      const element = this._tabster.focusedElement.getFocusedElement();
      if (element) {
        this.handleKeyPress(element, event);
      }
    };
    this._onMoveFocus = (e) => {
      var _a;
      const element = e.composedPath()[0];
      const action = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.action;
      if (element && action !== void 0 && !e.defaultPrevented) {
        if (action === GroupperMoveFocusActions.Enter) {
          this._enterGroupper(element);
        } else {
          this._escapeGroupper(element);
        }
        e.stopImmediatePropagation();
      }
    };
    this._tabster = tabster;
    this._win = getWindow2;
    tabster.queueInit(this._init);
  }
  dispose() {
    const win = this._win();
    this._tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);
    this._current = {};
    if (this._updateTimer) {
      win.clearTimeout(this._updateTimer);
      delete this._updateTimer;
    }
    this._tabster.focusedElement.unsubscribe(this._onFocus);
    win.document.removeEventListener("mousedown", this._onMouseDown, true);
    win.removeEventListener("keydown", this._onKeyDown, true);
    win.removeEventListener(GroupperMoveFocusEventName, this._onMoveFocus);
    Object.keys(this._grouppers).forEach((groupperId) => {
      if (this._grouppers[groupperId]) {
        this._grouppers[groupperId].dispose();
        delete this._grouppers[groupperId];
      }
    });
  }
  createGroupper(element, props, sys) {
    if (true) ;
    const tabster = this._tabster;
    const newGroupper = new Groupper(tabster, element, this._onGroupperDispose, props, sys);
    this._grouppers[newGroupper.id] = newGroupper;
    const focusedElement = tabster.focusedElement.getFocusedElement();
    if (focusedElement && dom.nodeContains(element, focusedElement) && !this._updateTimer) {
      this._updateTimer = this._win().setTimeout(() => {
        delete this._updateTimer;
        if (focusedElement === tabster.focusedElement.getFocusedElement()) {
          this._updateCurrent(focusedElement);
        }
      }, 0);
    }
    return newGroupper;
  }
  forgetCurrentGrouppers() {
    this._current = {};
  }
  _updateCurrent(element) {
    var _a;
    if (this._updateTimer) {
      this._win().clearTimeout(this._updateTimer);
      delete this._updateTimer;
    }
    const tabster = this._tabster;
    const newIds = {};
    for (let el = tabster.getParent(element); el; el = tabster.getParent(el)) {
      const groupper = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;
      if (groupper) {
        newIds[groupper.id] = true;
        this._current[groupper.id] = groupper;
        const isTabbable = groupper.isActive() || element !== el && (!groupper.getProps().delegated || groupper.getFirst(false) !== element);
        groupper.makeTabbable(isTabbable);
      }
    }
    for (const id of Object.keys(this._current)) {
      const groupper = this._current[id];
      if (!(groupper.id in newIds)) {
        groupper.makeTabbable(false);
        groupper.setFirst(void 0);
        delete this._current[id];
      }
    }
  }
  _enterGroupper(element, relatedEvent) {
    const tabster = this._tabster;
    const ctx = RootAPI.getTabsterContext(tabster, element);
    const groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);
    const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
    if (groupper && groupperElement && (element === groupperElement || groupper.getProps().delegated && element === groupper.getFirst(false))) {
      const next = tabster.focusable.findNext({
        container: groupperElement,
        currentElement: element,
        useActiveModalizer: true
      });
      if (next && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({
        by: "groupper",
        owner: groupperElement,
        next,
        relatedEvent
      })))) {
        if (relatedEvent) {
          relatedEvent.preventDefault();
          relatedEvent.stopImmediatePropagation();
        }
        next.focus();
        return next;
      }
    }
    return null;
  }
  _escapeGroupper(element, relatedEvent, fromModalizer) {
    const tabster = this._tabster;
    const ctx = RootAPI.getTabsterContext(tabster, element);
    let groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);
    const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
    if (groupper && groupperElement && dom.nodeContains(groupperElement, element)) {
      let next;
      if (element !== groupperElement || fromModalizer) {
        next = groupper.getFirst(true);
      } else {
        const parentElement2 = dom.getParentElement(groupperElement);
        const parentCtx = parentElement2 ? RootAPI.getTabsterContext(tabster, parentElement2) : void 0;
        groupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;
        next = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);
      }
      if (next && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({
        by: "groupper",
        owner: groupperElement,
        next,
        relatedEvent
      })))) {
        if (groupper) {
          groupper.makeTabbable(false);
        }
        next.focus();
        return next;
      }
    }
    return null;
  }
  moveFocus(element, action) {
    return action === GroupperMoveFocusActions.Enter ? this._enterGroupper(element) : this._escapeGroupper(element);
  }
  handleKeyPress(element, event, fromModalizer) {
    const tabster = this._tabster;
    const ctx = RootAPI.getTabsterContext(tabster, element);
    if (ctx && ((ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper))) {
      tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);
      if (ctx.ignoreKeydown(event)) {
        return;
      }
      if (event.key === Keys.Enter) {
        this._enterGroupper(element, event);
      } else if (event.key === Keys.Escape) {
        const focusedElement = tabster.focusedElement.getFocusedElement();
        tabster.focusedElement.requestAsyncFocus(AsyncFocusSources.EscapeGroupper, () => {
          if (focusedElement !== tabster.focusedElement.getFocusedElement() && // A part of Modalizer that has called this handler to escape the active groupper
          // might have been removed from DOM, if the focus is on body, we still want to handle Esc.
          (fromModalizer && !focusedElement || !fromModalizer)) {
            return;
          }
          this._escapeGroupper(element, event, fromModalizer);
        }, 0);
      }
    }
  }
};
function _setInformativeStyle$1(weakElement, remove) {
  if (true) {
    const element = weakElement.get();
    if (element) {
      if (remove) {
        element.style.removeProperty("--tabster-groupper");
      } else {
        element.style.setProperty("--tabster-groupper", "unlimited");
      }
    }
  }
}
var KeyboardNavigationState = class extends Subscribable {
  constructor(getWindow2) {
    super();
    this._onChange = (isNavigatingWithKeyboard) => {
      this.setVal(isNavigatingWithKeyboard, void 0);
    };
    this._keyborg = createKeyborg(getWindow2());
    this._keyborg.subscribe(this._onChange);
  }
  dispose() {
    super.dispose();
    if (this._keyborg) {
      this._keyborg.unsubscribe(this._onChange);
      disposeKeyborg(this._keyborg);
      delete this._keyborg;
    }
  }
  setNavigatingWithKeyboard(isNavigatingWithKeyboard) {
    var _a;
    (_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.setVal(isNavigatingWithKeyboard);
  }
  isNavigatingWithKeyboard() {
    var _a;
    return !!((_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.isNavigatingWithKeyboard());
  }
};
var _wasFocusedCounter = 0;
var _ariaHidden = "aria-hidden";
function _setInformativeStyle(weakElement, remove, internalId, userId, isActive, wasFocused) {
  if (true) {
    const element = weakElement.get();
    if (element) {
      if (remove) {
        element.style.removeProperty("--tabster-modalizer");
      } else {
        element.style.setProperty("--tabster-modalizer", internalId + "," + userId + "," + (isActive ? "active" : "inactive") + ",," + (wasFocused ? `focused(${wasFocused})` : "not-focused"));
      }
    }
  }
}
var ModalizerDummyManager = class extends DummyInputManager {
  constructor(element, tabster, sys) {
    super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);
    this._setHandlers((dummyInput, isBackward) => {
      var _a, _b;
      const el = element.get();
      const container = el && ((_a = RootAPI.getRoot(tabster, el)) === null || _a === void 0 ? void 0 : _a.getElement());
      const input = dummyInput.input;
      let toFocus;
      if (container && input) {
        const dummyContainer = getDummyInputContainer(input);
        const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);
        if (ctx) {
          toFocus = (_b = FocusedElementState.findNextTabbable(tabster, ctx, container, input, void 0, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;
        }
        if (toFocus) {
          nativeFocus(toFocus);
        }
      }
    });
  }
};
var Modalizer = class extends TabsterPart {
  constructor(tabster, element, onDispose, props, sys, activeElements) {
    super(tabster, element, props);
    this._wasFocused = 0;
    this.userId = props.id;
    this._onDispose = onDispose;
    this._activeElements = activeElements;
    if (!tabster.controlTab) {
      this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);
    }
    if (true) {
      _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);
    }
  }
  makeActive(isActive) {
    if (this._isActive !== isActive) {
      this._isActive = isActive;
      const element = this.getElement();
      if (element) {
        const activeElements = this._activeElements;
        const index = activeElements.map((e) => e.get()).indexOf(element);
        if (isActive) {
          if (index < 0) {
            activeElements.push(new WeakHTMLElement(this._tabster.getWindow, element));
          }
        } else {
          if (index >= 0) {
            activeElements.splice(index, 1);
          }
        }
      }
      if (true) {
        _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);
      }
      this._dispatchEvent(isActive);
    }
  }
  focused(noIncrement) {
    if (!noIncrement) {
      this._wasFocused = ++_wasFocusedCounter;
    }
    return this._wasFocused;
  }
  setProps(props) {
    if (props.id) {
      this.userId = props.id;
    }
    this._props = {
      ...props
    };
  }
  dispose() {
    var _a;
    this.makeActive(false);
    this._onDispose(this);
    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
    delete this.dummyManager;
    this._activeElements = [];
    this._remove();
  }
  isActive() {
    return !!this._isActive;
  }
  contains(element) {
    return dom.nodeContains(this.getElement(), element);
  }
  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
    var _a, _b;
    const modalizerElement = this.getElement();
    if (!modalizerElement) {
      return null;
    }
    const tabster = this._tabster;
    let next = null;
    let outOfDOMOrder = false;
    let uncontrolled;
    const container = currentElement && ((_a = RootAPI.getRoot(tabster, currentElement)) === null || _a === void 0 ? void 0 : _a.getElement());
    if (container) {
      const findProps = {
        container,
        currentElement,
        referenceElement,
        ignoreAccessibility,
        useActiveModalizer: true
      };
      const findPropsOut = {};
      next = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
      if (!next && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
        next = tabster.focusable[isBackward ? "findLast" : "findFirst"]({
          container,
          ignoreAccessibility,
          useActiveModalizer: true
        }, findPropsOut);
        if (next === null) {
          next = currentElement;
        }
        outOfDOMOrder = true;
      } else {
        outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
      }
      uncontrolled = findPropsOut.uncontrolled;
    }
    return {
      element: next,
      uncontrolled,
      outOfDOMOrder
    };
  }
  _dispatchEvent(isActive, allElements) {
    const element = this.getElement();
    let defaultPrevented = false;
    if (element) {
      const elements = allElements ? this._activeElements.map((e) => e.get()) : [element];
      for (const el of elements) {
        if (el) {
          const eventDetail = {
            id: this.userId,
            element
          };
          const event = isActive ? new ModalizerActiveEvent(eventDetail) : new ModalizerInactiveEvent(eventDetail);
          el.dispatchEvent(event);
          if (event.defaultPrevented) {
            defaultPrevented = true;
          }
        }
      }
    }
    return defaultPrevented;
  }
  _remove() {
    if (true) {
      _setInformativeStyle(this._element, true);
    }
  }
};
var ModalizerAPI = class {
  constructor(tabster, alwaysAccessibleSelector, accessibleCheck) {
    this._onModalizerDispose = (modalizer) => {
      const id = modalizer.id;
      const userId = modalizer.userId;
      const part = this._parts[userId];
      delete this._modalizers[id];
      if (part) {
        delete part[id];
        if (Object.keys(part).length === 0) {
          delete this._parts[userId];
          const activationHistory = this._activationHistory;
          const cleanActivationHistory = [];
          let prevHistoryItem;
          for (let i = activationHistory.length; i--; ) {
            const modalizerUserIdFromHistory = activationHistory[i];
            if (modalizerUserIdFromHistory === userId) {
              continue;
            }
            if (modalizerUserIdFromHistory !== prevHistoryItem) {
              prevHistoryItem = modalizerUserIdFromHistory;
              if (modalizerUserIdFromHistory || cleanActivationHistory.length > 0) {
                cleanActivationHistory.unshift(modalizerUserIdFromHistory);
              }
            }
          }
          this._activationHistory = cleanActivationHistory;
          if (this.activeId === userId) {
            const prevActiveId = cleanActivationHistory[0];
            const prevActive = prevActiveId ? Object.values(this._parts[prevActiveId])[0] : void 0;
            this.setActive(prevActive);
          }
        }
      }
    };
    this._onKeyDown = (event) => {
      var _a;
      if (event.key !== Keys.Escape) {
        return;
      }
      const tabster2 = this._tabster;
      const element = tabster2.focusedElement.getFocusedElement();
      if (element) {
        const ctx = RootAPI.getTabsterContext(tabster2, element);
        const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
        if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {
          const activeId = modalizer.userId;
          if (activeId) {
            const part = this._parts[activeId];
            if (part) {
              const focusedSince = Object.keys(part).map((id) => {
                var _a2;
                const m = part[id];
                const el = m.getElement();
                let groupper;
                if (el) {
                  groupper = (_a2 = getTabsterOnElement(tabster2, el)) === null || _a2 === void 0 ? void 0 : _a2.groupper;
                }
                return m && el && groupper ? {
                  el,
                  focusedSince: m.focused(true)
                } : {
                  focusedSince: 0
                };
              }).filter((f) => f.focusedSince > 0).sort((a, b) => a.focusedSince > b.focusedSince ? -1 : a.focusedSince < b.focusedSince ? 1 : 0);
              if (focusedSince.length) {
                const groupperElement = focusedSince[0].el;
                if (groupperElement) {
                  (_a = tabster2.groupper) === null || _a === void 0 ? void 0 : _a.handleKeyPress(groupperElement, event, true);
                }
              }
            }
          }
        }
      }
    };
    this._onFocus = (focusedElement, detail) => {
      var _a;
      const tabster2 = this._tabster;
      const ctx = focusedElement && RootAPI.getTabsterContext(tabster2, focusedElement);
      if (!ctx || !focusedElement) {
        return;
      }
      const augmentedMap = this._augMap;
      for (let e = focusedElement; e; e = dom.getParentElement(e)) {
        if (augmentedMap.has(e)) {
          augmentedMap.delete(e);
          augmentAttribute(tabster2, e, _ariaHidden);
        }
      }
      let modalizer = ctx.modalizer;
      const tabsterOnFocusedElement = getTabsterOnElement(tabster2, focusedElement);
      const modalizerOnFocusedElement = tabsterOnFocusedElement === null || tabsterOnFocusedElement === void 0 ? void 0 : tabsterOnFocusedElement.modalizer;
      if (modalizerOnFocusedElement) {
        modalizerOnFocusedElement.focused();
        if (modalizerOnFocusedElement.userId === this.activeId && tabsterOnFocusedElement.groupper) {
          const parentElement2 = tabster2.getParent(focusedElement);
          const parentModalizer = parentElement2 && ((_a = RootAPI.getTabsterContext(tabster2, parentElement2)) === null || _a === void 0 ? void 0 : _a.modalizer);
          if (parentModalizer) {
            modalizer = parentModalizer;
          } else {
            this.setActive(void 0);
            return;
          }
        }
      }
      modalizer === null || modalizer === void 0 ? void 0 : modalizer.focused();
      if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {
        this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
        return;
      }
      if (detail.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) {
        this.setActive(modalizer);
      } else {
        const win2 = this._win();
        win2.clearTimeout(this._restoreModalizerFocusTimer);
        this._restoreModalizerFocusTimer = win2.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);
      }
    };
    this._tabster = tabster;
    this._win = tabster.getWindow;
    this._modalizers = {};
    this._parts = {};
    this._augMap = /* @__PURE__ */ new WeakMap();
    this._aug = [];
    this._alwaysAccessibleSelector = alwaysAccessibleSelector;
    this._accessibleCheck = accessibleCheck;
    this._activationHistory = [];
    this.activeElements = [];
    if (!tabster.controlTab) {
      tabster.root.addDummyInputs();
    }
    const win = this._win();
    win.addEventListener("keydown", this._onKeyDown, true);
    tabster.queueInit(() => {
      this._tabster.focusedElement.subscribe(this._onFocus);
    });
  }
  dispose() {
    const win = this._win();
    win.removeEventListener("keydown", this._onKeyDown, true);
    Object.keys(this._modalizers).forEach((modalizerId) => {
      if (this._modalizers[modalizerId]) {
        this._modalizers[modalizerId].dispose();
        delete this._modalizers[modalizerId];
      }
    });
    win.clearTimeout(this._restoreModalizerFocusTimer);
    win.clearTimeout(this._hiddenUpdateTimer);
    this._parts = {};
    delete this.activeId;
    this.activeElements = [];
    this._augMap = /* @__PURE__ */ new WeakMap();
    this._aug = [];
    this._tabster.focusedElement.unsubscribe(this._onFocus);
  }
  createModalizer(element, props, sys) {
    var _a;
    if (true) ;
    const modalizer = new Modalizer(this._tabster, element, this._onModalizerDispose, props, sys, this.activeElements);
    const id = modalizer.id;
    const userId = props.id;
    this._modalizers[id] = modalizer;
    let part = this._parts[userId];
    if (!part) {
      part = this._parts[userId] = {};
    }
    part[id] = modalizer;
    const focusedElement = (_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null;
    if (element !== focusedElement && dom.nodeContains(element, focusedElement)) {
      if (userId !== this.activeId) {
        this.setActive(modalizer);
      } else {
        modalizer.makeActive(true);
      }
    }
    return modalizer;
  }
  isAugmented(element) {
    return this._augMap.has(element);
  }
  hiddenUpdate() {
    if (this._hiddenUpdateTimer) {
      return;
    }
    this._hiddenUpdateTimer = this._win().setTimeout(() => {
      delete this._hiddenUpdateTimer;
      this._hiddenUpdate();
    }, 250);
  }
  setActive(modalizer) {
    const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;
    const activeId = this.activeId;
    if (activeId === userId) {
      return;
    }
    this.activeId = userId;
    if (activeId) {
      const part = this._parts[activeId];
      if (part) {
        for (const id of Object.keys(part)) {
          part[id].makeActive(false);
        }
      }
    }
    if (userId) {
      const part = this._parts[userId];
      if (part) {
        for (const id of Object.keys(part)) {
          part[id].makeActive(true);
        }
      }
    }
    this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
    this.hiddenUpdate();
    const activationHistory = this._activationHistory;
    if (activationHistory[0] !== userId && (userId !== void 0 || activationHistory.length > 0)) {
      activationHistory.unshift(userId);
    }
  }
  focus(elementFromModalizer, noFocusFirst, noFocusDefault) {
    const tabster = this._tabster;
    const ctx = RootAPI.getTabsterContext(tabster, elementFromModalizer);
    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
    if (modalizer) {
      this.setActive(modalizer);
      const props = modalizer.getProps();
      const modalizerRoot = modalizer.getElement();
      if (modalizerRoot) {
        if (noFocusFirst === void 0) {
          noFocusFirst = props.isNoFocusFirst;
        }
        if (!noFocusFirst && tabster.keyboardNavigation.isNavigatingWithKeyboard() && tabster.focusedElement.focusFirst({
          container: modalizerRoot
        })) {
          return true;
        }
        if (noFocusDefault === void 0) {
          noFocusDefault = props.isNoFocusDefault;
        }
        if (!noFocusDefault && tabster.focusedElement.focusDefault(modalizerRoot)) {
          return true;
        }
        tabster.focusedElement.resetFocus(modalizerRoot);
      }
    } else if (true) {
      console.error("Element is not in Modalizer.", elementFromModalizer);
    }
    return false;
  }
  activate(modalizerElementOrContainer) {
    var _a;
    const modalizerToActivate = modalizerElementOrContainer ? (_a = RootAPI.getTabsterContext(this._tabster, modalizerElementOrContainer)) === null || _a === void 0 ? void 0 : _a.modalizer : void 0;
    if (!modalizerElementOrContainer || modalizerToActivate) {
      this.setActive(modalizerToActivate);
      return true;
    }
    return false;
  }
  acceptElement(element, state) {
    var _a;
    const modalizerUserId = state.modalizerUserId;
    const currentModalizer = (_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.modalizer;
    if (modalizerUserId) {
      for (const e of this.activeElements) {
        const el = e.get();
        if (el && (dom.nodeContains(element, el) || el === element)) {
          return NodeFilter.FILTER_SKIP;
        }
      }
    }
    const ret = modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? void 0 : NodeFilter.FILTER_SKIP;
    if (ret !== void 0) {
      state.skippedFocusable = true;
    }
    return ret;
  }
  _hiddenUpdate() {
    var _a;
    const tabster = this._tabster;
    const body = tabster.getWindow().document.body;
    const activeId = this.activeId;
    const parts = this._parts;
    const visibleElements = [];
    const hiddenElements = [];
    const alwaysAccessibleSelector = this._alwaysAccessibleSelector;
    const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(dom.querySelectorAll(body, alwaysAccessibleSelector)) : [];
    const activeModalizerElements = [];
    for (const userId of Object.keys(parts)) {
      const modalizerParts = parts[userId];
      for (const id of Object.keys(modalizerParts)) {
        const modalizer = modalizerParts[id];
        const el = modalizer.getElement();
        const props = modalizer.getProps();
        const isAlwaysAccessible = props.isAlwaysAccessible;
        if (el) {
          if (userId === activeId) {
            activeModalizerElements.push(el);
            if (!this.currentIsOthersAccessible) {
              visibleElements.push(el);
            }
          } else if (isAlwaysAccessible) {
            alwaysAccessibleElements.push(el);
          } else {
            hiddenElements.push(el);
          }
        }
      }
    }
    const augmentedMap = this._augMap;
    const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : void 0;
    const newAugmented = [];
    const newAugmentedMap = /* @__PURE__ */ new WeakMap();
    const toggle = (element, hide3) => {
      var _a2;
      const tagName = element.tagName;
      if (tagName === "SCRIPT" || tagName === "STYLE") {
        return;
      }
      let isAugmented = false;
      if (augmentedMap.has(element)) {
        if (hide3) {
          isAugmented = true;
        } else {
          augmentedMap.delete(element);
          augmentAttribute(tabster, element, _ariaHidden);
        }
      } else if (hide3 && !((_a2 = this._accessibleCheck) === null || _a2 === void 0 ? void 0 : _a2.call(this, element, activeModalizerElements)) && augmentAttribute(tabster, element, _ariaHidden, "true")) {
        augmentedMap.set(element, true);
        isAugmented = true;
      }
      if (isAugmented) {
        newAugmented.push(new WeakHTMLElement(tabster.getWindow, element));
        newAugmentedMap.set(element, true);
      }
    };
    const walk = (element) => {
      var _a2;
      for (let el = dom.getFirstElementChild(element); el; el = dom.getNextElementSibling(el)) {
        let skip = false;
        let containsModalizer = false;
        let containedByModalizer = false;
        if (allVisibleElements) {
          const elParent = tabster.getParent(el);
          for (const c of allVisibleElements) {
            if (el === c) {
              skip = true;
              break;
            }
            if (dom.nodeContains(el, c)) {
              containsModalizer = true;
              break;
            } else if (dom.nodeContains(c, elParent)) {
              containedByModalizer = true;
            }
          }
          if (containsModalizer || ((_a2 = el.__tabsterElementFlags) === null || _a2 === void 0 ? void 0 : _a2.noDirectAriaHidden)) {
            walk(el);
          } else if (!skip && !containedByModalizer) {
            toggle(el, true);
          }
        } else {
          toggle(el, false);
        }
      }
    };
    if (!allVisibleElements) {
      alwaysAccessibleElements.forEach((e) => toggle(e, false));
    }
    hiddenElements.forEach((e) => toggle(e, true));
    if (body) {
      walk(body);
    }
    (_a = this._aug) === null || _a === void 0 ? void 0 : _a.map((e) => e.get()).forEach((e) => {
      if (e && !newAugmentedMap.get(e)) {
        toggle(e, false);
      }
    });
    this._aug = newAugmented;
    this._augMap = newAugmentedMap;
  }
  /**
   * Called when an element is focused outside of an active modalizer.
   * Attempts to pull focus back into the active modalizer
   * @param outsideElement - An element being focused outside of the modalizer
   */
  _restoreModalizerFocus(outsideElement) {
    var _a;
    const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;
    if (!outsideElement || !ownerDocument) {
      return;
    }
    const focusedElement = this._tabster.focusedElement.getFocusedElement();
    const focusedElementModalizer = focusedElement && ((_a = RootAPI.getTabsterContext(this._tabster, focusedElement)) === null || _a === void 0 ? void 0 : _a.modalizer);
    if (!focusedElement || focusedElement && (focusedElementModalizer === null || focusedElementModalizer === void 0 ? void 0 : focusedElementModalizer.userId) === this.activeId) {
      return;
    }
    const tabster = this._tabster;
    const ctx = RootAPI.getTabsterContext(tabster, outsideElement);
    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
    const activeId = this.activeId;
    if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) {
      return;
    }
    const container = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();
    if (container) {
      let toFocus = tabster.focusable.findFirst({
        container,
        useActiveModalizer: true
      });
      if (toFocus) {
        if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {
          toFocus = tabster.focusable.findLast({
            container,
            useActiveModalizer: true
          });
          if (!toFocus) {
            throw new Error("Something went wrong.");
          }
        }
        tabster.focusedElement.focus(toFocus);
        return;
      }
    }
    outsideElement.blur();
  }
};
var _inputSelector = ["input", "textarea", "*[contenteditable]"].join(", ");
var MoverDummyManager = class extends DummyInputManager {
  constructor(element, tabster, getMemorized, sys) {
    super(tabster, element, DummyInputManagerPriorities.Mover, sys);
    this._onFocusDummyInput = (dummyInput) => {
      var _a, _b;
      const container = this._element.get();
      const input = dummyInput.input;
      if (container && input) {
        const ctx = RootAPI.getTabsterContext(this._tabster, container);
        let toFocus;
        if (ctx) {
          toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, void 0, input, void 0, !dummyInput.isFirst, true)) === null || _a === void 0 ? void 0 : _a.element;
        }
        const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();
        if (memorized && this._tabster.focusable.isFocusable(memorized)) {
          toFocus = memorized;
        }
        if (toFocus) {
          nativeFocus(toFocus);
        }
      }
    };
    this._tabster = tabster;
    this._getMemorized = getMemorized;
    this._setHandlers(this._onFocusDummyInput);
  }
};
var _moverUpdateAdd = 1;
var _moverUpdateAttr = 2;
var _moverUpdateRemove = 3;
var Mover = class extends TabsterPart {
  constructor(tabster, element, onDispose, props, sys) {
    var _a;
    super(tabster, element, props);
    this._visible = {};
    this._onIntersection = (entries) => {
      for (const entry of entries) {
        const el = entry.target;
        const id = getElementUId(this._win, el);
        let newVisibility;
        let fullyVisible = this._fullyVisible;
        if (entry.intersectionRatio >= 0.25) {
          newVisibility = entry.intersectionRatio >= 0.75 ? Visibilities.Visible : Visibilities.PartiallyVisible;
          if (newVisibility === Visibilities.Visible) {
            fullyVisible = id;
          }
        } else {
          newVisibility = Visibilities.Invisible;
        }
        if (this._visible[id] !== newVisibility) {
          if (newVisibility === void 0) {
            delete this._visible[id];
            if (fullyVisible === id) {
              delete this._fullyVisible;
            }
          } else {
            this._visible[id] = newVisibility;
            this._fullyVisible = fullyVisible;
          }
          const state = this.getState(el);
          if (state) {
            el.dispatchEvent(new MoverStateEvent(state));
          }
        }
      }
    };
    this._win = tabster.getWindow;
    this.visibilityTolerance = (_a = props.visibilityTolerance) !== null && _a !== void 0 ? _a : 0.8;
    if (this._props.trackState || this._props.visibilityAware) {
      this._intersectionObserver = new IntersectionObserver(this._onIntersection, {
        threshold: [0, 0.25, 0.5, 0.75, 1]
      });
      this._observeState();
    }
    this._onDispose = onDispose;
    const getMemorized = () => props.memorizeCurrent ? this._current : void 0;
    if (!tabster.controlTab) {
      this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);
    }
  }
  dispose() {
    var _a;
    this._onDispose(this);
    if (this._intersectionObserver) {
      this._intersectionObserver.disconnect();
      delete this._intersectionObserver;
    }
    delete this._current;
    delete this._fullyVisible;
    delete this._allElements;
    delete this._updateQueue;
    if (this._unobserve) {
      this._unobserve();
      delete this._unobserve;
    }
    const win = this._win();
    if (this._setCurrentTimer) {
      win.clearTimeout(this._setCurrentTimer);
      delete this._setCurrentTimer;
    }
    if (this._updateTimer) {
      win.clearTimeout(this._updateTimer);
      delete this._updateTimer;
    }
    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
    delete this.dummyManager;
  }
  setCurrent(element) {
    if (element) {
      this._current = new WeakHTMLElement(this._win, element);
    } else {
      this._current = void 0;
    }
    if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) {
      this._setCurrentTimer = this._win().setTimeout(() => {
        var _a;
        delete this._setCurrentTimer;
        const changed = [];
        if (this._current !== this._prevCurrent) {
          changed.push(this._current);
          changed.push(this._prevCurrent);
          this._prevCurrent = this._current;
        }
        for (const weak of changed) {
          const el = weak === null || weak === void 0 ? void 0 : weak.get();
          if (el && ((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) === this) {
            const props = this._props;
            if (el && (props.visibilityAware !== void 0 || props.trackState)) {
              const state = this.getState(el);
              if (state) {
                el.dispatchEvent(new MoverStateEvent(state));
              }
            }
          }
        }
      });
    }
  }
  getCurrent() {
    var _a;
    return ((_a = this._current) === null || _a === void 0 ? void 0 : _a.get()) || null;
  }
  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
    const container = this.getElement();
    const currentIsDummy = container && getDummyInputContainer(currentElement) === container;
    if (!container) {
      return null;
    }
    let next = null;
    let outOfDOMOrder = false;
    let uncontrolled;
    if (this._props.tabbable || currentIsDummy || currentElement && !dom.nodeContains(container, currentElement)) {
      const findProps = {
        currentElement,
        referenceElement,
        container,
        ignoreAccessibility,
        useActiveModalizer: true
      };
      const findPropsOut = {};
      next = this._tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
      uncontrolled = findPropsOut.uncontrolled;
    }
    return {
      element: next,
      uncontrolled,
      outOfDOMOrder
    };
  }
  acceptElement(element, state) {
    var _a, _b;
    if (!FocusedElementState.isTabbing) {
      return ((_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.excludedFromMover) ? NodeFilter.FILTER_REJECT : void 0;
    }
    const {
      memorizeCurrent,
      visibilityAware,
      hasDefault = true
    } = this._props;
    const moverElement = this.getElement();
    if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!dom.nodeContains(moverElement, state.from) || getDummyInputContainer(state.from) === moverElement)) {
      let found;
      if (memorizeCurrent) {
        const current = (_b = this._current) === null || _b === void 0 ? void 0 : _b.get();
        if (current && state.acceptCondition(current)) {
          found = current;
        }
      }
      if (!found && hasDefault) {
        found = this._tabster.focusable.findDefault({
          container: moverElement,
          useActiveModalizer: true
        });
      }
      if (!found && visibilityAware) {
        found = this._tabster.focusable.findElement({
          container: moverElement,
          useActiveModalizer: true,
          isBackward: state.isBackward,
          acceptCondition: (el) => {
            var _a2;
            const id = getElementUId(this._win, el);
            const visibility = this._visible[id];
            return moverElement !== el && !!((_a2 = this._allElements) === null || _a2 === void 0 ? void 0 : _a2.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));
          }
        });
      }
      if (found) {
        state.found = true;
        state.foundElement = found;
        state.rejectElementsFrom = moverElement;
        state.skippedFocusable = true;
        return NodeFilter.FILTER_ACCEPT;
      }
    }
    return void 0;
  }
  _observeState() {
    const element = this.getElement();
    if (this._unobserve || !element || typeof MutationObserver === "undefined") {
      return;
    }
    const win = this._win();
    const allElements = this._allElements = /* @__PURE__ */ new WeakMap();
    const tabsterFocusable = this._tabster.focusable;
    let updateQueue = this._updateQueue = [];
    const observer = dom.createMutationObserver((mutations) => {
      for (const mutation of mutations) {
        const target = mutation.target;
        const removed = mutation.removedNodes;
        const added = mutation.addedNodes;
        if (mutation.type === "attributes") {
          if (mutation.attributeName === "tabindex") {
            updateQueue.push({
              element: target,
              type: _moverUpdateAttr
            });
          }
        } else {
          for (let i = 0; i < removed.length; i++) {
            updateQueue.push({
              element: removed[i],
              type: _moverUpdateRemove
            });
          }
          for (let i = 0; i < added.length; i++) {
            updateQueue.push({
              element: added[i],
              type: _moverUpdateAdd
            });
          }
        }
      }
      requestUpdate();
    });
    const setElement = (element2, remove) => {
      var _a, _b;
      const current = allElements.get(element2);
      if (current && remove) {
        (_a = this._intersectionObserver) === null || _a === void 0 ? void 0 : _a.unobserve(element2);
        allElements.delete(element2);
      }
      if (!current && !remove) {
        allElements.set(element2, this);
        (_b = this._intersectionObserver) === null || _b === void 0 ? void 0 : _b.observe(element2);
      }
    };
    const updateElement = (element2) => {
      const isFocusable = tabsterFocusable.isFocusable(element2);
      const current = allElements.get(element2);
      if (current) {
        if (!isFocusable) {
          setElement(element2, true);
        }
      } else {
        if (isFocusable) {
          setElement(element2);
        }
      }
    };
    const addNewElements = (element2) => {
      const {
        mover
      } = getMoverGroupper(element2);
      if (mover && mover !== this) {
        if (mover.getElement() === element2 && tabsterFocusable.isFocusable(element2)) {
          setElement(element2);
        } else {
          return;
        }
      }
      const walker = createElementTreeWalker(win.document, element2, (node) => {
        const {
          mover: mover2,
          groupper
        } = getMoverGroupper(node);
        if (mover2 && mover2 !== this) {
          return NodeFilter.FILTER_REJECT;
        }
        const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);
        if (groupper && groupper.getElement() !== node && groupperFirstFocusable && groupperFirstFocusable !== node) {
          return NodeFilter.FILTER_REJECT;
        }
        if (tabsterFocusable.isFocusable(node)) {
          setElement(node);
        }
        return NodeFilter.FILTER_SKIP;
      });
      if (walker) {
        walker.currentNode = element2;
        while (walker.nextNode()) {
        }
      }
    };
    const removeWalk = (element2) => {
      const current = allElements.get(element2);
      if (current) {
        setElement(element2, true);
      }
      for (let el = dom.getFirstElementChild(element2); el; el = dom.getNextElementSibling(el)) {
        removeWalk(el);
      }
    };
    const requestUpdate = () => {
      if (!this._updateTimer && updateQueue.length) {
        this._updateTimer = win.setTimeout(() => {
          delete this._updateTimer;
          for (const {
            element: element2,
            type
          } of updateQueue) {
            switch (type) {
              case _moverUpdateAttr:
                updateElement(element2);
                break;
              case _moverUpdateAdd:
                addNewElements(element2);
                break;
              case _moverUpdateRemove:
                removeWalk(element2);
                break;
            }
          }
          updateQueue = this._updateQueue = [];
        }, 0);
      }
    };
    const getMoverGroupper = (element2) => {
      const ret = {};
      for (let el = element2; el; el = dom.getParentElement(el)) {
        const toe = getTabsterOnElement(this._tabster, el);
        if (toe) {
          if (toe.groupper && !ret.groupper) {
            ret.groupper = toe.groupper;
          }
          if (toe.mover) {
            ret.mover = toe.mover;
            break;
          }
        }
      }
      return ret;
    };
    updateQueue.push({
      element,
      type: _moverUpdateAdd
    });
    requestUpdate();
    observer.observe(element, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ["tabindex"]
    });
    this._unobserve = () => {
      observer.disconnect();
    };
  }
  getState(element) {
    const id = getElementUId(this._win, element);
    if (id in this._visible) {
      const visibility = this._visible[id] || Visibilities.Invisible;
      const isCurrent = this._current ? this._current.get() === element : void 0;
      return {
        isCurrent,
        visibility
      };
    }
    return void 0;
  }
};
function getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;
  const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;
  return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);
}
var MoverAPI = class {
  constructor(tabster, getWindow2) {
    this._init = () => {
      const win = this._win();
      win.addEventListener("keydown", this._onKeyDown, true);
      win.addEventListener(MoverMoveFocusEventName, this._onMoveFocus);
      win.addEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);
      this._tabster.focusedElement.subscribe(this._onFocus);
    };
    this._onMoverDispose = (mover) => {
      delete this._movers[mover.id];
    };
    this._onFocus = (element) => {
      var _a;
      let currentFocusableElement = element;
      let deepestFocusableElement = element;
      for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) {
        const mover = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.mover;
        if (mover) {
          mover.setCurrent(deepestFocusableElement);
          currentFocusableElement = void 0;
        }
        if (!currentFocusableElement && this._tabster.focusable.isFocusable(el)) {
          currentFocusableElement = deepestFocusableElement = el;
        }
      }
    };
    this._onKeyDown = async (event) => {
      var _a;
      if (this._ignoredInputTimer) {
        this._win().clearTimeout(this._ignoredInputTimer);
        delete this._ignoredInputTimer;
      }
      (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);
      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
        return;
      }
      const key = event.key;
      let moverKey;
      if (key === Keys.ArrowDown) {
        moverKey = MoverKeys.ArrowDown;
      } else if (key === Keys.ArrowRight) {
        moverKey = MoverKeys.ArrowRight;
      } else if (key === Keys.ArrowUp) {
        moverKey = MoverKeys.ArrowUp;
      } else if (key === Keys.ArrowLeft) {
        moverKey = MoverKeys.ArrowLeft;
      } else if (key === Keys.PageDown) {
        moverKey = MoverKeys.PageDown;
      } else if (key === Keys.PageUp) {
        moverKey = MoverKeys.PageUp;
      } else if (key === Keys.Home) {
        moverKey = MoverKeys.Home;
      } else if (key === Keys.End) {
        moverKey = MoverKeys.End;
      }
      if (!moverKey) {
        return;
      }
      const focused = this._tabster.focusedElement.getFocusedElement();
      if (!focused || await this._isIgnoredInput(focused, key)) {
        return;
      }
      this._moveFocus(focused, moverKey, event);
    };
    this._onMoveFocus = (e) => {
      var _a;
      const element = e.composedPath()[0];
      const key = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.key;
      if (element && key !== void 0 && !e.defaultPrevented) {
        this._moveFocus(element, key);
        e.stopImmediatePropagation();
      }
    };
    this._onMemorizedElement = (e) => {
      var _a;
      const target = e.composedPath()[0];
      let memorizedElement = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.memorizedElement;
      if (target) {
        const ctx = RootAPI.getTabsterContext(this._tabster, target);
        const mover = ctx === null || ctx === void 0 ? void 0 : ctx.mover;
        if (mover) {
          if (memorizedElement && !dom.nodeContains(mover.getElement(), memorizedElement)) {
            memorizedElement = void 0;
          }
          mover.setCurrent(memorizedElement);
          e.stopImmediatePropagation();
        }
      }
    };
    this._tabster = tabster;
    this._win = getWindow2;
    this._movers = {};
    tabster.queueInit(this._init);
  }
  dispose() {
    var _a;
    const win = this._win();
    this._tabster.focusedElement.unsubscribe(this._onFocus);
    (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);
    if (this._ignoredInputTimer) {
      win.clearTimeout(this._ignoredInputTimer);
      delete this._ignoredInputTimer;
    }
    win.removeEventListener("keydown", this._onKeyDown, true);
    win.removeEventListener(MoverMoveFocusEventName, this._onMoveFocus);
    win.removeEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);
    Object.keys(this._movers).forEach((moverId) => {
      if (this._movers[moverId]) {
        this._movers[moverId].dispose();
        delete this._movers[moverId];
      }
    });
  }
  createMover(element, props, sys) {
    if (true) ;
    const newMover = new Mover(this._tabster, element, this._onMoverDispose, props, sys);
    this._movers[newMover.id] = newMover;
    return newMover;
  }
  moveFocus(fromElement, key) {
    return this._moveFocus(fromElement, key);
  }
  _moveFocus(fromElement, key, relatedEvent) {
    var _a, _b;
    const tabster = this._tabster;
    const ctx = RootAPI.getTabsterContext(tabster, fromElement, {
      checkRtl: true
    });
    if (!ctx || !ctx.mover || ctx.excludedFromMover || relatedEvent && ctx.ignoreKeydown(relatedEvent)) {
      return null;
    }
    const mover = ctx.mover;
    const container = mover.getElement();
    if (ctx.groupperBeforeMover) {
      const groupper = ctx.groupper;
      if (groupper && !groupper.isActive(true)) {
        for (let el = dom.getParentElement(groupper.getElement()); el && el !== container; el = dom.getParentElement(el)) {
          if ((_b = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper) === null || _b === void 0 ? void 0 : _b.isActive(true)) {
            return null;
          }
        }
      } else {
        return null;
      }
    }
    if (!container) {
      return null;
    }
    const focusable = tabster.focusable;
    const moverProps = mover.getProps();
    const direction = moverProps.direction || MoverDirections.Both;
    const isBoth = direction === MoverDirections.Both;
    const isVertical = isBoth || direction === MoverDirections.Vertical;
    const isHorizontal = isBoth || direction === MoverDirections.Horizontal;
    const isGridLinear = direction === MoverDirections.GridLinear;
    const isGrid = isGridLinear || direction === MoverDirections.Grid;
    const isCyclic = moverProps.cyclic;
    let next;
    let scrollIntoViewArg;
    let focusedElementRect;
    let focusedElementX1 = 0;
    let focusedElementX2 = 0;
    if (isGrid) {
      focusedElementRect = fromElement.getBoundingClientRect();
      focusedElementX1 = Math.ceil(focusedElementRect.left);
      focusedElementX2 = Math.floor(focusedElementRect.right);
    }
    if (ctx.rtl) {
      if (key === MoverKeys.ArrowRight) {
        key = MoverKeys.ArrowLeft;
      } else if (key === MoverKeys.ArrowLeft) {
        key = MoverKeys.ArrowRight;
      }
    }
    if (key === MoverKeys.ArrowDown && isVertical || key === MoverKeys.ArrowRight && (isHorizontal || isGrid)) {
      next = focusable.findNext({
        currentElement: fromElement,
        container,
        useActiveModalizer: true
      });
      if (next && isGrid) {
        const nextElementX1 = Math.ceil(next.getBoundingClientRect().left);
        if (!isGridLinear && focusedElementX2 > nextElementX1) {
          next = void 0;
        }
      } else if (!next && isCyclic) {
        next = focusable.findFirst({
          container,
          useActiveModalizer: true
        });
      }
    } else if (key === MoverKeys.ArrowUp && isVertical || key === MoverKeys.ArrowLeft && (isHorizontal || isGrid)) {
      next = focusable.findPrev({
        currentElement: fromElement,
        container,
        useActiveModalizer: true
      });
      if (next && isGrid) {
        const nextElementX2 = Math.floor(next.getBoundingClientRect().right);
        if (!isGridLinear && nextElementX2 > focusedElementX1) {
          next = void 0;
        }
      } else if (!next && isCyclic) {
        next = focusable.findLast({
          container,
          useActiveModalizer: true
        });
      }
    } else if (key === MoverKeys.Home) {
      if (isGrid) {
        focusable.findElement({
          container,
          currentElement: fromElement,
          useActiveModalizer: true,
          isBackward: true,
          acceptCondition: (el) => {
            var _a2;
            if (!focusable.isFocusable(el)) {
              return false;
            }
            const nextElementX1 = Math.ceil((_a2 = el.getBoundingClientRect().left) !== null && _a2 !== void 0 ? _a2 : 0);
            if (el !== fromElement && focusedElementX1 <= nextElementX1) {
              return true;
            }
            next = el;
            return false;
          }
        });
      } else {
        next = focusable.findFirst({
          container,
          useActiveModalizer: true
        });
      }
    } else if (key === MoverKeys.End) {
      if (isGrid) {
        focusable.findElement({
          container,
          currentElement: fromElement,
          useActiveModalizer: true,
          acceptCondition: (el) => {
            var _a2;
            if (!focusable.isFocusable(el)) {
              return false;
            }
            const nextElementX1 = Math.ceil((_a2 = el.getBoundingClientRect().left) !== null && _a2 !== void 0 ? _a2 : 0);
            if (el !== fromElement && focusedElementX1 >= nextElementX1) {
              return true;
            }
            next = el;
            return false;
          }
        });
      } else {
        next = focusable.findLast({
          container,
          useActiveModalizer: true
        });
      }
    } else if (key === MoverKeys.PageUp) {
      focusable.findElement({
        currentElement: fromElement,
        container,
        useActiveModalizer: true,
        isBackward: true,
        acceptCondition: (el) => {
          if (!focusable.isFocusable(el)) {
            return false;
          }
          if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
            next = el;
            return false;
          }
          return true;
        }
      });
      if (isGrid && next) {
        const firstColumnX1 = Math.ceil(next.getBoundingClientRect().left);
        focusable.findElement({
          currentElement: next,
          container,
          useActiveModalizer: true,
          acceptCondition: (el) => {
            if (!focusable.isFocusable(el)) {
              return false;
            }
            const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
            if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) {
              return true;
            }
            next = el;
            return false;
          }
        });
      }
      scrollIntoViewArg = false;
    } else if (key === MoverKeys.PageDown) {
      focusable.findElement({
        currentElement: fromElement,
        container,
        useActiveModalizer: true,
        acceptCondition: (el) => {
          if (!focusable.isFocusable(el)) {
            return false;
          }
          if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
            next = el;
            return false;
          }
          return true;
        }
      });
      if (isGrid && next) {
        const lastColumnX1 = Math.ceil(next.getBoundingClientRect().left);
        focusable.findElement({
          currentElement: next,
          container,
          useActiveModalizer: true,
          isBackward: true,
          acceptCondition: (el) => {
            if (!focusable.isFocusable(el)) {
              return false;
            }
            const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
            if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) {
              return true;
            }
            next = el;
            return false;
          }
        });
      }
      scrollIntoViewArg = true;
    } else if (isGrid) {
      const isBackward = key === MoverKeys.ArrowUp;
      const ax1 = focusedElementX1;
      const ay1 = Math.ceil(focusedElementRect.top);
      const ax2 = focusedElementX2;
      const ay2 = Math.floor(focusedElementRect.bottom);
      let targetElement;
      let lastDistance;
      let lastIntersection = 0;
      focusable.findAll({
        container,
        currentElement: fromElement,
        isBackward,
        onElement: (el) => {
          const rect = el.getBoundingClientRect();
          const bx1 = Math.ceil(rect.left);
          const by1 = Math.ceil(rect.top);
          const bx2 = Math.floor(rect.right);
          const by2 = Math.floor(rect.bottom);
          if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) {
            return true;
          }
          const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));
          const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));
          if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {
            const intersection = xIntersectionWidth / minWidth;
            if (intersection > lastIntersection) {
              targetElement = el;
              lastIntersection = intersection;
            }
          } else if (lastIntersection === 0) {
            const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);
            if (lastDistance === void 0 || distance < lastDistance) {
              lastDistance = distance;
              targetElement = el;
            }
          } else if (lastIntersection > 0) {
            return false;
          }
          return true;
        }
      });
      next = targetElement;
    }
    if (next && (!relatedEvent || relatedEvent && container.dispatchEvent(new TabsterMoveFocusEvent({
      by: "mover",
      owner: container,
      next,
      relatedEvent
    })))) {
      if (scrollIntoViewArg !== void 0) {
        scrollIntoView(this._win, next, scrollIntoViewArg);
      }
      if (relatedEvent) {
        relatedEvent.preventDefault();
        relatedEvent.stopImmediatePropagation();
      }
      nativeFocus(next);
      return next;
    }
    return null;
  }
  async _isIgnoredInput(element, key) {
    if (element.getAttribute("aria-expanded") === "true" && element.hasAttribute("aria-activedescendant")) {
      return true;
    }
    if (matchesSelector(element, _inputSelector)) {
      let selectionStart = 0;
      let selectionEnd = 0;
      let textLength = 0;
      let asyncRet;
      if (element.tagName === "INPUT" || element.tagName === "TEXTAREA") {
        const type = element.type;
        const value = element.value;
        textLength = (value || "").length;
        if (type === "email" || type === "number") {
          if (textLength) {
            const selection = dom.getSelection(element);
            if (selection) {
              const initialLength = selection.toString().length;
              const isBackward = key === Keys.ArrowLeft || key === Keys.ArrowUp;
              selection.modify("extend", isBackward ? "backward" : "forward", "character");
              if (initialLength !== selection.toString().length) {
                selection.modify("extend", isBackward ? "forward" : "backward", "character");
                return true;
              } else {
                textLength = 0;
              }
            }
          }
        } else {
          const selStart = element.selectionStart;
          if (selStart === null) {
            return type === "hidden";
          }
          selectionStart = selStart || 0;
          selectionEnd = element.selectionEnd || 0;
        }
      } else if (element.contentEditable === "true") {
        asyncRet = new (getPromise(this._win))((resolve) => {
          this._ignoredInputResolve = (value) => {
            delete this._ignoredInputResolve;
            resolve(value);
          };
          const win = this._win();
          if (this._ignoredInputTimer) {
            win.clearTimeout(this._ignoredInputTimer);
          }
          const {
            anchorNode: prevAnchorNode,
            focusNode: prevFocusNode,
            anchorOffset: prevAnchorOffset,
            focusOffset: prevFocusOffset
          } = dom.getSelection(element) || {};
          this._ignoredInputTimer = win.setTimeout(() => {
            var _a, _b, _c;
            delete this._ignoredInputTimer;
            const {
              anchorNode,
              focusNode,
              anchorOffset,
              focusOffset
            } = dom.getSelection(element) || {};
            if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {
              (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);
              return;
            }
            selectionStart = anchorOffset || 0;
            selectionEnd = focusOffset || 0;
            textLength = ((_b = element.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;
            if (anchorNode && focusNode) {
              if (dom.nodeContains(element, anchorNode) && dom.nodeContains(element, focusNode)) {
                if (anchorNode !== element) {
                  let anchorFound = false;
                  const addOffsets = (node) => {
                    if (node === anchorNode) {
                      anchorFound = true;
                    } else if (node === focusNode) {
                      return true;
                    }
                    const nodeText = node.textContent;
                    if (nodeText && !dom.getFirstChild(node)) {
                      const len = nodeText.length;
                      if (anchorFound) {
                        if (focusNode !== anchorNode) {
                          selectionEnd += len;
                        }
                      } else {
                        selectionStart += len;
                        selectionEnd += len;
                      }
                    }
                    let stop = false;
                    for (let e = dom.getFirstChild(node); e && !stop; e = e.nextSibling) {
                      stop = addOffsets(e);
                    }
                    return stop;
                  };
                  addOffsets(element);
                }
              }
            }
            (_c = this._ignoredInputResolve) === null || _c === void 0 ? void 0 : _c.call(this, true);
          }, 0);
        });
      }
      if (asyncRet && !await asyncRet) {
        return true;
      }
      if (selectionStart !== selectionEnd) {
        return true;
      }
      if (selectionStart > 0 && (key === Keys.ArrowLeft || key === Keys.ArrowUp || key === Keys.Home)) {
        return true;
      }
      if (selectionStart < textLength && (key === Keys.ArrowRight || key === Keys.ArrowDown || key === Keys.End)) {
        return true;
      }
    }
    return false;
  }
};
function observeMutations(doc, tabster, updateTabsterByAttribute2, syncState) {
  if (typeof MutationObserver === "undefined") {
    return () => {
    };
  }
  const getWindow2 = tabster.getWindow;
  let elementByUId;
  const onMutation = (mutations) => {
    var _a, _b, _c, _d, _e;
    const removedNodes = /* @__PURE__ */ new Set();
    for (const mutation of mutations) {
      const target = mutation.target;
      const removed = mutation.removedNodes;
      const added = mutation.addedNodes;
      if (mutation.type === "attributes") {
        if (mutation.attributeName === TABSTER_ATTRIBUTE_NAME) {
          if (!removedNodes.has(target)) {
            updateTabsterByAttribute2(tabster, target);
          }
        }
      } else {
        for (let i = 0; i < removed.length; i++) {
          const removedNode = removed[i];
          removedNodes.add(removedNode);
          updateTabsterElements(removedNode, true);
          (_b = (_a = tabster._dummyObserver).domChanged) === null || _b === void 0 ? void 0 : _b.call(_a, target);
        }
        for (let i = 0; i < added.length; i++) {
          updateTabsterElements(added[i]);
          (_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 ? void 0 : _d.call(_c, target);
        }
      }
    }
    removedNodes.clear();
    (_e = tabster.modalizer) === null || _e === void 0 ? void 0 : _e.hiddenUpdate();
  };
  function updateTabsterElements(node, removed) {
    if (!elementByUId) {
      elementByUId = getInstanceContext(getWindow2).elementByUId;
    }
    processNode(node, removed);
    const walker = createElementTreeWalker(doc, node, (element) => {
      return processNode(element, removed);
    });
    if (walker) {
      while (walker.nextNode()) {
      }
    }
  }
  function processNode(element, removed) {
    var _a;
    if (!element.getAttribute) {
      return NodeFilter.FILTER_SKIP;
    }
    const uid = element.__tabsterElementUID;
    if (uid && elementByUId) {
      if (removed) {
        delete elementByUId[uid];
      } else {
        (_a = elementByUId[uid]) !== null && _a !== void 0 ? _a : elementByUId[uid] = new WeakHTMLElement(getWindow2, element);
      }
    }
    if (getTabsterOnElement(tabster, element) || element.hasAttribute(TABSTER_ATTRIBUTE_NAME)) {
      updateTabsterByAttribute2(tabster, element, removed);
    }
    return NodeFilter.FILTER_SKIP;
  }
  const observer = dom.createMutationObserver(onMutation);
  if (syncState) {
    updateTabsterElements(getWindow2().document.body);
  }
  observer.observe(doc, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeFilter: [TABSTER_ATTRIBUTE_NAME]
  });
  return () => {
    observer.disconnect();
  };
}
var _conditionCheckTimeout = 100;
var ObservedElementAPI = class extends Subscribable {
  constructor(tabster) {
    super();
    this._waiting = {};
    this._lastRequestFocusId = 0;
    this._observedById = {};
    this._observedByName = {};
    this._currentRequestTimestamp = 0;
    this._onFocus = (e) => {
      if (e) {
        const current = this._currentRequest;
        if (current) {
          const delta = Date.now() - this._currentRequestTimestamp;
          const settleTime = 300;
          if (delta >= settleTime) {
            delete this._currentRequest;
            current.cancel();
          }
        }
      }
    };
    this.onObservedElementUpdate = (element) => {
      var _a;
      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;
      const uid = getElementUId(this._win, element);
      let info = this._observedById[uid];
      if (observed && documentContains(element.ownerDocument, element)) {
        if (!info) {
          info = this._observedById[uid] = {
            element: new WeakHTMLElement(this._win, element)
          };
        }
        observed.names.sort();
        const observedNames = observed.names;
        const prevNames = info.prevNames;
        if (this._isObservedNamesUpdated(observedNames, prevNames)) {
          if (prevNames) {
            prevNames.forEach((prevName) => {
              const obn = this._observedByName[prevName];
              if (obn && obn[uid]) {
                if (Object.keys(obn).length > 1) {
                  delete obn[uid];
                } else {
                  delete this._observedByName[prevName];
                }
              }
            });
          }
          info.prevNames = observedNames;
        }
        observedNames.forEach((observedName) => {
          let obn = this._observedByName[observedName];
          if (!obn) {
            obn = this._observedByName[observedName] = {};
          }
          obn[uid] = info;
          this._waitConditional(observedName);
        });
      } else if (info) {
        const prevNames = info.prevNames;
        if (prevNames) {
          prevNames.forEach((prevName) => {
            const obn = this._observedByName[prevName];
            if (obn && obn[uid]) {
              if (Object.keys(obn).length > 1) {
                delete obn[uid];
              } else {
                delete this._observedByName[prevName];
              }
            }
          });
        }
        delete this._observedById[uid];
      }
    };
    this._tabster = tabster;
    this._win = tabster.getWindow;
    tabster.queueInit(() => {
      this._tabster.focusedElement.subscribe(this._onFocus);
    });
  }
  dispose() {
    this._tabster.focusedElement.unsubscribe(this._onFocus);
    for (const key of Object.keys(this._waiting)) {
      this._rejectWaiting(key);
    }
    this._observedById = {};
    this._observedByName = {};
  }
  _rejectWaiting(key, shouldResolve) {
    const w = this._waiting[key];
    if (w) {
      const win = this._win();
      if (w.timer) {
        win.clearTimeout(w.timer);
      }
      if (w.conditionTimer) {
        win.clearTimeout(w.conditionTimer);
      }
      if (!shouldResolve && w.reject) {
        w.reject();
      } else if (shouldResolve && w.resolve) {
        w.resolve(null);
      }
      delete this._waiting[key];
    }
  }
  _isObservedNamesUpdated(cur, prev) {
    if (!prev || cur.length !== prev.length) {
      return true;
    }
    for (let i = 0; i < cur.length; ++i) {
      if (cur[i] !== prev[i]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns existing element by observed name
   *
   * @param observedName An observed name
   * @param accessibility Optionally, return only if the element is accessible or focusable
   * @returns HTMLElement | null
   */
  getElement(observedName, accessibility) {
    const o = this._observedByName[observedName];
    if (o) {
      for (const uid of Object.keys(o)) {
        let el = o[uid].element.get() || null;
        if (el) {
          if (accessibility === ObservedElementAccessibilities.Accessible && !this._tabster.focusable.isAccessible(el) || accessibility === ObservedElementAccessibilities.Focusable && !this._tabster.focusable.isFocusable(el, true)) {
            el = null;
          }
        } else {
          delete o[uid];
          delete this._observedById[uid];
        }
        return el;
      }
    }
    return null;
  }
  /**
   * Waits for the element to appear in the DOM and returns it.
   *
   * @param observedName An observed name
   * @param timeout Wait no longer than this timeout
   * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it
   * @returns Promise<HTMLElement | null>
   */
  waitElement(observedName, timeout2, accessibility) {
    const el = this.getElement(observedName, accessibility);
    if (el) {
      return {
        result: getPromise(this._win).resolve(el),
        cancel: () => {
        },
        status: ObservedElementRequestStatuses.Succeeded
      };
    }
    let prefix;
    if (accessibility === ObservedElementAccessibilities.Accessible) {
      prefix = "a";
    } else if (accessibility === ObservedElementAccessibilities.Focusable) {
      prefix = "f";
    } else {
      prefix = "_";
    }
    const key = prefix + observedName;
    let w = this._waiting[key];
    if (w && w.request) {
      return w.request;
    }
    w = this._waiting[key] = {
      timer: this._win().setTimeout(() => {
        if (w.conditionTimer) {
          this._win().clearTimeout(w.conditionTimer);
        }
        delete this._waiting[key];
        if (w.request) {
          w.request.status = ObservedElementRequestStatuses.TimedOut;
        }
        if (w.resolve) {
          w.resolve(null);
        }
      }, timeout2)
    };
    const promise = new (getPromise(this._win))((resolve, reject) => {
      w.resolve = resolve;
      w.reject = reject;
    }).catch(() => {
      return null;
    });
    const request = {
      result: promise,
      cancel: () => {
        if (request.status === ObservedElementRequestStatuses.Waiting) {
          request.status = ObservedElementRequestStatuses.Canceled;
        }
        this._rejectWaiting(key, true);
      },
      status: ObservedElementRequestStatuses.Waiting
    };
    w.request = request;
    if (accessibility && this.getElement(observedName)) {
      this._waitConditional(observedName);
    }
    return request;
  }
  requestFocus(observedName, timeout2, options) {
    if (options === void 0) {
      options = {};
    }
    const requestId = ++this._lastRequestFocusId;
    const currentRequestFocus = this._currentRequest;
    if (currentRequestFocus) {
      currentRequestFocus.cancel();
    }
    const request = this.waitElement(observedName, timeout2, ObservedElementAccessibilities.Focusable);
    this._currentRequest = request;
    this._currentRequestTimestamp = Date.now();
    const ret = {
      result: request.result.then((element) => this._lastRequestFocusId === requestId && element ? this._tabster.focusedElement.focus(element, true, void 0, options.preventScroll) : false),
      cancel: () => {
        request.cancel();
      },
      status: request.status
    };
    request.result.finally(() => {
      if (this._currentRequest === request) {
        delete this._currentRequest;
      }
      ret.status = request.status;
    });
    return ret;
  }
  _waitConditional(observedName) {
    const waitingElementKey = "_" + observedName;
    const waitingAccessibleElementKey = "a" + observedName;
    const waitingFocusableElementKey = "f" + observedName;
    const waitingElement = this._waiting[waitingElementKey];
    const waitingAccessibleElement = this._waiting[waitingAccessibleElementKey];
    const waitingFocusableElement = this._waiting[waitingFocusableElementKey];
    const win = this._win();
    const resolve = (element, key, waiting, accessibility) => {
      var _a;
      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;
      if (!observed || !observed.names.includes(observedName)) {
        return;
      }
      if (waiting.timer) {
        win.clearTimeout(waiting.timer);
      }
      delete this._waiting[key];
      if (waiting.request) {
        waiting.request.status = ObservedElementRequestStatuses.Succeeded;
      }
      if (waiting.resolve) {
        waiting.resolve(element);
      }
      this.trigger(element, {
        names: [observedName],
        details: observed.details,
        accessibility
      });
    };
    if (waitingElement) {
      const element = this.getElement(observedName);
      if (element && documentContains(element.ownerDocument, element)) {
        resolve(element, waitingElementKey, waitingElement, ObservedElementAccessibilities.Any);
      }
    }
    if (waitingAccessibleElement && !waitingAccessibleElement.conditionTimer) {
      const resolveAccessible = () => {
        const element = this.getElement(observedName);
        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isAccessible(element)) {
          resolve(element, waitingAccessibleElementKey, waitingAccessibleElement, ObservedElementAccessibilities.Accessible);
        } else {
          waitingAccessibleElement.conditionTimer = win.setTimeout(resolveAccessible, _conditionCheckTimeout);
        }
      };
      resolveAccessible();
    }
    if (waitingFocusableElement && !waitingFocusableElement.conditionTimer) {
      const resolveFocusable = () => {
        const element = this.getElement(observedName);
        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isFocusable(element, true)) {
          resolve(element, waitingFocusableElementKey, waitingFocusableElement, ObservedElementAccessibilities.Focusable);
        } else {
          waitingFocusableElement.conditionTimer = win.setTimeout(resolveFocusable, _conditionCheckTimeout);
        }
      };
      resolveFocusable();
    }
  }
};
var UncontrolledAPI = class {
  constructor(isUncontrolledCompletely) {
    this._isUncontrolledCompletely = isUncontrolledCompletely;
  }
  isUncontrolledCompletely(element, completely) {
    var _a;
    const isUncontrolledCompletely = (_a = this._isUncontrolledCompletely) === null || _a === void 0 ? void 0 : _a.call(this, element, completely);
    return isUncontrolledCompletely === void 0 ? completely : isUncontrolledCompletely;
  }
};
var Restorer = class extends TabsterPart {
  constructor(tabster, element, props) {
    var _a;
    super(tabster, element, props);
    this._hasFocus = false;
    this._onFocusOut = (e) => {
      var _a2;
      const element2 = (_a2 = this._element) === null || _a2 === void 0 ? void 0 : _a2.get();
      if (element2 && e.relatedTarget === null) {
        element2.dispatchEvent(new RestorerRestoreFocusEvent());
      }
      if (element2 && !dom.nodeContains(element2, e.relatedTarget)) {
        this._hasFocus = false;
      }
    };
    this._onFocusIn = () => {
      this._hasFocus = true;
    };
    if (this._props.type === RestorerTypes.Source) {
      const element2 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
      element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("focusout", this._onFocusOut);
      element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("focusin", this._onFocusIn);
      this._hasFocus = dom.nodeContains(element2, element2 && dom.getActiveElement(element2.ownerDocument));
    }
  }
  dispose() {
    var _a;
    if (this._props.type === RestorerTypes.Source) {
      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
      element === null || element === void 0 ? void 0 : element.removeEventListener("focusout", this._onFocusOut);
      element === null || element === void 0 ? void 0 : element.removeEventListener("focusin", this._onFocusIn);
      if (this._hasFocus) {
        const doc = this._tabster.getWindow().document;
        doc.body.dispatchEvent(new RestorerRestoreFocusEvent());
      }
    }
  }
};
var History = class _History {
  constructor(getWindow2) {
    this._stack = [];
    this._getWindow = getWindow2;
  }
  /**
   * Push a weak element to the top of the history stack.
   * If the stack is full, the bottom weak element is removed.
   * If the element is already at the top of the stack, it is not duplicated.
   */
  push(element) {
    var _a;
    if (((_a = this._stack[this._stack.length - 1]) === null || _a === void 0 ? void 0 : _a.get()) === element) {
      return;
    }
    if (this._stack.length > _History.DEPTH) {
      this._stack.shift();
    }
    this._stack.push(new WeakHTMLElement(this._getWindow, element));
  }
  /**
   * Pop the first element from the history that satisfies the callback.
   * The history is searched from the top to the bottom (from the most recent to the least recent).
   *
   * If a weak reference to the element is broken,
   * or the element is no longer in the DOM,
   * the element is removed from the top of the stack while popping.
   *
   * If no matching element is found, undefined is returned.
   * If the stack is empty, undefined is returned.
   */
  pop(filter) {
    if (filter === void 0) {
      filter = () => true;
    }
    var _a;
    const doc = this._getWindow().document;
    for (let index = this._stack.length - 1; index >= 0; index--) {
      const maybeElement = (_a = this._stack.pop()) === null || _a === void 0 ? void 0 : _a.get();
      if (maybeElement && dom.nodeContains(doc.body, dom.getParentElement(maybeElement)) && filter(maybeElement)) {
        return maybeElement;
      }
    }
    return void 0;
  }
};
History.DEPTH = 10;
var RestorerAPI = class {
  constructor(tabster) {
    this._onRestoreFocus = (e) => {
      var _a, _b;
      this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);
      const source = e.composedPath()[0];
      if (source) {
        const sourceId = (_b = (_a = getTabsterOnElement(this._tabster, source)) === null || _a === void 0 ? void 0 : _a.restorer) === null || _b === void 0 ? void 0 : _b.getProps().id;
        this._focusedElementState.requestAsyncFocus(AsyncFocusSources.Restorer, () => this._restoreFocus(source, sourceId), 0);
      }
    };
    this._onFocusIn = (element) => {
      var _a;
      if (!element) {
        return;
      }
      const tabsterAttribute = getTabsterOnElement(this._tabster, element);
      if (((_a = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a === void 0 ? void 0 : _a.getProps().type) !== RestorerTypes.Target) {
        return;
      }
      this._history.push(element);
    };
    this._restoreFocus = (source, sourceId) => {
      var _a;
      const doc = this._getWindow().document;
      if (dom.getActiveElement(doc) !== doc.body) {
        return;
      }
      if (
        // clicking on any empty space focuses body - this is can be a false positive
        !this._keyboardNavState.isNavigatingWithKeyboard() && // Source no longer exists on DOM - always restore focus
        dom.nodeContains(doc.body, source)
      ) {
        return;
      }
      const getId = (element) => {
        var _a2, _b;
        const restorerProps = (_b = (_a2 = getTabsterOnElement(this._tabster, element)) === null || _a2 === void 0 ? void 0 : _a2.restorer) === null || _b === void 0 ? void 0 : _b.getProps();
        return restorerProps ? restorerProps.id : null;
      };
      (_a = this._history.pop((target) => sourceId === getId(target))) === null || _a === void 0 ? void 0 : _a.focus();
    };
    this._tabster = tabster;
    this._getWindow = tabster.getWindow;
    this._getWindow().addEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);
    this._history = new History(this._getWindow);
    this._keyboardNavState = tabster.keyboardNavigation;
    this._focusedElementState = tabster.focusedElement;
    this._focusedElementState.subscribe(this._onFocusIn);
  }
  dispose() {
    const win = this._getWindow();
    this._focusedElementState.unsubscribe(this._onFocusIn);
    this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);
    win.removeEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);
  }
  createRestorer(element, props) {
    const restorer = new Restorer(this._tabster, element, props);
    if (props.type === RestorerTypes.Target && dom.getActiveElement(element.ownerDocument) === element) {
      this._history.push(element);
    }
    return restorer;
  }
};
function getActiveElement(doc) {
  var _a;
  let activeElement = doc.activeElement;
  while ((_a = activeElement === null || activeElement === void 0 ? void 0 : activeElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.activeElement) {
    activeElement = activeElement.shadowRoot.activeElement;
  }
  return activeElement;
}
function nodeContains(node, otherNode) {
  var _a, _b;
  if (!node || !otherNode) {
    return false;
  }
  let currentNode = otherNode;
  while (currentNode) {
    if (currentNode === node) {
      return true;
    }
    if (typeof currentNode.assignedElements !== "function" && ((_a = currentNode.assignedSlot) === null || _a === void 0 ? void 0 : _a.parentNode)) {
      currentNode = (_b = currentNode.assignedSlot) === null || _b === void 0 ? void 0 : _b.parentNode;
    } else if (currentNode.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
      currentNode = currentNode.host;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return false;
}
function getParentNode(node) {
  if (!node) {
    return null;
  }
  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && node.host) {
    return node.host;
  }
  return node.parentNode;
}
function getParentElement(element) {
  for (let parentNode = getParentNode(element); parentNode; parentNode = getParentNode(parentNode)) {
    if (parentNode.nodeType === Node.ELEMENT_NODE) {
      return parentNode;
    }
  }
  return null;
}
function getFirstChild(node) {
  if (!node) {
    return null;
  }
  if (node.shadowRoot) {
    const child = getFirstChild(node.shadowRoot);
    if (child) {
      return child;
    }
  }
  return node.firstChild;
}
function getLastChild$1(node) {
  if (!node) {
    return null;
  }
  if (!node.lastChild && node.shadowRoot) {
    return getLastChild$1(node.shadowRoot);
  }
  return node.lastChild;
}
function getNextSibling(node) {
  return (node === null || node === void 0 ? void 0 : node.nextSibling) || null;
}
function getPreviousSibling(node) {
  var _a;
  if (!node) {
    return null;
  }
  let sibling = node.previousSibling;
  if (!sibling && ((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.shadowRoot)) {
    sibling = getLastChild$1(node.parentElement.shadowRoot);
  }
  return sibling;
}
function getFirstElementChild(element) {
  let child = getFirstChild(element);
  while (child && child.nodeType !== Node.ELEMENT_NODE) {
    child = getNextSibling(child);
  }
  return child;
}
function getLastElementChild(element) {
  let child = getLastChild$1(element);
  while (child && child.nodeType !== Node.ELEMENT_NODE) {
    child = getPreviousSibling(child);
  }
  return child;
}
function getNextElementSibling(element) {
  let sibling = getNextSibling(element);
  while (sibling && sibling.nodeType !== Node.ELEMENT_NODE) {
    sibling = getNextSibling(sibling);
  }
  return sibling;
}
function getPreviousElementSibling(element) {
  let sibling = getPreviousSibling(element);
  while (sibling && sibling.nodeType !== Node.ELEMENT_NODE) {
    sibling = getPreviousSibling(sibling);
  }
  return sibling;
}
function appendChild(parent2, child) {
  const shadowRoot = parent2.shadowRoot;
  return shadowRoot ? shadowRoot.appendChild(child) : parent2.appendChild(child);
}
function insertBefore(parent2, child, referenceChild) {
  const shadowRoot = parent2.shadowRoot;
  return shadowRoot ? shadowRoot.insertBefore(child, referenceChild) : parent2.insertBefore(child, referenceChild);
}
function getSelection(ref) {
  var _a;
  const win = (_a = ref.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  if (!win) {
    return null;
  }
  for (let el = ref; el; el = el.parentNode) {
    if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      const tmp = el;
      if (tmp.getSelection) {
        return tmp.getSelection() || null;
      }
      break;
    }
  }
  return win.getSelection() || null;
}
function getElementsByName(referenceElement, name) {
  for (let el = referenceElement; el; el = el.parentNode) {
    if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      return el.querySelectorAll(`[name=${name}]`);
    }
  }
  return referenceElement.ownerDocument.getElementsByName(name);
}
function getLastChild(container) {
  let lastChild = null;
  for (let i = getLastElementChild(container); i; i = getLastElementChild(i)) {
    lastChild = i;
  }
  return lastChild || void 0;
}
var ShadowTreeWalker = class {
  constructor(doc, root, whatToShow, filter) {
    this._walkerStack = [];
    this._currentSetFor = /* @__PURE__ */ new Set();
    this._acceptNode = (node) => {
      var _a;
      if (node.nodeType === Node.ELEMENT_NODE) {
        const shadowRoot2 = node.shadowRoot;
        if (shadowRoot2) {
          const walker = this._doc.createTreeWalker(shadowRoot2, this.whatToShow, {
            acceptNode: this._acceptNode
          });
          this._walkerStack.unshift(walker);
          return NodeFilter.FILTER_ACCEPT;
        } else {
          if (typeof this.filter === "function") {
            return this.filter(node);
          } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {
            return this.filter.acceptNode(node);
          } else if (this.filter === null) {
            return NodeFilter.FILTER_ACCEPT;
          }
        }
      }
      return NodeFilter.FILTER_SKIP;
    };
    this._doc = doc;
    this.root = root;
    this.filter = filter !== null && filter !== void 0 ? filter : null;
    this.whatToShow = whatToShow !== null && whatToShow !== void 0 ? whatToShow : NodeFilter.SHOW_ALL;
    this._currentNode = root;
    this._walkerStack.unshift(doc.createTreeWalker(root, whatToShow, this._acceptNode));
    const shadowRoot = root.shadowRoot;
    if (shadowRoot) {
      const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {
        acceptNode: this._acceptNode
      });
      this._walkerStack.unshift(walker);
    }
  }
  get currentNode() {
    return this._currentNode;
  }
  set currentNode(node) {
    if (!nodeContains(this.root, node)) {
      throw new Error("Cannot set currentNode to a node that is not contained by the root node.");
    }
    const walkers = [];
    let curNode = node;
    let currentWalkerCurrentNode = node;
    this._currentNode = node;
    while (curNode && curNode !== this.root) {
      if (curNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        const shadowRoot = curNode;
        const walker2 = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {
          acceptNode: this._acceptNode
        });
        walkers.push(walker2);
        walker2.currentNode = currentWalkerCurrentNode;
        this._currentSetFor.add(walker2);
        curNode = currentWalkerCurrentNode = shadowRoot.host;
      } else {
        curNode = curNode.parentNode;
      }
    }
    const walker = this._doc.createTreeWalker(this.root, this.whatToShow, {
      acceptNode: this._acceptNode
    });
    walkers.push(walker);
    walker.currentNode = currentWalkerCurrentNode;
    this._currentSetFor.add(walker);
    this._walkerStack = walkers;
  }
  firstChild() {
    if (true) {
      throw new Error("Method not implemented.");
    }
    return null;
  }
  lastChild() {
    if (true) {
      throw new Error("Method not implemented.");
    }
    return null;
  }
  nextNode() {
    var _a;
    const nextNode = this._walkerStack[0].nextNode();
    if (nextNode) {
      const shadowRoot = nextNode.shadowRoot;
      if (shadowRoot) {
        let nodeResult;
        if (typeof this.filter === "function") {
          nodeResult = this.filter(nextNode);
        } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {
          nodeResult = this.filter.acceptNode(nextNode);
        }
        if (nodeResult === NodeFilter.FILTER_ACCEPT) {
          return nextNode;
        }
        return this.nextNode();
      }
      return nextNode;
    } else {
      if (this._walkerStack.length > 1) {
        this._walkerStack.shift();
        return this.nextNode();
      } else {
        return null;
      }
    }
  }
  previousNode() {
    var _a, _b;
    const currentWalker = this._walkerStack[0];
    if (currentWalker.currentNode === currentWalker.root) {
      if (this._currentSetFor.has(currentWalker)) {
        this._currentSetFor.delete(currentWalker);
        if (this._walkerStack.length > 1) {
          this._walkerStack.shift();
          return this.previousNode();
        } else {
          return null;
        }
      }
      const lastChild = getLastChild(currentWalker.root);
      if (lastChild) {
        currentWalker.currentNode = lastChild;
        let nodeResult;
        if (typeof this.filter === "function") {
          nodeResult = this.filter(lastChild);
        } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {
          nodeResult = this.filter.acceptNode(lastChild);
        }
        if (nodeResult === NodeFilter.FILTER_ACCEPT) {
          return lastChild;
        }
      }
    }
    const previousNode = currentWalker.previousNode();
    if (previousNode) {
      const shadowRoot = previousNode.shadowRoot;
      if (shadowRoot) {
        let nodeResult;
        if (typeof this.filter === "function") {
          nodeResult = this.filter(previousNode);
        } else if ((_b = this.filter) === null || _b === void 0 ? void 0 : _b.acceptNode) {
          nodeResult = this.filter.acceptNode(previousNode);
        }
        if (nodeResult === NodeFilter.FILTER_ACCEPT) {
          return previousNode;
        }
        return this.previousNode();
      }
      return previousNode;
    } else {
      if (this._walkerStack.length > 1) {
        this._walkerStack.shift();
        return this.previousNode();
      } else {
        return null;
      }
    }
  }
  nextSibling() {
    if (true) {
      throw new Error("Method not implemented.");
    }
    return null;
  }
  previousSibling() {
    if (true) {
      throw new Error("Method not implemented.");
    }
    return null;
  }
  parentNode() {
    if (true) {
      throw new Error("Method not implemented.");
    }
    return null;
  }
};
function createShadowTreeWalker(doc, root, whatToShow, filter) {
  return new ShadowTreeWalker(doc, root, whatToShow, filter);
}
var ShadowMutationObserver = class _ShadowMutationObserver {
  static _overrideAttachShadow(win) {
    const origAttachShadow = win.Element.prototype.attachShadow;
    if (origAttachShadow.__origAttachShadow) {
      return;
    }
    Element.prototype.attachShadow = function(options) {
      const shadowRoot = origAttachShadow.call(this, options);
      for (const shadowObserver of _ShadowMutationObserver._shadowObservers) {
        shadowObserver._addSubObserver(shadowRoot);
      }
      return shadowRoot;
    };
    Element.prototype.attachShadow.__origAttachShadow = origAttachShadow;
  }
  constructor(callback) {
    this._isObserving = false;
    this._callbackWrapper = (mutations, observer) => {
      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          const removed = mutation.removedNodes;
          const added = mutation.addedNodes;
          for (let i = 0; i < removed.length; i++) {
            this._walkShadows(removed[i], true);
          }
          for (let i = 0; i < added.length; i++) {
            this._walkShadows(added[i]);
          }
        }
      }
      this._callback(mutations, observer);
    };
    this._callback = callback;
    this._observer = new MutationObserver(this._callbackWrapper);
    this._subObservers = /* @__PURE__ */ new Map();
  }
  _addSubObserver(shadowRoot) {
    if (!this._options || !this._callback || this._subObservers.has(shadowRoot)) {
      return;
    }
    if (this._options.subtree && nodeContains(this._root, shadowRoot)) {
      const subObserver = new MutationObserver(this._callbackWrapper);
      this._subObservers.set(shadowRoot, subObserver);
      if (this._isObserving) {
        subObserver.observe(shadowRoot, this._options);
      }
      this._walkShadows(shadowRoot);
    }
  }
  disconnect() {
    this._isObserving = false;
    delete this._options;
    _ShadowMutationObserver._shadowObservers.delete(this);
    for (const subObserver of this._subObservers.values()) {
      subObserver.disconnect();
    }
    this._subObservers.clear();
    this._observer.disconnect();
  }
  observe(target, options) {
    const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;
    const win = doc === null || doc === void 0 ? void 0 : doc.defaultView;
    if (!doc || !win) {
      return;
    }
    _ShadowMutationObserver._overrideAttachShadow(win);
    _ShadowMutationObserver._shadowObservers.add(this);
    this._root = target;
    this._options = options;
    this._isObserving = true;
    this._observer.observe(target, options);
    this._walkShadows(target);
  }
  _walkShadows(target, remove) {
    const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;
    if (!doc) {
      return;
    }
    if (target === doc) {
      target = doc.body;
    } else {
      const shadowRoot = target.shadowRoot;
      if (shadowRoot) {
        this._addSubObserver(shadowRoot);
        return;
      }
    }
    const walker = doc.createTreeWalker(target, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (remove) {
            const subObserver = this._subObservers.get(node);
            if (subObserver) {
              subObserver.disconnect();
              this._subObservers.delete(node);
            }
          } else {
            const shadowRoot = node.shadowRoot;
            if (shadowRoot) {
              this._addSubObserver(shadowRoot);
            }
          }
        }
        return NodeFilter.FILTER_SKIP;
      }
    });
    walker.nextNode();
  }
  takeRecords() {
    const records = this._observer.takeRecords();
    for (const subObserver of this._subObservers.values()) {
      records.push(...subObserver.takeRecords());
    }
    return records;
  }
};
ShadowMutationObserver._shadowObservers = /* @__PURE__ */ new Set();
function createShadowMutationObserver(callback) {
  return new ShadowMutationObserver(callback);
}
function shadowQuerySelector(node, selector, all) {
  const elements = [];
  walk(node, selector);
  return elements;
  function walk(from, selector2) {
    let el = null;
    const walker = document.createTreeWalker(from, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (n) => {
        if (n.nodeType === Node.ELEMENT_NODE) {
          if (n.matches(selector2)) {
            el = n;
            elements.push(el);
            return all ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
          }
          const shadowRoot = n.shadowRoot;
          if (shadowRoot) {
            walk(shadowRoot, selector2);
            return !all && elements.length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        }
        return NodeFilter.FILTER_SKIP;
      }
    });
    walker.nextNode();
  }
}
function querySelectorAll(node, selector) {
  return shadowQuerySelector(node, selector, true);
}
function querySelector(node, selector) {
  return shadowQuerySelector(node, selector, false)[0] || null;
}
function getElementById(doc, id) {
  return querySelector(doc, "#" + id);
}
var shadowDOMAPI = Object.freeze({
  __proto__: null,
  appendChild,
  createMutationObserver: createShadowMutationObserver,
  createTreeWalker: createShadowTreeWalker,
  getActiveElement,
  getElementById,
  getElementsByName,
  getFirstChild,
  getFirstElementChild,
  getLastChild: getLastChild$1,
  getLastElementChild,
  getNextElementSibling,
  getNextSibling,
  getParentElement,
  getParentNode,
  getPreviousElementSibling,
  getPreviousSibling,
  getSelection,
  insertBefore,
  nodeContains,
  querySelector,
  querySelectorAll
});
var Tabster = class {
  constructor(tabster) {
    this.keyboardNavigation = tabster.keyboardNavigation;
    this.focusedElement = tabster.focusedElement;
    this.focusable = tabster.focusable;
    this.root = tabster.root;
    this.uncontrolled = tabster.uncontrolled;
    this.core = tabster;
  }
};
var TabsterCore = class {
  constructor(win, props) {
    var _a, _b;
    this._forgetMemorizedElements = [];
    this._wrappers = /* @__PURE__ */ new Set();
    this._initQueue = [];
    this._version = "8.5.6";
    this._noop = false;
    this.getWindow = () => {
      if (!this._win) {
        throw new Error("Using disposed Tabster.");
      }
      return this._win;
    };
    this._storage = createWeakMap(win);
    this._win = win;
    const getWindow2 = this.getWindow;
    if (props === null || props === void 0 ? void 0 : props.DOMAPI) {
      setDOMAPI({
        ...props.DOMAPI
      });
    }
    this.keyboardNavigation = new KeyboardNavigationState(getWindow2);
    this.focusedElement = new FocusedElementState(this, getWindow2);
    this.focusable = new FocusableAPI(this);
    this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);
    this.uncontrolled = new UncontrolledAPI(
      // TODO: Remove checkUncontrolledTrappingFocus in the next major version.
      (props === null || props === void 0 ? void 0 : props.checkUncontrolledCompletely) || (props === null || props === void 0 ? void 0 : props.checkUncontrolledTrappingFocus)
    );
    this.controlTab = (_a = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a !== void 0 ? _a : true;
    this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);
    this._dummyObserver = new DummyInputObserver(getWindow2);
    this.getParent = (_b = props === null || props === void 0 ? void 0 : props.getParent) !== null && _b !== void 0 ? _b : dom.getParentNode;
    this.internal = {
      stopObserver: () => {
        if (this._unobserve) {
          this._unobserve();
          delete this._unobserve;
        }
      },
      resumeObserver: (syncState) => {
        if (!this._unobserve) {
          const doc = getWindow2().document;
          this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);
        }
      }
    };
    startFakeWeakRefsCleanup(getWindow2);
    this.queueInit(() => {
      this.internal.resumeObserver(true);
    });
  }
  /**
   * Merges external props with the current props. Not all
   * props can/should be mergeable, so let's add more as we move on.
   * @param props Tabster props
   */
  _mergeProps(props) {
    var _a;
    if (!props) {
      return;
    }
    this.getParent = (_a = props.getParent) !== null && _a !== void 0 ? _a : this.getParent;
  }
  createTabster(noRefCount, props) {
    const wrapper = new Tabster(this);
    if (!noRefCount) {
      this._wrappers.add(wrapper);
    }
    this._mergeProps(props);
    return wrapper;
  }
  disposeTabster(wrapper, allInstances) {
    if (allInstances) {
      this._wrappers.clear();
    } else {
      this._wrappers.delete(wrapper);
    }
    if (this._wrappers.size === 0) {
      this.dispose();
    }
  }
  dispose() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.internal.stopObserver();
    const win = this._win;
    win === null || win === void 0 ? void 0 : win.clearTimeout(this._initTimer);
    delete this._initTimer;
    this._initQueue = [];
    this._forgetMemorizedElements = [];
    if (win && this._forgetMemorizedTimer) {
      win.clearTimeout(this._forgetMemorizedTimer);
      delete this._forgetMemorizedTimer;
    }
    (_a = this.outline) === null || _a === void 0 ? void 0 : _a.dispose();
    (_b = this.crossOrigin) === null || _b === void 0 ? void 0 : _b.dispose();
    (_c = this.deloser) === null || _c === void 0 ? void 0 : _c.dispose();
    (_d = this.groupper) === null || _d === void 0 ? void 0 : _d.dispose();
    (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();
    (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();
    (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();
    (_h = this.restorer) === null || _h === void 0 ? void 0 : _h.dispose();
    this.keyboardNavigation.dispose();
    this.focusable.dispose();
    this.focusedElement.dispose();
    this.root.dispose();
    this._dummyObserver.dispose();
    stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);
    clearElementCache(this.getWindow);
    this._storage = /* @__PURE__ */ new WeakMap();
    this._wrappers.clear();
    if (win) {
      disposeInstanceContext(win);
      delete win.__tabsterInstance;
      delete this._win;
    }
  }
  storageEntry(element, addremove) {
    const storage = this._storage;
    let entry = storage.get(element);
    if (entry) {
      if (addremove === false && Object.keys(entry).length === 0) {
        storage.delete(element);
      }
    } else if (addremove === true) {
      entry = {};
      storage.set(element, entry);
    }
    return entry;
  }
  forceCleanup() {
    if (!this._win) {
      return;
    }
    this._forgetMemorizedElements.push(this._win.document.body);
    if (this._forgetMemorizedTimer) {
      return;
    }
    this._forgetMemorizedTimer = this._win.setTimeout(() => {
      delete this._forgetMemorizedTimer;
      for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {
        clearElementCache(this.getWindow, el);
        FocusedElementState.forgetMemorized(this.focusedElement, el);
      }
    }, 0);
    cleanupFakeWeakRefs(this.getWindow, true);
  }
  queueInit(callback) {
    var _a;
    if (!this._win) {
      return;
    }
    this._initQueue.push(callback);
    if (!this._initTimer) {
      this._initTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.setTimeout(() => {
        delete this._initTimer;
        this.drainInitQueue();
      }, 0);
    }
  }
  drainInitQueue() {
    if (!this._win) {
      return;
    }
    const queue = this._initQueue;
    this._initQueue = [];
    queue.forEach((callback) => callback());
  }
};
function createTabster(win, props) {
  let tabster = getCurrentTabster(win);
  if (tabster) {
    return tabster.createTabster(false, props);
  }
  tabster = new TabsterCore(win, props);
  win.__tabsterInstance = tabster;
  return tabster.createTabster();
}
function getGroupper(tabster) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.groupper) {
    tabsterCore.groupper = new GroupperAPI(tabsterCore, tabsterCore.getWindow);
  }
  return tabsterCore.groupper;
}
function getMover(tabster) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.mover) {
    tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);
  }
  return tabsterCore.mover;
}
function getModalizer(tabster, alwaysAccessibleSelector, accessibleCheck) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.modalizer) {
    tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector, accessibleCheck);
  }
  return tabsterCore.modalizer;
}
function getObservedElement(tabster) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.observedElement) {
    tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);
  }
  return tabsterCore.observedElement;
}
function getRestorer(tabster) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.restorer) {
    tabsterCore.restorer = new RestorerAPI(tabsterCore);
  }
  return tabsterCore.restorer;
}
function disposeTabster(tabster, allInstances) {
  tabster.core.disposeTabster(tabster, allInstances);
}
function getCurrentTabster(win) {
  return win.__tabsterInstance;
}
var Types = Object.freeze({
  __proto__: null
});
var EventsTypes = Object.freeze({
  __proto__: null
});

// node_modules/@fluentui/react-tabster/lib/hooks/useTabster.js
var React41 = __toESM(require_react());
var DEFAULT_FACTORY = (tabster) => {
  return tabster;
};
function createTabsterWithConfig(targetDocument) {
  const defaultView = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) || void 0;
  const shadowDOMAPI2 = defaultView === null || defaultView === void 0 ? void 0 : defaultView.__tabsterShadowDOMAPI;
  if (defaultView) {
    return createTabster(defaultView, {
      autoRoot: {},
      controlTab: false,
      getParent,
      // The non-undefined return value of checkUncontrolledCompletely() dominates the value that the element might
      // have in its `uncontrolled: { completely: true }` part of the tabster attribute. We must make sure to return
      // undefined if we want the value from tabster attribute to be respected.
      checkUncontrolledCompletely: (element) => {
        var _element_firstElementChild;
        return ((_element_firstElementChild = element.firstElementChild) === null || _element_firstElementChild === void 0 ? void 0 : _element_firstElementChild.hasAttribute("data-is-focus-trap-zone-bumper")) === true || void 0;
      },
      DOMAPI: shadowDOMAPI2
    });
  }
}
function useTabster(factory = DEFAULT_FACTORY) {
  const { targetDocument } = useFluent();
  const factoryResultRef = React41.useRef(null);
  useIsomorphicLayoutEffect(() => {
    const tabster = createTabsterWithConfig(targetDocument);
    if (tabster) {
      factoryResultRef.current = factory(tabster);
      return () => {
        disposeTabster(tabster);
        factoryResultRef.current = null;
      };
    }
  }, [
    targetDocument,
    factory
  ]);
  if (true) {
    const previousFactory = usePrevious(factory);
    if (previousFactory !== null && previousFactory !== factory) {
      throw new Error([
        "@fluentui/react-tabster: ",
        "The factory function passed to useTabster has changed. This should not ever happen."
      ].join("\n"));
    }
  }
  return factoryResultRef;
}

// node_modules/@fluentui/react-tabster/lib/hooks/useTabsterAttributes.js
var React42 = __toESM(require_react());
var useTabsterAttributes = (props) => {
  useTabster();
  const strAttr = getTabsterAttribute(props, true);
  return React42.useMemo(() => ({
    [TABSTER_ATTRIBUTE_NAME]: strAttr
  }), [
    strAttr
  ]);
};

// node_modules/@fluentui/react-tabster/lib/hooks/useArrowNavigationGroup.js
var useArrowNavigationGroup = (options = {}) => {
  const {
    circular,
    axis,
    memorizeCurrent = true,
    tabbable,
    ignoreDefaultKeydown,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_hasDefault
  } = options;
  useTabster(getMover);
  return useTabsterAttributes({
    mover: {
      cyclic: !!circular,
      direction: axisToMoverDirection(axis !== null && axis !== void 0 ? axis : "vertical"),
      memorizeCurrent,
      tabbable,
      hasDefault: unstable_hasDefault
    },
    ...ignoreDefaultKeydown && {
      focusable: {
        ignoreKeydown: ignoreDefaultKeydown
      }
    }
  });
};
function axisToMoverDirection(axis) {
  switch (axis) {
    case "horizontal":
      return MoverDirections.Horizontal;
    case "grid":
      return MoverDirections.Grid;
    case "grid-linear":
      return MoverDirections.GridLinear;
    case "both":
      return MoverDirections.Both;
    case "vertical":
    default:
      return MoverDirections.Vertical;
  }
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusableGroup.js
var useFocusableGroup = (options) => {
  useTabster(getGroupper);
  return useTabsterAttributes({
    groupper: {
      tabbability: getTabbability(options === null || options === void 0 ? void 0 : options.tabBehavior)
    },
    focusable: {
      ignoreKeydown: options === null || options === void 0 ? void 0 : options.ignoreDefaultKeydown
    }
  });
};
var getTabbability = (tabBehavior) => {
  switch (tabBehavior) {
    case "unlimited":
      return GroupperTabbabilities.Unlimited;
    case "limited":
      return GroupperTabbabilities.Limited;
    case "limited-trap-focus":
      return GroupperTabbabilities.LimitedTrapFocus;
    default:
      return void 0;
  }
};

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusFinders.js
var React43 = __toESM(require_react());
var useFocusFinders = () => {
  const tabsterRef = useTabster();
  const { targetDocument } = useFluent();
  const findAllFocusable = React43.useCallback((container, acceptCondition) => {
    var _tabsterRef_current;
    return container && ((_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findAll({
      container,
      acceptCondition
    })) || [];
  }, [
    tabsterRef
  ]);
  const findFirstFocusable = React43.useCallback((container) => {
    var _tabsterRef_current;
    return container && ((_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findFirst({
      container
    }));
  }, [
    tabsterRef
  ]);
  const findLastFocusable = React43.useCallback((container) => {
    var _tabsterRef_current;
    return container && ((_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findLast({
      container
    }));
  }, [
    tabsterRef
  ]);
  const findNextFocusable = React43.useCallback((currentElement, options = {}) => {
    if (!tabsterRef.current || !targetDocument || !currentElement) {
      return null;
    }
    const { container = targetDocument.body } = options;
    return tabsterRef.current.focusable.findNext({
      currentElement,
      container
    });
  }, [
    tabsterRef,
    targetDocument
  ]);
  const findPrevFocusable = React43.useCallback((currentElement, options = {}) => {
    if (!tabsterRef.current || !targetDocument || !currentElement) {
      return null;
    }
    const { container = targetDocument.body } = options;
    return tabsterRef.current.focusable.findPrev({
      currentElement,
      container
    });
  }, [
    tabsterRef,
    targetDocument
  ]);
  return {
    findAllFocusable,
    findFirstFocusable,
    findLastFocusable,
    findNextFocusable,
    findPrevFocusable
  };
};

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusVisible.js
var React44 = __toESM(require_react());

// node_modules/@fluentui/react-tabster/lib/focus/constants.js
var KEYBOARD_NAV_ATTRIBUTE = "data-keyboard-nav";
var KEYBOARD_NAV_SELECTOR = `:global([${KEYBOARD_NAV_ATTRIBUTE}])`;
var FOCUS_VISIBLE_ATTR = "data-fui-focus-visible";
var FOCUS_WITHIN_ATTR = "data-fui-focus-within";
var defaultOptions = {
  style: {},
  selector: "focus",
  customizeSelector: (selector) => selector
};

// node_modules/@fluentui/react-tabster/lib/focus/focusVisiblePolyfill.js
function applyFocusVisiblePolyfill(scope, targetWindow) {
  if (alreadyInScope(scope)) {
    return () => void 0;
  }
  const state = {
    current: void 0
  };
  const keyborg = createKeyborg(targetWindow);
  function registerElementIfNavigating(el) {
    if (keyborg.isNavigatingWithKeyboard() && isHTMLElement(el)) {
      state.current = el;
      el.setAttribute(FOCUS_VISIBLE_ATTR, "");
    }
  }
  function disposeCurrentElement() {
    if (state.current) {
      state.current.removeAttribute(FOCUS_VISIBLE_ATTR);
      state.current = void 0;
    }
  }
  keyborg.subscribe((isNavigatingWithKeyboard) => {
    if (!isNavigatingWithKeyboard) {
      disposeCurrentElement();
    } else {
      registerElementIfNavigating(targetWindow.document.activeElement);
    }
  });
  const keyborgListener = (e) => {
    disposeCurrentElement();
    const target = e.composedPath()[0];
    registerElementIfNavigating(target);
  };
  const blurListener = (e) => {
    if (!e.relatedTarget || isHTMLElement(e.relatedTarget) && !scope.contains(e.relatedTarget)) {
      disposeCurrentElement();
    }
  };
  scope.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
  scope.addEventListener("focusout", blurListener);
  scope.focusVisible = true;
  if (scope.contains(targetWindow.document.activeElement)) {
    registerElementIfNavigating(targetWindow.document.activeElement);
  }
  return () => {
    disposeCurrentElement();
    scope.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
    scope.removeEventListener("focusout", blurListener);
    scope.focusVisible = void 0;
    disposeKeyborg(keyborg);
  };
}
function alreadyInScope(el) {
  if (!el) {
    return false;
  }
  if (el.focusVisible) {
    return true;
  }
  return alreadyInScope(el === null || el === void 0 ? void 0 : el.parentElement);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusVisible.js
function useFocusVisible(options = {}) {
  const contextValue = useFluent();
  const scopeRef = React44.useRef(null);
  var _options_targetDocument;
  const targetDocument = (_options_targetDocument = options.targetDocument) !== null && _options_targetDocument !== void 0 ? _options_targetDocument : contextValue.targetDocument;
  React44.useEffect(() => {
    if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && scopeRef.current) {
      return applyFocusVisiblePolyfill(scopeRef.current, targetDocument.defaultView);
    }
  }, [
    scopeRef,
    targetDocument
  ]);
  return scopeRef;
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusWithin.js
var React45 = __toESM(require_react());

// node_modules/@fluentui/react-tabster/lib/focus/focusWithinPolyfill.js
function applyFocusWithinPolyfill(element, win) {
  const keyborg = createKeyborg(win);
  keyborg.subscribe((isNavigatingWithKeyboard) => {
    if (!isNavigatingWithKeyboard) {
      removeFocusWithinClass(element);
    }
  });
  const keyborgListener = (e) => {
    if (keyborg.isNavigatingWithKeyboard() && isHTMLElement2(e.target)) {
      applyFocusWithinClass(element);
    }
  };
  const blurListener = (e) => {
    if (!e.relatedTarget || isHTMLElement2(e.relatedTarget) && !element.contains(e.relatedTarget)) {
      removeFocusWithinClass(element);
    }
  };
  element.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
  element.addEventListener("focusout", blurListener);
  return () => {
    element.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
    element.removeEventListener("focusout", blurListener);
    disposeKeyborg(keyborg);
  };
}
function applyFocusWithinClass(el) {
  el.setAttribute(FOCUS_WITHIN_ATTR, "");
}
function removeFocusWithinClass(el) {
  el.removeAttribute(FOCUS_WITHIN_ATTR);
}
function isHTMLElement2(target) {
  if (!target) {
    return false;
  }
  return Boolean(target && typeof target === "object" && "classList" in target && "contains" in target);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusWithin.js
function useFocusWithin() {
  const { targetDocument } = useFluent();
  const elementRef = React45.useRef(null);
  React45.useEffect(() => {
    if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && elementRef.current) {
      return applyFocusWithinPolyfill(elementRef.current, targetDocument.defaultView);
    }
  }, [
    elementRef,
    targetDocument
  ]);
  return elementRef;
}

// node_modules/@fluentui/react-tabster/lib/hooks/useKeyboardNavAttribute.js
var React46 = __toESM(require_react());
function useKeyboardNavAttribute() {
  const { targetDocument } = useFluent();
  const keyborg = React46.useMemo(() => targetDocument && createKeyborg(targetDocument.defaultView), [
    targetDocument
  ]);
  const ref = React46.useRef(null);
  React46.useEffect(() => {
    if (keyborg) {
      setBooleanAttribute(ref, KEYBOARD_NAV_ATTRIBUTE, keyborg.isNavigatingWithKeyboard());
      const cb = (next) => {
        setBooleanAttribute(ref, KEYBOARD_NAV_ATTRIBUTE, next);
      };
      keyborg.subscribe(cb);
      return () => keyborg.unsubscribe(cb);
    }
  }, [
    keyborg
  ]);
  return ref;
}
function setBooleanAttribute(elementRef, attribute, value) {
  if (!elementRef.current) {
    return;
  }
  if (value) {
    elementRef.current.setAttribute(attribute, "");
  } else {
    elementRef.current.removeAttribute(attribute);
  }
}

// node_modules/@fluentui/react-tabster/lib/hooks/useOnKeyboardNavigationChange.js
var React48 = __toESM(require_react());

// node_modules/@fluentui/react-tabster/lib/hooks/useKeyborgRef.js
var React47 = __toESM(require_react());
function useKeyborgRef() {
  const { targetDocument } = useFluent();
  const keyborgRef = React47.useRef(null);
  React47.useEffect(() => {
    const targetWindow = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
    if (targetWindow) {
      const keyborg = createKeyborg(targetWindow);
      keyborgRef.current = keyborg;
      return () => {
        disposeKeyborg(keyborg);
        keyborgRef.current = null;
      };
    }
  }, [
    targetDocument
  ]);
  return keyborgRef;
}

// node_modules/@fluentui/react-tabster/lib/hooks/useOnKeyboardNavigationChange.js
function useOnKeyboardNavigationChange(callback) {
  const keyborgRef = useKeyborgRef();
  const eventCallback = useEventCallback(callback);
  React48.useEffect(() => {
    const keyborg = keyborgRef.current;
    if (keyborg) {
      const cb = (next) => {
        eventCallback(next);
      };
      keyborg.subscribe(cb);
      cb(keyborg.isNavigatingWithKeyboard());
      return () => {
        keyborg.unsubscribe(cb);
      };
    }
  }, [
    keyborgRef,
    eventCallback
  ]);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useModalAttributes.js
var DangerousNeverHiddenAttribute = "data-tabster-never-hide";
var DangerousNeverHiddenPropObject = {
  [DangerousNeverHiddenAttribute]: ""
};
function useDangerousNeverHidden_unstable() {
  return DangerousNeverHiddenPropObject;
}
var tabsterAccessibleCheck = (element) => {
  return element.hasAttribute(DangerousNeverHiddenAttribute);
};
function initTabsterModules(tabster) {
  getModalizer(tabster, void 0, tabsterAccessibleCheck);
  getRestorer(tabster);
}
var useModalAttributes = (options = {}) => {
  const { trapFocus, alwaysFocusable, legacyTrapFocus } = options;
  useTabster(initTabsterModules);
  const id = useId2("modal-", options.id);
  const modalAttributes = useTabsterAttributes({
    restorer: {
      type: RestorerTypes.Source
    },
    ...trapFocus && {
      modalizer: {
        id,
        isOthersAccessible: !trapFocus,
        isAlwaysAccessible: alwaysFocusable,
        isTrapped: legacyTrapFocus && trapFocus
      }
    }
  });
  const triggerAttributes = useTabsterAttributes({
    restorer: {
      type: RestorerTypes.Target
    }
  });
  return {
    modalAttributes,
    triggerAttributes
  };
};

// node_modules/@fluentui/react-tabster/lib/hooks/useObservedElement.js
function useObservedElement(name) {
  useTabster(getObservedElement);
  return useTabsterAttributes({
    observed: {
      names: Array.isArray(name) ? name : [
        name
      ]
    }
  });
}

// node_modules/@fluentui/react-tabster/lib/hooks/useMergeTabsterAttributes.js
var React49 = __toESM(require_react());
var useMergedTabsterAttributes_unstable = (...attributes) => {
  "use no memo";
  const stringAttributes = attributes.reduce((acc, curr) => {
    if (curr === null || curr === void 0 ? void 0 : curr[TABSTER_ATTRIBUTE_NAME]) {
      acc.push(curr[TABSTER_ATTRIBUTE_NAME]);
    }
    return acc;
  }, []);
  if (true) {
    useWarnIfUnstableAttributes(stringAttributes);
  }
  return React49.useMemo(
    () => ({
      [TABSTER_ATTRIBUTE_NAME]: stringAttributes.length > 0 ? stringAttributes.reduce(mergeJSONStrings) : void 0
    }),
    // disable exhaustive-deps because we want to memoize the result of the reduction
    // this is safe because the collection of attributes is not expected to change at runtime
    // eslint-disable-next-line react-hooks/exhaustive-deps
    stringAttributes
  );
};
var mergeJSONStrings = (a, b) => JSON.stringify(Object.assign(safelyParseJSON(a), safelyParseJSON(b)));
var safelyParseJSON = (json) => {
  try {
    return JSON.parse(json);
  } catch {
    return {};
  }
};
var useWarnIfUnstableAttributes = (attributes) => {
  "use no memo";
  const initialAttributesRef = React49.useRef(attributes);
  let isStable = initialAttributesRef.current.length === attributes.length;
  if (initialAttributesRef.current !== attributes && isStable) {
    for (let i = 0; i < attributes.length; i++) {
      if (initialAttributesRef.current[i] !== attributes[i]) {
        isStable = false;
        break;
      }
    }
  }
  React49.useEffect(() => {
    if (!isStable) {
      const error = new Error();
      console.warn(
        /** #__DE-INDENT__ */
        `
        @fluentui/react-tabster [useMergedTabsterAttributes]:
        The attributes passed to the hook changed at runtime.
        This might lead to unexpected behavior, please ensure that the attributes are stable.
        ${error.stack}
      `
      );
    }
  }, [
    isStable
  ]);
};

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusObserved.js
var React50 = __toESM(require_react());
function useFocusObserved(name, options = {}) {
  const { timeout: timeout2 = 1e3 } = options;
  const observedAPIRef = useTabster(getObservedElement);
  return React50.useCallback(() => {
    const observerAPI = observedAPIRef.current;
    if (observerAPI) {
      return observerAPI.requestFocus(name, timeout2);
    }
    return {
      result: Promise.resolve(false),
      cancel: () => null
    };
  }, [
    observedAPIRef,
    name,
    timeout2
  ]);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useRestoreFocus.js
function useRestoreFocusTarget() {
  useTabster(getRestorer);
  return getTabsterAttribute({
    restorer: {
      type: RestorerTypes.Target
    }
  });
}
function useRestoreFocusSource() {
  useTabster(getRestorer);
  return getTabsterAttribute({
    restorer: {
      type: RestorerTypes.Source
    }
  });
}

// node_modules/@fluentui/react-tabster/lib/hooks/useUncontrolledFocus.js
function useUncontrolledFocus() {
  useTabster();
  return getTabsterAttribute({
    uncontrolled: {}
  });
}

// node_modules/@fluentui/react-tabster/lib/hooks/useIsNavigatingWithKeyboard.js
var React51 = __toESM(require_react());
function useIsNavigatingWithKeyboard() {
  const keyborgRef = useKeyborgRef();
  return React51.useCallback(() => {
    var _keyborgRef_current;
    var _keyborgRef_current_isNavigatingWithKeyboard;
    return (_keyborgRef_current_isNavigatingWithKeyboard = (_keyborgRef_current = keyborgRef.current) === null || _keyborgRef_current === void 0 ? void 0 : _keyborgRef_current.isNavigatingWithKeyboard()) !== null && _keyborgRef_current_isNavigatingWithKeyboard !== void 0 ? _keyborgRef_current_isNavigatingWithKeyboard : false;
  }, [
    keyborgRef
  ]);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useSetKeyboardNavigation.js
var React52 = __toESM(require_react());
function useSetKeyboardNavigation() {
  const keyborgRef = useKeyborgRef();
  return React52.useCallback((isNavigatingWithKeyboard) => {
    var _keyborgRef_current;
    (_keyborgRef_current = keyborgRef.current) === null || _keyborgRef_current === void 0 ? void 0 : _keyborgRef_current.setVal(isNavigatingWithKeyboard);
  }, [
    keyborgRef
  ]);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusedElementChange.js
var React53 = __toESM(require_react());
function useFocusedElementChange(callback) {
  const { targetDocument } = useFluent();
  const listener = useEventCallback(callback);
  React53.useEffect(() => {
    const tabster = createTabsterWithConfig(targetDocument);
    if (tabster) {
      tabster.focusedElement.subscribe(listener);
      return () => {
        tabster.focusedElement.unsubscribe(listener);
        disposeTabster(tabster);
      };
    }
  }, [
    listener,
    targetDocument
  ]);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useActivateModal.js
var React54 = __toESM(require_react());
function useActivateModal() {
  const modalizerRefAPI = useTabster(getModalizer);
  const [setActivateModalTimeout] = useTimeout();
  const activateModal = React54.useCallback((elementFromModal) => {
    setActivateModalTimeout(() => {
      var _modalizerRefAPI_current;
      (_modalizerRefAPI_current = modalizerRefAPI.current) === null || _modalizerRefAPI_current === void 0 ? void 0 : _modalizerRefAPI_current.activate(elementFromModal);
    }, 0);
  }, [
    modalizerRefAPI,
    setActivateModalTimeout
  ]);
  return activateModal;
}

// node_modules/@fluentui/react-tabster/lib/focus/createCustomFocusIndicatorStyle.js
function createCustomFocusIndicatorStyle(style, { selector: selectorType = defaultOptions.selector, customizeSelector = defaultOptions.customizeSelector } = defaultOptions) {
  return {
    [customizeSelector(createBaseSelector(selectorType))]: style
  };
}
function createBaseSelector(selectorType) {
  switch (selectorType) {
    case "focus":
      return `&[${FOCUS_VISIBLE_ATTR}]`;
    case "focus-within":
      return `&[${FOCUS_WITHIN_ATTR}]:focus-within`;
  }
}

// node_modules/@fluentui/tokens/lib/global/colors.js
var grey = {
  "2": "#050505",
  "4": "#0a0a0a",
  "6": "#0f0f0f",
  "8": "#141414",
  "10": "#1a1a1a",
  "12": "#1f1f1f",
  "14": "#242424",
  "16": "#292929",
  "18": "#2e2e2e",
  "20": "#333333",
  "22": "#383838",
  "24": "#3d3d3d",
  "26": "#424242",
  "28": "#474747",
  "30": "#4d4d4d",
  "32": "#525252",
  "34": "#575757",
  "36": "#5c5c5c",
  "38": "#616161",
  "40": "#666666",
  "42": "#6b6b6b",
  "44": "#707070",
  "46": "#757575",
  "48": "#7a7a7a",
  "50": "#808080",
  "52": "#858585",
  "54": "#8a8a8a",
  "56": "#8f8f8f",
  "58": "#949494",
  "60": "#999999",
  "62": "#9e9e9e",
  "64": "#a3a3a3",
  "66": "#a8a8a8",
  "68": "#adadad",
  "70": "#b3b3b3",
  "72": "#b8b8b8",
  "74": "#bdbdbd",
  "76": "#c2c2c2",
  "78": "#c7c7c7",
  "80": "#cccccc",
  "82": "#d1d1d1",
  "84": "#d6d6d6",
  "86": "#dbdbdb",
  "88": "#e0e0e0",
  "90": "#e6e6e6",
  "92": "#ebebeb",
  "94": "#f0f0f0",
  "96": "#f5f5f5",
  "98": "#fafafa"
};
var whiteAlpha = {
  "5": "rgba(255, 255, 255, 0.05)",
  "10": "rgba(255, 255, 255, 0.1)",
  "20": "rgba(255, 255, 255, 0.2)",
  "30": "rgba(255, 255, 255, 0.3)",
  "40": "rgba(255, 255, 255, 0.4)",
  "50": "rgba(255, 255, 255, 0.5)",
  "60": "rgba(255, 255, 255, 0.6)",
  "70": "rgba(255, 255, 255, 0.7)",
  "80": "rgba(255, 255, 255, 0.8)",
  "90": "rgba(255, 255, 255, 0.9)"
};
var blackAlpha = {
  "5": "rgba(0, 0, 0, 0.05)",
  "10": "rgba(0, 0, 0, 0.1)",
  "20": "rgba(0, 0, 0, 0.2)",
  "30": "rgba(0, 0, 0, 0.3)",
  "40": "rgba(0, 0, 0, 0.4)",
  "50": "rgba(0, 0, 0, 0.5)",
  "60": "rgba(0, 0, 0, 0.6)",
  "70": "rgba(0, 0, 0, 0.7)",
  "80": "rgba(0, 0, 0, 0.8)",
  "90": "rgba(0, 0, 0, 0.9)"
};
var grey10Alpha = {
  "5": "rgba(26, 26, 26, 0.05)",
  "10": "rgba(26, 26, 26, 0.1)",
  "20": "rgba(26, 26, 26, 0.2)",
  "30": "rgba(26, 26, 26, 0.3)",
  "40": "rgba(26, 26, 26, 0.4)",
  "50": "rgba(26, 26, 26, 0.5)",
  "60": "rgba(26, 26, 26, 0.6)",
  "70": "rgba(26, 26, 26, 0.7)",
  "80": "rgba(26, 26, 26, 0.8)",
  "90": "rgba(26, 26, 26, 0.9)"
};
var grey12Alpha = {
  "5": "rgba(31, 31, 31, 0.05)",
  "10": "rgba(31, 31, 31, 0.1)",
  "20": "rgba(31, 31, 31, 0.2)",
  "30": "rgba(31, 31, 31, 0.3)",
  "40": "rgba(31, 31, 31, 0.4)",
  "50": "rgba(31, 31, 31, 0.5)",
  "60": "rgba(31, 31, 31, 0.6)",
  "70": "rgba(31, 31, 31, 0.7)",
  "80": "rgba(31, 31, 31, 0.8)",
  "90": "rgba(31, 31, 31, 0.9)"
};
var grey14Alpha = {
  "5": "rgba(36, 36, 36, 0.05)",
  "10": "rgba(36, 36, 36, 0.1)",
  "20": "rgba(36, 36, 36, 0.2)",
  "30": "rgba(36, 36, 36, 0.3)",
  "40": "rgba(36, 36, 36, 0.4)",
  "50": "rgba(36, 36, 36, 0.5)",
  "60": "rgba(36, 36, 36, 0.6)",
  "70": "rgba(36, 36, 36, 0.7)",
  "80": "rgba(36, 36, 36, 0.8)",
  "90": "rgba(36, 36, 36, 0.9)"
};
var white = "#ffffff";
var black = "#000000";
var hcHyperlink = "#ffff00";
var hcHighlight = "#1aebff";
var hcDisabled = "#3ff23f";
var hcCanvas = "#000000";
var hcCanvasText = "#ffffff";
var hcHighlightText = "#000000";
var hcButtonText = "#000000";
var hcButtonFace = "#ffffff";
var darkRed = {
  shade50: "#130204",
  shade40: "#230308",
  shade30: "#420610",
  shade20: "#590815",
  shade10: "#690a19",
  primary: "#750b1c",
  tint10: "#861b2c",
  tint20: "#962f3f",
  tint30: "#ac4f5e",
  tint40: "#d69ca5",
  tint50: "#e9c7cd",
  tint60: "#f9f0f2"
};
var cranberry = {
  shade50: "#200205",
  shade40: "#3b0509",
  shade30: "#6e0811",
  shade20: "#960b18",
  shade10: "#b10e1c",
  primary: "#c50f1f",
  tint10: "#cc2635",
  tint20: "#d33f4c",
  tint30: "#dc626d",
  tint40: "#eeacb2",
  tint50: "#f6d1d5",
  tint60: "#fdf3f4"
};
var red = {
  shade50: "#210809",
  shade40: "#3f1011",
  shade30: "#751d1f",
  shade20: "#9f282b",
  shade10: "#bc2f32",
  primary: "#d13438",
  tint10: "#d7494c",
  tint20: "#dc5e62",
  tint30: "#e37d80",
  tint40: "#f1bbbc",
  tint50: "#f8dadb",
  tint60: "#fdf6f6"
};
var darkOrange = {
  shade50: "#230900",
  shade40: "#411200",
  shade30: "#7a2101",
  shade20: "#a62d01",
  shade10: "#c43501",
  primary: "#da3b01",
  tint10: "#de501c",
  tint20: "#e36537",
  tint30: "#e9835e",
  tint40: "#f4bfab",
  tint50: "#f9dcd1",
  tint60: "#fdf6f3"
};
var pumpkin = {
  shade50: "#200d03",
  shade40: "#3d1805",
  shade30: "#712d09",
  shade20: "#9a3d0c",
  shade10: "#b6480e",
  primary: "#ca5010",
  tint10: "#d06228",
  tint20: "#d77440",
  tint30: "#df8e64",
  tint40: "#efc4ad",
  tint50: "#f7dfd2",
  tint60: "#fdf7f4"
};
var orange = {
  shade50: "#271002",
  shade40: "#4a1e04",
  shade30: "#8a3707",
  shade20: "#bc4b09",
  shade10: "#de590b",
  primary: "#f7630c",
  tint10: "#f87528",
  tint20: "#f98845",
  tint30: "#faa06b",
  tint40: "#fdcfb4",
  tint50: "#fee5d7",
  tint60: "#fff9f5"
};
var peach = {
  shade50: "#291600",
  shade40: "#4d2a00",
  shade30: "#8f4e00",
  shade20: "#c26a00",
  shade10: "#e67e00",
  primary: "#ff8c00",
  tint10: "#ff9a1f",
  tint20: "#ffa83d",
  tint30: "#ffba66",
  tint40: "#ffddb3",
  tint50: "#ffedd6",
  tint60: "#fffaf5"
};
var marigold = {
  shade50: "#251a00",
  shade40: "#463100",
  shade30: "#835b00",
  shade20: "#b27c00",
  shade10: "#d39300",
  primary: "#eaa300",
  tint10: "#edad1c",
  tint20: "#efb839",
  tint30: "#f2c661",
  tint40: "#f9e2ae",
  tint50: "#fcefd3",
  tint60: "#fefbf4"
};
var yellow = {
  shade50: "#282400",
  shade40: "#4c4400",
  shade30: "#817400",
  shade20: "#c0ad00",
  shade10: "#e4cc00",
  primary: "#fde300",
  tint10: "#fde61e",
  tint20: "#fdea3d",
  tint30: "#feee66",
  tint40: "#fef7b2",
  tint50: "#fffad6",
  tint60: "#fffef5"
};
var gold = {
  shade50: "#1f1900",
  shade40: "#3a2f00",
  shade30: "#6c5700",
  shade20: "#937700",
  shade10: "#ae8c00",
  primary: "#c19c00",
  tint10: "#c8a718",
  tint20: "#d0b232",
  tint30: "#dac157",
  tint40: "#ecdfa5",
  tint50: "#f5eece",
  tint60: "#fdfbf2"
};
var brass = {
  shade50: "#181202",
  shade40: "#2e2103",
  shade30: "#553e06",
  shade20: "#745408",
  shade10: "#89640a",
  primary: "#986f0b",
  tint10: "#a47d1e",
  tint20: "#b18c34",
  tint30: "#c1a256",
  tint40: "#e0cea2",
  tint50: "#efe4cb",
  tint60: "#fbf8f2"
};
var brown = {
  shade50: "#170e07",
  shade40: "#2b1a0e",
  shade30: "#50301a",
  shade20: "#6c4123",
  shade10: "#804d29",
  primary: "#8e562e",
  tint10: "#9c663f",
  tint20: "#a97652",
  tint30: "#bb8f6f",
  tint40: "#ddc3b0",
  tint50: "#edded3",
  tint60: "#faf7f4"
};
var forest = {
  shade50: "#0c1501",
  shade40: "#162702",
  shade30: "#294903",
  shade20: "#376304",
  shade10: "#427505",
  primary: "#498205",
  tint10: "#599116",
  tint20: "#6ba02b",
  tint30: "#85b44c",
  tint40: "#bdd99b",
  tint50: "#dbebc7",
  tint60: "#f6faf0"
};
var seafoam = {
  shade50: "#002111",
  shade40: "#003d20",
  shade30: "#00723b",
  shade20: "#009b51",
  shade10: "#00b85f",
  primary: "#00cc6a",
  tint10: "#19d279",
  tint20: "#34d889",
  tint30: "#5ae0a0",
  tint40: "#a8f0cd",
  tint50: "#cff7e4",
  tint60: "#f3fdf8"
};
var lightGreen = {
  shade50: "#031a02",
  shade40: "#063004",
  shade30: "#0b5a08",
  shade20: "#0e7a0b",
  shade10: "#11910d",
  primary: "#13a10e",
  tint10: "#27ac22",
  tint20: "#3db838",
  tint30: "#5ec75a",
  tint40: "#a7e3a5",
  tint50: "#cef0cd",
  tint60: "#f2fbf2"
};
var green = {
  shade50: "#031403",
  shade40: "#052505",
  shade30: "#094509",
  shade20: "#0c5e0c",
  shade10: "#0e700e",
  primary: "#107c10",
  tint10: "#218c21",
  tint20: "#359b35",
  tint30: "#54b054",
  tint40: "#9fd89f",
  tint50: "#c9eac9",
  tint60: "#f1faf1"
};
var darkGreen = {
  shade50: "#021102",
  shade40: "#032003",
  shade30: "#063b06",
  shade20: "#085108",
  shade10: "#0a5f0a",
  primary: "#0b6a0b",
  tint10: "#1a7c1a",
  tint20: "#2d8e2d",
  tint30: "#4da64d",
  tint40: "#9ad29a",
  tint50: "#c6e7c6",
  tint60: "#f0f9f0"
};
var lightTeal = {
  shade50: "#001d1f",
  shade40: "#00373a",
  shade30: "#00666d",
  shade20: "#008b94",
  shade10: "#00a5af",
  primary: "#00b7c3",
  tint10: "#18bfca",
  tint20: "#32c8d1",
  tint30: "#58d3db",
  tint40: "#a6e9ed",
  tint50: "#cef3f5",
  tint60: "#f2fcfd"
};
var teal = {
  shade50: "#001516",
  shade40: "#012728",
  shade30: "#02494c",
  shade20: "#026467",
  shade10: "#037679",
  primary: "#038387",
  tint10: "#159195",
  tint20: "#2aa0a4",
  tint30: "#4cb4b7",
  tint40: "#9bd9db",
  tint50: "#c7ebec",
  tint60: "#f0fafa"
};
var steel = {
  shade50: "#000f12",
  shade40: "#001b22",
  shade30: "#00333f",
  shade20: "#004555",
  shade10: "#005265",
  primary: "#005b70",
  tint10: "#0f6c81",
  tint20: "#237d92",
  tint30: "#4496a9",
  tint40: "#94c8d4",
  tint50: "#c3e1e8",
  tint60: "#eff7f9"
};
var blue = {
  shade50: "#001322",
  shade40: "#002440",
  shade30: "#004377",
  shade20: "#005ba1",
  shade10: "#006cbf",
  primary: "#0078d4",
  tint10: "#1a86d9",
  tint20: "#3595de",
  tint30: "#5caae5",
  tint40: "#a9d3f2",
  tint50: "#d0e7f8",
  tint60: "#f3f9fd"
};
var royalBlue = {
  shade50: "#000c16",
  shade40: "#00172a",
  shade30: "#002c4e",
  shade20: "#003b6a",
  shade10: "#00467e",
  primary: "#004e8c",
  tint10: "#125e9a",
  tint20: "#286fa8",
  tint30: "#4a89ba",
  tint40: "#9abfdc",
  tint50: "#c7dced",
  tint60: "#f0f6fa"
};
var cornflower = {
  shade50: "#0d1126",
  shade40: "#182047",
  shade30: "#2c3c85",
  shade20: "#3c51b4",
  shade10: "#4760d5",
  primary: "#4f6bed",
  tint10: "#637cef",
  tint20: "#778df1",
  tint30: "#93a4f4",
  tint40: "#c8d1fa",
  tint50: "#e1e6fc",
  tint60: "#f7f9fe"
};
var navy = {
  shade50: "#00061d",
  shade40: "#000c36",
  shade30: "#001665",
  shade20: "#001e89",
  shade10: "#0023a2",
  primary: "#0027b4",
  tint10: "#173bbd",
  tint20: "#3050c6",
  tint30: "#546fd2",
  tint40: "#a3b2e8",
  tint50: "#ccd5f3",
  tint60: "#f2f4fc"
};
var lavender = {
  shade50: "#120f25",
  shade40: "#221d46",
  shade30: "#3f3682",
  shade20: "#5649b0",
  shade10: "#6656d1",
  primary: "#7160e8",
  tint10: "#8172eb",
  tint20: "#9184ee",
  tint30: "#a79cf1",
  tint40: "#d2ccf8",
  tint50: "#e7e4fb",
  tint60: "#f9f8fe"
};
var purple = {
  shade50: "#0f0717",
  shade40: "#1c0e2b",
  shade30: "#341a51",
  shade20: "#46236e",
  shade10: "#532982",
  primary: "#5c2e91",
  tint10: "#6b3f9e",
  tint20: "#7c52ab",
  tint30: "#9470bd",
  tint40: "#c6b1de",
  tint50: "#e0d3ed",
  tint60: "#f7f4fb"
};
var grape = {
  shade50: "#160418",
  shade40: "#29072e",
  shade30: "#4c0d55",
  shade20: "#671174",
  shade10: "#7a1589",
  primary: "#881798",
  tint10: "#952aa4",
  tint20: "#a33fb1",
  tint30: "#b55fc1",
  tint40: "#d9a7e0",
  tint50: "#eaceef",
  tint60: "#faf2fb"
};
var berry = {
  shade50: "#1f091d",
  shade40: "#3a1136",
  shade30: "#6d2064",
  shade20: "#932b88",
  shade10: "#af33a1",
  primary: "#c239b3",
  tint10: "#c94cbc",
  tint20: "#d161c4",
  tint30: "#da7ed0",
  tint40: "#edbbe7",
  tint50: "#f5daf2",
  tint60: "#fdf5fc"
};
var lilac = {
  shade50: "#1c0b1f",
  shade40: "#35153a",
  shade30: "#63276d",
  shade20: "#863593",
  shade10: "#9f3faf",
  primary: "#b146c2",
  tint10: "#ba58c9",
  tint20: "#c36bd1",
  tint30: "#cf87da",
  tint40: "#e6bfed",
  tint50: "#f2dcf5",
  tint60: "#fcf6fd"
};
var pink = {
  shade50: "#24091b",
  shade40: "#441232",
  shade30: "#80215d",
  shade20: "#ad2d7e",
  shade10: "#cd3595",
  primary: "#e43ba6",
  tint10: "#e750b0",
  tint20: "#ea66ba",
  tint30: "#ef85c8",
  tint40: "#f7c0e3",
  tint50: "#fbddf0",
  tint60: "#fef6fb"
};
var magenta = {
  shade50: "#1f0013",
  shade40: "#390024",
  shade30: "#6b0043",
  shade20: "#91005a",
  shade10: "#ac006b",
  primary: "#bf0077",
  tint10: "#c71885",
  tint20: "#ce3293",
  tint30: "#d957a8",
  tint40: "#eca5d1",
  tint50: "#f5cee6",
  tint60: "#fcf2f9"
};
var plum = {
  shade50: "#13000c",
  shade40: "#240017",
  shade30: "#43002b",
  shade20: "#5a003b",
  shade10: "#6b0045",
  primary: "#77004d",
  tint10: "#87105d",
  tint20: "#98246f",
  tint30: "#ad4589",
  tint40: "#d696c0",
  tint50: "#e9c4dc",
  tint60: "#faf0f6"
};
var beige = {
  shade50: "#141313",
  shade40: "#252323",
  shade30: "#444241",
  shade20: "#5d5958",
  shade10: "#6e6968",
  primary: "#7a7574",
  tint10: "#8a8584",
  tint20: "#9a9594",
  tint30: "#afabaa",
  tint40: "#d7d4d4",
  tint50: "#eae8e8",
  tint60: "#faf9f9"
};
var mink = {
  shade50: "#0f0e0e",
  shade40: "#1c1b1a",
  shade30: "#343231",
  shade20: "#474443",
  shade10: "#54514f",
  primary: "#5d5a58",
  tint10: "#706d6b",
  tint20: "#84817e",
  tint30: "#9e9b99",
  tint40: "#cecccb",
  tint50: "#e5e4e3",
  tint60: "#f8f8f8"
};
var platinum = {
  shade50: "#111314",
  shade40: "#1f2426",
  shade30: "#3b4447",
  shade20: "#505c60",
  shade10: "#5f6d71",
  primary: "#69797e",
  tint10: "#79898d",
  tint20: "#89989d",
  tint30: "#a0adb2",
  tint40: "#cdd6d8",
  tint50: "#e4e9ea",
  tint60: "#f8f9fa"
};
var anchor = {
  shade50: "#090a0b",
  shade40: "#111315",
  shade30: "#202427",
  shade20: "#2b3135",
  shade10: "#333a3f",
  primary: "#394146",
  tint10: "#4d565c",
  tint20: "#626c72",
  tint30: "#808a90",
  tint40: "#bcc3c7",
  tint50: "#dbdfe1",
  tint60: "#f6f7f8"
};

// node_modules/@fluentui/tokens/lib/global/colorPalette.js
var statusSharedColors = {
  red,
  green,
  darkOrange,
  yellow,
  berry,
  lightGreen,
  marigold
};
var personaSharedColors = {
  darkRed,
  cranberry,
  pumpkin,
  peach,
  gold,
  brass,
  brown,
  forest,
  seafoam,
  darkGreen,
  lightTeal,
  teal,
  steel,
  blue,
  royalBlue,
  cornflower,
  navy,
  lavender,
  purple,
  grape,
  lilac,
  pink,
  magenta,
  plum,
  beige,
  mink,
  platinum,
  anchor
};
var mappedStatusColors = {
  cranberry,
  green,
  orange
};

// node_modules/@fluentui/tokens/lib/sharedColorNames.js
var statusSharedColorNames = [
  "red",
  "green",
  "darkOrange",
  "yellow",
  "berry",
  "lightGreen",
  "marigold"
];
var personaSharedColorNames = [
  "darkRed",
  "cranberry",
  "pumpkin",
  "peach",
  "gold",
  "brass",
  "brown",
  "forest",
  "seafoam",
  "darkGreen",
  "lightTeal",
  "teal",
  "steel",
  "blue",
  "royalBlue",
  "cornflower",
  "navy",
  "lavender",
  "purple",
  "grape",
  "lilac",
  "pink",
  "magenta",
  "plum",
  "beige",
  "mink",
  "platinum",
  "anchor"
];

// node_modules/@fluentui/tokens/lib/statusColorMapping.js
var statusColorMapping = {
  success: "green",
  warning: "orange",
  danger: "cranberry"
};

// node_modules/@fluentui/tokens/lib/alias/lightColorPalette.js
var statusColorPaletteTokens = statusSharedColorNames.reduce((acc, sharedColor) => {
  const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color2}Background1`]: statusSharedColors[sharedColor].tint60,
    [`colorPalette${color2}Background2`]: statusSharedColors[sharedColor].tint40,
    [`colorPalette${color2}Background3`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color2}Foreground1`]: statusSharedColors[sharedColor].shade10,
    [`colorPalette${color2}Foreground2`]: statusSharedColors[sharedColor].shade30,
    [`colorPalette${color2}Foreground3`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color2}BorderActive`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color2}Border1`]: statusSharedColors[sharedColor].tint40,
    [`colorPalette${color2}Border2`]: statusSharedColors[sharedColor].primary
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
statusColorPaletteTokens.colorPaletteYellowForeground1 = statusSharedColors.yellow.shade30;
statusColorPaletteTokens.colorPaletteRedForegroundInverted = statusSharedColors.red.tint20;
statusColorPaletteTokens.colorPaletteGreenForegroundInverted = statusSharedColors.green.tint20;
statusColorPaletteTokens.colorPaletteYellowForegroundInverted = statusSharedColors.yellow.tint40;
var personaColorPaletteTokens = personaSharedColorNames.reduce((acc, sharedColor) => {
  const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color2}Background2`]: personaSharedColors[sharedColor].tint40,
    [`colorPalette${color2}Foreground2`]: personaSharedColors[sharedColor].shade30,
    [`colorPalette${color2}BorderActive`]: personaSharedColors[sharedColor].primary
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
var colorPaletteTokens = {
  ...statusColorPaletteTokens,
  ...personaColorPaletteTokens
};
var colorStatusTokens = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
  const color2 = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
  const statusColorTokens = {
    [`colorStatus${color2}Background1`]: mappedStatusColors[sharedColor].tint60,
    [`colorStatus${color2}Background2`]: mappedStatusColors[sharedColor].tint40,
    [`colorStatus${color2}Background3`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color2}Foreground1`]: mappedStatusColors[sharedColor].shade10,
    [`colorStatus${color2}Foreground2`]: mappedStatusColors[sharedColor].shade30,
    [`colorStatus${color2}Foreground3`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color2}ForegroundInverted`]: mappedStatusColors[sharedColor].tint30,
    [`colorStatus${color2}BorderActive`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color2}Border1`]: mappedStatusColors[sharedColor].tint40,
    [`colorStatus${color2}Border2`]: mappedStatusColors[sharedColor].primary
  };
  return Object.assign(acc, statusColorTokens);
}, {});
colorStatusTokens.colorStatusDangerBackground3Hover = mappedStatusColors[statusColorMapping.danger].shade10;
colorStatusTokens.colorStatusDangerBackground3Pressed = mappedStatusColors[statusColorMapping.danger].shade20;
colorStatusTokens.colorStatusWarningForeground1 = mappedStatusColors[statusColorMapping.warning].shade20;
colorStatusTokens.colorStatusWarningForeground3 = mappedStatusColors[statusColorMapping.warning].shade20;
colorStatusTokens.colorStatusWarningBorder2 = mappedStatusColors[statusColorMapping.warning].shade20;

// node_modules/@fluentui/tokens/lib/alias/lightColor.js
var generateColorTokens = (brand) => ({
  colorNeutralForeground1: grey[14],
  colorNeutralForeground1Hover: grey[14],
  colorNeutralForeground1Pressed: grey[14],
  colorNeutralForeground1Selected: grey[14],
  colorNeutralForeground2: grey[26],
  colorNeutralForeground2Hover: grey[14],
  colorNeutralForeground2Pressed: grey[14],
  colorNeutralForeground2Selected: grey[14],
  colorNeutralForeground2BrandHover: brand[80],
  colorNeutralForeground2BrandPressed: brand[70],
  colorNeutralForeground2BrandSelected: brand[80],
  colorNeutralForeground3: grey[38],
  colorNeutralForeground3Hover: grey[26],
  colorNeutralForeground3Pressed: grey[26],
  colorNeutralForeground3Selected: grey[26],
  colorNeutralForeground3BrandHover: brand[80],
  colorNeutralForeground3BrandPressed: brand[70],
  colorNeutralForeground3BrandSelected: brand[80],
  colorNeutralForeground4: grey[44],
  colorNeutralForegroundDisabled: grey[74],
  colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
  colorBrandForegroundLink: brand[70],
  colorBrandForegroundLinkHover: brand[60],
  colorBrandForegroundLinkPressed: brand[40],
  colorBrandForegroundLinkSelected: brand[70],
  colorNeutralForeground2Link: grey[26],
  colorNeutralForeground2LinkHover: grey[14],
  colorNeutralForeground2LinkPressed: grey[14],
  colorNeutralForeground2LinkSelected: grey[14],
  colorCompoundBrandForeground1: brand[80],
  colorCompoundBrandForeground1Hover: brand[70],
  colorCompoundBrandForeground1Pressed: brand[60],
  colorBrandForeground1: brand[80],
  colorBrandForeground2: brand[70],
  colorBrandForeground2Hover: brand[60],
  colorBrandForeground2Pressed: brand[30],
  colorNeutralForeground1Static: grey[14],
  colorNeutralForegroundStaticInverted: white,
  colorNeutralForegroundInverted: white,
  colorNeutralForegroundInvertedHover: white,
  colorNeutralForegroundInvertedPressed: white,
  colorNeutralForegroundInvertedSelected: white,
  colorNeutralForegroundInverted2: white,
  colorNeutralForegroundOnBrand: white,
  colorNeutralForegroundInvertedLink: white,
  colorNeutralForegroundInvertedLinkHover: white,
  colorNeutralForegroundInvertedLinkPressed: white,
  colorNeutralForegroundInvertedLinkSelected: white,
  colorBrandForegroundInverted: brand[100],
  colorBrandForegroundInvertedHover: brand[110],
  colorBrandForegroundInvertedPressed: brand[100],
  colorBrandForegroundOnLight: brand[80],
  colorBrandForegroundOnLightHover: brand[70],
  colorBrandForegroundOnLightPressed: brand[50],
  colorBrandForegroundOnLightSelected: brand[60],
  colorNeutralBackground1: white,
  colorNeutralBackground1Hover: grey[96],
  colorNeutralBackground1Pressed: grey[88],
  colorNeutralBackground1Selected: grey[92],
  colorNeutralBackground2: grey[98],
  colorNeutralBackground2Hover: grey[94],
  colorNeutralBackground2Pressed: grey[86],
  colorNeutralBackground2Selected: grey[90],
  colorNeutralBackground3: grey[96],
  colorNeutralBackground3Hover: grey[92],
  colorNeutralBackground3Pressed: grey[84],
  colorNeutralBackground3Selected: grey[88],
  colorNeutralBackground4: grey[94],
  colorNeutralBackground4Hover: grey[98],
  colorNeutralBackground4Pressed: grey[96],
  colorNeutralBackground4Selected: white,
  colorNeutralBackground5: grey[92],
  colorNeutralBackground5Hover: grey[96],
  colorNeutralBackground5Pressed: grey[94],
  colorNeutralBackground5Selected: grey[98],
  colorNeutralBackground6: grey[90],
  colorNeutralBackgroundInverted: grey[16],
  colorNeutralBackgroundStatic: grey[20],
  colorNeutralBackgroundAlpha: whiteAlpha[50],
  colorNeutralBackgroundAlpha2: whiteAlpha[80],
  colorSubtleBackground: "transparent",
  colorSubtleBackgroundHover: grey[96],
  colorSubtleBackgroundPressed: grey[88],
  colorSubtleBackgroundSelected: grey[92],
  colorSubtleBackgroundLightAlphaHover: whiteAlpha[70],
  colorSubtleBackgroundLightAlphaPressed: whiteAlpha[50],
  colorSubtleBackgroundLightAlphaSelected: "transparent",
  colorSubtleBackgroundInverted: "transparent",
  colorSubtleBackgroundInvertedHover: blackAlpha[10],
  colorSubtleBackgroundInvertedPressed: blackAlpha[30],
  colorSubtleBackgroundInvertedSelected: blackAlpha[20],
  colorTransparentBackground: "transparent",
  colorTransparentBackgroundHover: "transparent",
  colorTransparentBackgroundPressed: "transparent",
  colorTransparentBackgroundSelected: "transparent",
  colorNeutralBackgroundDisabled: grey[94],
  colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
  colorNeutralStencil1: grey[90],
  colorNeutralStencil2: grey[98],
  colorNeutralStencil1Alpha: blackAlpha[10],
  colorNeutralStencil2Alpha: blackAlpha[5],
  colorBackgroundOverlay: blackAlpha[40],
  colorScrollbarOverlay: blackAlpha[50],
  colorBrandBackground: brand[80],
  colorBrandBackgroundHover: brand[70],
  colorBrandBackgroundPressed: brand[40],
  colorBrandBackgroundSelected: brand[60],
  colorCompoundBrandBackground: brand[80],
  colorCompoundBrandBackgroundHover: brand[70],
  colorCompoundBrandBackgroundPressed: brand[60],
  colorBrandBackgroundStatic: brand[80],
  colorBrandBackground2: brand[160],
  colorBrandBackground2Hover: brand[150],
  colorBrandBackground2Pressed: brand[130],
  colorBrandBackground3Static: brand[60],
  colorBrandBackground4Static: brand[40],
  colorBrandBackgroundInverted: white,
  colorBrandBackgroundInvertedHover: brand[160],
  colorBrandBackgroundInvertedPressed: brand[140],
  colorBrandBackgroundInvertedSelected: brand[150],
  colorNeutralCardBackground: grey[98],
  colorNeutralCardBackgroundHover: white,
  colorNeutralCardBackgroundPressed: grey[96],
  colorNeutralCardBackgroundSelected: grey[92],
  colorNeutralCardBackgroundDisabled: grey[94],
  colorNeutralStrokeAccessible: grey[38],
  colorNeutralStrokeAccessibleHover: grey[34],
  colorNeutralStrokeAccessiblePressed: grey[30],
  colorNeutralStrokeAccessibleSelected: brand[80],
  colorNeutralStroke1: grey[82],
  colorNeutralStroke1Hover: grey[78],
  colorNeutralStroke1Pressed: grey[70],
  colorNeutralStroke1Selected: grey[74],
  colorNeutralStroke2: grey[88],
  colorNeutralStroke3: grey[94],
  colorNeutralStrokeSubtle: grey[88],
  colorNeutralStrokeOnBrand: white,
  colorNeutralStrokeOnBrand2: white,
  colorNeutralStrokeOnBrand2Hover: white,
  colorNeutralStrokeOnBrand2Pressed: white,
  colorNeutralStrokeOnBrand2Selected: white,
  colorBrandStroke1: brand[80],
  colorBrandStroke2: brand[140],
  colorBrandStroke2Hover: brand[120],
  colorBrandStroke2Pressed: brand[80],
  colorBrandStroke2Contrast: brand[140],
  colorCompoundBrandStroke: brand[80],
  colorCompoundBrandStrokeHover: brand[70],
  colorCompoundBrandStrokePressed: brand[60],
  colorNeutralStrokeDisabled: grey[88],
  colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
  colorTransparentStroke: "transparent",
  colorTransparentStrokeInteractive: "transparent",
  colorTransparentStrokeDisabled: "transparent",
  colorNeutralStrokeAlpha: blackAlpha[5],
  colorNeutralStrokeAlpha2: whiteAlpha[20],
  colorStrokeFocus1: white,
  colorStrokeFocus2: black,
  colorNeutralShadowAmbient: "rgba(0,0,0,0.12)",
  colorNeutralShadowKey: "rgba(0,0,0,0.14)",
  colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.06)",
  colorNeutralShadowKeyLighter: "rgba(0,0,0,0.07)",
  colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.20)",
  colorNeutralShadowKeyDarker: "rgba(0,0,0,0.24)",
  colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
  colorBrandShadowKey: "rgba(0,0,0,0.25)"
});

// node_modules/@fluentui/tokens/lib/global/borderRadius.js
var borderRadius = {
  borderRadiusNone: "0",
  borderRadiusSmall: "2px",
  borderRadiusMedium: "4px",
  borderRadiusLarge: "6px",
  borderRadiusXLarge: "8px",
  borderRadiusCircular: "10000px"
};

// node_modules/@fluentui/tokens/lib/global/curves.js
var curves = {
  curveAccelerateMax: "cubic-bezier(0.9,0.1,1,0.2)",
  curveAccelerateMid: "cubic-bezier(1,0,1,1)",
  curveAccelerateMin: "cubic-bezier(0.8,0,0.78,1)",
  curveDecelerateMax: "cubic-bezier(0.1,0.9,0.2,1)",
  curveDecelerateMid: "cubic-bezier(0,0,0,1)",
  curveDecelerateMin: "cubic-bezier(0.33,0,0.1,1)",
  curveEasyEaseMax: "cubic-bezier(0.8,0,0.2,1)",
  curveEasyEase: "cubic-bezier(0.33,0,0.67,1)",
  curveLinear: "cubic-bezier(0,0,1,1)"
};

// node_modules/@fluentui/tokens/lib/global/durations.js
var durations = {
  durationUltraFast: "50ms",
  durationFaster: "100ms",
  durationFast: "150ms",
  durationNormal: "200ms",
  durationGentle: "250ms",
  durationSlow: "300ms",
  durationSlower: "400ms",
  durationUltraSlow: "500ms"
};

// node_modules/@fluentui/tokens/lib/global/fonts.js
var fontSizes = {
  fontSizeBase100: "10px",
  fontSizeBase200: "12px",
  fontSizeBase300: "14px",
  fontSizeBase400: "16px",
  fontSizeBase500: "20px",
  fontSizeBase600: "24px",
  fontSizeHero700: "28px",
  fontSizeHero800: "32px",
  fontSizeHero900: "40px",
  fontSizeHero1000: "68px"
};
var lineHeights = {
  lineHeightBase100: "14px",
  lineHeightBase200: "16px",
  lineHeightBase300: "20px",
  lineHeightBase400: "22px",
  lineHeightBase500: "28px",
  lineHeightBase600: "32px",
  lineHeightHero700: "36px",
  lineHeightHero800: "40px",
  lineHeightHero900: "52px",
  lineHeightHero1000: "92px"
};
var fontWeights = {
  fontWeightRegular: 400,
  fontWeightMedium: 500,
  fontWeightSemibold: 600,
  fontWeightBold: 700
};
var fontFamilies = {
  fontFamilyBase: "'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif",
  fontFamilyMonospace: "Consolas, 'Courier New', Courier, monospace",
  fontFamilyNumeric: "Bahnschrift, 'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif"
};

// node_modules/@fluentui/tokens/lib/global/spacings.js
var spacings = {
  none: "0",
  xxs: "2px",
  xs: "4px",
  sNudge: "6px",
  s: "8px",
  mNudge: "10px",
  m: "12px",
  l: "16px",
  xl: "20px",
  xxl: "24px",
  xxxl: "32px"
};
var horizontalSpacings = {
  spacingHorizontalNone: spacings.none,
  spacingHorizontalXXS: spacings.xxs,
  spacingHorizontalXS: spacings.xs,
  spacingHorizontalSNudge: spacings.sNudge,
  spacingHorizontalS: spacings.s,
  spacingHorizontalMNudge: spacings.mNudge,
  spacingHorizontalM: spacings.m,
  spacingHorizontalL: spacings.l,
  spacingHorizontalXL: spacings.xl,
  spacingHorizontalXXL: spacings.xxl,
  spacingHorizontalXXXL: spacings.xxxl
};
var verticalSpacings = {
  spacingVerticalNone: spacings.none,
  spacingVerticalXXS: spacings.xxs,
  spacingVerticalXS: spacings.xs,
  spacingVerticalSNudge: spacings.sNudge,
  spacingVerticalS: spacings.s,
  spacingVerticalMNudge: spacings.mNudge,
  spacingVerticalM: spacings.m,
  spacingVerticalL: spacings.l,
  spacingVerticalXL: spacings.xl,
  spacingVerticalXXL: spacings.xxl,
  spacingVerticalXXXL: spacings.xxxl
};

// node_modules/@fluentui/tokens/lib/global/strokeWidths.js
var strokeWidths = {
  strokeWidthThin: "1px",
  strokeWidthThick: "2px",
  strokeWidthThicker: "3px",
  strokeWidthThickest: "4px"
};

// node_modules/@fluentui/tokens/lib/tokens.js
var tokens = {
  // Color tokens
  colorNeutralForeground1: "var(--colorNeutralForeground1)",
  colorNeutralForeground1Hover: "var(--colorNeutralForeground1Hover)",
  colorNeutralForeground1Pressed: "var(--colorNeutralForeground1Pressed)",
  colorNeutralForeground1Selected: "var(--colorNeutralForeground1Selected)",
  colorNeutralForeground2: "var(--colorNeutralForeground2)",
  colorNeutralForeground2Hover: "var(--colorNeutralForeground2Hover)",
  colorNeutralForeground2Pressed: "var(--colorNeutralForeground2Pressed)",
  colorNeutralForeground2Selected: "var(--colorNeutralForeground2Selected)",
  colorNeutralForeground2BrandHover: "var(--colorNeutralForeground2BrandHover)",
  colorNeutralForeground2BrandPressed: "var(--colorNeutralForeground2BrandPressed)",
  colorNeutralForeground2BrandSelected: "var(--colorNeutralForeground2BrandSelected)",
  colorNeutralForeground3: "var(--colorNeutralForeground3)",
  colorNeutralForeground3Hover: "var(--colorNeutralForeground3Hover)",
  colorNeutralForeground3Pressed: "var(--colorNeutralForeground3Pressed)",
  colorNeutralForeground3Selected: "var(--colorNeutralForeground3Selected)",
  colorNeutralForeground3BrandHover: "var(--colorNeutralForeground3BrandHover)",
  colorNeutralForeground3BrandPressed: "var(--colorNeutralForeground3BrandPressed)",
  colorNeutralForeground3BrandSelected: "var(--colorNeutralForeground3BrandSelected)",
  colorNeutralForeground4: "var(--colorNeutralForeground4)",
  colorNeutralForegroundDisabled: "var(--colorNeutralForegroundDisabled)",
  colorBrandForegroundLink: "var(--colorBrandForegroundLink)",
  colorBrandForegroundLinkHover: "var(--colorBrandForegroundLinkHover)",
  colorBrandForegroundLinkPressed: "var(--colorBrandForegroundLinkPressed)",
  colorBrandForegroundLinkSelected: "var(--colorBrandForegroundLinkSelected)",
  colorNeutralForeground2Link: "var(--colorNeutralForeground2Link)",
  colorNeutralForeground2LinkHover: "var(--colorNeutralForeground2LinkHover)",
  colorNeutralForeground2LinkPressed: "var(--colorNeutralForeground2LinkPressed)",
  colorNeutralForeground2LinkSelected: "var(--colorNeutralForeground2LinkSelected)",
  colorCompoundBrandForeground1: "var(--colorCompoundBrandForeground1)",
  colorCompoundBrandForeground1Hover: "var(--colorCompoundBrandForeground1Hover)",
  colorCompoundBrandForeground1Pressed: "var(--colorCompoundBrandForeground1Pressed)",
  colorNeutralForegroundOnBrand: "var(--colorNeutralForegroundOnBrand)",
  colorNeutralForegroundInverted: "var(--colorNeutralForegroundInverted)",
  colorNeutralForegroundInvertedHover: "var(--colorNeutralForegroundInvertedHover)",
  colorNeutralForegroundInvertedPressed: "var(--colorNeutralForegroundInvertedPressed)",
  colorNeutralForegroundInvertedSelected: "var(--colorNeutralForegroundInvertedSelected)",
  colorNeutralForegroundInverted2: "var(--colorNeutralForegroundInverted2)",
  colorNeutralForegroundStaticInverted: "var(--colorNeutralForegroundStaticInverted)",
  colorNeutralForegroundInvertedLink: "var(--colorNeutralForegroundInvertedLink)",
  colorNeutralForegroundInvertedLinkHover: "var(--colorNeutralForegroundInvertedLinkHover)",
  colorNeutralForegroundInvertedLinkPressed: "var(--colorNeutralForegroundInvertedLinkPressed)",
  colorNeutralForegroundInvertedLinkSelected: "var(--colorNeutralForegroundInvertedLinkSelected)",
  colorNeutralForegroundInvertedDisabled: "var(--colorNeutralForegroundInvertedDisabled)",
  colorBrandForeground1: "var(--colorBrandForeground1)",
  colorBrandForeground2: "var(--colorBrandForeground2)",
  colorBrandForeground2Hover: "var(--colorBrandForeground2Hover)",
  colorBrandForeground2Pressed: "var(--colorBrandForeground2Pressed)",
  colorNeutralForeground1Static: "var(--colorNeutralForeground1Static)",
  colorBrandForegroundInverted: "var(--colorBrandForegroundInverted)",
  colorBrandForegroundInvertedHover: "var(--colorBrandForegroundInvertedHover)",
  colorBrandForegroundInvertedPressed: "var(--colorBrandForegroundInvertedPressed)",
  colorBrandForegroundOnLight: "var(--colorBrandForegroundOnLight)",
  colorBrandForegroundOnLightHover: "var(--colorBrandForegroundOnLightHover)",
  colorBrandForegroundOnLightPressed: "var(--colorBrandForegroundOnLightPressed)",
  colorBrandForegroundOnLightSelected: "var(--colorBrandForegroundOnLightSelected)",
  colorNeutralBackground1: "var(--colorNeutralBackground1)",
  colorNeutralBackground1Hover: "var(--colorNeutralBackground1Hover)",
  colorNeutralBackground1Pressed: "var(--colorNeutralBackground1Pressed)",
  colorNeutralBackground1Selected: "var(--colorNeutralBackground1Selected)",
  colorNeutralBackground2: "var(--colorNeutralBackground2)",
  colorNeutralBackground2Hover: "var(--colorNeutralBackground2Hover)",
  colorNeutralBackground2Pressed: "var(--colorNeutralBackground2Pressed)",
  colorNeutralBackground2Selected: "var(--colorNeutralBackground2Selected)",
  colorNeutralBackground3: "var(--colorNeutralBackground3)",
  colorNeutralBackground3Hover: "var(--colorNeutralBackground3Hover)",
  colorNeutralBackground3Pressed: "var(--colorNeutralBackground3Pressed)",
  colorNeutralBackground3Selected: "var(--colorNeutralBackground3Selected)",
  colorNeutralBackground4: "var(--colorNeutralBackground4)",
  colorNeutralBackground4Hover: "var(--colorNeutralBackground4Hover)",
  colorNeutralBackground4Pressed: "var(--colorNeutralBackground4Pressed)",
  colorNeutralBackground4Selected: "var(--colorNeutralBackground4Selected)",
  colorNeutralBackground5: "var(--colorNeutralBackground5)",
  colorNeutralBackground5Hover: "var(--colorNeutralBackground5Hover)",
  colorNeutralBackground5Pressed: "var(--colorNeutralBackground5Pressed)",
  colorNeutralBackground5Selected: "var(--colorNeutralBackground5Selected)",
  colorNeutralBackground6: "var(--colorNeutralBackground6)",
  colorNeutralBackgroundInverted: "var(--colorNeutralBackgroundInverted)",
  colorNeutralBackgroundStatic: "var(--colorNeutralBackgroundStatic)",
  colorNeutralBackgroundAlpha: "var(--colorNeutralBackgroundAlpha)",
  colorNeutralBackgroundAlpha2: "var(--colorNeutralBackgroundAlpha2)",
  colorSubtleBackground: "var(--colorSubtleBackground)",
  colorSubtleBackgroundHover: "var(--colorSubtleBackgroundHover)",
  colorSubtleBackgroundPressed: "var(--colorSubtleBackgroundPressed)",
  colorSubtleBackgroundSelected: "var(--colorSubtleBackgroundSelected)",
  colorSubtleBackgroundLightAlphaHover: "var(--colorSubtleBackgroundLightAlphaHover)",
  colorSubtleBackgroundLightAlphaPressed: "var(--colorSubtleBackgroundLightAlphaPressed)",
  colorSubtleBackgroundLightAlphaSelected: "var(--colorSubtleBackgroundLightAlphaSelected)",
  colorSubtleBackgroundInverted: "var(--colorSubtleBackgroundInverted)",
  colorSubtleBackgroundInvertedHover: "var(--colorSubtleBackgroundInvertedHover)",
  colorSubtleBackgroundInvertedPressed: "var(--colorSubtleBackgroundInvertedPressed)",
  colorSubtleBackgroundInvertedSelected: "var(--colorSubtleBackgroundInvertedSelected)",
  colorTransparentBackground: "var(--colorTransparentBackground)",
  colorTransparentBackgroundHover: "var(--colorTransparentBackgroundHover)",
  colorTransparentBackgroundPressed: "var(--colorTransparentBackgroundPressed)",
  colorTransparentBackgroundSelected: "var(--colorTransparentBackgroundSelected)",
  colorNeutralBackgroundDisabled: "var(--colorNeutralBackgroundDisabled)",
  colorNeutralBackgroundInvertedDisabled: "var(--colorNeutralBackgroundInvertedDisabled)",
  colorNeutralStencil1: "var(--colorNeutralStencil1)",
  colorNeutralStencil2: "var(--colorNeutralStencil2)",
  colorNeutralStencil1Alpha: "var(--colorNeutralStencil1Alpha)",
  colorNeutralStencil2Alpha: "var(--colorNeutralStencil2Alpha)",
  colorBackgroundOverlay: "var(--colorBackgroundOverlay)",
  colorScrollbarOverlay: "var(--colorScrollbarOverlay)",
  colorBrandBackground: "var(--colorBrandBackground)",
  colorBrandBackgroundHover: "var(--colorBrandBackgroundHover)",
  colorBrandBackgroundPressed: "var(--colorBrandBackgroundPressed)",
  colorBrandBackgroundSelected: "var(--colorBrandBackgroundSelected)",
  colorCompoundBrandBackground: "var(--colorCompoundBrandBackground)",
  colorCompoundBrandBackgroundHover: "var(--colorCompoundBrandBackgroundHover)",
  colorCompoundBrandBackgroundPressed: "var(--colorCompoundBrandBackgroundPressed)",
  colorBrandBackgroundStatic: "var(--colorBrandBackgroundStatic)",
  colorBrandBackground2: "var(--colorBrandBackground2)",
  colorBrandBackground2Hover: "var(--colorBrandBackground2Hover)",
  colorBrandBackground2Pressed: "var(--colorBrandBackground2Pressed)",
  colorBrandBackground3Static: "var(--colorBrandBackground3Static)",
  colorBrandBackground4Static: "var(--colorBrandBackground4Static)",
  colorBrandBackgroundInverted: "var(--colorBrandBackgroundInverted)",
  colorBrandBackgroundInvertedHover: "var(--colorBrandBackgroundInvertedHover)",
  colorBrandBackgroundInvertedPressed: "var(--colorBrandBackgroundInvertedPressed)",
  colorBrandBackgroundInvertedSelected: "var(--colorBrandBackgroundInvertedSelected)",
  colorNeutralCardBackground: "var(--colorNeutralCardBackground)",
  colorNeutralCardBackgroundHover: "var(--colorNeutralCardBackgroundHover)",
  colorNeutralCardBackgroundPressed: "var(--colorNeutralCardBackgroundPressed)",
  colorNeutralCardBackgroundSelected: "var(--colorNeutralCardBackgroundSelected)",
  colorNeutralCardBackgroundDisabled: "var(--colorNeutralCardBackgroundDisabled)",
  colorNeutralStrokeAccessible: "var(--colorNeutralStrokeAccessible)",
  colorNeutralStrokeAccessibleHover: "var(--colorNeutralStrokeAccessibleHover)",
  colorNeutralStrokeAccessiblePressed: "var(--colorNeutralStrokeAccessiblePressed)",
  colorNeutralStrokeAccessibleSelected: "var(--colorNeutralStrokeAccessibleSelected)",
  colorNeutralStroke1: "var(--colorNeutralStroke1)",
  colorNeutralStroke1Hover: "var(--colorNeutralStroke1Hover)",
  colorNeutralStroke1Pressed: "var(--colorNeutralStroke1Pressed)",
  colorNeutralStroke1Selected: "var(--colorNeutralStroke1Selected)",
  colorNeutralStroke2: "var(--colorNeutralStroke2)",
  colorNeutralStroke3: "var(--colorNeutralStroke3)",
  colorNeutralStrokeSubtle: "var(--colorNeutralStrokeSubtle)",
  colorNeutralStrokeOnBrand: "var(--colorNeutralStrokeOnBrand)",
  colorNeutralStrokeOnBrand2: "var(--colorNeutralStrokeOnBrand2)",
  colorNeutralStrokeOnBrand2Hover: "var(--colorNeutralStrokeOnBrand2Hover)",
  colorNeutralStrokeOnBrand2Pressed: "var(--colorNeutralStrokeOnBrand2Pressed)",
  colorNeutralStrokeOnBrand2Selected: "var(--colorNeutralStrokeOnBrand2Selected)",
  colorBrandStroke1: "var(--colorBrandStroke1)",
  colorBrandStroke2: "var(--colorBrandStroke2)",
  colorBrandStroke2Hover: "var(--colorBrandStroke2Hover)",
  colorBrandStroke2Pressed: "var(--colorBrandStroke2Pressed)",
  colorBrandStroke2Contrast: "var(--colorBrandStroke2Contrast)",
  colorCompoundBrandStroke: "var(--colorCompoundBrandStroke)",
  colorCompoundBrandStrokeHover: "var(--colorCompoundBrandStrokeHover)",
  colorCompoundBrandStrokePressed: "var(--colorCompoundBrandStrokePressed)",
  colorNeutralStrokeDisabled: "var(--colorNeutralStrokeDisabled)",
  colorNeutralStrokeInvertedDisabled: "var(--colorNeutralStrokeInvertedDisabled)",
  colorTransparentStroke: "var(--colorTransparentStroke)",
  colorTransparentStrokeInteractive: "var(--colorTransparentStrokeInteractive)",
  colorTransparentStrokeDisabled: "var(--colorTransparentStrokeDisabled)",
  colorNeutralStrokeAlpha: "var(--colorNeutralStrokeAlpha)",
  colorNeutralStrokeAlpha2: "var(--colorNeutralStrokeAlpha2)",
  colorStrokeFocus1: "var(--colorStrokeFocus1)",
  colorStrokeFocus2: "var(--colorStrokeFocus2)",
  colorNeutralShadowAmbient: "var(--colorNeutralShadowAmbient)",
  colorNeutralShadowKey: "var(--colorNeutralShadowKey)",
  colorNeutralShadowAmbientLighter: "var(--colorNeutralShadowAmbientLighter)",
  colorNeutralShadowKeyLighter: "var(--colorNeutralShadowKeyLighter)",
  colorNeutralShadowAmbientDarker: "var(--colorNeutralShadowAmbientDarker)",
  colorNeutralShadowKeyDarker: "var(--colorNeutralShadowKeyDarker)",
  colorBrandShadowAmbient: "var(--colorBrandShadowAmbient)",
  colorBrandShadowKey: "var(--colorBrandShadowKey)",
  // Color palette tokens
  // Color palette red tokens
  colorPaletteRedBackground1: "var(--colorPaletteRedBackground1)",
  colorPaletteRedBackground2: "var(--colorPaletteRedBackground2)",
  colorPaletteRedBackground3: "var(--colorPaletteRedBackground3)",
  colorPaletteRedBorderActive: "var(--colorPaletteRedBorderActive)",
  colorPaletteRedBorder1: "var(--colorPaletteRedBorder1)",
  colorPaletteRedBorder2: "var(--colorPaletteRedBorder2)",
  colorPaletteRedForeground1: "var(--colorPaletteRedForeground1)",
  colorPaletteRedForeground2: "var(--colorPaletteRedForeground2)",
  colorPaletteRedForeground3: "var(--colorPaletteRedForeground3)",
  colorPaletteRedForegroundInverted: "var(--colorPaletteRedForegroundInverted)",
  // Color palette green tokens
  colorPaletteGreenBackground1: "var(--colorPaletteGreenBackground1)",
  colorPaletteGreenBackground2: "var(--colorPaletteGreenBackground2)",
  colorPaletteGreenBackground3: "var(--colorPaletteGreenBackground3)",
  colorPaletteGreenBorderActive: "var(--colorPaletteGreenBorderActive)",
  colorPaletteGreenBorder1: "var(--colorPaletteGreenBorder1)",
  colorPaletteGreenBorder2: "var(--colorPaletteGreenBorder2)",
  colorPaletteGreenForeground1: "var(--colorPaletteGreenForeground1)",
  colorPaletteGreenForeground2: "var(--colorPaletteGreenForeground2)",
  colorPaletteGreenForeground3: "var(--colorPaletteGreenForeground3)",
  colorPaletteGreenForegroundInverted: "var(--colorPaletteGreenForegroundInverted)",
  // Color palette dark orange tokens
  colorPaletteDarkOrangeBackground1: "var(--colorPaletteDarkOrangeBackground1)",
  colorPaletteDarkOrangeBackground2: "var(--colorPaletteDarkOrangeBackground2)",
  colorPaletteDarkOrangeBackground3: "var(--colorPaletteDarkOrangeBackground3)",
  colorPaletteDarkOrangeBorderActive: "var(--colorPaletteDarkOrangeBorderActive)",
  colorPaletteDarkOrangeBorder1: "var(--colorPaletteDarkOrangeBorder1)",
  colorPaletteDarkOrangeBorder2: "var(--colorPaletteDarkOrangeBorder2)",
  colorPaletteDarkOrangeForeground1: "var(--colorPaletteDarkOrangeForeground1)",
  colorPaletteDarkOrangeForeground2: "var(--colorPaletteDarkOrangeForeground2)",
  colorPaletteDarkOrangeForeground3: "var(--colorPaletteDarkOrangeForeground3)",
  // Color palette yellow tokens
  colorPaletteYellowBackground1: "var(--colorPaletteYellowBackground1)",
  colorPaletteYellowBackground2: "var(--colorPaletteYellowBackground2)",
  colorPaletteYellowBackground3: "var(--colorPaletteYellowBackground3)",
  colorPaletteYellowBorderActive: "var(--colorPaletteYellowBorderActive)",
  colorPaletteYellowBorder1: "var(--colorPaletteYellowBorder1)",
  colorPaletteYellowBorder2: "var(--colorPaletteYellowBorder2)",
  colorPaletteYellowForeground1: "var(--colorPaletteYellowForeground1)",
  colorPaletteYellowForeground2: "var(--colorPaletteYellowForeground2)",
  colorPaletteYellowForeground3: "var(--colorPaletteYellowForeground3)",
  colorPaletteYellowForegroundInverted: "var(--colorPaletteYellowForegroundInverted)",
  // Color palette berry tokens
  colorPaletteBerryBackground1: "var(--colorPaletteBerryBackground1)",
  colorPaletteBerryBackground2: "var(--colorPaletteBerryBackground2)",
  colorPaletteBerryBackground3: "var(--colorPaletteBerryBackground3)",
  colorPaletteBerryBorderActive: "var(--colorPaletteBerryBorderActive)",
  colorPaletteBerryBorder1: "var(--colorPaletteBerryBorder1)",
  colorPaletteBerryBorder2: "var(--colorPaletteBerryBorder2)",
  colorPaletteBerryForeground1: "var(--colorPaletteBerryForeground1)",
  colorPaletteBerryForeground2: "var(--colorPaletteBerryForeground2)",
  colorPaletteBerryForeground3: "var(--colorPaletteBerryForeground3)",
  // Color palette marigold tokens
  colorPaletteMarigoldBackground1: "var(--colorPaletteMarigoldBackground1)",
  colorPaletteMarigoldBackground2: "var(--colorPaletteMarigoldBackground2)",
  colorPaletteMarigoldBackground3: "var(--colorPaletteMarigoldBackground3)",
  colorPaletteMarigoldBorderActive: "var(--colorPaletteMarigoldBorderActive)",
  colorPaletteMarigoldBorder1: "var(--colorPaletteMarigoldBorder1)",
  colorPaletteMarigoldBorder2: "var(--colorPaletteMarigoldBorder2)",
  colorPaletteMarigoldForeground1: "var(--colorPaletteMarigoldForeground1)",
  colorPaletteMarigoldForeground2: "var(--colorPaletteMarigoldForeground2)",
  colorPaletteMarigoldForeground3: "var(--colorPaletteMarigoldForeground3)",
  // Color palette light green tokens
  colorPaletteLightGreenBackground1: "var(--colorPaletteLightGreenBackground1)",
  colorPaletteLightGreenBackground2: "var(--colorPaletteLightGreenBackground2)",
  colorPaletteLightGreenBackground3: "var(--colorPaletteLightGreenBackground3)",
  colorPaletteLightGreenBorderActive: "var(--colorPaletteLightGreenBorderActive)",
  colorPaletteLightGreenBorder1: "var(--colorPaletteLightGreenBorder1)",
  colorPaletteLightGreenBorder2: "var(--colorPaletteLightGreenBorder2)",
  colorPaletteLightGreenForeground1: "var(--colorPaletteLightGreenForeground1)",
  colorPaletteLightGreenForeground2: "var(--colorPaletteLightGreenForeground2)",
  colorPaletteLightGreenForeground3: "var(--colorPaletteLightGreenForeground3)",
  // Color palette anchor tokens
  colorPaletteAnchorBackground2: "var(--colorPaletteAnchorBackground2)",
  colorPaletteAnchorBorderActive: "var(--colorPaletteAnchorBorderActive)",
  colorPaletteAnchorForeground2: "var(--colorPaletteAnchorForeground2)",
  // Color palette beige tokens
  colorPaletteBeigeBackground2: "var(--colorPaletteBeigeBackground2)",
  colorPaletteBeigeBorderActive: "var(--colorPaletteBeigeBorderActive)",
  colorPaletteBeigeForeground2: "var(--colorPaletteBeigeForeground2)",
  // Color palette blue tokens
  colorPaletteBlueBackground2: "var(--colorPaletteBlueBackground2)",
  colorPaletteBlueBorderActive: "var(--colorPaletteBlueBorderActive)",
  colorPaletteBlueForeground2: "var(--colorPaletteBlueForeground2)",
  // Color palette brass tokens
  colorPaletteBrassBackground2: "var(--colorPaletteBrassBackground2)",
  colorPaletteBrassBorderActive: "var(--colorPaletteBrassBorderActive)",
  colorPaletteBrassForeground2: "var(--colorPaletteBrassForeground2)",
  // Color palette brown tokens
  colorPaletteBrownBackground2: "var(--colorPaletteBrownBackground2)",
  colorPaletteBrownBorderActive: "var(--colorPaletteBrownBorderActive)",
  colorPaletteBrownForeground2: "var(--colorPaletteBrownForeground2)",
  // Color palette cornflower tokens
  colorPaletteCornflowerBackground2: "var(--colorPaletteCornflowerBackground2)",
  colorPaletteCornflowerBorderActive: "var(--colorPaletteCornflowerBorderActive)",
  colorPaletteCornflowerForeground2: "var(--colorPaletteCornflowerForeground2)",
  // Color palette cranberry tokens
  colorPaletteCranberryBackground2: "var(--colorPaletteCranberryBackground2)",
  colorPaletteCranberryBorderActive: "var(--colorPaletteCranberryBorderActive)",
  colorPaletteCranberryForeground2: "var(--colorPaletteCranberryForeground2)",
  // Color palette dark green tokens
  colorPaletteDarkGreenBackground2: "var(--colorPaletteDarkGreenBackground2)",
  colorPaletteDarkGreenBorderActive: "var(--colorPaletteDarkGreenBorderActive)",
  colorPaletteDarkGreenForeground2: "var(--colorPaletteDarkGreenForeground2)",
  // Color palette dark red tokens
  colorPaletteDarkRedBackground2: "var(--colorPaletteDarkRedBackground2)",
  colorPaletteDarkRedBorderActive: "var(--colorPaletteDarkRedBorderActive)",
  colorPaletteDarkRedForeground2: "var(--colorPaletteDarkRedForeground2)",
  // Color palette forest tokens
  colorPaletteForestBackground2: "var(--colorPaletteForestBackground2)",
  colorPaletteForestBorderActive: "var(--colorPaletteForestBorderActive)",
  colorPaletteForestForeground2: "var(--colorPaletteForestForeground2)",
  // Color palette gold tokens
  colorPaletteGoldBackground2: "var(--colorPaletteGoldBackground2)",
  colorPaletteGoldBorderActive: "var(--colorPaletteGoldBorderActive)",
  colorPaletteGoldForeground2: "var(--colorPaletteGoldForeground2)",
  // Color palette grape tokens
  colorPaletteGrapeBackground2: "var(--colorPaletteGrapeBackground2)",
  colorPaletteGrapeBorderActive: "var(--colorPaletteGrapeBorderActive)",
  colorPaletteGrapeForeground2: "var(--colorPaletteGrapeForeground2)",
  // Color palette lavender tokens
  colorPaletteLavenderBackground2: "var(--colorPaletteLavenderBackground2)",
  colorPaletteLavenderBorderActive: "var(--colorPaletteLavenderBorderActive)",
  colorPaletteLavenderForeground2: "var(--colorPaletteLavenderForeground2)",
  // Color palette light teal tokens
  colorPaletteLightTealBackground2: "var(--colorPaletteLightTealBackground2)",
  colorPaletteLightTealBorderActive: "var(--colorPaletteLightTealBorderActive)",
  colorPaletteLightTealForeground2: "var(--colorPaletteLightTealForeground2)",
  // Color palette lilac tokens
  colorPaletteLilacBackground2: "var(--colorPaletteLilacBackground2)",
  colorPaletteLilacBorderActive: "var(--colorPaletteLilacBorderActive)",
  colorPaletteLilacForeground2: "var(--colorPaletteLilacForeground2)",
  // Color palette magenta tokens
  colorPaletteMagentaBackground2: "var(--colorPaletteMagentaBackground2)",
  colorPaletteMagentaBorderActive: "var(--colorPaletteMagentaBorderActive)",
  colorPaletteMagentaForeground2: "var(--colorPaletteMagentaForeground2)",
  // Color palette mink tokens
  colorPaletteMinkBackground2: "var(--colorPaletteMinkBackground2)",
  colorPaletteMinkBorderActive: "var(--colorPaletteMinkBorderActive)",
  colorPaletteMinkForeground2: "var(--colorPaletteMinkForeground2)",
  // Color palette navy tokens
  colorPaletteNavyBackground2: "var(--colorPaletteNavyBackground2)",
  colorPaletteNavyBorderActive: "var(--colorPaletteNavyBorderActive)",
  colorPaletteNavyForeground2: "var(--colorPaletteNavyForeground2)",
  // Color palette peach tokens
  colorPalettePeachBackground2: "var(--colorPalettePeachBackground2)",
  colorPalettePeachBorderActive: "var(--colorPalettePeachBorderActive)",
  colorPalettePeachForeground2: "var(--colorPalettePeachForeground2)",
  // Color palette pink tokens
  colorPalettePinkBackground2: "var(--colorPalettePinkBackground2)",
  colorPalettePinkBorderActive: "var(--colorPalettePinkBorderActive)",
  colorPalettePinkForeground2: "var(--colorPalettePinkForeground2)",
  // Color palette platinum tokens
  colorPalettePlatinumBackground2: "var(--colorPalettePlatinumBackground2)",
  colorPalettePlatinumBorderActive: "var(--colorPalettePlatinumBorderActive)",
  colorPalettePlatinumForeground2: "var(--colorPalettePlatinumForeground2)",
  // Color palette plum tokens
  colorPalettePlumBackground2: "var(--colorPalettePlumBackground2)",
  colorPalettePlumBorderActive: "var(--colorPalettePlumBorderActive)",
  colorPalettePlumForeground2: "var(--colorPalettePlumForeground2)",
  // Color palette pumpkin tokens
  colorPalettePumpkinBackground2: "var(--colorPalettePumpkinBackground2)",
  colorPalettePumpkinBorderActive: "var(--colorPalettePumpkinBorderActive)",
  colorPalettePumpkinForeground2: "var(--colorPalettePumpkinForeground2)",
  // Color palette purple tokens
  colorPalettePurpleBackground2: "var(--colorPalettePurpleBackground2)",
  colorPalettePurpleBorderActive: "var(--colorPalettePurpleBorderActive)",
  colorPalettePurpleForeground2: "var(--colorPalettePurpleForeground2)",
  // Color palette royal blue tokens
  colorPaletteRoyalBlueBackground2: "var(--colorPaletteRoyalBlueBackground2)",
  colorPaletteRoyalBlueBorderActive: "var(--colorPaletteRoyalBlueBorderActive)",
  colorPaletteRoyalBlueForeground2: "var(--colorPaletteRoyalBlueForeground2)",
  // Color palette seafoam tokens
  colorPaletteSeafoamBackground2: "var(--colorPaletteSeafoamBackground2)",
  colorPaletteSeafoamBorderActive: "var(--colorPaletteSeafoamBorderActive)",
  colorPaletteSeafoamForeground2: "var(--colorPaletteSeafoamForeground2)",
  // Color palette steel tokens
  colorPaletteSteelBackground2: "var(--colorPaletteSteelBackground2)",
  colorPaletteSteelBorderActive: "var(--colorPaletteSteelBorderActive)",
  colorPaletteSteelForeground2: "var(--colorPaletteSteelForeground2)",
  // Color palette teal tokens
  colorPaletteTealBackground2: "var(--colorPaletteTealBackground2)",
  colorPaletteTealBorderActive: "var(--colorPaletteTealBorderActive)",
  colorPaletteTealForeground2: "var(--colorPaletteTealForeground2)",
  // Color status success tokens
  colorStatusSuccessBackground1: "var(--colorStatusSuccessBackground1)",
  colorStatusSuccessBackground2: "var(--colorStatusSuccessBackground2)",
  colorStatusSuccessBackground3: "var(--colorStatusSuccessBackground3)",
  colorStatusSuccessForeground1: "var(--colorStatusSuccessForeground1)",
  colorStatusSuccessForeground2: "var(--colorStatusSuccessForeground2)",
  colorStatusSuccessForeground3: "var(--colorStatusSuccessForeground3)",
  colorStatusSuccessForegroundInverted: "var(--colorStatusSuccessForegroundInverted)",
  colorStatusSuccessBorderActive: "var(--colorStatusSuccessBorderActive)",
  colorStatusSuccessBorder1: "var(--colorStatusSuccessBorder1)",
  colorStatusSuccessBorder2: "var(--colorStatusSuccessBorder2)",
  // Color status warning tokens
  colorStatusWarningBackground1: "var(--colorStatusWarningBackground1)",
  colorStatusWarningBackground2: "var(--colorStatusWarningBackground2)",
  colorStatusWarningBackground3: "var(--colorStatusWarningBackground3)",
  colorStatusWarningForeground1: "var(--colorStatusWarningForeground1)",
  colorStatusWarningForeground2: "var(--colorStatusWarningForeground2)",
  colorStatusWarningForeground3: "var(--colorStatusWarningForeground3)",
  colorStatusWarningForegroundInverted: "var(--colorStatusWarningForegroundInverted)",
  colorStatusWarningBorderActive: "var(--colorStatusWarningBorderActive)",
  colorStatusWarningBorder1: "var(--colorStatusWarningBorder1)",
  colorStatusWarningBorder2: "var(--colorStatusWarningBorder2)",
  // Color status danger tokens
  colorStatusDangerBackground1: "var(--colorStatusDangerBackground1)",
  colorStatusDangerBackground2: "var(--colorStatusDangerBackground2)",
  colorStatusDangerBackground3: "var(--colorStatusDangerBackground3)",
  colorStatusDangerBackground3Hover: "var(--colorStatusDangerBackground3Hover)",
  colorStatusDangerBackground3Pressed: "var(--colorStatusDangerBackground3Pressed)",
  colorStatusDangerForeground1: "var(--colorStatusDangerForeground1)",
  colorStatusDangerForeground2: "var(--colorStatusDangerForeground2)",
  colorStatusDangerForeground3: "var(--colorStatusDangerForeground3)",
  colorStatusDangerForegroundInverted: "var(--colorStatusDangerForegroundInverted)",
  colorStatusDangerBorderActive: "var(--colorStatusDangerBorderActive)",
  colorStatusDangerBorder1: "var(--colorStatusDangerBorder1)",
  colorStatusDangerBorder2: "var(--colorStatusDangerBorder2)",
  // Border radius tokens
  borderRadiusNone: "var(--borderRadiusNone)",
  borderRadiusSmall: "var(--borderRadiusSmall)",
  borderRadiusMedium: "var(--borderRadiusMedium)",
  borderRadiusLarge: "var(--borderRadiusLarge)",
  borderRadiusXLarge: "var(--borderRadiusXLarge)",
  borderRadiusCircular: "var(--borderRadiusCircular)",
  // Font family tokens
  fontFamilyBase: "var(--fontFamilyBase)",
  fontFamilyMonospace: "var(--fontFamilyMonospace)",
  fontFamilyNumeric: "var(--fontFamilyNumeric)",
  // Font size tokens
  fontSizeBase100: "var(--fontSizeBase100)",
  fontSizeBase200: "var(--fontSizeBase200)",
  fontSizeBase300: "var(--fontSizeBase300)",
  fontSizeBase400: "var(--fontSizeBase400)",
  fontSizeBase500: "var(--fontSizeBase500)",
  fontSizeBase600: "var(--fontSizeBase600)",
  fontSizeHero700: "var(--fontSizeHero700)",
  fontSizeHero800: "var(--fontSizeHero800)",
  fontSizeHero900: "var(--fontSizeHero900)",
  fontSizeHero1000: "var(--fontSizeHero1000)",
  // Font weight tokens
  fontWeightRegular: "var(--fontWeightRegular)",
  fontWeightMedium: "var(--fontWeightMedium)",
  fontWeightSemibold: "var(--fontWeightSemibold)",
  fontWeightBold: "var(--fontWeightBold)",
  // Line height tokens
  lineHeightBase100: "var(--lineHeightBase100)",
  lineHeightBase200: "var(--lineHeightBase200)",
  lineHeightBase300: "var(--lineHeightBase300)",
  lineHeightBase400: "var(--lineHeightBase400)",
  lineHeightBase500: "var(--lineHeightBase500)",
  lineHeightBase600: "var(--lineHeightBase600)",
  lineHeightHero700: "var(--lineHeightHero700)",
  lineHeightHero800: "var(--lineHeightHero800)",
  lineHeightHero900: "var(--lineHeightHero900)",
  lineHeightHero1000: "var(--lineHeightHero1000)",
  // Shadow tokens
  shadow2: "var(--shadow2)",
  shadow4: "var(--shadow4)",
  shadow8: "var(--shadow8)",
  shadow16: "var(--shadow16)",
  shadow28: "var(--shadow28)",
  shadow64: "var(--shadow64)",
  // Shadow brand tokens
  shadow2Brand: "var(--shadow2Brand)",
  shadow4Brand: "var(--shadow4Brand)",
  shadow8Brand: "var(--shadow8Brand)",
  shadow16Brand: "var(--shadow16Brand)",
  shadow28Brand: "var(--shadow28Brand)",
  shadow64Brand: "var(--shadow64Brand)",
  // Stroke width tokens
  strokeWidthThin: "var(--strokeWidthThin)",
  strokeWidthThick: "var(--strokeWidthThick)",
  strokeWidthThicker: "var(--strokeWidthThicker)",
  strokeWidthThickest: "var(--strokeWidthThickest)",
  // Spacings
  spacingHorizontalNone: "var(--spacingHorizontalNone)",
  spacingHorizontalXXS: "var(--spacingHorizontalXXS)",
  spacingHorizontalXS: "var(--spacingHorizontalXS)",
  spacingHorizontalSNudge: "var(--spacingHorizontalSNudge)",
  spacingHorizontalS: "var(--spacingHorizontalS)",
  spacingHorizontalMNudge: "var(--spacingHorizontalMNudge)",
  spacingHorizontalM: "var(--spacingHorizontalM)",
  spacingHorizontalL: "var(--spacingHorizontalL)",
  spacingHorizontalXL: "var(--spacingHorizontalXL)",
  spacingHorizontalXXL: "var(--spacingHorizontalXXL)",
  spacingHorizontalXXXL: "var(--spacingHorizontalXXXL)",
  spacingVerticalNone: "var(--spacingVerticalNone)",
  spacingVerticalXXS: "var(--spacingVerticalXXS)",
  spacingVerticalXS: "var(--spacingVerticalXS)",
  spacingVerticalSNudge: "var(--spacingVerticalSNudge)",
  spacingVerticalS: "var(--spacingVerticalS)",
  spacingVerticalMNudge: "var(--spacingVerticalMNudge)",
  spacingVerticalM: "var(--spacingVerticalM)",
  spacingVerticalL: "var(--spacingVerticalL)",
  spacingVerticalXL: "var(--spacingVerticalXL)",
  spacingVerticalXXL: "var(--spacingVerticalXXL)",
  spacingVerticalXXXL: "var(--spacingVerticalXXXL)",
  // Durations
  durationUltraFast: "var(--durationUltraFast)",
  durationFaster: "var(--durationFaster)",
  durationFast: "var(--durationFast)",
  durationNormal: "var(--durationNormal)",
  durationGentle: "var(--durationGentle)",
  durationSlow: "var(--durationSlow)",
  durationSlower: "var(--durationSlower)",
  durationUltraSlow: "var(--durationUltraSlow)",
  // Curves
  curveAccelerateMax: "var(--curveAccelerateMax)",
  curveAccelerateMid: "var(--curveAccelerateMid)",
  curveAccelerateMin: "var(--curveAccelerateMin)",
  curveDecelerateMax: "var(--curveDecelerateMax)",
  curveDecelerateMid: "var(--curveDecelerateMid)",
  curveDecelerateMin: "var(--curveDecelerateMin)",
  curveEasyEaseMax: "var(--curveEasyEaseMax)",
  curveEasyEase: "var(--curveEasyEase)",
  curveLinear: "var(--curveLinear)",
  /**
  * ZIndexes
  * Special case where the tokens contain default values
  * ZIndexes are not mandatory, so they are not included in the theme, but can be used as tokens with default values
  */
  /**
  * Elevation 0
  * Can be used for background elements, like surfaces
  */
  zIndexBackground: "var(--zIndexBackground, 0)",
  /**
  * Elevation 2
  * Can be used content that is on top of the background, like cards
  */
  zIndexContent: "var(--zIndexContent, 1)",
  /**
  * Elevation 4
  * Can be used for overlays, like the backdrop of a modal
  */
  zIndexOverlay: "var(--zIndexOverlay, 1000)",
  /**
  * Elevation 8
  * Can be used for popups, like modals and drawers
  */
  zIndexPopup: "var(--zIndexPopup, 2000)",
  /**
  * Elevation 16
  * Can be used for messages, like snackbars and toasts
  */
  zIndexMessages: "var(--zIndexMessages, 3000)",
  /**
  * Elevation 28
  * Can be used for floating elements, like dropdowns
  */
  zIndexFloating: "var(--zIndexFloating, 4000)",
  /**
  * Elevation 64
  * Can be used for high priority floating elements, like tooltips
  */
  zIndexPriority: "var(--zIndexPriority, 5000)",
  /**
  * Special elevation
  * Can be used for elements that need to be above everything else, like debug overlays
  */
  zIndexDebug: "var(--zIndexDebug, 6000)"
};

// node_modules/@fluentui/tokens/lib/global/typographyStyles.js
var typographyStyles = {
  body1: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase300,
    fontWeight: tokens.fontWeightRegular,
    lineHeight: tokens.lineHeightBase300
  },
  body1Strong: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase300,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase300
  },
  body1Stronger: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase300,
    fontWeight: tokens.fontWeightBold,
    lineHeight: tokens.lineHeightBase300
  },
  body2: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase400,
    fontWeight: tokens.fontWeightRegular,
    lineHeight: tokens.lineHeightBase400
  },
  caption1: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase200,
    fontWeight: tokens.fontWeightRegular,
    lineHeight: tokens.lineHeightBase200
  },
  caption1Strong: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase200,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase200
  },
  caption1Stronger: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase200,
    fontWeight: tokens.fontWeightBold,
    lineHeight: tokens.lineHeightBase200
  },
  caption2: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase100,
    fontWeight: tokens.fontWeightRegular,
    lineHeight: tokens.lineHeightBase100
  },
  caption2Strong: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase100,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase100
  },
  subtitle1: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase500,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase500
  },
  subtitle2: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase400,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase400
  },
  subtitle2Stronger: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase400,
    fontWeight: tokens.fontWeightBold,
    lineHeight: tokens.lineHeightBase400
  },
  title1: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeHero800,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightHero800
  },
  title2: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeHero700,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightHero700
  },
  title3: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase600,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase600
  },
  largeTitle: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeHero900,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightHero900
  },
  display: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeHero1000,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightHero1000
  }
};

// node_modules/@fluentui/tokens/lib/utils/shadows.js
function createShadowTokens(ambientColor, keyColor, tokenSuffix = "") {
  return {
    [`shadow2${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 1px 2px ${keyColor}`,
    [`shadow4${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 2px 4px ${keyColor}`,
    [`shadow8${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 4px 8px ${keyColor}`,
    [`shadow16${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 8px 16px ${keyColor}`,
    [`shadow28${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 14px 28px ${keyColor}`,
    [`shadow64${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 32px 64px ${keyColor}`
  };
}

// node_modules/@fluentui/tokens/lib/utils/createLightTheme.js
var createLightTheme = (brand) => {
  const colorTokens = generateColorTokens(brand);
  return {
    ...borderRadius,
    ...fontSizes,
    ...lineHeights,
    ...fontFamilies,
    ...fontWeights,
    ...strokeWidths,
    ...horizontalSpacings,
    ...verticalSpacings,
    ...durations,
    ...curves,
    ...colorTokens,
    ...colorPaletteTokens,
    ...colorStatusTokens,
    ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
    ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
  };
};

// node_modules/@fluentui/tokens/lib/global/brandColors.js
var brandWeb = {
  10: `#061724`,
  20: `#082338`,
  30: `#0a2e4a`,
  40: `#0c3b5e`,
  50: `#0e4775`,
  60: `#0f548c`,
  70: `#115ea3`,
  80: `#0f6cbd`,
  90: `#2886de`,
  100: `#479ef5`,
  110: `#62abf5`,
  120: `#77b7f7`,
  130: `#96c6fa`,
  140: `#b4d6fa`,
  150: `#cfe4fa`,
  160: `#ebf3fc`
};
var brandTeams = {
  10: `#2b2b40`,
  20: `#2f2f4a`,
  30: `#333357`,
  40: `#383966`,
  50: `#3d3e78`,
  60: `#444791`,
  70: `#4f52b2`,
  80: `#5b5fc7`,
  90: `#7579eb`,
  100: `#7f85f5`,
  110: `#9299f7`,
  120: `#aab1fa`,
  130: `#b6bcfa`,
  140: `#c5cbfa`,
  150: `#dce0fa`,
  160: `#e8ebfa`
};
var brandTeamsV21 = {
  10: `#29274f`,
  20: `#2f2a5e`,
  30: `#352e70`,
  40: `#3b3185`,
  50: `#44359e`,
  60: `#4d3aba`,
  70: `#5a40db`,
  80: `#654cf5`,
  90: `#7769fa`,
  100: `#887dff`,
  110: `#9791ff`,
  120: `#aba8ff`,
  130: `#bab8ff`,
  140: `#c8c7ff`,
  150: `#dcdbff`,
  160: `#e8e8ff`
};

// node_modules/@fluentui/tokens/lib/alias/teamsFontFamilies.js
var fontFamilies2 = {
  ...fontFamilies,
  fontFamilyBase: '-apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, "Apple Color Emoji", "Segoe UI Emoji", sans-serif'
};

// node_modules/@fluentui/tokens/lib/themes/teams/lightTheme.js
var teamsLightTheme = {
  ...createLightTheme(brandTeams),
  ...fontFamilies2
};
var teamsLightV21Theme = {
  ...createLightTheme(brandTeamsV21),
  ...fontFamilies2
};

// node_modules/@fluentui/tokens/lib/alias/darkColorPalette.js
var statusColorPaletteTokens2 = statusSharedColorNames.reduce((acc, sharedColor) => {
  const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color2}Background1`]: statusSharedColors[sharedColor].shade40,
    [`colorPalette${color2}Background2`]: statusSharedColors[sharedColor].shade30,
    [`colorPalette${color2}Background3`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color2}Foreground1`]: statusSharedColors[sharedColor].tint30,
    [`colorPalette${color2}Foreground2`]: statusSharedColors[sharedColor].tint40,
    [`colorPalette${color2}Foreground3`]: statusSharedColors[sharedColor].tint20,
    [`colorPalette${color2}BorderActive`]: statusSharedColors[sharedColor].tint30,
    [`colorPalette${color2}Border1`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color2}Border2`]: statusSharedColors[sharedColor].tint20
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
statusColorPaletteTokens2.colorPaletteRedForeground3 = statusSharedColors.red.tint30;
statusColorPaletteTokens2.colorPaletteRedBorder2 = statusSharedColors.red.tint30;
statusColorPaletteTokens2.colorPaletteGreenForeground3 = statusSharedColors.green.tint40;
statusColorPaletteTokens2.colorPaletteGreenBorder2 = statusSharedColors.green.tint40;
statusColorPaletteTokens2.colorPaletteDarkOrangeForeground3 = statusSharedColors.darkOrange.tint30;
statusColorPaletteTokens2.colorPaletteDarkOrangeBorder2 = statusSharedColors.darkOrange.tint30;
statusColorPaletteTokens2.colorPaletteRedForegroundInverted = statusSharedColors.red.primary;
statusColorPaletteTokens2.colorPaletteGreenForegroundInverted = statusSharedColors.green.primary;
statusColorPaletteTokens2.colorPaletteYellowForegroundInverted = statusSharedColors.yellow.shade30;
var personaColorPaletteTokens2 = personaSharedColorNames.reduce((acc, sharedColor) => {
  const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color2}Background2`]: personaSharedColors[sharedColor].shade30,
    [`colorPalette${color2}Foreground2`]: personaSharedColors[sharedColor].tint40,
    [`colorPalette${color2}BorderActive`]: personaSharedColors[sharedColor].tint30
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
personaColorPaletteTokens2.colorPaletteDarkRedBackground2 = personaSharedColors.darkRed.shade20;
personaColorPaletteTokens2.colorPalettePlumBackground2 = personaSharedColors.plum.shade20;
var colorPaletteTokens2 = {
  ...statusColorPaletteTokens2,
  ...personaColorPaletteTokens2
};
var colorStatusTokens2 = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
  const color2 = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
  const statusColorTokens = {
    [`colorStatus${color2}Background1`]: mappedStatusColors[sharedColor].shade40,
    [`colorStatus${color2}Background2`]: mappedStatusColors[sharedColor].shade30,
    [`colorStatus${color2}Background3`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color2}Foreground1`]: mappedStatusColors[sharedColor].tint30,
    [`colorStatus${color2}Foreground2`]: mappedStatusColors[sharedColor].tint40,
    [`colorStatus${color2}Foreground3`]: mappedStatusColors[sharedColor].tint20,
    [`colorStatus${color2}BorderActive`]: mappedStatusColors[sharedColor].tint30,
    [`colorStatus${color2}ForegroundInverted`]: mappedStatusColors[sharedColor].shade10,
    [`colorStatus${color2}Border1`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color2}Border2`]: mappedStatusColors[sharedColor].tint20
  };
  return Object.assign(acc, statusColorTokens);
}, {});
colorStatusTokens2.colorStatusDangerBackground3Hover = mappedStatusColors[statusColorMapping.danger].shade10;
colorStatusTokens2.colorStatusDangerBackground3Pressed = mappedStatusColors[statusColorMapping.danger].shade20;
colorStatusTokens2.colorStatusDangerForeground3 = mappedStatusColors[statusColorMapping.danger].tint40;
colorStatusTokens2.colorStatusDangerBorder2 = mappedStatusColors[statusColorMapping.danger].tint30;
colorStatusTokens2.colorStatusSuccessForeground3 = mappedStatusColors[statusColorMapping.success].tint40;
colorStatusTokens2.colorStatusSuccessBorder2 = mappedStatusColors[statusColorMapping.success].tint40;
colorStatusTokens2.colorStatusWarningForegroundInverted = mappedStatusColors[statusColorMapping.warning].shade20;

// node_modules/@fluentui/tokens/lib/alias/teamsDarkColor.js
var generateColorTokens2 = (brand) => ({
  colorNeutralForeground1: white,
  colorNeutralForeground1Hover: white,
  colorNeutralForeground1Pressed: white,
  colorNeutralForeground1Selected: white,
  colorNeutralForeground2: grey[84],
  colorNeutralForeground2Hover: white,
  colorNeutralForeground2Pressed: white,
  colorNeutralForeground2Selected: white,
  colorNeutralForeground2BrandHover: brand[100],
  colorNeutralForeground2BrandPressed: brand[90],
  colorNeutralForeground2BrandSelected: brand[100],
  colorNeutralForeground3: grey[68],
  colorNeutralForeground3Hover: grey[84],
  colorNeutralForeground3Pressed: grey[84],
  colorNeutralForeground3Selected: grey[84],
  colorNeutralForeground3BrandHover: brand[100],
  colorNeutralForeground3BrandPressed: brand[90],
  colorNeutralForeground3BrandSelected: brand[100],
  colorNeutralForeground4: grey[60],
  colorNeutralForegroundDisabled: grey[36],
  colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
  colorBrandForegroundLink: brand[100],
  colorBrandForegroundLinkHover: brand[110],
  colorBrandForegroundLinkPressed: brand[90],
  colorBrandForegroundLinkSelected: brand[100],
  colorNeutralForeground2Link: grey[84],
  colorNeutralForeground2LinkHover: white,
  colorNeutralForeground2LinkPressed: white,
  colorNeutralForeground2LinkSelected: white,
  colorCompoundBrandForeground1: brand[100],
  colorCompoundBrandForeground1Hover: brand[110],
  colorCompoundBrandForeground1Pressed: brand[90],
  colorBrandForeground1: brand[100],
  colorBrandForeground2: brand[120],
  colorBrandForeground2Hover: brand[130],
  colorBrandForeground2Pressed: brand[160],
  colorNeutralForeground1Static: grey[14],
  colorNeutralForegroundStaticInverted: white,
  colorNeutralForegroundInverted: grey[14],
  colorNeutralForegroundInvertedHover: grey[14],
  colorNeutralForegroundInvertedPressed: grey[14],
  colorNeutralForegroundInvertedSelected: grey[14],
  colorNeutralForegroundInverted2: grey[14],
  colorNeutralForegroundOnBrand: white,
  colorNeutralForegroundInvertedLink: white,
  colorNeutralForegroundInvertedLinkHover: white,
  colorNeutralForegroundInvertedLinkPressed: white,
  colorNeutralForegroundInvertedLinkSelected: white,
  colorBrandForegroundInverted: brand[80],
  colorBrandForegroundInvertedHover: brand[70],
  colorBrandForegroundInvertedPressed: brand[60],
  colorBrandForegroundOnLight: brand[80],
  colorBrandForegroundOnLightHover: brand[70],
  colorBrandForegroundOnLightPressed: brand[50],
  colorBrandForegroundOnLightSelected: brand[60],
  colorNeutralBackground1: grey[16],
  colorNeutralBackground1Hover: grey[24],
  colorNeutralBackground1Pressed: grey[12],
  colorNeutralBackground1Selected: grey[22],
  colorNeutralBackground2: grey[14],
  colorNeutralBackground2Hover: grey[22],
  colorNeutralBackground2Pressed: grey[10],
  colorNeutralBackground2Selected: grey[20],
  colorNeutralBackground3: grey[12],
  colorNeutralBackground3Hover: grey[20],
  colorNeutralBackground3Pressed: grey[8],
  colorNeutralBackground3Selected: grey[18],
  colorNeutralBackground4: grey[8],
  colorNeutralBackground4Hover: grey[16],
  colorNeutralBackground4Pressed: grey[4],
  colorNeutralBackground4Selected: grey[14],
  colorNeutralBackground5: grey[4],
  colorNeutralBackground5Hover: grey[12],
  colorNeutralBackground5Pressed: black,
  colorNeutralBackground5Selected: grey[10],
  colorNeutralBackground6: grey[20],
  colorNeutralBackgroundInverted: white,
  colorNeutralBackgroundStatic: grey[24],
  colorNeutralBackgroundAlpha: grey10Alpha[50],
  colorNeutralBackgroundAlpha2: grey12Alpha[70],
  colorSubtleBackground: "transparent",
  colorSubtleBackgroundHover: grey[22],
  colorSubtleBackgroundPressed: grey[18],
  colorSubtleBackgroundSelected: grey[20],
  colorSubtleBackgroundLightAlphaHover: grey14Alpha[80],
  colorSubtleBackgroundLightAlphaPressed: grey14Alpha[50],
  colorSubtleBackgroundLightAlphaSelected: "transparent",
  colorSubtleBackgroundInverted: "transparent",
  colorSubtleBackgroundInvertedHover: blackAlpha[10],
  colorSubtleBackgroundInvertedPressed: blackAlpha[30],
  colorSubtleBackgroundInvertedSelected: blackAlpha[20],
  colorTransparentBackground: "transparent",
  colorTransparentBackgroundHover: "transparent",
  colorTransparentBackgroundPressed: "transparent",
  colorTransparentBackgroundSelected: "transparent",
  colorNeutralBackgroundDisabled: grey[8],
  colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
  colorNeutralStencil1: grey[34],
  colorNeutralStencil2: grey[20],
  colorNeutralStencil1Alpha: whiteAlpha[10],
  colorNeutralStencil2Alpha: whiteAlpha[5],
  colorBackgroundOverlay: blackAlpha[50],
  colorScrollbarOverlay: whiteAlpha[60],
  colorBrandBackground: brand[70],
  colorBrandBackgroundHover: brand[80],
  colorBrandBackgroundPressed: brand[40],
  colorBrandBackgroundSelected: brand[60],
  colorCompoundBrandBackground: brand[100],
  colorCompoundBrandBackgroundHover: brand[110],
  colorCompoundBrandBackgroundPressed: brand[90],
  colorBrandBackgroundStatic: brand[80],
  colorBrandBackground2: brand[20],
  colorBrandBackground2Hover: brand[40],
  colorBrandBackground2Pressed: brand[10],
  colorBrandBackground3Static: brand[60],
  colorBrandBackground4Static: brand[40],
  colorBrandBackgroundInverted: white,
  colorBrandBackgroundInvertedHover: brand[160],
  colorBrandBackgroundInvertedPressed: brand[140],
  colorBrandBackgroundInvertedSelected: brand[150],
  colorNeutralCardBackground: grey[20],
  colorNeutralCardBackgroundHover: grey[24],
  colorNeutralCardBackgroundPressed: grey[18],
  colorNeutralCardBackgroundSelected: grey[22],
  colorNeutralCardBackgroundDisabled: grey[8],
  colorNeutralStrokeAccessible: grey[68],
  colorNeutralStrokeAccessibleHover: grey[74],
  colorNeutralStrokeAccessiblePressed: grey[70],
  colorNeutralStrokeAccessibleSelected: brand[100],
  colorNeutralStroke1: grey[40],
  colorNeutralStroke1Hover: grey[46],
  colorNeutralStroke1Pressed: grey[42],
  colorNeutralStroke1Selected: grey[44],
  colorNeutralStroke2: grey[32],
  colorNeutralStroke3: grey[24],
  colorNeutralStrokeSubtle: grey[4],
  colorNeutralStrokeOnBrand: grey[16],
  colorNeutralStrokeOnBrand2: white,
  colorNeutralStrokeOnBrand2Hover: white,
  colorNeutralStrokeOnBrand2Pressed: white,
  colorNeutralStrokeOnBrand2Selected: white,
  colorBrandStroke1: brand[100],
  colorBrandStroke2: brand[50],
  colorBrandStroke2Hover: brand[50],
  colorBrandStroke2Pressed: brand[30],
  colorBrandStroke2Contrast: brand[50],
  colorCompoundBrandStroke: brand[90],
  colorCompoundBrandStrokeHover: brand[100],
  colorCompoundBrandStrokePressed: brand[80],
  colorNeutralStrokeDisabled: grey[26],
  colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
  colorTransparentStroke: "transparent",
  colorTransparentStrokeInteractive: "transparent",
  colorTransparentStrokeDisabled: "transparent",
  colorNeutralStrokeAlpha: whiteAlpha[10],
  colorNeutralStrokeAlpha2: whiteAlpha[20],
  colorStrokeFocus1: black,
  colorStrokeFocus2: white,
  colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
  colorNeutralShadowKey: "rgba(0,0,0,0.28)",
  colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
  colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
  colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
  colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
  colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
  colorBrandShadowKey: "rgba(0,0,0,0.25)"
});

// node_modules/@fluentui/tokens/lib/utils/createTeamsDarkTheme.js
var createTeamsDarkTheme = (brand) => {
  const colorTokens = generateColorTokens2(brand);
  return {
    ...borderRadius,
    ...fontSizes,
    ...lineHeights,
    ...fontFamilies,
    ...fontWeights,
    ...strokeWidths,
    ...horizontalSpacings,
    ...verticalSpacings,
    ...durations,
    ...curves,
    ...colorTokens,
    ...colorPaletteTokens2,
    ...colorStatusTokens2,
    ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
    ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
  };
};

// node_modules/@fluentui/tokens/lib/themes/teams/darkTheme.js
var teamsDarkTheme = {
  ...createTeamsDarkTheme(brandTeams),
  ...fontFamilies2
};
var teamsDarkV21Theme = {
  ...createTeamsDarkTheme(brandTeamsV21),
  ...fontFamilies2
};

// node_modules/@fluentui/tokens/lib/alias/highContrastColorPalette.js
var statusColorPaletteTokens3 = statusSharedColorNames.reduce((acc, sharedColor) => {
  const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color2}Background1`]: hcCanvas,
    [`colorPalette${color2}Background2`]: hcCanvas,
    [`colorPalette${color2}Background3`]: hcCanvasText,
    [`colorPalette${color2}Foreground1`]: hcCanvasText,
    [`colorPalette${color2}Foreground2`]: hcCanvasText,
    [`colorPalette${color2}Foreground3`]: hcCanvasText,
    [`colorPalette${color2}BorderActive`]: hcHighlight,
    [`colorPalette${color2}Border1`]: hcCanvasText,
    [`colorPalette${color2}Border2`]: hcCanvasText
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
statusColorPaletteTokens3.colorPaletteRedForegroundInverted = hcCanvasText;
statusColorPaletteTokens3.colorPaletteGreenForegroundInverted = hcCanvasText;
statusColorPaletteTokens3.colorPaletteYellowForegroundInverted = hcCanvasText;
var personaColorPaletteTokens3 = personaSharedColorNames.reduce((acc, sharedColor) => {
  const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color2}Background2`]: hcCanvas,
    [`colorPalette${color2}Foreground2`]: hcCanvasText,
    [`colorPalette${color2}BorderActive`]: hcHighlight
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
var colorPaletteTokens3 = {
  ...statusColorPaletteTokens3,
  ...personaColorPaletteTokens3
};
var colorStatusTokens3 = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
  const color2 = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
  const statusColorTokens = {
    [`colorStatus${color2}Background1`]: hcCanvas,
    [`colorStatus${color2}Background2`]: hcCanvas,
    [`colorStatus${color2}Background3`]: hcCanvasText,
    [`colorStatus${color2}Foreground1`]: hcCanvasText,
    [`colorStatus${color2}Foreground2`]: hcCanvasText,
    [`colorStatus${color2}Foreground3`]: hcCanvasText,
    [`colorStatus${color2}BorderActive`]: hcHighlight,
    [`colorStatus${color2}ForegroundInverted`]: hcCanvasText,
    [`colorStatus${color2}Border1`]: hcCanvasText,
    [`colorStatus${color2}Border2`]: hcCanvasText
  };
  return Object.assign(acc, statusColorTokens);
}, {});
colorStatusTokens3.colorStatusDangerBackground3Hover = hcHighlight;
colorStatusTokens3.colorStatusDangerBackground3Pressed = hcHighlight;

// node_modules/@fluentui/tokens/lib/alias/highContrastColor.js
var generateColorTokens3 = () => ({
  colorNeutralForeground1: hcCanvasText,
  colorNeutralForeground1Hover: hcHighlightText,
  colorNeutralForeground1Pressed: hcHighlightText,
  colorNeutralForeground1Selected: hcHighlightText,
  colorNeutralForeground2: hcCanvasText,
  colorNeutralForeground2Hover: hcHighlightText,
  colorNeutralForeground2Pressed: hcHighlightText,
  colorNeutralForeground2Selected: hcHighlightText,
  colorNeutralForeground2BrandHover: hcHighlightText,
  colorNeutralForeground2BrandPressed: hcHighlightText,
  colorNeutralForeground2BrandSelected: hcHighlightText,
  colorNeutralForeground3: hcCanvasText,
  colorNeutralForeground3Hover: hcHighlightText,
  colorNeutralForeground3Pressed: hcHighlightText,
  colorNeutralForeground3Selected: hcHighlightText,
  colorNeutralForeground3BrandHover: hcHighlightText,
  colorNeutralForeground3BrandPressed: hcHighlightText,
  colorNeutralForeground3BrandSelected: hcHighlightText,
  colorNeutralForeground4: hcCanvasText,
  colorNeutralForegroundDisabled: hcDisabled,
  colorNeutralForegroundInvertedDisabled: hcDisabled,
  colorBrandForegroundLink: hcHyperlink,
  colorBrandForegroundLinkHover: hcHyperlink,
  colorBrandForegroundLinkPressed: hcHyperlink,
  colorBrandForegroundLinkSelected: hcHyperlink,
  colorNeutralForeground2Link: hcHyperlink,
  colorNeutralForeground2LinkHover: hcHyperlink,
  colorNeutralForeground2LinkPressed: hcHyperlink,
  colorNeutralForeground2LinkSelected: hcHyperlink,
  colorCompoundBrandForeground1: hcHighlight,
  colorCompoundBrandForeground1Hover: hcHighlight,
  colorCompoundBrandForeground1Pressed: hcHighlight,
  colorBrandForeground1: hcCanvasText,
  colorBrandForeground2: hcCanvasText,
  colorBrandForeground2Hover: hcCanvasText,
  colorBrandForeground2Pressed: hcCanvasText,
  colorNeutralForeground1Static: hcCanvas,
  colorNeutralForegroundStaticInverted: hcCanvasText,
  colorNeutralForegroundInverted: hcHighlightText,
  colorNeutralForegroundInvertedHover: hcHighlightText,
  colorNeutralForegroundInvertedPressed: hcHighlightText,
  colorNeutralForegroundInvertedSelected: hcHighlightText,
  colorNeutralForegroundInverted2: hcCanvasText,
  colorNeutralForegroundOnBrand: hcButtonText,
  colorNeutralForegroundInvertedLink: hcHyperlink,
  colorNeutralForegroundInvertedLinkHover: hcHyperlink,
  colorNeutralForegroundInvertedLinkPressed: hcHyperlink,
  colorNeutralForegroundInvertedLinkSelected: hcHyperlink,
  colorBrandForegroundInverted: hcCanvasText,
  colorBrandForegroundInvertedHover: hcHighlightText,
  colorBrandForegroundInvertedPressed: hcHighlightText,
  colorBrandForegroundOnLight: hcButtonText,
  colorBrandForegroundOnLightHover: hcHighlightText,
  colorBrandForegroundOnLightPressed: hcHighlightText,
  colorBrandForegroundOnLightSelected: hcHighlightText,
  colorNeutralBackground1: hcCanvas,
  colorNeutralBackground1Hover: hcHighlight,
  colorNeutralBackground1Pressed: hcHighlight,
  colorNeutralBackground1Selected: hcHighlight,
  colorNeutralBackground2: hcCanvas,
  colorNeutralBackground2Hover: hcHighlight,
  colorNeutralBackground2Pressed: hcHighlight,
  colorNeutralBackground2Selected: hcHighlight,
  colorNeutralBackground3: hcCanvas,
  colorNeutralBackground3Hover: hcHighlight,
  colorNeutralBackground3Pressed: hcHighlight,
  colorNeutralBackground3Selected: hcHighlight,
  colorNeutralBackground4: hcCanvas,
  colorNeutralBackground4Hover: hcHighlight,
  colorNeutralBackground4Pressed: hcHighlight,
  colorNeutralBackground4Selected: hcHighlight,
  colorNeutralBackground5: hcCanvas,
  colorNeutralBackground5Hover: hcHighlight,
  colorNeutralBackground5Pressed: hcHighlight,
  colorNeutralBackground5Selected: hcHighlight,
  colorNeutralBackground6: hcCanvas,
  colorNeutralBackgroundInverted: hcCanvas,
  colorNeutralBackgroundStatic: hcCanvas,
  colorNeutralBackgroundAlpha: hcCanvas,
  colorNeutralBackgroundAlpha2: hcCanvas,
  colorSubtleBackground: "transparent",
  colorSubtleBackgroundHover: hcHighlight,
  colorSubtleBackgroundPressed: hcHighlight,
  colorSubtleBackgroundSelected: hcHighlight,
  colorSubtleBackgroundLightAlphaHover: hcHighlight,
  colorSubtleBackgroundLightAlphaPressed: hcHighlight,
  colorSubtleBackgroundLightAlphaSelected: hcHighlight,
  colorSubtleBackgroundInverted: "transparent",
  colorSubtleBackgroundInvertedHover: hcHighlight,
  colorSubtleBackgroundInvertedPressed: hcHighlight,
  colorSubtleBackgroundInvertedSelected: hcHighlight,
  colorTransparentBackground: "transparent",
  colorTransparentBackgroundHover: hcHighlight,
  colorTransparentBackgroundPressed: hcHighlight,
  colorTransparentBackgroundSelected: hcHighlight,
  colorNeutralBackgroundDisabled: hcCanvas,
  colorNeutralBackgroundInvertedDisabled: hcCanvas,
  colorNeutralStencil1: hcCanvasText,
  colorNeutralStencil2: hcCanvasText,
  colorNeutralStencil1Alpha: hcCanvasText,
  colorNeutralStencil2Alpha: hcCanvasText,
  colorBackgroundOverlay: blackAlpha[50],
  colorScrollbarOverlay: hcButtonFace,
  colorBrandBackground: hcButtonFace,
  colorBrandBackgroundHover: hcHighlight,
  colorBrandBackgroundPressed: hcHighlight,
  colorBrandBackgroundSelected: hcHighlight,
  colorCompoundBrandBackground: hcHighlight,
  colorCompoundBrandBackgroundHover: hcHighlight,
  colorCompoundBrandBackgroundPressed: hcHighlight,
  colorBrandBackgroundStatic: hcCanvas,
  colorBrandBackground2: hcCanvas,
  colorBrandBackground2Hover: hcCanvas,
  colorBrandBackground2Pressed: hcCanvas,
  colorBrandBackground3Static: hcCanvas,
  colorBrandBackground4Static: hcCanvas,
  colorBrandBackgroundInverted: hcButtonFace,
  colorBrandBackgroundInvertedHover: hcHighlight,
  colorBrandBackgroundInvertedPressed: hcHighlight,
  colorBrandBackgroundInvertedSelected: hcHighlight,
  colorNeutralCardBackground: hcCanvas,
  colorNeutralCardBackgroundHover: hcHighlight,
  colorNeutralCardBackgroundPressed: hcHighlight,
  colorNeutralCardBackgroundSelected: hcHighlight,
  colorNeutralCardBackgroundDisabled: hcCanvas,
  colorNeutralStrokeAccessible: hcCanvasText,
  colorNeutralStrokeAccessibleHover: hcHighlight,
  colorNeutralStrokeAccessiblePressed: hcHighlight,
  colorNeutralStrokeAccessibleSelected: hcHighlight,
  colorNeutralStroke1: hcCanvasText,
  colorNeutralStroke1Hover: hcHighlight,
  colorNeutralStroke1Pressed: hcHighlight,
  colorNeutralStroke1Selected: hcHighlight,
  colorNeutralStroke2: hcCanvasText,
  colorNeutralStroke3: hcCanvasText,
  colorNeutralStrokeSubtle: hcCanvasText,
  colorNeutralStrokeOnBrand: hcCanvas,
  colorNeutralStrokeOnBrand2: hcCanvasText,
  colorNeutralStrokeOnBrand2Hover: hcCanvasText,
  colorNeutralStrokeOnBrand2Pressed: hcCanvasText,
  colorNeutralStrokeOnBrand2Selected: hcCanvasText,
  colorBrandStroke1: hcCanvasText,
  colorBrandStroke2: hcCanvasText,
  colorBrandStroke2Hover: hcHighlight,
  colorBrandStroke2Pressed: hcHighlight,
  colorBrandStroke2Contrast: hcCanvas,
  colorCompoundBrandStroke: hcHighlight,
  colorCompoundBrandStrokeHover: hcHighlight,
  colorCompoundBrandStrokePressed: hcHighlight,
  colorNeutralStrokeDisabled: hcDisabled,
  colorNeutralStrokeInvertedDisabled: hcDisabled,
  colorTransparentStroke: hcCanvasText,
  colorTransparentStrokeInteractive: hcHighlight,
  colorTransparentStrokeDisabled: hcDisabled,
  colorNeutralStrokeAlpha: hcCanvasText,
  colorNeutralStrokeAlpha2: hcCanvas,
  colorStrokeFocus1: hcCanvas,
  colorStrokeFocus2: hcHighlight,
  colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
  colorNeutralShadowKey: "rgba(0,0,0,0.28)",
  colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
  colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
  colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
  colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
  colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
  colorBrandShadowKey: "rgba(0,0,0,0.25)"
});

// node_modules/@fluentui/tokens/lib/utils/createHighContrastTheme.js
var createHighContrastTheme = () => {
  const colorTokens = generateColorTokens3();
  return {
    ...borderRadius,
    ...fontSizes,
    ...lineHeights,
    ...fontFamilies,
    ...fontWeights,
    ...strokeWidths,
    ...horizontalSpacings,
    ...verticalSpacings,
    ...durations,
    ...curves,
    ...colorTokens,
    ...colorPaletteTokens3,
    ...colorStatusTokens3,
    ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
    ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
  };
};

// node_modules/@fluentui/tokens/lib/themes/teams/highContrastTheme.js
var teamsHighContrastTheme = {
  ...createHighContrastTheme(),
  ...fontFamilies2
};

// node_modules/@fluentui/tokens/lib/themes/web/lightTheme.js
var webLightTheme = createLightTheme(brandWeb);

// node_modules/@fluentui/tokens/lib/alias/darkColor.js
var generateColorTokens4 = (brand) => ({
  colorNeutralForeground1: white,
  colorNeutralForeground1Hover: white,
  colorNeutralForeground1Pressed: white,
  colorNeutralForeground1Selected: white,
  colorNeutralForeground2: grey[84],
  colorNeutralForeground2Hover: white,
  colorNeutralForeground2Pressed: white,
  colorNeutralForeground2Selected: white,
  colorNeutralForeground2BrandHover: brand[100],
  colorNeutralForeground2BrandPressed: brand[90],
  colorNeutralForeground2BrandSelected: brand[100],
  colorNeutralForeground3: grey[68],
  colorNeutralForeground3Hover: grey[84],
  colorNeutralForeground3Pressed: grey[84],
  colorNeutralForeground3Selected: grey[84],
  colorNeutralForeground3BrandHover: brand[100],
  colorNeutralForeground3BrandPressed: brand[90],
  colorNeutralForeground3BrandSelected: brand[100],
  colorNeutralForeground4: grey[60],
  colorNeutralForegroundDisabled: grey[36],
  colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
  colorBrandForegroundLink: brand[100],
  colorBrandForegroundLinkHover: brand[110],
  colorBrandForegroundLinkPressed: brand[90],
  colorBrandForegroundLinkSelected: brand[100],
  colorNeutralForeground2Link: grey[84],
  colorNeutralForeground2LinkHover: white,
  colorNeutralForeground2LinkPressed: white,
  colorNeutralForeground2LinkSelected: white,
  colorCompoundBrandForeground1: brand[100],
  colorCompoundBrandForeground1Hover: brand[110],
  colorCompoundBrandForeground1Pressed: brand[90],
  colorBrandForeground1: brand[100],
  colorBrandForeground2: brand[110],
  colorBrandForeground2Hover: brand[130],
  colorBrandForeground2Pressed: brand[160],
  colorNeutralForeground1Static: grey[14],
  colorNeutralForegroundStaticInverted: white,
  colorNeutralForegroundInverted: grey[14],
  colorNeutralForegroundInvertedHover: grey[14],
  colorNeutralForegroundInvertedPressed: grey[14],
  colorNeutralForegroundInvertedSelected: grey[14],
  colorNeutralForegroundInverted2: grey[14],
  colorNeutralForegroundOnBrand: white,
  colorNeutralForegroundInvertedLink: white,
  colorNeutralForegroundInvertedLinkHover: white,
  colorNeutralForegroundInvertedLinkPressed: white,
  colorNeutralForegroundInvertedLinkSelected: white,
  colorBrandForegroundInverted: brand[80],
  colorBrandForegroundInvertedHover: brand[70],
  colorBrandForegroundInvertedPressed: brand[60],
  colorBrandForegroundOnLight: brand[80],
  colorBrandForegroundOnLightHover: brand[70],
  colorBrandForegroundOnLightPressed: brand[50],
  colorBrandForegroundOnLightSelected: brand[60],
  colorNeutralBackground1: grey[16],
  colorNeutralBackground1Hover: grey[24],
  colorNeutralBackground1Pressed: grey[12],
  colorNeutralBackground1Selected: grey[22],
  colorNeutralBackground2: grey[12],
  colorNeutralBackground2Hover: grey[20],
  colorNeutralBackground2Pressed: grey[8],
  colorNeutralBackground2Selected: grey[18],
  colorNeutralBackground3: grey[8],
  colorNeutralBackground3Hover: grey[16],
  colorNeutralBackground3Pressed: grey[4],
  colorNeutralBackground3Selected: grey[14],
  colorNeutralBackground4: grey[4],
  colorNeutralBackground4Hover: grey[12],
  colorNeutralBackground4Pressed: black,
  colorNeutralBackground4Selected: grey[10],
  colorNeutralBackground5: black,
  colorNeutralBackground5Hover: grey[8],
  colorNeutralBackground5Pressed: grey[2],
  colorNeutralBackground5Selected: grey[6],
  colorNeutralBackground6: grey[20],
  colorNeutralBackgroundInverted: white,
  colorNeutralBackgroundStatic: grey[24],
  colorNeutralBackgroundAlpha: grey10Alpha[50],
  colorNeutralBackgroundAlpha2: grey12Alpha[70],
  colorSubtleBackground: "transparent",
  colorSubtleBackgroundHover: grey[22],
  colorSubtleBackgroundPressed: grey[18],
  colorSubtleBackgroundSelected: grey[20],
  colorSubtleBackgroundLightAlphaHover: grey14Alpha[80],
  colorSubtleBackgroundLightAlphaPressed: grey14Alpha[50],
  colorSubtleBackgroundLightAlphaSelected: "transparent",
  colorSubtleBackgroundInverted: "transparent",
  colorSubtleBackgroundInvertedHover: blackAlpha[10],
  colorSubtleBackgroundInvertedPressed: blackAlpha[30],
  colorSubtleBackgroundInvertedSelected: blackAlpha[20],
  colorTransparentBackground: "transparent",
  colorTransparentBackgroundHover: "transparent",
  colorTransparentBackgroundPressed: "transparent",
  colorTransparentBackgroundSelected: "transparent",
  colorNeutralBackgroundDisabled: grey[8],
  colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
  colorNeutralStencil1: grey[34],
  colorNeutralStencil2: grey[20],
  colorNeutralStencil1Alpha: whiteAlpha[10],
  colorNeutralStencil2Alpha: whiteAlpha[5],
  colorBackgroundOverlay: blackAlpha[50],
  colorScrollbarOverlay: whiteAlpha[60],
  colorBrandBackground: brand[70],
  colorBrandBackgroundHover: brand[80],
  colorBrandBackgroundPressed: brand[40],
  colorBrandBackgroundSelected: brand[60],
  colorCompoundBrandBackground: brand[100],
  colorCompoundBrandBackgroundHover: brand[110],
  colorCompoundBrandBackgroundPressed: brand[90],
  colorBrandBackgroundStatic: brand[80],
  colorBrandBackground2: brand[20],
  colorBrandBackground2Hover: brand[40],
  colorBrandBackground2Pressed: brand[10],
  colorBrandBackground3Static: brand[60],
  colorBrandBackground4Static: brand[40],
  colorBrandBackgroundInverted: white,
  colorBrandBackgroundInvertedHover: brand[160],
  colorBrandBackgroundInvertedPressed: brand[140],
  colorBrandBackgroundInvertedSelected: brand[150],
  colorNeutralCardBackground: grey[20],
  colorNeutralCardBackgroundHover: grey[24],
  colorNeutralCardBackgroundPressed: grey[18],
  colorNeutralCardBackgroundSelected: grey[22],
  colorNeutralCardBackgroundDisabled: grey[8],
  colorNeutralStrokeAccessible: grey[68],
  colorNeutralStrokeAccessibleHover: grey[74],
  colorNeutralStrokeAccessiblePressed: grey[70],
  colorNeutralStrokeAccessibleSelected: brand[100],
  colorNeutralStroke1: grey[40],
  colorNeutralStroke1Hover: grey[46],
  colorNeutralStroke1Pressed: grey[42],
  colorNeutralStroke1Selected: grey[44],
  colorNeutralStroke2: grey[32],
  colorNeutralStroke3: grey[24],
  colorNeutralStrokeSubtle: grey[4],
  colorNeutralStrokeOnBrand: grey[16],
  colorNeutralStrokeOnBrand2: white,
  colorNeutralStrokeOnBrand2Hover: white,
  colorNeutralStrokeOnBrand2Pressed: white,
  colorNeutralStrokeOnBrand2Selected: white,
  colorBrandStroke1: brand[100],
  colorBrandStroke2: brand[50],
  colorBrandStroke2Hover: brand[50],
  colorBrandStroke2Pressed: brand[30],
  colorBrandStroke2Contrast: brand[50],
  colorCompoundBrandStroke: brand[100],
  colorCompoundBrandStrokeHover: brand[110],
  colorCompoundBrandStrokePressed: brand[90],
  colorNeutralStrokeDisabled: grey[26],
  colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
  colorTransparentStroke: "transparent",
  colorTransparentStrokeInteractive: "transparent",
  colorTransparentStrokeDisabled: "transparent",
  colorNeutralStrokeAlpha: whiteAlpha[10],
  colorNeutralStrokeAlpha2: whiteAlpha[20],
  colorStrokeFocus1: black,
  colorStrokeFocus2: white,
  colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
  colorNeutralShadowKey: "rgba(0,0,0,0.28)",
  colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
  colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
  colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
  colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
  colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
  colorBrandShadowKey: "rgba(0,0,0,0.25)"
});

// node_modules/@fluentui/tokens/lib/utils/createDarkTheme.js
var createDarkTheme = (brand) => {
  const colorTokens = generateColorTokens4(brand);
  return {
    ...borderRadius,
    ...fontSizes,
    ...lineHeights,
    ...fontFamilies,
    ...fontWeights,
    ...strokeWidths,
    ...horizontalSpacings,
    ...verticalSpacings,
    ...durations,
    ...curves,
    ...colorTokens,
    ...colorPaletteTokens2,
    ...colorStatusTokens2,
    ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
    ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
  };
};

// node_modules/@fluentui/tokens/lib/themes/web/darkTheme.js
var webDarkTheme = createDarkTheme(brandWeb);

// node_modules/@fluentui/tokens/lib/themeToTokensObject.js
function themeToTokensObject(theme) {
  const tokens2 = {};
  const keys = Object.keys(theme);
  for (const key of keys) {
    tokens2[key] = `var(--${String(key)})`;
  }
  return tokens2;
}

// node_modules/@fluentui/react-tabster/lib/focus/createFocusOutlineStyle.js
function getOutlinePosition({ outlineWidth, outlineOffset }, position) {
  const offsetValue = (outlineOffset === null || outlineOffset === void 0 ? void 0 : outlineOffset[position]) || outlineOffset;
  if (!outlineOffset) {
    return `calc(${outlineWidth} * -1)`;
  }
  return `calc(0px - ${outlineWidth} - ${offsetValue})`;
}
var getFocusOutlineStyles = (options) => {
  const { outlineRadius, outlineColor, outlineWidth } = options;
  return {
    ...shorthands.borderColor("transparent"),
    "@media (forced-colors: active)": {
      "::after": {
        ...shorthands.borderColor("Highlight")
      }
    },
    "::after": {
      content: '""',
      position: "absolute",
      pointerEvents: "none",
      zIndex: 1,
      border: `${outlineWidth} solid ${outlineColor}`,
      borderRadius: outlineRadius,
      top: getOutlinePosition(options, "top"),
      right: getOutlinePosition(options, "right"),
      bottom: getOutlinePosition(options, "bottom"),
      left: getOutlinePosition(options, "left")
    }
  };
};
var createFocusOutlineStyle = ({ enableOutline = false, selector = defaultOptions.selector, customizeSelector, style = defaultOptions.style } = defaultOptions) => ({
  ":focus": {
    outlineStyle: enableOutline ? void 0 : "none"
  },
  ":focus-visible": {
    outlineStyle: enableOutline ? void 0 : "none"
  },
  ...createCustomFocusIndicatorStyle(getFocusOutlineStyles({
    outlineColor: tokens.colorStrokeFocus2,
    outlineRadius: tokens.borderRadiusMedium,
    // FIXME: tokens.strokeWidthThick causes some weird bugs
    outlineWidth: "2px",
    ...style
  }), {
    selector,
    customizeSelector
  })
});

// node_modules/@fluentui/react-tabster/lib/tabster-types-6.0.1-do-not-use.js
var FocusableSelector = [
  "a[href]",
  "button:not([disabled])",
  "input:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "*[tabindex]",
  "*[contenteditable]"
].join(", ");

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProvider.js
var React56 = __toESM(require_react());

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderThemeStyleTag.js
var React55 = __toESM(require_react());

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderStyles.styles.js
var fluentProviderClassNames = {
  root: "fui-FluentProvider"
};
var useStyles = __styles({
  root: {
    sj55zd: "f19n0e5",
    De3pzq: "fxugw4r",
    fsow6f: ["f1o700av", "fes3tcz"],
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});
var useFluentProviderStyles_unstable = (state) => {
  "use no memo";
  const renderer = useRenderer();
  const styles = useStyles({
    dir: state.dir,
    renderer
  });
  state.root.className = mergeClasses(fluentProviderClassNames.root, state.themeClassName, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderThemeStyleTag.js
var useInsertionEffect2 = React55["useInsertionEffect"] ? React55["useInsertionEffect"] : useIsomorphicLayoutEffect;
var createStyleTag = (target, elementAttributes) => {
  if (!(target === null || target === void 0 ? void 0 : target.head)) {
    return void 0;
  }
  const tag = target.createElement("style");
  Object.keys(elementAttributes).forEach((attrName) => {
    tag.setAttribute(attrName, elementAttributes[attrName]);
  });
  target.head.appendChild(tag);
  return tag;
};
var insertSheet = (tag, rule) => {
  const sheet = tag.sheet;
  if (sheet) {
    if (sheet.cssRules.length > 0) {
      sheet.deleteRule(0);
    }
    sheet.insertRule(rule, 0);
  } else if (true) {
    console.error("FluentProvider: No sheet available on styleTag, styles will not be inserted into DOM.");
  }
};
var useFluentProviderThemeStyleTag = (options) => {
  "use no memo";
  const { targetDocument, theme, rendererAttributes } = options;
  const styleTag = React55.useRef(void 0);
  const styleTagId = useId2(fluentProviderClassNames.root);
  const styleElementAttributes = rendererAttributes;
  const rule = React55.useMemo(() => createCSSRuleFromTheme(`.${styleTagId}`, theme), [
    theme,
    styleTagId
  ]);
  if (true) {
    React55.useMemo(() => {
      if (targetDocument) {
        var _styleElement_textContent;
        const providerElementSelector = `.${fluentProviderClassNames.root}.${styleTagId}`;
        const providerElements = targetDocument.querySelectorAll(providerElementSelector);
        const styleElementSelector = `style[id="${styleTagId}"]`;
        const styleElements = targetDocument.querySelectorAll(styleElementSelector);
        if (styleElements.length > 1) {
          console.error([
            "@fluentui/react-provider: We found multiple <style> elements with same IDs in your DOM.",
            "Please make sure that you configured your application properly.",
            "\n",
            "\n",
            "Configuration guide: https://aka.ms/fluentui-conflicting-ids"
          ].join(" "));
          return;
        }
        const styleElement = styleElements.item(0);
        var _styleElement_textContent_length;
        const isSSR = ((_styleElement_textContent_length = styleElement === null || styleElement === void 0 ? void 0 : (_styleElement_textContent = styleElement.textContent) === null || _styleElement_textContent === void 0 ? void 0 : _styleElement_textContent.length) !== null && _styleElement_textContent_length !== void 0 ? _styleElement_textContent_length : 0) > 0;
        const elementsCount = isSSR ? 1 : 0;
        if (providerElements.length > elementsCount) {
          console.error([
            "@fluentui/react-provider: There are conflicting ids in your DOM.",
            "Please make sure that you configured your application properly.",
            "\n",
            "\n",
            "Configuration guide: https://aka.ms/fluentui-conflicting-ids"
          ].join(" "));
        }
      }
    }, []);
  }
  useHandleSSRStyleElements(targetDocument, styleTagId);
  useInsertionEffect2(() => {
    const ssrStyleElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.getElementById(styleTagId);
    if (ssrStyleElement) {
      styleTag.current = ssrStyleElement;
    } else {
      styleTag.current = createStyleTag(targetDocument, {
        ...styleElementAttributes,
        id: styleTagId
      });
      if (styleTag.current) {
        insertSheet(styleTag.current, rule);
      }
    }
    return () => {
      var _styleTag_current;
      (_styleTag_current = styleTag.current) === null || _styleTag_current === void 0 ? void 0 : _styleTag_current.remove();
    };
  }, [
    styleTagId,
    targetDocument,
    rule,
    styleElementAttributes
  ]);
  return {
    styleTagId,
    rule
  };
};
function useHandleSSRStyleElements(targetDocument, styleTagId) {
  React55.useState(() => {
    if (!targetDocument) {
      return;
    }
    const themeStyleElement = targetDocument.getElementById(styleTagId);
    if (themeStyleElement) {
      targetDocument.head.append(themeStyleElement);
    }
  });
}

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProvider.js
var DEFAULT_STYLE_HOOKS = {};
var DEFAULT_RENDERER_ATTRIBUTES = {};
var useFluentProvider_unstable = (props, ref) => {
  "use no memo";
  const parentContext = useFluent();
  const parentTheme = useTheme();
  const parentOverrides = useOverrides();
  const parentCustomStyleHooks = React56.useContext(CustomStyleHooksContext) || DEFAULT_STYLE_HOOKS;
  const {
    applyStylesToPortals = true,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    customStyleHooks_unstable,
    dir = parentContext.dir,
    targetDocument = parentContext.targetDocument,
    theme,
    overrides_unstable: overrides = {}
  } = props;
  const mergedTheme = shallowMerge(parentTheme, theme);
  const mergedOverrides = shallowMerge(parentOverrides, overrides);
  const mergedCustomStyleHooks = shallowMerge(parentCustomStyleHooks, customStyleHooks_unstable);
  const renderer = useRenderer();
  var _renderer_styleElementAttributes;
  const { styleTagId, rule } = useFluentProviderThemeStyleTag({
    theme: mergedTheme,
    targetDocument,
    rendererAttributes: (_renderer_styleElementAttributes = renderer.styleElementAttributes) !== null && _renderer_styleElementAttributes !== void 0 ? _renderer_styleElementAttributes : DEFAULT_RENDERER_ATTRIBUTES
  });
  if (true) {
    React56.useEffect(() => {
      if (mergedTheme === void 0) {
        console.warn([
          '@fluentui/react-provider: FluentProvider does not have your "theme" defined.',
          "Make sure that your top-level FluentProvider has set a `theme` prop or you're setting the theme in your child FluentProvider."
        ].join(" "));
      }
    }, []);
  }
  return {
    applyStylesToPortals,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    customStyleHooks_unstable: mergedCustomStyleHooks,
    dir,
    targetDocument,
    theme: mergedTheme,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    overrides_unstable: mergedOverrides,
    themeClassName: styleTagId,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ...props,
      dir,
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, useFocusVisible({
        targetDocument
      }))
    }), {
      elementType: "div"
    }),
    serverStyleProps: {
      cssRule: rule,
      attributes: {
        ...renderer.styleElementAttributes,
        id: styleTagId
      }
    }
  };
};
function shallowMerge(a, b) {
  if (a && b) {
    return {
      ...a,
      ...b
    };
  }
  if (a) {
    return a;
  }
  return b;
}
function useTheme() {
  return React56.useContext(ThemeContext);
}

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderContextValues.js
var React57 = __toESM(require_react());
function useFluentProviderContextValues_unstable(state) {
  const {
    applyStylesToPortals,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    customStyleHooks_unstable,
    dir,
    root,
    targetDocument,
    theme,
    themeClassName,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    overrides_unstable
  } = state;
  const provider = React57.useMemo(() => ({
    dir,
    targetDocument
  }), [
    dir,
    targetDocument
  ]);
  const [tooltip] = React57.useState(() => ({}));
  const iconDirection = React57.useMemo(() => ({
    textDirection: dir
  }), [
    dir
  ]);
  return {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    customStyleHooks_unstable,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    overrides_unstable,
    provider,
    textDirection: dir,
    iconDirection,
    tooltip,
    theme,
    themeClassName: applyStylesToPortals ? root.className : themeClassName
  };
}

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/FluentProvider.js
var FluentProvider = React58.forwardRef((props, ref) => {
  const state = useFluentProvider_unstable(props, ref);
  useFluentProviderStyles_unstable(state);
  const contextValues = useFluentProviderContextValues_unstable(state);
  return renderFluentProvider_unstable(state, contextValues);
});
FluentProvider.displayName = "FluentProvider";

// node_modules/@fluentui/react-accordion/lib/components/Accordion/Accordion.js
var React63 = __toESM(require_react());

// node_modules/@fluentui/react-context-selector/lib/createContext.js
var React59 = __toESM(require_react());
var import_scheduler = __toESM(require_scheduler());
var createProvider = (Original) => {
  const Provider2 = (props) => {
    const valueRef = React59.useRef(props.value);
    const versionRef = React59.useRef(0);
    const contextValue = React59.useRef();
    if (!contextValue.current) {
      contextValue.current = {
        value: valueRef,
        version: versionRef,
        listeners: []
      };
    }
    useIsomorphicLayoutEffect(() => {
      valueRef.current = props.value;
      versionRef.current += 1;
      (0, import_scheduler.unstable_runWithPriority)(import_scheduler.unstable_NormalPriority, () => {
        contextValue.current.listeners.forEach((listener) => {
          listener([
            versionRef.current,
            props.value
          ]);
        });
      });
    }, [
      props.value
    ]);
    return React59.createElement(Original, {
      value: contextValue.current
    }, props.children);
  };
  if (true) {
    Provider2.displayName = "ContextSelector.Provider";
  }
  return Provider2;
};
var createContext13 = (defaultValue) => {
  const context = React59.createContext({
    value: {
      current: defaultValue
    },
    version: {
      current: -1
    },
    listeners: []
  });
  context.Provider = createProvider(context.Provider);
  delete context.Consumer;
  return context;
};

// node_modules/@fluentui/react-context-selector/lib/useContextSelector.js
var React60 = __toESM(require_react());
var useContextSelector = (context, selector) => {
  const contextValue = React60.useContext(context);
  const { value: { current: value }, version: { current: version2 }, listeners } = contextValue;
  const selected = selector(value);
  const [state, setState] = React60.useState([
    value,
    selected
  ]);
  const dispatch = (payload) => {
    setState((prevState) => {
      if (!payload) {
        return [
          value,
          selected
        ];
      }
      if (payload[0] <= version2) {
        if (Object.is(prevState[1], selected)) {
          return prevState;
        }
        return [
          value,
          selected
        ];
      }
      try {
        if (Object.is(prevState[0], payload[1])) {
          return prevState;
        }
        const nextSelected = selector(payload[1]);
        if (Object.is(prevState[1], nextSelected)) {
          return prevState;
        }
        return [
          payload[1],
          nextSelected
        ];
      } catch (e) {
      }
      return [
        prevState[0],
        prevState[1]
      ];
    });
  };
  if (!Object.is(state[1], selected)) {
    dispatch(void 0);
  }
  const stableDispatch = useEventCallback(dispatch);
  useIsomorphicLayoutEffect(() => {
    listeners.push(stableDispatch);
    return () => {
      const index = listeners.indexOf(stableDispatch);
      listeners.splice(index, 1);
    };
  }, [
    stableDispatch,
    listeners
  ]);
  return state[1];
};

// node_modules/@fluentui/react-context-selector/lib/useHasParentContext.js
var React61 = __toESM(require_react());
function useHasParentContext(context) {
  const contextValue = React61.useContext(context);
  if (contextValue.version) {
    return contextValue.version.current !== -1;
  }
  return false;
}

// node_modules/@fluentui/react-accordion/lib/contexts/accordion.js
var AccordionContext = createContext13(void 0);
var accordionContextDefaultValue = {
  openItems: [],
  collapsible: false,
  multiple: false,
  navigation: void 0,
  requestToggle() {
  }
};
var { Provider: AccordionProvider } = AccordionContext;
var useAccordionContext_unstable = (selector) => useContextSelector(AccordionContext, (ctx = accordionContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-accordion/lib/components/Accordion/renderAccordion.js
var renderAccordion_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(AccordionProvider, {
      value: contextValues.accordion,
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-accordion/lib/components/Accordion/useAccordion.js
var React62 = __toESM(require_react());
var useAccordion_unstable = (props, ref) => {
  const {
    openItems: controlledOpenItems,
    defaultOpenItems,
    multiple = false,
    collapsible = false,
    onToggle,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    navigation,
    ...rest
  } = props;
  const [openItems, setOpenItems] = useControllableState({
    state: React62.useMemo(() => normalizeValues(controlledOpenItems), [
      controlledOpenItems
    ]),
    defaultState: defaultOpenItems && (() => initializeUncontrolledOpenItems({
      defaultOpenItems,
      multiple
    })),
    initialState: []
  });
  const arrowNavigationProps = useArrowNavigationGroup({
    circular: navigation === "circular",
    tabbable: true
  });
  const requestToggle = useEventCallback((data) => {
    const nextOpenItems = updateOpenItems(data.value, openItems, multiple, collapsible);
    onToggle === null || onToggle === void 0 ? void 0 : onToggle(data.event, {
      value: data.value,
      openItems: nextOpenItems
    });
    setOpenItems(nextOpenItems);
  });
  return {
    collapsible,
    multiple,
    navigation,
    openItems,
    requestToggle,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ...rest,
      ...navigation ? arrowNavigationProps : void 0,
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref
    }), {
      elementType: "div"
    })
  };
};
function initializeUncontrolledOpenItems({ defaultOpenItems, multiple }) {
  if (defaultOpenItems !== void 0) {
    if (Array.isArray(defaultOpenItems)) {
      return multiple ? defaultOpenItems : [
        defaultOpenItems[0]
      ];
    }
    return [
      defaultOpenItems
    ];
  }
  return [];
}
function updateOpenItems(value, previousOpenItems, multiple, collapsible) {
  if (multiple) {
    if (previousOpenItems.includes(value)) {
      if (previousOpenItems.length > 1 || collapsible) {
        return previousOpenItems.filter((i) => i !== value);
      }
    } else {
      return [
        ...previousOpenItems,
        value
      ].sort();
    }
  } else {
    return previousOpenItems[0] === value && collapsible ? [] : [
      value
    ];
  }
  return previousOpenItems;
}
function normalizeValues(index) {
  if (index === void 0) {
    return void 0;
  }
  return Array.isArray(index) ? index : [
    index
  ];
}

// node_modules/@fluentui/react-accordion/lib/components/Accordion/useAccordionContextValues.js
function useAccordionContextValues_unstable(state) {
  const { navigation, openItems, requestToggle, multiple, collapsible } = state;
  const accordion = {
    navigation,
    openItems,
    requestToggle,
    collapsible,
    multiple
  };
  return {
    accordion
  };
}

// node_modules/@fluentui/react-accordion/lib/components/Accordion/useAccordionStyles.styles.js
var accordionClassNames = {
  root: "fui-Accordion"
};
var useAccordionStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(accordionClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-accordion/lib/components/Accordion/Accordion.js
var Accordion = React63.forwardRef((props, ref) => {
  const state = useAccordion_unstable(props, ref);
  const contextValues = useAccordionContextValues_unstable(state);
  useAccordionStyles_unstable(state);
  useCustomStyleHook("useAccordionStyles_unstable")(state);
  return renderAccordion_unstable(state, contextValues);
});
Accordion.displayName = "Accordion";

// node_modules/@fluentui/react-accordion/lib/components/AccordionItem/AccordionItem.js
var React67 = __toESM(require_react());

// node_modules/@fluentui/react-accordion/lib/components/AccordionItem/useAccordionItem.js
var React64 = __toESM(require_react());
var useAccordionItem_unstable = (props, ref) => {
  const { value, disabled = false } = props;
  const requestToggle = useAccordionContext_unstable((ctx) => ctx.requestToggle);
  const open = useAccordionContext_unstable((ctx) => ctx.openItems.includes(value));
  const onAccordionHeaderClick = useEventCallback((event) => requestToggle({
    event,
    value
  }));
  return {
    open,
    value,
    disabled,
    onHeaderClick: onAccordionHeaderClick,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionItem/useAccordionItemContextValues.js
var React65 = __toESM(require_react());
function useAccordionItemContextValues_unstable(state) {
  const { disabled, open, value, onHeaderClick } = state;
  const accordionItem = React65.useMemo(() => ({
    disabled,
    open,
    value,
    onHeaderClick
  }), [
    disabled,
    open,
    value,
    onHeaderClick
  ]);
  return {
    accordionItem
  };
}

// node_modules/@fluentui/react-accordion/lib/contexts/accordionItem.js
var React66 = __toESM(require_react());
var AccordionItemContext = React66.createContext(void 0);
var accordionItemContextDefaultValue = {
  open: false,
  disabled: false,
  value: void 0,
  onHeaderClick() {
  }
};
var { Provider: AccordionItemProvider } = AccordionItemContext;
var useAccordionItemContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React66.useContext(AccordionItemContext)) !== null && _React_useContext !== void 0 ? _React_useContext : accordionItemContextDefaultValue;
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionItem/renderAccordionItem.js
var renderAccordionItem_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(AccordionItemProvider, {
      value: contextValues.accordionItem,
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionItem/useAccordionItemStyles.styles.js
var accordionItemClassNames = {
  root: "fui-AccordionItem"
};
var useAccordionItemStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(accordionItemClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionItem/AccordionItem.js
var AccordionItem = React67.forwardRef((props, ref) => {
  const state = useAccordionItem_unstable(props, ref);
  const contextValues = useAccordionItemContextValues_unstable(state);
  useAccordionItemStyles_unstable(state);
  useCustomStyleHook("useAccordionItemStyles_unstable")(state);
  return renderAccordionItem_unstable(state, contextValues);
});
AccordionItem.displayName = "AccordionItem";

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/AccordionHeader.js
var React95 = __toESM(require_react());

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/useAccordionHeader.js
var React92 = __toESM(require_react());

// node_modules/@fluentui/keyboard-keys/lib/keys.js
var Shift = "Shift";
var Enter = "Enter";
var Space = " ";
var Tab = "Tab";
var ArrowDown = "ArrowDown";
var ArrowLeft = "ArrowLeft";
var ArrowRight = "ArrowRight";
var ArrowUp = "ArrowUp";
var End = "End";
var Home = "Home";
var PageDown = "PageDown";
var PageUp = "PageUp";
var Backspace = "Backspace";
var Delete = "Delete";
var Escape = "Escape";

// node_modules/@fluentui/react-aria/lib/button/useARIAButtonProps.js
var React68 = __toESM(require_react());
function useARIAButtonProps(type, props) {
  const { disabled, disabledFocusable = false, ["aria-disabled"]: ariaDisabled, onClick, onKeyDown, onKeyUp, ...rest } = props !== null && props !== void 0 ? props : {};
  const normalizedARIADisabled = typeof ariaDisabled === "string" ? ariaDisabled === "true" : ariaDisabled;
  const isDisabled = disabled || disabledFocusable || normalizedARIADisabled;
  const handleClick = useEventCallback((ev) => {
    if (isDisabled) {
      ev.preventDefault();
      ev.stopPropagation();
    } else {
      onClick === null || onClick === void 0 ? void 0 : onClick(ev);
    }
  });
  const handleKeyDown = useEventCallback((ev) => {
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);
    if (ev.isDefaultPrevented()) {
      return;
    }
    const key = ev.key;
    if (isDisabled && (key === Enter || key === Space)) {
      ev.preventDefault();
      ev.stopPropagation();
      return;
    }
    if (key === Space) {
      ev.preventDefault();
      return;
    } else if (key === Enter) {
      ev.preventDefault();
      ev.currentTarget.click();
    }
  });
  const handleKeyUp = useEventCallback((ev) => {
    onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(ev);
    if (ev.isDefaultPrevented()) {
      return;
    }
    const key = ev.key;
    if (isDisabled && (key === Enter || key === Space)) {
      ev.preventDefault();
      ev.stopPropagation();
      return;
    }
    if (key === Space) {
      ev.preventDefault();
      ev.currentTarget.click();
    }
  });
  if (type === "button" || type === void 0) {
    return {
      ...rest,
      disabled: disabled && !disabledFocusable,
      "aria-disabled": disabledFocusable ? true : normalizedARIADisabled,
      // onclick should still use internal handler to ensure prevention if disabled
      // if disabledFocusable then there's no requirement for handlers as those events should not be propagated
      onClick: disabledFocusable ? void 0 : handleClick,
      onKeyUp: disabledFocusable ? void 0 : onKeyUp,
      onKeyDown: disabledFocusable ? void 0 : onKeyDown
    };
  } else {
    const isLink = !!rest.href;
    let roleOverride = isLink ? void 0 : "button";
    if (!roleOverride && isDisabled) {
      roleOverride = "link";
    }
    const resultProps = {
      role: roleOverride,
      tabIndex: disabledFocusable || !isLink && !disabled ? 0 : void 0,
      ...rest,
      // If it's not a <button> than listeners are required even with disabledFocusable
      // Since you cannot assure the default behavior of the element
      // E.g: <a> will redirect on click
      onClick: handleClick,
      onKeyUp: handleKeyUp,
      onKeyDown: handleKeyDown,
      "aria-disabled": isDisabled
    };
    if (type === "a" && isDisabled) {
      resultProps.href = void 0;
    }
    return resultProps;
  }
}

// node_modules/@fluentui/react-aria/lib/activedescendant/ActiveDescendantContext.js
var React69 = __toESM(require_react());
var noop2 = () => void 0;
var activeDescendantContextDefaultValue = {
  controller: {
    active: noop2,
    blur: noop2,
    find: noop2,
    first: noop2,
    focus: noop2,
    focusLastActive: noop2,
    scrollActiveIntoView: noop2,
    last: noop2,
    next: noop2,
    prev: noop2,
    showAttributes: noop2,
    hideAttributes: noop2,
    showFocusVisibleAttributes: noop2,
    hideFocusVisibleAttributes: noop2
  }
};
var ActiveDescendantContext = React69.createContext(void 0);
var ActiveDescendantContextProvider = ActiveDescendantContext.Provider;
var useActiveDescendantContext = () => {
  var _React_useContext;
  return (_React_useContext = React69.useContext(ActiveDescendantContext)) !== null && _React_useContext !== void 0 ? _React_useContext : activeDescendantContextDefaultValue;
};
var useHasParentActiveDescendantContext = () => !!React69.useContext(ActiveDescendantContext);

// node_modules/@fluentui/react-aria/lib/activedescendant/useActiveDescendant.js
var React71 = __toESM(require_react());

// node_modules/@fluentui/react-aria/lib/activedescendant/useOptionWalker.js
var React70 = __toESM(require_react());
function useOptionWalker(options) {
  const { matchOption } = options;
  const { targetDocument } = useFluent();
  const treeWalkerRef = React70.useRef(null);
  const listboxRef = React70.useRef(null);
  const optionFilter = React70.useCallback((node) => {
    if (isHTMLElement(node) && matchOption(node)) {
      return NodeFilter.FILTER_ACCEPT;
    }
    return NodeFilter.FILTER_SKIP;
  }, [
    matchOption
  ]);
  const setListbox = React70.useCallback((el) => {
    if (el && targetDocument) {
      listboxRef.current = el;
      treeWalkerRef.current = targetDocument.createTreeWalker(el, NodeFilter.SHOW_ELEMENT, optionFilter);
    } else {
      listboxRef.current = null;
      treeWalkerRef.current = null;
    }
  }, [
    targetDocument,
    optionFilter
  ]);
  const optionWalker = React70.useMemo(() => ({
    first: () => {
      if (!treeWalkerRef.current || !listboxRef.current) {
        return null;
      }
      treeWalkerRef.current.currentNode = listboxRef.current;
      return treeWalkerRef.current.firstChild();
    },
    last: () => {
      if (!treeWalkerRef.current || !listboxRef.current) {
        return null;
      }
      treeWalkerRef.current.currentNode = listboxRef.current;
      return treeWalkerRef.current.lastChild();
    },
    next: () => {
      if (!treeWalkerRef.current) {
        return null;
      }
      return treeWalkerRef.current.nextNode();
    },
    prev: () => {
      if (!treeWalkerRef.current) {
        return null;
      }
      return treeWalkerRef.current.previousNode();
    },
    find: (predicate, startFrom) => {
      if (!treeWalkerRef.current || !listboxRef.current) {
        return null;
      }
      const start = startFrom ? targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.getElementById(startFrom) : null;
      treeWalkerRef.current.currentNode = start !== null && start !== void 0 ? start : listboxRef.current;
      let cur = treeWalkerRef.current.currentNode;
      while (cur && !predicate(cur.id)) {
        cur = treeWalkerRef.current.nextNode();
      }
      return cur;
    },
    setCurrent: (el) => {
      if (!treeWalkerRef.current) {
        return;
      }
      treeWalkerRef.current.currentNode = el;
    }
  }), [
    targetDocument
  ]);
  return {
    optionWalker,
    listboxCallbackRef: setListbox
  };
}

// node_modules/@fluentui/react-aria/lib/activedescendant/constants.js
var ACTIVEDESCENDANT_ATTRIBUTE = "data-activedescendant";
var ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE = "data-activedescendant-focusvisible";

// node_modules/@fluentui/react-aria/lib/activedescendant/scrollIntoView.js
var scrollIntoView2 = (target) => {
  if (!target) {
    return;
  }
  const scrollParent = findScrollableParent(target.parentElement);
  if (!scrollParent) {
    return;
  }
  const { offsetHeight } = target;
  const offsetTop = getTotalOffsetTop(target, scrollParent);
  const { scrollMarginTop, scrollMarginBottom } = getScrollMargins(target);
  const { offsetHeight: parentOffsetHeight, scrollTop } = scrollParent;
  const isAbove = offsetTop - scrollMarginTop < scrollTop;
  const isBelow = offsetTop + offsetHeight + scrollMarginBottom > scrollTop + parentOffsetHeight;
  const buffer = 2;
  if (isAbove) {
    scrollParent.scrollTo(0, offsetTop - scrollMarginTop - buffer);
  } else if (isBelow) {
    scrollParent.scrollTo(0, offsetTop + offsetHeight + scrollMarginBottom - parentOffsetHeight + buffer);
  }
};
var findScrollableParent = (element) => {
  if (!element) {
    return null;
  }
  if (element.scrollHeight > element.offsetHeight) {
    return element;
  }
  return findScrollableParent(element.parentElement);
};
var getTotalOffsetTop = (element, scrollParent) => {
  if (!element || element === scrollParent) {
    return 0;
  }
  if (element.contains(scrollParent)) {
    return scrollParent.offsetTop * -1;
  }
  return element.offsetTop + getTotalOffsetTop(element.offsetParent, scrollParent);
};
var getScrollMargins = (element) => {
  var _element_ownerDocument;
  const win = (_element_ownerDocument = element.ownerDocument) === null || _element_ownerDocument === void 0 ? void 0 : _element_ownerDocument.defaultView;
  if (!win) {
    return {
      scrollMarginTop: 0,
      scrollMarginBottom: 0
    };
  }
  const computedStyles = win.getComputedStyle(element);
  var _getIntValueOfComputedStyle;
  const scrollMarginTop = (_getIntValueOfComputedStyle = getIntValueOfComputedStyle(computedStyles.scrollMarginTop)) !== null && _getIntValueOfComputedStyle !== void 0 ? _getIntValueOfComputedStyle : getIntValueOfComputedStyle(computedStyles.scrollMarginBlockStart);
  var _getIntValueOfComputedStyle1;
  const scrollMarginBottom = (_getIntValueOfComputedStyle1 = getIntValueOfComputedStyle(computedStyles.scrollMarginBottom)) !== null && _getIntValueOfComputedStyle1 !== void 0 ? _getIntValueOfComputedStyle1 : getIntValueOfComputedStyle(computedStyles.scrollMarginBlockEnd);
  return {
    scrollMarginTop,
    scrollMarginBottom
  };
};
var getIntValueOfComputedStyle = (computedStyle) => {
  return computedStyle ? parseInt(computedStyle, 10) : 0;
};

// node_modules/@fluentui/react-aria/lib/activedescendant/useActiveDescendant.js
var createActiveDescendantChangeEvent = (detail) => new CustomEvent("activedescendantchange", {
  bubbles: true,
  cancelable: false,
  composed: true,
  detail
});
function useActiveDescendant(options) {
  const { imperativeRef, matchOption: matchOptionUnstable } = options;
  const focusVisibleRef = React71.useRef(false);
  const shouldShowFocusVisibleAttrRef = React71.useRef(true);
  const activeIdRef = React71.useRef(null);
  const lastActiveIdRef = React71.useRef(null);
  const activeParentRef = React71.useRef(null);
  const attributeVisibilityRef = React71.useRef(true);
  const removeAttribute = React71.useCallback(() => {
    var _activeParentRef_current;
    (_activeParentRef_current = activeParentRef.current) === null || _activeParentRef_current === void 0 ? void 0 : _activeParentRef_current.removeAttribute("aria-activedescendant");
  }, []);
  const setAttribute = React71.useCallback((id) => {
    if (id) {
      activeIdRef.current = id;
    }
    if (attributeVisibilityRef.current && activeIdRef.current) {
      var _activeParentRef_current;
      (_activeParentRef_current = activeParentRef.current) === null || _activeParentRef_current === void 0 ? void 0 : _activeParentRef_current.setAttribute("aria-activedescendant", activeIdRef.current);
    }
  }, []);
  useOnKeyboardNavigationChange((isNavigatingWithKeyboard) => {
    focusVisibleRef.current = isNavigatingWithKeyboard;
    const active = getActiveDescendant();
    if (!active) {
      return;
    }
    if (isNavigatingWithKeyboard && shouldShowFocusVisibleAttrRef.current) {
      active.setAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE, "");
    } else {
      active.removeAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE);
    }
  });
  const matchOption = useEventCallback(matchOptionUnstable);
  const listboxRef = React71.useRef(null);
  const { optionWalker, listboxCallbackRef } = useOptionWalker({
    matchOption
  });
  const getActiveDescendant = React71.useCallback(() => {
    var _listboxRef_current;
    return (_listboxRef_current = listboxRef.current) === null || _listboxRef_current === void 0 ? void 0 : _listboxRef_current.querySelector(`#${activeIdRef.current}`);
  }, [
    listboxRef
  ]);
  const setShouldShowFocusVisibleAttribute = React71.useCallback((shouldShow) => {
    shouldShowFocusVisibleAttrRef.current = shouldShow;
    const active = getActiveDescendant();
    if (!active) {
      return;
    }
    if (shouldShow && focusVisibleRef.current) {
      active.setAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE, "");
    } else {
      active.removeAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE);
    }
  }, [
    getActiveDescendant
  ]);
  const blurActiveDescendant = React71.useCallback(() => {
    const active = getActiveDescendant();
    if (active) {
      active.removeAttribute(ACTIVEDESCENDANT_ATTRIBUTE);
      active.removeAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE);
    }
    removeAttribute();
    lastActiveIdRef.current = activeIdRef.current;
    activeIdRef.current = null;
    var _active_id;
    return (_active_id = active === null || active === void 0 ? void 0 : active.id) !== null && _active_id !== void 0 ? _active_id : null;
  }, [
    getActiveDescendant,
    removeAttribute
  ]);
  const focusActiveDescendant = React71.useCallback((nextActive) => {
    if (!nextActive) {
      return;
    }
    const previousActiveId = blurActiveDescendant();
    scrollIntoView2(nextActive);
    setAttribute(nextActive.id);
    nextActive.setAttribute(ACTIVEDESCENDANT_ATTRIBUTE, "");
    if (focusVisibleRef.current && shouldShowFocusVisibleAttrRef.current) {
      nextActive.setAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE, "");
    }
    const event = createActiveDescendantChangeEvent({
      id: nextActive.id,
      previousId: previousActiveId
    });
    nextActive.dispatchEvent(event);
  }, [
    blurActiveDescendant,
    setAttribute
  ]);
  const controller = React71.useMemo(() => ({
    first: ({ passive } = {}) => {
      const first = optionWalker.first();
      if (!passive) {
        focusActiveDescendant(first);
      }
      return first === null || first === void 0 ? void 0 : first.id;
    },
    last: ({ passive } = {}) => {
      const last = optionWalker.last();
      if (!passive) {
        focusActiveDescendant(last);
      }
      return last === null || last === void 0 ? void 0 : last.id;
    },
    next: ({ passive } = {}) => {
      const active = getActiveDescendant();
      if (!active) {
        return;
      }
      optionWalker.setCurrent(active);
      const next = optionWalker.next();
      if (!passive) {
        focusActiveDescendant(next);
      }
      return next === null || next === void 0 ? void 0 : next.id;
    },
    prev: ({ passive } = {}) => {
      const active = getActiveDescendant();
      if (!active) {
        return;
      }
      optionWalker.setCurrent(active);
      const next = optionWalker.prev();
      if (!passive) {
        focusActiveDescendant(next);
      }
      return next === null || next === void 0 ? void 0 : next.id;
    },
    blur: () => {
      blurActiveDescendant();
    },
    active: () => {
      var _getActiveDescendant;
      return (_getActiveDescendant = getActiveDescendant()) === null || _getActiveDescendant === void 0 ? void 0 : _getActiveDescendant.id;
    },
    focus: (id) => {
      if (!listboxRef.current) {
        return;
      }
      const target = listboxRef.current.querySelector(`#${id}`);
      if (target) {
        focusActiveDescendant(target);
      }
    },
    focusLastActive: () => {
      if (!listboxRef.current || !lastActiveIdRef.current) {
        return;
      }
      const target = listboxRef.current.querySelector(`#${lastActiveIdRef.current}`);
      if (target) {
        focusActiveDescendant(target);
        return true;
      }
    },
    find(predicate, { passive, startFrom } = {}) {
      const target = optionWalker.find(predicate, startFrom);
      if (!passive) {
        focusActiveDescendant(target);
      }
      return target === null || target === void 0 ? void 0 : target.id;
    },
    scrollActiveIntoView: () => {
      if (!listboxRef.current) {
        return;
      }
      const active = getActiveDescendant();
      if (!active) {
        return;
      }
      scrollIntoView2(active);
    },
    showAttributes() {
      attributeVisibilityRef.current = true;
      setAttribute();
    },
    hideAttributes() {
      attributeVisibilityRef.current = false;
      removeAttribute();
    },
    showFocusVisibleAttributes() {
      setShouldShowFocusVisibleAttribute(true);
    },
    hideFocusVisibleAttributes() {
      setShouldShowFocusVisibleAttribute(false);
    }
  }), [
    optionWalker,
    listboxRef,
    setAttribute,
    removeAttribute,
    focusActiveDescendant,
    blurActiveDescendant,
    getActiveDescendant,
    setShouldShowFocusVisibleAttribute
  ]);
  React71.useImperativeHandle(imperativeRef, () => controller);
  return {
    listboxRef: useMergedRefs(listboxRef, listboxCallbackRef),
    activeParentRef,
    controller
  };
}

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/AriaLiveAnnouncer.js
var React77 = __toESM(require_react());

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/renderAriaLiveAnnouncer.js
var React72 = __toESM(require_react());
var renderAriaLiveAnnouncer_unstable = (state, contextValues) => {
  return React72.createElement(AnnounceProvider, {
    value: contextValues.announce
  }, state.children);
};

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useAriaLiveAnnouncer.js
var React75 = __toESM(require_react());

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useDomAnnounce.js
var React73 = __toESM(require_react());
var MESSAGE_DURATION = 500;
var VISUALLY_HIDDEN_STYLES = {
  clip: "rect(0px, 0px, 0px, 0px)",
  height: "1px",
  margin: "-1px",
  width: "1px",
  position: "absolute",
  overflow: "hidden",
  textWrap: "nowrap"
};
var useDomAnnounce_unstable = () => {
  const { targetDocument } = useFluent();
  const timeoutRef = React73.useRef(void 0);
  const [setAnnounceTimeout, clearAnnounceTimeout] = useTimeout();
  const tabsterNeverHiddenAttributes = useDangerousNeverHidden_unstable();
  const elementRef = React73.useRef(null);
  const order = React73.useRef(0);
  const batchMessages = React73.useRef([]);
  const [messageQueue] = React73.useState(() => createPriorityQueue((a, b) => {
    if (a.priority !== b.priority) {
      return b.priority - a.priority;
    }
    return a.createdAt - b.createdAt;
  }));
  const queueMessage = React73.useCallback(() => {
    if (timeoutRef.current || !elementRef.current) {
      return;
    }
    const runCycle = () => {
      if (!elementRef.current) {
        return;
      }
      if (targetDocument && messageQueue.peek()) {
        const wrappingEl = targetDocument.createElement("span");
        wrappingEl.innerText = messageQueue.all().filter((msg) => msg.message.trim().length > 0).reduce((prevText, currMsg) => prevText + currMsg.message + ". ", "");
        elementRef.current.innerText = "";
        elementRef.current.appendChild(wrappingEl);
        messageQueue.clear();
        batchMessages.current = [];
        timeoutRef.current = setAnnounceTimeout(() => {
          runCycle();
        }, MESSAGE_DURATION);
      } else {
        elementRef.current.textContent = "";
        clearAnnounceTimeout();
        timeoutRef.current = void 0;
      }
    };
    timeoutRef.current = setAnnounceTimeout(() => {
      runCycle();
    }, 0);
  }, [
    clearAnnounceTimeout,
    messageQueue,
    setAnnounceTimeout,
    targetDocument
  ]);
  const announce = React73.useCallback((message, options = {}) => {
    const { alert = false, priority = 0, batchId } = options;
    if (alert) {
    }
    const liveMessage = {
      message,
      createdAt: order.current++,
      priority,
      batchId
    };
    if (batchId) {
      const batchMessage = batchMessages.current.find((msg) => msg.batchId === batchId);
      if (batchMessage) {
        messageQueue.remove(batchMessage.message);
        batchMessage.message = liveMessage;
      } else {
        batchMessages.current = [
          ...batchMessages.current,
          {
            batchId,
            message: liveMessage
          }
        ];
      }
    }
    messageQueue.enqueue(liveMessage);
    queueMessage();
  }, [
    messageQueue,
    queueMessage
  ]);
  React73.useEffect(() => {
    if (!targetDocument) {
      return;
    }
    const element = targetDocument.createElement("div");
    element.setAttribute("aria-live", "assertive");
    Object.entries(tabsterNeverHiddenAttributes).forEach(([key, value]) => {
      element.setAttribute(key, value);
    });
    Object.assign(element.style, VISUALLY_HIDDEN_STYLES);
    targetDocument.body.append(element);
    elementRef.current = element;
    return () => {
      element.remove();
      elementRef.current = null;
      clearAnnounceTimeout();
      timeoutRef.current = void 0;
    };
  }, [
    clearAnnounceTimeout,
    tabsterNeverHiddenAttributes,
    targetDocument
  ]);
  return announce;
};

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useAriaNotifyAnnounce.js
var React74 = __toESM(require_react());
var useAriaNotifyAnnounce_unstable = () => {
  const { targetDocument } = useFluent();
  const announce = React74.useCallback((message, options = {}) => {
    if (!targetDocument) {
      return;
    }
    const { alert = false, polite } = options;
    const defaultPriority = polite ? 0 : alert ? 2 : 1;
    var _options_priority;
    const priority = (_options_priority = options.priority) !== null && _options_priority !== void 0 ? _options_priority : defaultPriority;
    const ariaNotifyOptions = {
      priority: priority > 1 ? "high" : "normal"
    };
    targetDocument.ariaNotify(message, ariaNotifyOptions);
  }, [
    targetDocument
  ]);
  return announce;
};

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useAriaLiveAnnouncer.js
var useAriaLiveAnnouncer_unstable = (props) => {
  const { targetDocument } = useFluent();
  const domAnnounce = useDomAnnounce_unstable();
  const ariaNotifyAnnounce = useAriaNotifyAnnounce_unstable();
  const announce = React75.useMemo(() => {
    const supportsAriaNotify = typeof (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.ariaNotify) === "function";
    return supportsAriaNotify ? ariaNotifyAnnounce : domAnnounce;
  }, [
    targetDocument,
    ariaNotifyAnnounce,
    domAnnounce
  ]);
  return {
    announce,
    children: props.children
  };
};

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useAriaLiveAnnouncerContextValues.js
var React76 = __toESM(require_react());
function useAriaLiveAnnouncerContextValues_unstable(state) {
  const { announce } = state;
  return React76.useMemo(() => ({
    announce: {
      announce
    }
  }), [
    announce
  ]);
}

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/AriaLiveAnnouncer.js
var AriaLiveAnnouncer = (props) => {
  const state = useAriaLiveAnnouncer_unstable(props);
  const contextValues = useAriaLiveAnnouncerContextValues_unstable(state);
  return renderAriaLiveAnnouncer_unstable(state, contextValues);
};
AriaLiveAnnouncer.displayName = "AriaLiveAnnouncer";

// node_modules/@fluentui/react-aria/lib/useTypingAnnounce/useTypingAnnounce.js
var React78 = __toESM(require_react());
var valueMutationOptions = {
  attributes: true,
  subtree: true,
  characterData: true,
  attributeFilter: [
    "value"
  ]
};
function useTypingAnnounce() {
  const { targetDocument } = useFluent();
  const { announce } = useAnnounce();
  const inputRef = React78.useRef(null);
  const observer = React78.useRef();
  const [setTypingTimeout, clearTypingTimeout] = useTimeout();
  const messageQueue = React78.useRef([]);
  const callback = React78.useCallback((mutationList, mutationObserver) => {
    setTypingTimeout(() => {
      messageQueue.current.forEach(({ message, options }) => {
        announce(message, options);
      });
      messageQueue.current.length = 0;
      mutationObserver.disconnect();
    }, 500);
  }, [
    announce,
    setTypingTimeout
  ]);
  const typingAnnounce = React78.useCallback((message, options = {}) => {
    messageQueue.current.push({
      message,
      options
    });
    if (inputRef.current && observer.current) {
      observer.current.observe(inputRef.current, valueMutationOptions);
    }
    setTypingTimeout(() => {
      observer.current && callback([], observer.current);
    }, 500);
  }, [
    callback,
    inputRef,
    setTypingTimeout
  ]);
  React78.useEffect(() => {
    const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
    if (!win) {
      return;
    }
    if (!observer.current) {
      observer.current = new win.MutationObserver(callback);
    }
    return () => {
      if (observer.current) {
        observer.current.disconnect();
        clearTypingTimeout();
      }
    };
  }, [
    callback,
    clearTypingTimeout,
    targetDocument
  ]);
  return {
    typingAnnounce,
    inputRef
  };
}

// node_modules/@fluentui/react-motion/lib/motions/motionTokens.js
var durations2 = {
  durationUltraFast: 50,
  durationFaster: 100,
  durationFast: 150,
  durationNormal: 200,
  durationGentle: 250,
  durationSlow: 300,
  durationSlower: 400,
  durationUltraSlow: 500
};
var curves2 = {
  curveAccelerateMax: "cubic-bezier(0.9,0.1,1,0.2)",
  curveAccelerateMid: "cubic-bezier(1,0,1,1)",
  curveAccelerateMin: "cubic-bezier(0.8,0,0.78,1)",
  curveDecelerateMax: "cubic-bezier(0.1,0.9,0.2,1)",
  curveDecelerateMid: "cubic-bezier(0,0,0,1)",
  curveDecelerateMin: "cubic-bezier(0.33,0,0.1,1)",
  curveEasyEaseMax: "cubic-bezier(0.8,0,0.2,1)",
  curveEasyEase: "cubic-bezier(0.33,0,0.67,1)",
  curveLinear: "cubic-bezier(0,0,1,1)"
};
var motionTokens = {
  ...durations2,
  ...curves2
};

// node_modules/@fluentui/react-motion/lib/factories/createMotionComponent.js
var React84 = __toESM(require_react());

// node_modules/@fluentui/react-motion/lib/hooks/useAnimateAtoms.js
var React79 = __toESM(require_react());

// node_modules/@fluentui/react-motion/lib/utils/isAnimationRunning.js
function isAnimationRunning(animation) {
  if (animation.playState === "running") {
    var _animation_effect;
    if (animation.overallProgress !== void 0) {
      var _animation_overallProgress;
      const overallProgress = (_animation_overallProgress = animation.overallProgress) !== null && _animation_overallProgress !== void 0 ? _animation_overallProgress : 0;
      return overallProgress > 0 && overallProgress < 1;
    }
    var _animation_currentTime;
    const currentTime = Number((_animation_currentTime = animation.currentTime) !== null && _animation_currentTime !== void 0 ? _animation_currentTime : 0);
    var _animation_effect_getTiming_duration;
    const totalTime = Number((_animation_effect_getTiming_duration = (_animation_effect = animation.effect) === null || _animation_effect === void 0 ? void 0 : _animation_effect.getTiming().duration) !== null && _animation_effect_getTiming_duration !== void 0 ? _animation_effect_getTiming_duration : 0);
    return currentTime > 0 && currentTime < totalTime;
  }
  return false;
}

// node_modules/@fluentui/react-motion/lib/hooks/useAnimateAtoms.js
var DEFAULT_ANIMATION_OPTIONS = {
  fill: "forwards"
};
var DEFAULT_REDUCED_MOTION_ATOM = {
  duration: 1
};
function useAnimateAtomsInSupportedEnvironment() {
  var _window_Animation;
  const SUPPORTS_PERSIST = typeof window !== "undefined" && typeof ((_window_Animation = window.Animation) === null || _window_Animation === void 0 ? void 0 : _window_Animation.prototype.persist) === "function";
  return React79.useCallback((element, value, options) => {
    const atoms = Array.isArray(value) ? value : [
      value
    ];
    const { isReducedMotion } = options;
    const animations = atoms.map((motion) => {
      const { keyframes: motionKeyframes, reducedMotion = DEFAULT_REDUCED_MOTION_ATOM, ...params } = motion;
      const { keyframes: reducedMotionKeyframes = motionKeyframes, ...reducedMotionParams } = reducedMotion;
      const animationKeyframes = isReducedMotion ? reducedMotionKeyframes : motionKeyframes;
      const animationParams = {
        ...DEFAULT_ANIMATION_OPTIONS,
        ...params,
        // Use reduced motion overrides (e.g. duration, easing) when reduced motion is enabled
        ...isReducedMotion && reducedMotionParams
      };
      try {
        const animation = element.animate(animationKeyframes, animationParams);
        if (SUPPORTS_PERSIST) {
          animation === null || animation === void 0 ? void 0 : animation.persist();
        } else {
          const resultKeyframe = animationKeyframes[animationKeyframes.length - 1];
          var _element_style;
          Object.assign((_element_style = element.style) !== null && _element_style !== void 0 ? _element_style : {}, resultKeyframe);
        }
        return animation;
      } catch (e) {
        return null;
      }
    }).filter((animation) => !!animation);
    return {
      set playbackRate(rate) {
        animations.forEach((animation) => {
          animation.playbackRate = rate;
        });
      },
      setMotionEndCallbacks(onfinish, oncancel) {
        const promises = animations.map((animation) => {
          return new Promise((resolve, reject) => {
            animation.onfinish = () => resolve();
            animation.oncancel = () => reject();
          });
        });
        Promise.all(promises).then(() => {
          onfinish();
        }).catch(() => {
          oncancel();
        });
      },
      isRunning() {
        return animations.some((animation) => isAnimationRunning(animation));
      },
      cancel: () => {
        animations.forEach((animation) => {
          animation.cancel();
        });
      },
      pause: () => {
        animations.forEach((animation) => {
          animation.pause();
        });
      },
      play: () => {
        animations.forEach((animation) => {
          animation.play();
        });
      },
      finish: () => {
        animations.forEach((animation) => {
          animation.finish();
        });
      },
      reverse: () => {
        animations.forEach((animation) => {
          animation.reverse();
        });
      }
    };
  }, [
    SUPPORTS_PERSIST
  ]);
}
function useAnimateAtoms() {
  "use no memo";
  if (false) {
    return useAnimateAtomsInTestEnvironment();
  }
  return useAnimateAtomsInSupportedEnvironment();
}

// node_modules/@fluentui/react-motion/lib/hooks/useMotionImperativeRef.js
var React80 = __toESM(require_react());
function useMotionImperativeRef(imperativeRef) {
  const animationRef = React80.useRef(void 0);
  React80.useImperativeHandle(imperativeRef, () => ({
    setPlayState: (state) => {
      if (state === "running") {
        var _animationRef_current;
        (_animationRef_current = animationRef.current) === null || _animationRef_current === void 0 ? void 0 : _animationRef_current.play();
      }
      if (state === "paused") {
        var _animationRef_current1;
        (_animationRef_current1 = animationRef.current) === null || _animationRef_current1 === void 0 ? void 0 : _animationRef_current1.pause();
      }
    },
    setPlaybackRate: (rate) => {
      if (animationRef.current) {
        animationRef.current.playbackRate = rate;
      }
    }
  }));
  return animationRef;
}

// node_modules/@fluentui/react-motion/lib/hooks/useIsReducedMotion.js
var React81 = __toESM(require_react());
var REDUCED_MEDIA_QUERY = "screen and (prefers-reduced-motion: reduce)";
function useIsReducedMotion() {
  const { targetDocument } = useFluent();
  var _targetDocument_defaultView;
  const targetWindow = (_targetDocument_defaultView = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) !== null && _targetDocument_defaultView !== void 0 ? _targetDocument_defaultView : null;
  const queryValue = React81.useRef(false);
  const isEnabled = React81.useCallback(() => queryValue.current, []);
  useIsomorphicLayoutEffect(() => {
    if (targetWindow === null || typeof targetWindow.matchMedia !== "function") {
      return;
    }
    const queryMatch = targetWindow.matchMedia(REDUCED_MEDIA_QUERY);
    if (queryMatch.matches) {
      queryValue.current = true;
    }
    const matchListener = (e) => {
      queryValue.current = e.matches;
    };
    queryMatch.addEventListener("change", matchListener);
    return () => {
      queryMatch.removeEventListener("change", matchListener);
    };
  }, [
    targetWindow
  ]);
  return isEnabled;
}

// node_modules/@fluentui/react-motion/lib/utils/useChildElement.js
var React82 = __toESM(require_react());
var CHILD_ERROR_MESSAGE = [
  "@fluentui/react-motion: Invalid child element.",
  "\n",
  "Motion factories require a single child element to be passed. ",
  "That element element should support ref forwarding i.e. it should be either an intrinsic element (e.g. div) or a component that uses React.forwardRef()."
].join("");
function useChildElement(children2, mounted = true) {
  const childRef = React82.useRef(null);
  React82.useEffect(() => {
    if (true) {
      if (mounted && !childRef.current) {
        console.error(CHILD_ERROR_MESSAGE);
      }
    }
  }, [
    mounted
  ]);
  try {
    const child = React82.Children.only(children2);
    if (React82.isValidElement(child)) {
      return [
        React82.cloneElement(child, {
          ref: useMergedRefs(childRef, getReactElementRef(child))
        }),
        childRef
      ];
    }
  } catch {
  }
  throw new Error(CHILD_ERROR_MESSAGE);
}

// node_modules/@fluentui/react-motion/lib/contexts/MotionBehaviourContext.js
var React83 = __toESM(require_react());
var MotionBehaviourContext = React83.createContext(void 0);
var MotionBehaviourProvider = MotionBehaviourContext.Provider;
var useMotionBehaviourContext = () => {
  var _React_useContext;
  return (_React_useContext = React83.useContext(MotionBehaviourContext)) !== null && _React_useContext !== void 0 ? _React_useContext : "default";
};

// node_modules/@fluentui/react-motion/lib/factories/createMotionComponent.js
function createMotionComponent(value) {
  const Atom = (props) => {
    "use no memo";
    const { children: children2, imperativeRef, onMotionFinish: onMotionFinishProp, onMotionStart: onMotionStartProp, onMotionCancel: onMotionCancelProp, ..._rest } = props;
    const params = _rest;
    const [child, childRef] = useChildElement(children2);
    const handleRef = useMotionImperativeRef(imperativeRef);
    const skipMotions = useMotionBehaviourContext() === "skip";
    const optionsRef = React84.useRef({
      skipMotions,
      params
    });
    const animateAtoms = useAnimateAtoms();
    const isReducedMotion = useIsReducedMotion();
    const onMotionStart = useEventCallback(() => {
      onMotionStartProp === null || onMotionStartProp === void 0 ? void 0 : onMotionStartProp(null);
    });
    const onMotionFinish = useEventCallback(() => {
      onMotionFinishProp === null || onMotionFinishProp === void 0 ? void 0 : onMotionFinishProp(null);
    });
    const onMotionCancel = useEventCallback(() => {
      onMotionCancelProp === null || onMotionCancelProp === void 0 ? void 0 : onMotionCancelProp(null);
    });
    useIsomorphicLayoutEffect(() => {
      optionsRef.current = {
        skipMotions,
        params
      };
    });
    useIsomorphicLayoutEffect(() => {
      const element = childRef.current;
      if (element) {
        const atoms = typeof value === "function" ? value({
          element,
          ...optionsRef.current.params
        }) : value;
        onMotionStart();
        const handle = animateAtoms(element, atoms, {
          isReducedMotion: isReducedMotion()
        });
        handleRef.current = handle;
        handle.setMotionEndCallbacks(onMotionFinish, onMotionCancel);
        if (optionsRef.current.skipMotions) {
          handle.finish();
        }
        return () => {
          handle.cancel();
        };
      }
    }, [
      animateAtoms,
      childRef,
      handleRef,
      isReducedMotion,
      onMotionFinish,
      onMotionStart,
      onMotionCancel
    ]);
    return child;
  };
  return Atom;
}

// node_modules/@fluentui/react-motion/lib/factories/createPresenceComponent.js
var React87 = __toESM(require_react());

// node_modules/@fluentui/react-motion/lib/contexts/PresenceGroupChildContext.js
var React85 = __toESM(require_react());
var PresenceGroupChildContext = React85.createContext(void 0);
var PresenceGroupChildProvider = PresenceGroupChildContext.Provider;

// node_modules/@fluentui/react-motion/lib/hooks/useMountedState.js
var React86 = __toESM(require_react());
function useMountedState(visible = false, unmountOnExit = false) {
  const mountedRef = React86.useRef(unmountOnExit ? visible : true);
  const forceUpdate = useForceUpdate();
  const setMounted = React86.useCallback((newValue) => {
    if (mountedRef.current !== newValue) {
      mountedRef.current = newValue;
      forceUpdate();
    }
  }, [
    forceUpdate
  ]);
  React86.useEffect(() => {
    if (visible) {
      mountedRef.current = visible;
    }
  });
  return [
    visible || mountedRef.current,
    setMounted
  ];
}

// node_modules/@fluentui/react-motion/lib/factories/createPresenceComponent.js
var MOTION_DEFINITION = Symbol("MOTION_DEFINITION");
var INTERRUPTABLE_MOTION_SYMBOL = Symbol.for("interruptablePresence");
function createPresenceComponent(value) {
  return Object.assign((props) => {
    "use no memo";
    const itemContext = React87.useContext(PresenceGroupChildContext);
    const merged = {
      ...itemContext,
      ...props
    };
    const skipMotions = useMotionBehaviourContext() === "skip";
    const { appear, children: children2, imperativeRef, onExit, onMotionFinish, onMotionStart, onMotionCancel, visible, unmountOnExit, ..._rest } = merged;
    const params = _rest;
    const [mounted, setMounted] = useMountedState(visible, unmountOnExit);
    const [child, childRef] = useChildElement(children2, mounted);
    const handleRef = useMotionImperativeRef(imperativeRef);
    const optionsRef = React87.useRef({
      appear,
      params,
      skipMotions
    });
    const animateAtoms = useAnimateAtoms();
    const isFirstMount = useFirstMount();
    const isReducedMotion = useIsReducedMotion();
    const handleMotionStart = useEventCallback((direction) => {
      onMotionStart === null || onMotionStart === void 0 ? void 0 : onMotionStart(null, {
        direction
      });
    });
    const handleMotionFinish = useEventCallback((direction) => {
      onMotionFinish === null || onMotionFinish === void 0 ? void 0 : onMotionFinish(null, {
        direction
      });
      if (direction === "exit" && unmountOnExit) {
        setMounted(false);
        onExit === null || onExit === void 0 ? void 0 : onExit();
      }
    });
    const handleMotionCancel = useEventCallback((direction) => {
      onMotionCancel === null || onMotionCancel === void 0 ? void 0 : onMotionCancel(null, {
        direction
      });
    });
    useIsomorphicLayoutEffect(() => {
      optionsRef.current = {
        appear,
        params,
        skipMotions
      };
    });
    useIsomorphicLayoutEffect(
      () => {
        const element = childRef.current;
        if (!element) {
          return;
        }
        let handle;
        function cleanup() {
          if (!handle) {
            return;
          }
          if (IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION && handle.isRunning()) {
            return;
          }
          handle.cancel();
          handleRef.current = void 0;
        }
        const presenceMotion = typeof value === "function" ? value({
          element,
          ...optionsRef.current.params
        }) : value;
        const IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION = presenceMotion[INTERRUPTABLE_MOTION_SYMBOL];
        if (IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION) {
          handle = handleRef.current;
          if (handle && handle.isRunning()) {
            handle.reverse();
            return cleanup;
          }
        }
        const atoms = visible ? presenceMotion.enter : presenceMotion.exit;
        const direction = visible ? "enter" : "exit";
        const applyInitialStyles = !optionsRef.current.appear && isFirstMount;
        const skipAnimationByConfig = optionsRef.current.skipMotions;
        if (!applyInitialStyles) {
          handleMotionStart(direction);
        }
        handle = animateAtoms(element, atoms, {
          isReducedMotion: isReducedMotion()
        });
        if (applyInitialStyles) {
          handle.finish();
          return cleanup;
        }
        handleRef.current = handle;
        handle.setMotionEndCallbacks(() => handleMotionFinish(direction), () => handleMotionCancel(direction));
        if (skipAnimationByConfig) {
          handle.finish();
        }
        return cleanup;
      },
      // Excluding `isFirstMount` from deps to prevent re-triggering the animation on subsequent renders
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        animateAtoms,
        childRef,
        handleRef,
        isReducedMotion,
        handleMotionFinish,
        handleMotionStart,
        handleMotionCancel,
        visible
      ]
    );
    if (mounted) {
      return child;
    }
    return null;
  }, {
    // Heads up!
    // Always normalize it to a function to simplify types
    [MOTION_DEFINITION]: typeof value === "function" ? value : () => value
  }, {
    // Wrap `enter` in its own motion component as a static method, e.g. <Fade.In>
    In: createMotionComponent(
      // If we have a motion function, wrap it to forward the runtime params and pick `enter`.
      // Otherwise, pass the `enter` motion object directly.
      typeof value === "function" ? (...args) => value(...args).enter : value.enter
    ),
    // Wrap `exit` in its own motion component as a static method, e.g. <Fade.Out>
    Out: createMotionComponent(
      // If we have a motion function, wrap it to forward the runtime params and pick `exit`.
      // Otherwise, pass the `exit` motion object directly.
      typeof value === "function" ? (...args) => value(...args).exit : value.exit
    )
  });
}

// node_modules/@fluentui/react-motion/lib/factories/createPresenceComponentVariant.js
function createPresenceFnVariant(presenceFn, variantParams) {
  const variantFn = (runtimeParams) => presenceFn({
    ...variantParams,
    ...runtimeParams
  });
  return variantFn;
}
function createPresenceComponentVariant(component, variantParams) {
  const originalFn = component[MOTION_DEFINITION];
  const variantFn = createPresenceFnVariant(originalFn, variantParams);
  return createPresenceComponent(variantFn);
}

// node_modules/@swc/helpers/esm/_define_property.js
function _define_property(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else obj[key] = value;
  return obj;
}

// node_modules/@fluentui/react-motion/lib/components/PresenceGroup.js
var React90 = __toESM(require_react());

// node_modules/@fluentui/react-motion/lib/utils/groups/mergeChildMappings.js
function mergeChildMappings(prevMapping, nextMapping) {
  function getValueForKey(key) {
    return key in nextMapping ? nextMapping[key] : prevMapping[key];
  }
  const nextKeysPending = {};
  let pendingKeys = [];
  for (const prevKey in prevMapping) {
    if (prevKey in nextMapping) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
      continue;
    }
    pendingKeys.push(prevKey);
  }
  const childMapping = {};
  for (const nextKey in nextMapping) {
    if (nextKeysPending[nextKey]) {
      for (const pendingNextKey of nextKeysPending[nextKey]) {
        childMapping[pendingNextKey] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (const pendingKey of pendingKeys) {
    childMapping[pendingKey] = getValueForKey(pendingKey);
  }
  return childMapping;
}

// node_modules/@fluentui/react-motion/lib/utils/groups/getNextChildMapping.js
function getNextChildMapping(prevChildMapping, nextChildMapping) {
  const childrenMapping = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.entries(childrenMapping).forEach(([key, childDefinition]) => {
    const hasPrev = key in prevChildMapping;
    const hasNext = key in nextChildMapping;
    if (hasNext) {
      if (hasPrev) {
        childrenMapping[key] = {
          ...childDefinition
        };
        return;
      }
      childrenMapping[key] = {
        ...childDefinition,
        appear: true,
        visible: true
      };
      return;
    }
    childrenMapping[key] = {
      ...childDefinition,
      visible: false
    };
  });
  return childrenMapping;
}

// node_modules/@fluentui/react-motion/lib/utils/groups/getChildMapping.js
var React88 = __toESM(require_react());
function getChildMapping(children2) {
  const childMapping = {};
  if (children2) {
    React88.Children.toArray(children2).forEach((child) => {
      if (React88.isValidElement(child)) {
        var _child_key;
        childMapping[(_child_key = child.key) !== null && _child_key !== void 0 ? _child_key : ""] = {
          appear: false,
          element: child,
          visible: true,
          unmountOnExit: true
        };
      }
    });
  }
  return childMapping;
}

// node_modules/@fluentui/react-motion/lib/components/PresenceGroupItemProvider.js
var React89 = __toESM(require_react());
var PresenceGroupItemProvider = (props) => {
  const { appear, childKey, onExit, visible, unmountOnExit } = props;
  const contextValue = React89.useMemo(() => ({
    appear,
    visible,
    onExit: () => onExit(childKey),
    unmountOnExit
  }), [
    appear,
    childKey,
    onExit,
    visible,
    unmountOnExit
  ]);
  return React89.createElement(PresenceGroupChildContext.Provider, {
    value: contextValue
  }, props.children);
};

// node_modules/@fluentui/react-motion/lib/components/PresenceGroup.js
var PresenceGroup = class extends React90.Component {
  static getDerivedStateFromProps(nextProps, { childMapping: prevChildMapping, firstRender }) {
    const nextChildMapping = getChildMapping(nextProps.children);
    return {
      childMapping: firstRender ? nextChildMapping : getNextChildMapping(prevChildMapping, nextChildMapping),
      firstRender: false
    };
  }
  componentDidMount() {
    this.mounted = true;
  }
  componentWillUnmount() {
    this.mounted = false;
  }
  render() {
    return React90.createElement(React90.Fragment, null, Object.entries(this.state.childMapping).map(([childKey, childProps]) => React90.createElement(PresenceGroupItemProvider, {
      ...childProps,
      childKey,
      key: childKey,
      onExit: this.handleExit
    }, childProps.element)));
  }
  constructor(props, context) {
    super(props, context), _define_property(this, "mounted", false), _define_property(this, "handleExit", (childKey) => {
      const currentChildMapping = getChildMapping(this.props.children);
      if (childKey in currentChildMapping) {
        return;
      }
      if (this.mounted) {
        this.setState((state) => {
          const childMapping = {
            ...state.childMapping
          };
          delete childMapping[childKey];
          return {
            childMapping
          };
        });
      }
    });
    this.state = {
      childMapping: {},
      firstRender: true
    };
  }
};

// node_modules/@fluentui/react-motion/lib/slots/presenceMotionSlot.js
var React91 = __toESM(require_react());
function presenceMotionSlot(motion, options) {
  const { as, children: children2, ...rest } = motion !== null && motion !== void 0 ? motion : {};
  if (true) {
    if (typeof as !== "undefined") {
      throw new Error(`@fluentui/react-motion: "as" property is not supported on motion slots.`);
    }
  }
  if (motion === null) {
    const isUnmounted = !options.defaultProps.visible && options.defaultProps.unmountOnExit;
    const renderFn = (_, props) => isUnmounted ? null : React91.createElement(React91.Fragment, null, props.children);
    return {
      [SLOT_RENDER_FUNCTION_SYMBOL]: renderFn,
      [SLOT_ELEMENT_TYPE_SYMBOL]: options.elementType
    };
  }
  const propsWithMetadata = {
    ...options.defaultProps,
    ...rest,
    [SLOT_ELEMENT_TYPE_SYMBOL]: options.elementType
  };
  if (typeof children2 === "function") {
    propsWithMetadata[SLOT_RENDER_FUNCTION_SYMBOL] = children2;
  }
  return propsWithMetadata;
}

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/useAccordionHeader.js
var useAccordionHeader_unstable = (props, ref) => {
  const { icon, button, expandIcon, inline: inline2 = false, size: size3 = "medium", expandIconPosition = "start" } = props;
  const { value, disabled, open } = useAccordionItemContext_unstable();
  const requestToggle = useAccordionContext_unstable((ctx) => ctx.requestToggle);
  const disabledFocusable = useAccordionContext_unstable((ctx) => !ctx.collapsible && ctx.openItems.length === 1 && open);
  const { dir } = useFluent();
  let expandIconRotation;
  if (expandIconPosition === "end") {
    expandIconRotation = open ? -90 : 90;
  } else {
    expandIconRotation = open ? 90 : dir !== "rtl" ? 0 : 180;
  }
  const buttonSlot = slot_exports.always(button, {
    elementType: "button",
    defaultProps: {
      disabled,
      disabledFocusable,
      "aria-expanded": open,
      type: "button"
    }
  });
  buttonSlot.onClick = useEventCallback((event) => {
    if (isResolvedShorthand(button)) {
      var _button_onClick;
      (_button_onClick = button.onClick) === null || _button_onClick === void 0 ? void 0 : _button_onClick.call(button, event);
    }
    if (!event.defaultPrevented) {
      requestToggle({
        value,
        event
      });
    }
  });
  return {
    disabled,
    open,
    size: size3,
    inline: inline2,
    expandIconPosition,
    components: {
      root: "div",
      button: "button",
      expandIcon: "span",
      icon: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    icon: slot_exports.optional(icon, {
      elementType: "div"
    }),
    expandIcon: slot_exports.optional(expandIcon, {
      renderByDefault: true,
      defaultProps: {
        children: React92.createElement(ChevronRightRegular, {
          style: {
            transform: `rotate(${expandIconRotation}deg)`,
            transition: `transform ${motionTokens.durationNormal}ms ease-out`
          }
        }),
        "aria-hidden": true
      },
      elementType: "span"
    }),
    button: useARIAButtonProps(buttonSlot.as, buttonSlot)
  };
};

// node_modules/@fluentui/react-accordion/lib/contexts/accordionHeader.js
var React93 = __toESM(require_react());
var AccordionHeaderContext = React93.createContext(void 0);
var { Provider: AccordionHeaderProvider } = AccordionHeaderContext;

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/renderAccordionHeader.js
var renderAccordionHeader_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(AccordionHeaderProvider, {
    value: contextValues.accordionHeader,
    children: jsx(state.root, {
      children: jsxs(state.button, {
        children: [
          state.expandIconPosition === "start" && state.expandIcon && jsx(state.expandIcon, {}),
          state.icon && jsx(state.icon, {}),
          state.root.children,
          state.expandIconPosition === "end" && state.expandIcon && jsx(state.expandIcon, {})
        ]
      })
    })
  });
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/useAccordionHeaderStyles.styles.js
var accordionHeaderClassNames = {
  root: "fui-AccordionHeader",
  button: "fui-AccordionHeader__button",
  expandIcon: "fui-AccordionHeader__expandIcon",
  icon: "fui-AccordionHeader__icon"
};
var useStyles2 = __styles2({
  resetButton: {
    B7ck84d: "f1e4lqlz",
    De3pzq: "f1u2r49w",
    sj55zd: "f1ym3bx4",
    Bahqtrf: "f1mo0ibp",
    Be2twd7: "fjoy568",
    Bg96gwp: "fytdu2e",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1gl81tg",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    Bv0vk6g: "f37px4s",
    fsow6f: "fgusgyc"
  },
  focusIndicator: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Bb7d1vk: "f226i61",
    zhwhgb: ["f13kzufm", "fsx75g8"],
    dhy2o1: "flujwa2",
    Gfyso: ["fsx75g8", "f13kzufm"],
    Bm4h7ae: "f15bsgw9",
    B7ys5i9: "f14e48fq",
    Busjfv9: "f18yb2kv",
    Bhk32uz: "fd6o370",
    f6g5ot: 0,
    Boxcth7: 0,
    Bhdgwq3: 0,
    hgwjuy: 0,
    Bshpdp8: 0,
    Bsom6fd: 0,
    Blkhhs4: 0,
    Bonggc9: 0,
    Ddfuxk: 0,
    i03rao: 0,
    kclons: 0,
    clg4pj: 0,
    Bpqj9nj: 0,
    B6dhp37: 0,
    Bf4ptjt: 0,
    Bqtpl0w: 0,
    i4rwgc: "ffwy5si",
    Dah5zi: 0,
    B1tsrr9: 0,
    qqdqy8: 0,
    Bkh64rk: 0,
    e3fwne: "f3znvyf",
    J0r882: "f57olzd",
    Bule8hv: ["f4stah7", "fs1por5"],
    Bjwuhne: "f480a47",
    Ghsupd: ["fs1por5", "f4stah7"]
  },
  root: {
    sj55zd: "f19n0e5",
    De3pzq: "f1c21dwh",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  rootDisabled: {
    Bcmaq0h: "fwrgwhw",
    sj55zd: "f1s2aq7o"
  },
  rootInline: {
    mc9l5x: "f14t3ns0"
  },
  button: {
    qhf8xq: "f10pi13n",
    a9b677: "fly5x3f",
    B4j52fo: "fre7gi1",
    Bekrc4i: ["f1358rze", "f1rvrf73"],
    Bn0qgzm: "fqdk4by",
    ibv6hh: ["f1rvrf73", "f1358rze"],
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1rmphuq", "f26yw9j"],
    sshi5w: "f5pgtk9",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Bceei9c: "f1k6fduh",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    B7ck84d: "f1ewtqcl"
  },
  buttonSmall: {
    sshi5w: "f1nxs5xn",
    Be2twd7: "fy9rknc"
  },
  buttonLarge: {
    Bg96gwp: "faaz57k",
    Be2twd7: "fod5ikn"
  },
  buttonExtraLarge: {
    Bg96gwp: "f106mvju",
    Be2twd7: "f1pp30po"
  },
  buttonInline: {
    mc9l5x: "ftuwxu6"
  },
  buttonExpandIconEndNoIcon: {
    uwmqm3: ["f1uw59to", "fw5db7e"]
  },
  buttonExpandIconEnd: {
    z189sj: ["f11gcy0p", "f1ng84yb"]
  },
  buttonDisabled: {
    Bceei9c: "fdrzuqr"
  },
  expandIcon: {
    Bqenvij: "f1l02sjl",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Bg96gwp: "f106mvju",
    Be2twd7: "f1pp30po"
  },
  expandIconStart: {
    z189sj: ["f1vdfbxk", "f1f5gg8d"]
  },
  expandIconEnd: {
    Bh6795r: "fqerorx",
    Bnnss6s: "f1neuvcm",
    xawz: "flqd7gy",
    mc9l5x: "f22iagw",
    Brf1p80: "f9c4gz4",
    uwmqm3: ["f1f5gg8d", "f1vdfbxk"]
  },
  icon: {
    Bqenvij: "f1l02sjl",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    z189sj: ["f1vdfbxk", "f1f5gg8d"],
    Bg96gwp: "f106mvju",
    Be2twd7: "f1pp30po"
  }
}, {
  d: [".f1e4lqlz{box-sizing:content-box;}", ".f1u2r49w{background-color:inherit;}", ".f1ym3bx4{color:inherit;}", ".f1mo0ibp{font-family:inherit;}", ".fjoy568{font-size:inherit;}", ".fytdu2e{line-height:normal;}", [".f1gl81tg{overflow:visible;}", {
    p: -1
  }], [".f1mk8lai{padding:0;}", {
    p: -1
  }], ".f37px4s{-webkit-appearance:button;}", ".fgusgyc{text-align:unset;}", ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", '.f15bsgw9[data-fui-focus-visible]::after{content:"";}', ".f14e48fq[data-fui-focus-visible]::after{position:absolute;}", ".f18yb2kv[data-fui-focus-visible]::after{pointer-events:none;}", ".fd6o370[data-fui-focus-visible]::after{z-index:1;}", [".ffwy5si[data-fui-focus-visible]::after{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f3znvyf[data-fui-focus-visible]::after{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f57olzd[data-fui-focus-visible]::after{top:calc(2px * -1);}", ".f4stah7[data-fui-focus-visible]::after{right:calc(2px * -1);}", ".fs1por5[data-fui-focus-visible]::after{left:calc(2px * -1);}", ".f480a47[data-fui-focus-visible]::after{bottom:calc(2px * -1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".f1s184ao{margin:0;}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fwrgwhw{background-image:none;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f14t3ns0{display:inline-block;}", ".f10pi13n{position:relative;}", ".fly5x3f{width:100%;}", ".fre7gi1{border-top-width:0;}", ".f1358rze{border-right-width:0;}", ".f1rvrf73{border-left-width:0;}", ".fqdk4by{border-bottom-width:0;}", [".f1rmphuq{padding:0 var(--spacingHorizontalM) 0 var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".f26yw9j{padding:0 var(--spacingHorizontalMNudge) 0 var(--spacingHorizontalM);}", {
    p: -1
  }], ".f5pgtk9{min-height:44px;}", ".f22iagw{display:flex;}", ".f122n59{align-items:center;}", ".f1k6fduh{cursor:pointer;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1ewtqcl{box-sizing:border-box;}", ".f1nxs5xn{min-height:32px;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".f106mvju{line-height:var(--lineHeightBase500);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".ftuwxu6{display:inline-flex;}", ".f1uw59to{padding-left:var(--spacingHorizontalM);}", ".fw5db7e{padding-right:var(--spacingHorizontalM);}", ".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}", ".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}", ".fdrzuqr{cursor:not-allowed;}", ".f1l02sjl{height:100%;}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".fqerorx{flex-grow:1;}", ".f1neuvcm{flex-shrink:1;}", ".flqd7gy{flex-basis:0%;}", ".f9c4gz4{justify-content:flex-end;}"],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"],
  m: [["@media (forced-colors: active){.f226i61[data-fui-focus-visible]::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f13kzufm[data-fui-focus-visible]::after{border-right-color:Highlight;}.fsx75g8[data-fui-focus-visible]::after{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.flujwa2[data-fui-focus-visible]::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useAccordionHeaderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles2();
  state.root.className = mergeClasses(accordionHeaderClassNames.root, styles.root, state.inline && styles.rootInline, state.disabled && styles.rootDisabled, state.root.className);
  state.button.className = mergeClasses(accordionHeaderClassNames.button, styles.resetButton, styles.button, styles.focusIndicator, state.expandIconPosition === "end" && !state.icon && styles.buttonExpandIconEndNoIcon, state.expandIconPosition === "end" && styles.buttonExpandIconEnd, state.inline && styles.buttonInline, state.size === "small" && styles.buttonSmall, state.size === "large" && styles.buttonLarge, state.size === "extra-large" && styles.buttonExtraLarge, state.disabled && styles.buttonDisabled, state.button.className);
  if (state.expandIcon) {
    state.expandIcon.className = mergeClasses(accordionHeaderClassNames.expandIcon, styles.expandIcon, state.expandIconPosition === "start" && styles.expandIconStart, state.expandIconPosition === "end" && styles.expandIconEnd, state.expandIcon.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(accordionHeaderClassNames.icon, styles.icon, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/useAccordionHeaderContextValues.js
var React94 = __toESM(require_react());
function useAccordionHeaderContextValues_unstable(state) {
  const { disabled, expandIconPosition, open, size: size3 } = state;
  const accordionHeader = React94.useMemo(() => ({
    disabled,
    expandIconPosition,
    open,
    size: size3
  }), [
    disabled,
    expandIconPosition,
    open,
    size3
  ]);
  return {
    accordionHeader
  };
}

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/AccordionHeader.js
var AccordionHeader = React95.forwardRef((props, ref) => {
  const state = useAccordionHeader_unstable(props, ref);
  const contextValues = useAccordionHeaderContextValues_unstable(state);
  useAccordionHeaderStyles_unstable(state);
  useCustomStyleHook("useAccordionHeaderStyles_unstable")(state);
  return renderAccordionHeader_unstable(state, contextValues);
});
AccordionHeader.displayName = "AccordionHeader";

// node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/AccordionPanel.js
var React97 = __toESM(require_react());

// node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/useAccordionPanel.js
var React96 = __toESM(require_react());

// node_modules/@fluentui/react-motion-components-preview/lib/components/Collapse/collapse-atoms.js
var sizeValuesForOrientation = (orientation, element) => {
  const sizeName = orientation === "horizontal" ? "maxWidth" : "maxHeight";
  const overflowName = orientation === "horizontal" ? "overflowX" : "overflowY";
  const measuredSize = orientation === "horizontal" ? element.scrollWidth : element.scrollHeight;
  const toSize = `${measuredSize}px`;
  return {
    sizeName,
    overflowName,
    toSize
  };
};
var sizeEnterAtom = ({ orientation, duration, easing, element, fromSize = "0" }) => {
  const { sizeName, overflowName, toSize } = sizeValuesForOrientation(orientation, element);
  return {
    keyframes: [
      {
        [sizeName]: fromSize,
        [overflowName]: "hidden"
      },
      {
        [sizeName]: toSize,
        offset: 0.9999,
        [overflowName]: "hidden"
      },
      {
        [sizeName]: "unset",
        [overflowName]: "unset"
      }
    ],
    duration,
    easing
  };
};
var sizeExitAtom = ({ orientation, duration, easing, element, delay = 0, fromSize = "0" }) => {
  const { sizeName, overflowName, toSize } = sizeValuesForOrientation(orientation, element);
  return {
    keyframes: [
      {
        [sizeName]: toSize,
        [overflowName]: "hidden"
      },
      {
        [sizeName]: fromSize,
        [overflowName]: "hidden"
      }
    ],
    duration,
    easing,
    fill: "both",
    delay
  };
};
var whitespaceValuesForOrientation = (orientation) => {
  if (orientation === "horizontal") {
    return {
      paddingStart: "paddingInlineStart",
      paddingEnd: "paddingInlineEnd",
      marginStart: "marginInlineStart",
      marginEnd: "marginInlineEnd"
    };
  }
  return {
    paddingStart: "paddingBlockStart",
    paddingEnd: "paddingBlockEnd",
    marginStart: "marginBlockStart",
    marginEnd: "marginBlockEnd"
  };
};
var whitespaceAtom = ({ direction, orientation, duration, easing, delay = 0 }) => {
  const { paddingStart, paddingEnd, marginStart, marginEnd } = whitespaceValuesForOrientation(orientation);
  const offset4 = direction === "enter" ? 0 : 1;
  const keyframes = [
    {
      [paddingStart]: "0",
      [paddingEnd]: "0",
      [marginStart]: "0",
      [marginEnd]: "0",
      offset: offset4
    }
  ];
  const atom = {
    keyframes,
    duration,
    easing,
    delay
  };
  if (direction === "exit") {
    atom.fill = "forwards";
  }
  return atom;
};

// node_modules/@fluentui/react-motion-components-preview/lib/atoms/fade-atom.js
var fadeAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, fromOpacity = 0 }) => {
  const keyframes = [
    {
      opacity: fromOpacity
    },
    {
      opacity: 1
    }
  ];
  if (direction === "exit") {
    keyframes.reverse();
  }
  return {
    keyframes,
    duration,
    easing,
    delay,
    // Applying opacity backwards and forwards in time is important
    // to avoid a bug where a delayed animation is not hidden when it should be.
    fill: "both"
  };
};

// node_modules/@fluentui/react-motion-components-preview/lib/components/Collapse/Collapse.js
function createCollapseAtoms({
  element,
  orientation,
  animateOpacity,
  // Enter params
  sizeDuration,
  opacityDuration = sizeDuration,
  easing,
  delay,
  // Exit params
  exitSizeDuration,
  exitOpacityDuration = exitSizeDuration,
  exitEasing,
  exitDelay
}) {
  const enterAtoms = [
    sizeEnterAtom({
      orientation,
      duration: sizeDuration,
      easing,
      element
    }),
    whitespaceAtom({
      direction: "enter",
      orientation,
      duration: sizeDuration,
      easing
    })
  ];
  if (animateOpacity) {
    enterAtoms.push({
      ...fadeAtom({
        direction: "enter",
        duration: opacityDuration,
        easing
      }),
      delay,
      fill: "both"
    });
  }
  const exitAtoms = [];
  if (animateOpacity) {
    exitAtoms.push(fadeAtom({
      direction: "exit",
      duration: exitOpacityDuration,
      easing: exitEasing
    }));
  }
  exitAtoms.push(sizeExitAtom({
    orientation,
    duration: exitSizeDuration,
    easing: exitEasing,
    element,
    delay: exitDelay
  }), whitespaceAtom({
    direction: "exit",
    orientation,
    duration: exitSizeDuration,
    easing: exitEasing,
    delay: exitDelay
  }));
  return {
    enter: enterAtoms,
    exit: exitAtoms
  };
}
var collapsePresenceFn = ({ element, duration = motionTokens.durationNormal, easing = motionTokens.curveEasyEaseMax, exitDuration = duration, exitEasing = easing, animateOpacity = true, orientation = "vertical" }) => {
  return createCollapseAtoms({
    element,
    orientation,
    animateOpacity,
    sizeDuration: duration,
    opacityDuration: duration,
    easing,
    exitSizeDuration: exitDuration,
    exitOpacityDuration: exitDuration,
    exitEasing,
    delay: 0,
    exitDelay: 0
  });
};
var collapseDelayedPresenceFn = ({ element, sizeDuration = motionTokens.durationNormal, opacityDuration = motionTokens.durationSlower, easing = motionTokens.curveEasyEase, delay = motionTokens.durationNormal, exitSizeDuration = sizeDuration, exitOpacityDuration = opacityDuration, exitEasing = easing, exitDelay = motionTokens.durationSlower, animateOpacity = true, orientation = "vertical" }) => {
  return createCollapseAtoms({
    element,
    orientation,
    animateOpacity,
    sizeDuration,
    opacityDuration,
    easing,
    delay,
    exitSizeDuration,
    exitOpacityDuration,
    exitEasing,
    exitDelay
  });
};
var Collapse = createPresenceComponent(collapsePresenceFn);
var CollapseSnappy = createPresenceComponentVariant(Collapse, {
  duration: motionTokens.durationFast
});
var CollapseRelaxed = createPresenceComponentVariant(Collapse, {
  duration: motionTokens.durationSlower
});
var CollapseDelayed = createPresenceComponent(collapseDelayedPresenceFn);

// node_modules/@fluentui/react-motion-components-preview/lib/components/Fade/Fade.js
var fadePresenceFn = ({ duration = motionTokens.durationNormal, easing = motionTokens.curveEasyEase, delay = 0, exitDuration = duration, exitEasing = easing, exitDelay = delay }) => {
  return {
    enter: fadeAtom({
      direction: "enter",
      duration,
      easing,
      delay
    }),
    exit: fadeAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay
    })
  };
};
var Fade = createPresenceComponent(fadePresenceFn);
var FadeSnappy = createPresenceComponentVariant(Fade, {
  duration: motionTokens.durationFast
});
var FadeRelaxed = createPresenceComponentVariant(Fade, {
  duration: motionTokens.durationGentle
});

// node_modules/@fluentui/react-motion-components-preview/lib/atoms/scale-atom.js
var scaleAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, fromScale = 0.9, toScale = 1 }) => {
  const keyframes = [
    {
      scale: fromScale
    },
    {
      scale: toScale
    }
  ];
  if (direction === "exit") {
    keyframes.reverse();
  }
  return {
    keyframes,
    duration,
    easing,
    delay
  };
};

// node_modules/@fluentui/react-motion-components-preview/lib/components/Scale/Scale.js
var scalePresenceFn = ({ duration = motionTokens.durationGentle, easing = motionTokens.curveDecelerateMax, delay = 0, exitDuration = motionTokens.durationNormal, exitEasing = motionTokens.curveAccelerateMax, exitDelay = delay, fromScale = 0.9, animateOpacity = true }) => {
  const enterAtoms = [
    scaleAtom({
      direction: "enter",
      duration,
      easing,
      delay,
      fromScale
    })
  ];
  const exitAtoms = [
    scaleAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay,
      fromScale
    })
  ];
  if (animateOpacity) {
    enterAtoms.push(fadeAtom({
      direction: "enter",
      duration,
      easing,
      delay
    }));
    exitAtoms.push(fadeAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay
    }));
  }
  return {
    enter: enterAtoms,
    exit: exitAtoms
  };
};
var Scale = createPresenceComponent(scalePresenceFn);
var ScaleSnappy = createPresenceComponentVariant(Scale, {
  duration: motionTokens.durationNormal,
  exitDuration: motionTokens.durationFast
});
var ScaleRelaxed = createPresenceComponentVariant(Scale, {
  duration: motionTokens.durationSlow,
  exitDuration: motionTokens.durationGentle
});

// node_modules/@fluentui/react-motion-components-preview/lib/atoms/slide-atom.js
var slideAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, fromX = "0px", fromY = "20px" }) => {
  const keyframes = [
    {
      translate: `${fromX} ${fromY}`
    },
    {
      translate: "0px 0px"
    }
  ];
  if (direction === "exit") {
    keyframes.reverse();
  }
  return {
    keyframes,
    duration,
    easing,
    delay
  };
};

// node_modules/@fluentui/react-motion-components-preview/lib/components/Slide/Slide.js
var slidePresenceFn = ({ duration = motionTokens.durationNormal, easing = motionTokens.curveDecelerateMid, delay = 0, exitDuration = duration, exitEasing = motionTokens.curveAccelerateMid, exitDelay = delay, fromX = "0px", fromY = "20px", animateOpacity = true }) => {
  const enterAtoms = [
    slideAtom({
      direction: "enter",
      duration,
      easing,
      delay,
      fromX,
      fromY
    })
  ];
  const exitAtoms = [
    slideAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay,
      fromX,
      fromY
    })
  ];
  if (animateOpacity) {
    enterAtoms.push(fadeAtom({
      direction: "enter",
      duration,
      easing,
      delay
    }));
    exitAtoms.push(fadeAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay
    }));
  }
  return {
    enter: enterAtoms,
    exit: exitAtoms
  };
};
var Slide = createPresenceComponent(slidePresenceFn);
var SlideSnappy = createPresenceComponentVariant(Slide, {
  easing: motionTokens.curveDecelerateMax,
  exitEasing: motionTokens.curveAccelerateMax
});
var SlideRelaxed = createPresenceComponentVariant(Slide, {
  duration: motionTokens.durationGentle
});

// node_modules/@fluentui/react-motion-components-preview/lib/atoms/blur-atom.js
var blurAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, fromRadius = "10px" }) => {
  const keyframes = [
    {
      filter: `blur(${fromRadius})`
    },
    {
      filter: "blur(0px)"
    }
  ];
  if (direction === "exit") {
    keyframes.reverse();
  }
  return {
    keyframes,
    duration,
    easing,
    delay
  };
};

// node_modules/@fluentui/react-motion-components-preview/lib/components/Blur/Blur.js
var blurPresenceFn = ({ duration = motionTokens.durationSlow, easing = motionTokens.curveDecelerateMin, delay = 0, exitDuration = duration, exitEasing = motionTokens.curveAccelerateMin, exitDelay = delay, fromRadius = "10px", animateOpacity = true }) => {
  const enterAtoms = [
    blurAtom({
      direction: "enter",
      duration,
      easing,
      delay,
      fromRadius
    })
  ];
  const exitAtoms = [
    blurAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay,
      fromRadius
    })
  ];
  if (animateOpacity) {
    enterAtoms.push(fadeAtom({
      direction: "enter",
      duration,
      easing,
      delay
    }));
    exitAtoms.push(fadeAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay
    }));
  }
  return {
    enter: enterAtoms,
    exit: exitAtoms
  };
};
var Blur = createPresenceComponent(blurPresenceFn);

// node_modules/@fluentui/react-motion-components-preview/lib/atoms/rotate-atom.js
var createRotateValue = (axis, angle) => {
  return `${axis.toLowerCase()} ${angle}deg`;
};
var rotateAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, axis = "y", angle = -90, exitAngle = -angle }) => {
  let fromAngle = angle;
  let toAngle = 0;
  if (direction === "exit") {
    fromAngle = 0;
    toAngle = exitAngle;
  }
  const keyframes = [
    {
      rotate: createRotateValue(axis, fromAngle)
    },
    {
      rotate: createRotateValue(axis, toAngle)
    }
  ];
  return {
    keyframes,
    duration,
    easing,
    delay
  };
};

// node_modules/@fluentui/react-motion-components-preview/lib/components/Rotate/Rotate.js
var rotatePresenceFn = ({ duration = motionTokens.durationGentle, easing = motionTokens.curveDecelerateMax, delay = 0, exitDuration = duration, exitEasing = motionTokens.curveAccelerateMax, exitDelay = delay, axis = "y", angle = -90, exitAngle = -angle, animateOpacity = true }) => {
  const enterAtoms = [
    rotateAtom({
      direction: "enter",
      duration,
      easing,
      delay,
      axis,
      angle,
      exitAngle
    })
  ];
  const exitAtoms = [
    rotateAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay,
      axis,
      angle,
      exitAngle
    })
  ];
  if (animateOpacity) {
    enterAtoms.push(fadeAtom({
      direction: "enter",
      duration,
      easing,
      delay
    }));
    exitAtoms.push(fadeAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay
    }));
  }
  return {
    enter: enterAtoms,
    exit: exitAtoms
  };
};
var Rotate = createPresenceComponent(rotatePresenceFn);

// node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/useAccordionPanel.js
var useAccordionPanel_unstable = (props, ref) => {
  const { open } = useAccordionItemContext_unstable();
  const focusableProps = useTabsterAttributes({
    focusable: {
      excludeFromMover: true
    }
  });
  const navigation = useAccordionContext_unstable((ctx) => ctx.navigation);
  return {
    open,
    components: {
      root: "div",
      collapseMotion: Collapse
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props,
      ...navigation && focusableProps
    }), {
      elementType: "div"
    }),
    collapseMotion: presenceMotionSlot(props.collapseMotion, {
      elementType: Collapse,
      defaultProps: {
        visible: open,
        unmountOnExit: true
      }
    })
  };
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/renderAccordionPanel.js
var renderAccordionPanel_unstable = (state) => {
  assertSlots(state);
  return state.collapseMotion ? jsx(state.collapseMotion, {
    children: jsx(state.root, {})
  }) : jsx(state.root, {});
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/useAccordionPanelStyles.styles.js
var accordionPanelClassNames = {
  root: "fui-AccordionPanel"
};
var useStyles3 = __styles2({
  root: {
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1axvtxu"
  }
}, {
  d: [[".f1axvtxu{margin:0 var(--spacingHorizontalM);}", {
    p: -1
  }]]
});
var useAccordionPanelStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles3();
  state.root.className = mergeClasses(accordionPanelClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/AccordionPanel.js
var AccordionPanel = React97.forwardRef((props, ref) => {
  const state = useAccordionPanel_unstable(props, ref);
  useAccordionPanelStyles_unstable(state);
  useCustomStyleHook("useAccordionPanelStyles_unstable")(state);
  return renderAccordionPanel_unstable(state);
});
AccordionPanel.displayName = "AccordionPanel";

// node_modules/@fluentui/react-avatar/lib/components/Avatar/Avatar.js
var React108 = __toESM(require_react());

// node_modules/@fluentui/react-avatar/lib/components/Avatar/renderAvatar.js
var renderAvatar_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.initials && jsx(state.initials, {}),
      state.icon && jsx(state.icon, {}),
      state.image && jsx(state.image, {}),
      state.badge && jsx(state.badge, {}),
      state.activeAriaLabelElement
    ]
  });
};

// node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatar.js
var React107 = __toESM(require_react());

// node_modules/@fluentui/react-avatar/lib/utils/getInitials.js
var UNWANTED_ENCLOSURES_REGEX = /[\(\[\{][^\)\]\}]*[\)\]\}]/g;
var UNWANTED_CHARS_REGEX = /[\0-\u001F\!-/:-@\[-`\{-\u00BF\u0250-\u036F\uD800-\uFFFF]/g;
var PHONENUMBER_REGEX = /^\d+[\d\s]*(:?ext|x|)\s*\d+$/i;
var MULTIPLE_WHITESPACES_REGEX = /\s+/g;
var UNSUPPORTED_TEXT_REGEX = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uAC00-\uD7AF\uD7B0-\uD7FF\u3040-\u309F\u30A0-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD869][\uDC00-\uDED6]/;
function getInitialsLatin(displayName, isRtl, firstInitialOnly) {
  let initials = "";
  const splits = displayName.split(" ");
  if (splits.length !== 0) {
    initials += splits[0].charAt(0).toUpperCase();
  }
  if (!firstInitialOnly) {
    if (splits.length === 2) {
      initials += splits[1].charAt(0).toUpperCase();
    } else if (splits.length === 3) {
      initials += splits[2].charAt(0).toUpperCase();
    }
  }
  if (isRtl && initials.length > 1) {
    return initials.charAt(1) + initials.charAt(0);
  }
  return initials;
}
function cleanupDisplayName(displayName) {
  displayName = displayName.replace(UNWANTED_ENCLOSURES_REGEX, "");
  displayName = displayName.replace(UNWANTED_CHARS_REGEX, "");
  displayName = displayName.replace(MULTIPLE_WHITESPACES_REGEX, " ");
  displayName = displayName.trim();
  return displayName;
}
function getInitials(displayName, isRtl, options) {
  if (!displayName) {
    return "";
  }
  displayName = cleanupDisplayName(displayName);
  if (UNSUPPORTED_TEXT_REGEX.test(displayName) || !(options === null || options === void 0 ? void 0 : options.allowPhoneInitials) && PHONENUMBER_REGEX.test(displayName)) {
    return "";
  }
  return getInitialsLatin(displayName, isRtl, options === null || options === void 0 ? void 0 : options.firstInitialOnly);
}

// node_modules/@fluentui/react-avatar/lib/utils/partitionAvatarGroupItems.js
var partitionAvatarGroupItems = (options) => {
  const { items } = options;
  const isPie = options.layout === "pie";
  if (isPie) {
    return {
      inlineItems: items.slice(0, 3),
      overflowItems: items.length > 0 ? items : void 0
    };
  }
  var _options_maxInlineItems;
  const maxInlineItems = (_options_maxInlineItems = options.maxInlineItems) !== null && _options_maxInlineItems !== void 0 ? _options_maxInlineItems : 5;
  const inlineCount = -(maxInlineItems - (items.length > maxInlineItems ? 1 : 0));
  const overflowItems = items.slice(0, inlineCount);
  return {
    inlineItems: items.slice(inlineCount),
    overflowItems: overflowItems.length > 0 ? overflowItems : void 0
  };
};

// node_modules/@fluentui/react-badge/lib/components/Badge/Badge.js
var React100 = __toESM(require_react());

// node_modules/@fluentui/react-badge/lib/components/Badge/useBadge.js
var React98 = __toESM(require_react());
var useBadge_unstable = (props, ref) => {
  const { shape = "circular", size: size3 = "medium", iconPosition = "before", appearance = "filled", color: color2 = "brand" } = props;
  const state = {
    shape,
    size: size3,
    iconPosition,
    appearance,
    color: color2,
    components: {
      root: "div",
      icon: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    icon: slot_exports.optional(props.icon, {
      elementType: "span"
    })
  };
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/Badge/useBadgeStyles.styles.js
var React99 = __toESM(require_react());
var badgeClassNames = {
  root: "fui-Badge",
  icon: "fui-Badge__icon"
};
var textPadding = tokens.spacingHorizontalXXS;
var useRootClassName = __resetStyles("r1iycov", "r115jdol", [".r1iycov{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;position:relative;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase200);height:20px;min-width:20px;padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));border-radius:var(--borderRadiusCircular);border-color:var(--colorTransparentStroke);}", '.r1iycov::after{content:"";position:absolute;top:0;left:0;bottom:0;right:0;border-style:solid;border-color:inherit;border-width:var(--strokeWidthThin);border-radius:inherit;}', ".r115jdol{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;position:relative;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase200);height:20px;min-width:20px;padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));border-radius:var(--borderRadiusCircular);border-color:var(--colorTransparentStroke);}", '.r115jdol::after{content:"";position:absolute;top:0;right:0;bottom:0;left:0;border-style:solid;border-color:inherit;border-width:var(--strokeWidthThin);border-radius:inherit;}']);
var useRootStyles = __styles2({
  fontSmallToTiny: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f13mqy1h",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fcpl73t"
  },
  tiny: {
    a9b677: "f16dn6v3",
    Bqenvij: "f3mu39s",
    Be2twd7: "f130uwy9",
    Bg96gwp: "fod1mrr",
    Bf4jedk: "f18p0k4z",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f19jm9xf"
  },
  "extra-small": {
    a9b677: "fpd43o0",
    Bqenvij: "f30q22z",
    Be2twd7: "f1tccstq",
    Bg96gwp: "f1y3arg5",
    Bf4jedk: "f18p0k4z",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f19jm9xf"
  },
  small: {
    Bf4jedk: "fq2vo04",
    Bqenvij: "fd461yt",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fupdldz"
  },
  medium: {},
  large: {
    Bf4jedk: "f17fgpbq",
    Bqenvij: "frvgh55",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1996nqw"
  },
  "extra-large": {
    Bf4jedk: "fwbmr0d",
    Bqenvij: "f1d2rq10",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fty64o7"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw"
  },
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  roundedSmallToTiny: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fq9zq91"
  },
  circular: {},
  borderGhost: {
    ap17g6: "f10ludwy"
  },
  filled: {},
  "filled-brand": {
    De3pzq: "ffp7eso",
    sj55zd: "f1phragk"
  },
  "filled-danger": {
    De3pzq: "fdl5y0r",
    sj55zd: "f1phragk"
  },
  "filled-important": {
    De3pzq: "f1c73kur",
    sj55zd: "fr0bkrk"
  },
  "filled-informative": {
    De3pzq: "f3vzo32",
    sj55zd: "f11d4kpn"
  },
  "filled-severe": {
    De3pzq: "f1s438gw",
    sj55zd: "f1phragk"
  },
  "filled-subtle": {
    De3pzq: "fxugw4r",
    sj55zd: "f19n0e5"
  },
  "filled-success": {
    De3pzq: "flxk52p",
    sj55zd: "f1phragk"
  },
  "filled-warning": {
    De3pzq: "ffq97bm",
    sj55zd: "ff5vbop"
  },
  ghost: {},
  "ghost-brand": {
    sj55zd: "f16muhyy"
  },
  "ghost-danger": {
    sj55zd: "f1whyuy6"
  },
  "ghost-important": {
    sj55zd: "f19n0e5"
  },
  "ghost-informative": {
    sj55zd: "f11d4kpn"
  },
  "ghost-severe": {
    sj55zd: "f1l8vj45"
  },
  "ghost-subtle": {
    sj55zd: "fonrgv7"
  },
  "ghost-success": {
    sj55zd: "f1m7fhi8"
  },
  "ghost-warning": {
    sj55zd: "fpti2h4"
  },
  outline: {
    g2u3we: "f23ftbb",
    h3c5rm: ["f1gkuv52", "f1p1bl80"],
    B9xav0g: "fioka3i",
    zhjwy3: ["f1p1bl80", "f1gkuv52"]
  },
  "outline-brand": {
    sj55zd: "f16muhyy"
  },
  "outline-danger": {
    sj55zd: "f1whyuy6",
    g2u3we: "fyqpifd",
    h3c5rm: ["f3ukxca", "f1k7dugc"],
    B9xav0g: "f1njxb2b",
    zhjwy3: ["f1k7dugc", "f3ukxca"]
  },
  "outline-important": {
    sj55zd: "f11d4kpn",
    g2u3we: "fq0vr37",
    h3c5rm: ["f1byw159", "f11cr0be"],
    B9xav0g: "f1c1zstj",
    zhjwy3: ["f11cr0be", "f1byw159"]
  },
  "outline-informative": {
    sj55zd: "f11d4kpn",
    g2u3we: "f68mrw8",
    h3c5rm: ["f7pw515", "fw35ms5"],
    B9xav0g: "frpde29",
    zhjwy3: ["fw35ms5", "f7pw515"]
  },
  "outline-severe": {
    sj55zd: "f1l8vj45"
  },
  "outline-subtle": {
    sj55zd: "fonrgv7"
  },
  "outline-success": {
    sj55zd: "f1m7fhi8",
    g2u3we: "f1mmhl11",
    h3c5rm: ["f1tjpp2f", "f1ocn5n7"],
    B9xav0g: "f1gjv25d",
    zhjwy3: ["f1ocn5n7", "f1tjpp2f"]
  },
  "outline-warning": {
    sj55zd: "fpti2h4"
  },
  tint: {},
  "tint-brand": {
    De3pzq: "f16xkysk",
    sj55zd: "faj9fo0",
    g2u3we: "f161y7kd",
    h3c5rm: ["f1c8dzaj", "f1sl6hi9"],
    B9xav0g: "f1619yhw",
    zhjwy3: ["f1sl6hi9", "f1c8dzaj"]
  },
  "tint-danger": {
    De3pzq: "ff0poqj",
    sj55zd: "f1hcrxcs",
    g2u3we: "f1oqjm8o",
    h3c5rm: ["fkgrb8g", "frb5wm0"],
    B9xav0g: "f1iai1ph",
    zhjwy3: ["frb5wm0", "fkgrb8g"]
  },
  "tint-important": {
    De3pzq: "f945g0u",
    sj55zd: "fr0bkrk",
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"]
  },
  "tint-informative": {
    De3pzq: "f1ctqxl6",
    sj55zd: "f11d4kpn",
    g2u3we: "f68mrw8",
    h3c5rm: ["f7pw515", "fw35ms5"],
    B9xav0g: "frpde29",
    zhjwy3: ["fw35ms5", "f7pw515"]
  },
  "tint-severe": {
    De3pzq: "f1xzsg4",
    sj55zd: "f1k5f75o",
    g2u3we: "fxy9dsj",
    h3c5rm: ["f54u6j2", "fcm23ze"],
    B9xav0g: "f4vf0uq",
    zhjwy3: ["fcm23ze", "f54u6j2"]
  },
  "tint-subtle": {
    De3pzq: "fxugw4r",
    sj55zd: "f11d4kpn",
    g2u3we: "f68mrw8",
    h3c5rm: ["f7pw515", "fw35ms5"],
    B9xav0g: "frpde29",
    zhjwy3: ["fw35ms5", "f7pw515"]
  },
  "tint-success": {
    De3pzq: "f2vsrz6",
    sj55zd: "ffmvakt",
    g2u3we: "fdmic9h",
    h3c5rm: ["f196y6m", "fetptd8"],
    B9xav0g: "f1pev5xq",
    zhjwy3: ["fetptd8", "f196y6m"]
  },
  "tint-warning": {
    De3pzq: "f10s6hli",
    sj55zd: "f42v8de",
    g2u3we: "fn9i3n",
    h3c5rm: ["f1aw8cx4", "f51if14"],
    B9xav0g: "fvq8iai",
    zhjwy3: ["f51if14", "f1aw8cx4"]
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fcpl73t{line-height:var(--lineHeightBase100);}", ".f16dn6v3{width:6px;}", ".f3mu39s{height:6px;}", ".f130uwy9{font-size:4px;}", ".fod1mrr{line-height:4px;}", ".f18p0k4z{min-width:unset;}", [".f19jm9xf{padding:unset;}", {
    p: -1
  }], ".fpd43o0{width:10px;}", ".f30q22z{height:10px;}", ".f1tccstq{font-size:6px;}", ".f1y3arg5{line-height:6px;}", [".f19jm9xf{padding:unset;}", {
    p: -1
  }], ".fq2vo04{min-width:16px;}", ".fd461yt{height:16px;}", [".fupdldz{padding:0 calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], ".f17fgpbq{min-width:24px;}", ".frvgh55{height:24px;}", [".f1996nqw{padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], ".fwbmr0d{min-width:32px;}", ".f1d2rq10{height:32px;}", [".fty64o7{padding:0 calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
    p: -1
  }], ".f10ludwy::after{display:none;}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fdl5y0r{background-color:var(--colorPaletteRedBackground3);}", ".f1c73kur{background-color:var(--colorNeutralForeground1);}", ".fr0bkrk{color:var(--colorNeutralBackground1);}", ".f3vzo32{background-color:var(--colorNeutralBackground5);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f1s438gw{background-color:var(--colorPaletteDarkOrangeBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".flxk52p{background-color:var(--colorPaletteGreenBackground3);}", ".ffq97bm{background-color:var(--colorPaletteYellowBackground3);}", ".ff5vbop{color:var(--colorNeutralForeground1Static);}", ".f16muhyy{color:var(--colorBrandForeground1);}", ".f1whyuy6{color:var(--colorPaletteRedForeground3);}", ".f1l8vj45{color:var(--colorPaletteDarkOrangeForeground3);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1m7fhi8{color:var(--colorPaletteGreenForeground3);}", ".fpti2h4{color:var(--colorPaletteYellowForeground2);}", ".f23ftbb{border-top-color:currentColor;}", ".f1gkuv52{border-right-color:currentColor;}", ".f1p1bl80{border-left-color:currentColor;}", ".fioka3i{border-bottom-color:currentColor;}", ".fyqpifd{border-top-color:var(--colorPaletteRedBorder2);}", ".f3ukxca{border-right-color:var(--colorPaletteRedBorder2);}", ".f1k7dugc{border-left-color:var(--colorPaletteRedBorder2);}", ".f1njxb2b{border-bottom-color:var(--colorPaletteRedBorder2);}", ".fq0vr37{border-top-color:var(--colorNeutralStrokeAccessible);}", ".f1byw159{border-right-color:var(--colorNeutralStrokeAccessible);}", ".f11cr0be{border-left-color:var(--colorNeutralStrokeAccessible);}", ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", ".f68mrw8{border-top-color:var(--colorNeutralStroke2);}", ".f7pw515{border-right-color:var(--colorNeutralStroke2);}", ".fw35ms5{border-left-color:var(--colorNeutralStroke2);}", ".frpde29{border-bottom-color:var(--colorNeutralStroke2);}", ".f1mmhl11{border-top-color:var(--colorPaletteGreenBorder2);}", ".f1tjpp2f{border-right-color:var(--colorPaletteGreenBorder2);}", ".f1ocn5n7{border-left-color:var(--colorPaletteGreenBorder2);}", ".f1gjv25d{border-bottom-color:var(--colorPaletteGreenBorder2);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".faj9fo0{color:var(--colorBrandForeground2);}", ".f161y7kd{border-top-color:var(--colorBrandStroke2);}", ".f1c8dzaj{border-right-color:var(--colorBrandStroke2);}", ".f1sl6hi9{border-left-color:var(--colorBrandStroke2);}", ".f1619yhw{border-bottom-color:var(--colorBrandStroke2);}", ".ff0poqj{background-color:var(--colorPaletteRedBackground1);}", ".f1hcrxcs{color:var(--colorPaletteRedForeground1);}", ".f1oqjm8o{border-top-color:var(--colorPaletteRedBorder1);}", ".fkgrb8g{border-right-color:var(--colorPaletteRedBorder1);}", ".frb5wm0{border-left-color:var(--colorPaletteRedBorder1);}", ".f1iai1ph{border-bottom-color:var(--colorPaletteRedBorder1);}", ".f945g0u{background-color:var(--colorNeutralForeground3);}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".f1ctqxl6{background-color:var(--colorNeutralBackground4);}", ".f1xzsg4{background-color:var(--colorPaletteDarkOrangeBackground1);}", ".f1k5f75o{color:var(--colorPaletteDarkOrangeForeground1);}", ".fxy9dsj{border-top-color:var(--colorPaletteDarkOrangeBorder1);}", ".f54u6j2{border-right-color:var(--colorPaletteDarkOrangeBorder1);}", ".fcm23ze{border-left-color:var(--colorPaletteDarkOrangeBorder1);}", ".f4vf0uq{border-bottom-color:var(--colorPaletteDarkOrangeBorder1);}", ".f2vsrz6{background-color:var(--colorPaletteGreenBackground1);}", ".ffmvakt{color:var(--colorPaletteGreenForeground1);}", ".fdmic9h{border-top-color:var(--colorPaletteGreenBorder1);}", ".f196y6m{border-right-color:var(--colorPaletteGreenBorder1);}", ".fetptd8{border-left-color:var(--colorPaletteGreenBorder1);}", ".f1pev5xq{border-bottom-color:var(--colorPaletteGreenBorder1);}", ".f10s6hli{background-color:var(--colorPaletteYellowBackground1);}", ".f42v8de{color:var(--colorPaletteYellowForeground1);}", ".fn9i3n{border-top-color:var(--colorPaletteYellowBorder1);}", ".f1aw8cx4{border-right-color:var(--colorPaletteYellowBorder1);}", ".f51if14{border-left-color:var(--colorPaletteYellowBorder1);}", ".fvq8iai{border-bottom-color:var(--colorPaletteYellowBorder1);}"]
});
var useIconRootClassName = __resetStyles("rttl5z0", null, [".rttl5z0{display:flex;line-height:1;margin:0 calc(-1 * var(--spacingHorizontalXXS));font-size:12px;}"]);
var useIconStyles = __styles2({
  beforeText: {
    t21cq0: ["f1t8l4o1", "f11juvx6"]
  },
  afterText: {
    Frg6f3: ["f11juvx6", "f1t8l4o1"]
  },
  beforeTextXL: {
    t21cq0: ["f1rs9grm", "f1kwmkpi"]
  },
  afterTextXL: {
    Frg6f3: ["f1kwmkpi", "f1rs9grm"]
  },
  tiny: {
    Be2twd7: "f1tccstq"
  },
  "extra-small": {
    Be2twd7: "fnmn6fi"
  },
  small: {
    Be2twd7: "f1ugzwwg"
  },
  medium: {},
  large: {
    Be2twd7: "f4ybsrx"
  },
  "extra-large": {
    Be2twd7: "fe5j1ua"
  }
}, {
  d: [".f1t8l4o1{margin-right:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", ".f11juvx6{margin-left:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", ".f1rs9grm{margin-right:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", ".f1kwmkpi{margin-left:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", ".f1tccstq{font-size:6px;}", ".fnmn6fi{font-size:10px;}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}"]
});
var useBadgeStyles_unstable = (state) => {
  "use no memo";
  const rootClassName = useRootClassName();
  const rootStyles = useRootStyles();
  const smallToTiny = state.size === "small" || state.size === "extra-small" || state.size === "tiny";
  state.root.className = mergeClasses(badgeClassNames.root, rootClassName, smallToTiny && rootStyles.fontSmallToTiny, rootStyles[state.size], rootStyles[state.shape], state.shape === "rounded" && smallToTiny && rootStyles.roundedSmallToTiny, state.appearance === "ghost" && rootStyles.borderGhost, rootStyles[state.appearance], rootStyles[`${state.appearance}-${state.color}`], state.root.className);
  const iconRootClassName = useIconRootClassName();
  const iconStyles = useIconStyles();
  if (state.icon) {
    let iconPositionClass;
    if (React99.Children.toArray(state.root.children).length > 0) {
      if (state.size === "extra-large") {
        iconPositionClass = state.iconPosition === "after" ? iconStyles.afterTextXL : iconStyles.beforeTextXL;
      } else {
        iconPositionClass = state.iconPosition === "after" ? iconStyles.afterText : iconStyles.beforeText;
      }
    }
    state.icon.className = mergeClasses(badgeClassNames.icon, iconRootClassName, iconPositionClass, iconStyles[state.size], state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/Badge/renderBadge.js
var renderBadge_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.iconPosition === "before" && state.icon && jsx(state.icon, {}),
      state.root.children,
      state.iconPosition === "after" && state.icon && jsx(state.icon, {})
    ]
  });
};

// node_modules/@fluentui/react-badge/lib/components/Badge/Badge.js
var Badge = React100.forwardRef((props, ref) => {
  const state = useBadge_unstable(props, ref);
  useBadgeStyles_unstable(state);
  useCustomStyleHook("useBadgeStyles_unstable")(state);
  return renderBadge_unstable(state);
});
Badge.displayName = "Badge";

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/PresenceBadge.js
var React103 = __toESM(require_react());

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadge.js
var React102 = __toESM(require_react());

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/presenceIcons.js
var React101 = __toESM(require_react());
var presenceAwayRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceAway10Regular,
  "extra-small": PresenceAway10Regular,
  small: PresenceAway12Regular,
  medium: PresenceAway16Regular,
  large: PresenceAway20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceAway20Regular
};
var presenceAwayFilled = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceAway10Filled,
  "extra-small": PresenceAway10Filled,
  small: PresenceAway12Filled,
  medium: PresenceAway16Filled,
  large: PresenceAway20Filled,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceAway20Filled
};
var presenceAvailableRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceAvailable10Regular,
  "extra-small": PresenceAvailable10Regular,
  small: PresenceAvailable12Regular,
  medium: PresenceAvailable16Regular,
  large: PresenceAvailable20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceAvailable20Regular
};
var presenceAvailableFilled = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceAvailable10Filled,
  "extra-small": PresenceAvailable10Filled,
  small: PresenceAvailable12Filled,
  medium: PresenceAvailable16Filled,
  large: PresenceAvailable20Filled,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceAvailable20Filled
};
var presenceBlockedRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceBlocked10Regular,
  "extra-small": PresenceBlocked10Regular,
  small: PresenceBlocked12Regular,
  medium: PresenceBlocked16Regular,
  large: PresenceBlocked20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceBlocked20Regular
};
var presenceBusyFilled = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceBusy10Filled,
  "extra-small": PresenceBusy10Filled,
  small: PresenceBusy12Filled,
  medium: PresenceBusy16Filled,
  large: PresenceBusy20Filled,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceBusy20Filled
};
var presenceDndFilled = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceDnd10Filled,
  "extra-small": PresenceDnd10Filled,
  small: PresenceDnd12Filled,
  medium: PresenceDnd16Filled,
  large: PresenceDnd20Filled,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceDnd20Filled
};
var presenceDndRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceDnd10Regular,
  "extra-small": PresenceDnd10Regular,
  small: PresenceDnd12Regular,
  medium: PresenceDnd16Regular,
  large: PresenceDnd20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceDnd20Regular
};
var presenceOofRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceOof10Regular,
  "extra-small": PresenceOof10Regular,
  small: PresenceOof12Regular,
  medium: PresenceOof16Regular,
  large: PresenceOof20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceOof20Regular
};
var presenceOfflineRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceOffline10Regular,
  "extra-small": PresenceOffline10Regular,
  small: PresenceOffline12Regular,
  medium: PresenceOffline16Regular,
  large: PresenceOffline20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceOffline20Regular
};
var presenceUnknownRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceUnknown10Regular,
  "extra-small": PresenceUnknown10Regular,
  small: PresenceUnknown12Regular,
  medium: PresenceUnknown16Regular,
  large: PresenceUnknown20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceUnknown20Regular
};

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadge.js
var iconMap = (status, outOfOffice, size3) => {
  switch (status) {
    case "available":
      return outOfOffice ? presenceAvailableRegular[size3] : presenceAvailableFilled[size3];
    case "away":
      return outOfOffice ? presenceOofRegular[size3] : presenceAwayFilled[size3];
    case "blocked":
      return presenceBlockedRegular[size3];
    case "busy":
      return outOfOffice ? presenceUnknownRegular[size3] : presenceBusyFilled[size3];
    case "do-not-disturb":
      return outOfOffice ? presenceDndRegular[size3] : presenceDndFilled[size3];
    case "offline":
      return outOfOffice ? presenceOofRegular[size3] : presenceOfflineRegular[size3];
    case "out-of-office":
      return presenceOofRegular[size3];
    case "unknown":
      return presenceUnknownRegular[size3];
  }
};
var DEFAULT_STRINGS = {
  busy: "busy",
  "out-of-office": "out of office",
  away: "away",
  available: "available",
  offline: "offline",
  "do-not-disturb": "do not disturb",
  unknown: "unknown",
  blocked: "blocked"
};
var usePresenceBadge_unstable = (props, ref) => {
  const { size: size3 = "medium", status = "available", outOfOffice = false } = props;
  const statusText = DEFAULT_STRINGS[status];
  const oofText = props.outOfOffice && props.status !== "out-of-office" ? ` ${DEFAULT_STRINGS["out-of-office"]}` : "";
  const IconElement = iconMap(status, outOfOffice, size3);
  const state = {
    ...useBadge_unstable({
      "aria-label": statusText + oofText,
      role: "img",
      ...props,
      size: size3,
      icon: slot_exports.optional(props.icon, {
        defaultProps: {
          children: IconElement ? React102.createElement(IconElement, null) : null
        },
        renderByDefault: true,
        elementType: "span"
      })
    }, ref),
    status,
    outOfOffice
  };
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadgeStyles.styles.js
var presenceBadgeClassNames = {
  root: "fui-PresenceBadge",
  icon: "fui-PresenceBadge__icon"
};
var getIsBusy = (status) => {
  if (status === "busy" || status === "do-not-disturb" || status === "blocked") {
    return true;
  }
  return false;
};
var useRootClassName2 = __resetStyles("r832ydo", null, [".r832ydo{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;border-radius:var(--borderRadiusCircular);background-color:var(--colorNeutralBackground1);padding:1px;background-clip:content-box;}"]);
var useIconClassName = __resetStyles("r11ag4qr", null, [".r11ag4qr{display:flex;margin:-1px;}"]);
var useStyles4 = __styles2({
  statusBusy: {
    sj55zd: "fvi85wt"
  },
  statusAway: {
    sj55zd: "f14k8a89"
  },
  statusAvailable: {
    sj55zd: "fqa5hgp"
  },
  statusOffline: {
    sj55zd: "f11d4kpn"
  },
  statusOutOfOffice: {
    sj55zd: "fdce8r3"
  },
  statusUnknown: {
    sj55zd: "f11d4kpn"
  },
  outOfOffice: {
    sj55zd: "fr0bkrk"
  },
  outOfOfficeAvailable: {
    sj55zd: "fqa5hgp"
  },
  outOfOfficeBusy: {
    sj55zd: "fvi85wt"
  },
  outOfOfficeUnknown: {
    sj55zd: "f11d4kpn"
  },
  tiny: {
    Bubjx69: "f9ikmtg",
    a9b677: "f16dn6v3",
    B2eet1l: "f1w2irj7",
    B5pe6w7: "fab5kbq",
    p4uzdd: "f1ms1d91"
  },
  large: {
    Bubjx69: "f9ikmtg",
    a9b677: "f64fuq3",
    B5pe6w7: "f1vfi1yj",
    p4uzdd: "f15s34gz"
  },
  extraLarge: {
    Bubjx69: "f9ikmtg",
    a9b677: "f1w9dchk",
    B5pe6w7: "f14efy9b",
    p4uzdd: "fhipgdu"
  }
}, {
  d: [".fvi85wt{color:var(--colorPaletteRedBackground3);}", ".f14k8a89{color:var(--colorPaletteMarigoldBackground3);}", ".fqa5hgp{color:var(--colorPaletteLightGreenForeground3);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".fdce8r3{color:var(--colorPaletteBerryForeground3);}", ".fr0bkrk{color:var(--colorNeutralBackground1);}", ".f9ikmtg{aspect-ratio:1;}", ".f16dn6v3{width:6px;}", ".f1w2irj7{background-clip:unset;}", ".fab5kbq svg{width:6px!important;}", ".f1ms1d91 svg{height:6px!important;}", ".f64fuq3{width:20px;}", ".f1vfi1yj svg{width:20px!important;}", ".f15s34gz svg{height:20px!important;}", ".f1w9dchk{width:28px;}", ".f14efy9b svg{width:28px!important;}", ".fhipgdu svg{height:28px!important;}"]
});
var usePresenceBadgeStyles_unstable = (state) => {
  "use no memo";
  const rootClassName = useRootClassName2();
  const iconClassName = useIconClassName();
  const styles = useStyles4();
  const isBusy = getIsBusy(state.status);
  state.root.className = mergeClasses(presenceBadgeClassNames.root, rootClassName, isBusy && styles.statusBusy, state.status === "away" && styles.statusAway, state.status === "available" && styles.statusAvailable, state.status === "offline" && styles.statusOffline, state.status === "out-of-office" && styles.statusOutOfOffice, state.status === "unknown" && styles.statusUnknown, state.outOfOffice && styles.outOfOffice, state.outOfOffice && state.status === "available" && styles.outOfOfficeAvailable, state.outOfOffice && isBusy && styles.outOfOfficeBusy, state.outOfOffice && (state.status === "out-of-office" || state.status === "away" || state.status === "offline") && styles.statusOutOfOffice, state.outOfOffice && state.status === "unknown" && styles.outOfOfficeUnknown, state.size === "tiny" && styles.tiny, state.size === "large" && styles.large, state.size === "extra-large" && styles.extraLarge, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(presenceBadgeClassNames.icon, iconClassName, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/PresenceBadge.js
var PresenceBadge = React103.forwardRef((props, ref) => {
  const state = usePresenceBadge_unstable(props, ref);
  usePresenceBadgeStyles_unstable(state);
  useCustomStyleHook("usePresenceBadgeStyles_unstable")(state);
  return renderBadge_unstable(state);
});
PresenceBadge.displayName = "PresenceBadge";

// node_modules/@fluentui/react-badge/lib/components/CounterBadge/CounterBadge.js
var React105 = __toESM(require_react());

// node_modules/@fluentui/react-badge/lib/components/CounterBadge/useCounterBadge.js
var React104 = __toESM(require_react());
var useCounterBadge_unstable = (props, ref) => {
  const { shape = "circular", appearance = "filled", showZero = false, overflowCount = 99, count = 0, dot = false } = props;
  const state = {
    ...useBadge_unstable(props, ref),
    shape,
    appearance,
    showZero,
    count,
    dot
  };
  if ((count !== 0 || showZero) && !dot && !state.root.children) {
    state.root.children = count > overflowCount ? `${overflowCount}+` : `${count}`;
  }
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/CounterBadge/useCounterBadgeStyles.styles.js
var counterBadgeClassNames = {
  root: "fui-CounterBadge",
  icon: "fui-CounterBadge__icon"
};
var useStyles5 = __styles2({
  dot: {
    Bf4jedk: "fgfkb25",
    a9b677: "f16dn6v3",
    Bqenvij: "f3mu39s",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai"
  },
  hide: {
    mc9l5x: "fjseox"
  }
}, {
  d: [".fgfkb25{min-width:auto;}", ".f16dn6v3{width:6px;}", ".f3mu39s{height:6px;}", [".f1mk8lai{padding:0;}", {
    p: -1
  }], ".fjseox{display:none;}"]
});
var useCounterBadgeStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles5();
  state.root.className = mergeClasses(counterBadgeClassNames.root, state.dot && styles.dot, !state.root.children && !state.dot && styles.hide, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(counterBadgeClassNames.icon, state.icon.className);
  }
  return useBadgeStyles_unstable(state);
};

// node_modules/@fluentui/react-badge/lib/components/CounterBadge/CounterBadge.js
var CounterBadge = React105.forwardRef((props, ref) => {
  const state = useCounterBadge_unstable(props, ref);
  useCounterBadgeStyles_unstable(state);
  useCustomStyleHook("useCounterBadgeStyles_unstable")(state);
  return renderBadge_unstable(state);
});
CounterBadge.displayName = "CounterBadge";

// node_modules/@fluentui/react-avatar/lib/contexts/AvatarContext.js
var React106 = __toESM(require_react());
var avatarContext = React106.createContext(void 0);
var avatarContextDefaultValue = {};
var AvatarContextProvider = avatarContext.Provider;
var useAvatarContext = () => {
  var _React_useContext;
  return (_React_useContext = React106.useContext(avatarContext)) !== null && _React_useContext !== void 0 ? _React_useContext : avatarContextDefaultValue;
};

// node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatar.js
var DEFAULT_STRINGS2 = {
  active: "active",
  inactive: "inactive"
};
var useAvatar_unstable = (props, ref) => {
  const { dir } = useFluent();
  const { shape: contextShape, size: contextSize } = useAvatarContext();
  const { name, size: size3 = contextSize !== null && contextSize !== void 0 ? contextSize : 32, shape = contextShape !== null && contextShape !== void 0 ? contextShape : "circular", active = "unset", activeAppearance = "ring", idForColor } = props;
  let { color: color2 = "neutral" } = props;
  if (color2 === "colorful") {
    var _ref;
    color2 = avatarColors[getHashCode((_ref = idForColor !== null && idForColor !== void 0 ? idForColor : name) !== null && _ref !== void 0 ? _ref : "") % avatarColors.length];
  }
  const baseId = useId2("avatar-");
  const root = slot_exports.always(getIntrinsicElementProps(
    "span",
    {
      role: "img",
      id: baseId,
      // aria-label and/or aria-labelledby are resolved below
      ...props,
      ref
    },
    /* excludedPropNames: */
    [
      "name"
    ]
  ), {
    elementType: "span"
  });
  const [imageHidden, setImageHidden] = React107.useState(void 0);
  let image = slot_exports.optional(props.image, {
    defaultProps: {
      alt: "",
      role: "presentation",
      "aria-hidden": true,
      hidden: imageHidden
    },
    elementType: "img"
  });
  if (!(image === null || image === void 0 ? void 0 : image.src)) {
    image = void 0;
  }
  if (image) {
    image.onError = mergeCallbacks(image.onError, () => setImageHidden(true));
    image.onLoad = mergeCallbacks(image.onLoad, () => setImageHidden(void 0));
  }
  let initials = slot_exports.optional(props.initials, {
    renderByDefault: true,
    defaultProps: {
      children: getInitials(name, dir === "rtl", {
        firstInitialOnly: size3 <= 16
      }),
      id: baseId + "__initials"
    },
    elementType: "span"
  });
  if (!(initials === null || initials === void 0 ? void 0 : initials.children)) {
    initials = void 0;
  }
  let icon = void 0;
  if (!initials && (!image || imageHidden)) {
    icon = slot_exports.optional(props.icon, {
      renderByDefault: true,
      defaultProps: {
        children: React107.createElement(PersonRegular, null),
        "aria-hidden": true
      },
      elementType: "span"
    });
  }
  const badge = slot_exports.optional(props.badge, {
    defaultProps: {
      size: getBadgeSize(size3),
      id: baseId + "__badge"
    },
    elementType: PresenceBadge
  });
  let activeAriaLabelElement;
  if (!root["aria-label"] && !root["aria-labelledby"]) {
    if (name) {
      root["aria-label"] = name;
      if (badge) {
        root["aria-labelledby"] = root.id + " " + badge.id;
      }
    } else if (initials) {
      root["aria-labelledby"] = initials.id + (badge ? " " + badge.id : "");
    }
    if (active === "active" || active === "inactive") {
      const activeText = DEFAULT_STRINGS2[active];
      if (root["aria-labelledby"]) {
        const activeId = baseId + "__active";
        root["aria-labelledby"] += " " + activeId;
        activeAriaLabelElement = React107.createElement("span", {
          hidden: true,
          id: activeId
        }, activeText);
      } else if (root["aria-label"]) {
        root["aria-label"] += " " + activeText;
      }
    }
  }
  return {
    size: size3,
    shape,
    active,
    activeAppearance,
    activeAriaLabelElement,
    color: color2,
    components: {
      root: "span",
      initials: "span",
      icon: "span",
      image: "img",
      badge: PresenceBadge
    },
    root,
    initials,
    icon,
    image,
    badge
  };
};
var getBadgeSize = (size3) => {
  if (size3 >= 96) {
    return "extra-large";
  } else if (size3 >= 64) {
    return "large";
  } else if (size3 >= 56) {
    return "medium";
  } else if (size3 >= 40) {
    return "small";
  } else if (size3 >= 28) {
    return "extra-small";
  } else {
    return "tiny";
  }
};
var avatarColors = [
  "dark-red",
  "cranberry",
  "red",
  "pumpkin",
  "peach",
  "marigold",
  "gold",
  "brass",
  "brown",
  "forest",
  "seafoam",
  "dark-green",
  "light-teal",
  "teal",
  "steel",
  "blue",
  "royal-blue",
  "cornflower",
  "navy",
  "lavender",
  "purple",
  "grape",
  "lilac",
  "pink",
  "magenta",
  "plum",
  "beige",
  "mink",
  "platinum",
  "anchor"
];
var getHashCode = (str) => {
  let hashCode = 0;
  for (let len = str.length - 1; len >= 0; len--) {
    const ch = str.charCodeAt(len);
    const shift4 = len % 8;
    hashCode ^= (ch << shift4) + (ch >> 8 - shift4);
  }
  return hashCode;
};

// node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatarStyles.styles.js
var avatarClassNames = {
  root: "fui-Avatar",
  image: "fui-Avatar__image",
  initials: "fui-Avatar__initials",
  icon: "fui-Avatar__icon",
  badge: "fui-Avatar__badge"
};
var useRootClassName3 = __resetStyles("r81b29z", "r1aatmv", {
  r: [".r81b29z{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}", ".r81b29z::before,.r81b29z::after{position:absolute;top:0;left:0;bottom:0;right:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}", ".r81b29z::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}", ".r1aatmv{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}", ".r1aatmv::before,.r1aatmv::after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}", ".r1aatmv::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.r81b29z::before,.r81b29z::after{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1aatmv::before,.r1aatmv::after{transition-duration:0.01ms;}}"]
});
var useImageClassName = __resetStyles("r136dc0n", "rjly0nl", [".r136dc0n{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}", ".rjly0nl{position:absolute;top:0;right:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}"]);
var useIconInitialsClassName = __resetStyles("rip04v", "r31uzil", [".rip04v{position:absolute;box-sizing:border-box;top:0;left:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:inherit;}", ".r31uzil{position:absolute;box-sizing:border-box;top:0;right:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:inherit;}"]);
var useStyles6 = __styles2({
  textCaption2Strong: {
    Be2twd7: "f13mqy1h"
  },
  textCaption1Strong: {
    Be2twd7: "fy9rknc"
  },
  textSubtitle2: {
    Be2twd7: "fod5ikn"
  },
  textSubtitle1: {
    Be2twd7: "f1pp30po"
  },
  textTitle3: {
    Be2twd7: "f1x0m3f5"
  },
  squareSmall: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fq9zq91"
  },
  squareMedium: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  squareLarge: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1o0qvyv"
  },
  squareXLarge: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1kijzfu"
  },
  activeOrInactive: {
    Bz10aip: "ftfx35i",
    Bmy1vo4: "fv0atk9",
    B3o57yi: "f1iry5bo",
    Bkqvd7p: "f15n41j8",
    Hwfdqs: "f1onx1g3"
  },
  ring: {
    Ftih45: "f1wl9k8s"
  },
  ringBadgeCutout: {
    f4a502: "fp2gujx"
  },
  ringThick: {
    of393c: "fq1w1vq"
  },
  ringThicker: {
    of393c: "fzg6ace"
  },
  ringThickest: {
    of393c: "f1nu8p71"
  },
  shadow: {
    Bsft5z2: "f13zj6fq"
  },
  shadow4: {
    Be6vj1x: "fcjn15l"
  },
  shadow8: {
    Be6vj1x: "f1tm8t9f"
  },
  shadow16: {
    Be6vj1x: "f1a1aohj"
  },
  shadow28: {
    Be6vj1x: "fond6v5"
  },
  inactive: {
    abs64n: "fp25eh",
    Bz10aip: "f1clczzi",
    Bkqvd7p: "f1l3s34x",
    Bfgortx: 0,
    Bnvr3x9: 0,
    b2tv09: 0,
    Bucmhp4: 0,
    iayac2: "flkahu5",
    b6ubon: "fw457kn",
    Bqinb2h: "f1wmllxl"
  },
  badge: {
    qhf8xq: "f1euv43f",
    B5kzvoi: "f1yab3r1",
    j35jbq: ["f1e31b4d", "f1vgc2s3"]
  },
  badgeCutout: {
    btxmck: "f1eugkqs"
  },
  badgeAlign: {
    Dnlfbu: ["f1tlnv9o", "f1y9kyih"]
  },
  tiny: {
    Bdjeniz: "f1uwoubl",
    niu6jh: "fid048z"
  },
  "extra-small": {
    Bdjeniz: "f13ar0e0",
    niu6jh: "fid048z"
  },
  small: {
    Bdjeniz: "fwwuruf",
    niu6jh: "fid048z"
  },
  medium: {
    Bdjeniz: "f1af27q5",
    niu6jh: "fid048z"
  },
  large: {
    Bdjeniz: "f18yy57a",
    niu6jh: "f924bxt"
  },
  "extra-large": {
    Bdjeniz: "f2jg042",
    niu6jh: "f924bxt"
  },
  icon12: {
    Be2twd7: "f1ugzwwg"
  },
  icon16: {
    Be2twd7: "f4ybsrx"
  },
  icon20: {
    Be2twd7: "fe5j1ua"
  },
  icon24: {
    Be2twd7: "f1rt2boy"
  },
  icon28: {
    Be2twd7: "f24l1pt"
  },
  icon32: {
    Be2twd7: "ffl51b"
  },
  icon48: {
    Be2twd7: "f18m8u13"
  }
}, {
  d: [".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f1x0m3f5{font-size:var(--fontSizeBase600);}", [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f1o0qvyv{border-radius:var(--borderRadiusLarge);}", {
    p: -1
  }], [".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", {
    p: -1
  }], ".ftfx35i{transform:perspective(1px);}", ".fv0atk9{transition-property:transform,opacity;}", ".f1iry5bo{transition-duration:var(--durationUltraSlow),var(--durationFaster);}", ".f15n41j8{transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);}", '.f1wl9k8s::before{content:"";}', ".fp2gujx::before{-webkit-mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}", ".fq1w1vq{--fui-Avatar-ringWidth:var(--strokeWidthThick);}", ".fzg6ace{--fui-Avatar-ringWidth:var(--strokeWidthThicker);}", ".f1nu8p71{--fui-Avatar-ringWidth:var(--strokeWidthThickest);}", '.f13zj6fq::after{content:"";}', ".fcjn15l::after{box-shadow:var(--shadow4);}", ".f1tm8t9f::after{box-shadow:var(--shadow8);}", ".f1a1aohj::after{box-shadow:var(--shadow16);}", ".fond6v5::after{box-shadow:var(--shadow28);}", ".fp25eh{opacity:0.8;}", ".f1clczzi{transform:scale(0.875);}", ".f1l3s34x{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}", [".flkahu5::before,.flkahu5::after{margin:0;}", {
    p: -1
  }], ".fw457kn::before,.fw457kn::after{opacity:0;}", ".f1wmllxl::before,.f1wmllxl::after{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}", ".f1euv43f{position:absolute;}", ".f1yab3r1{bottom:0;}", ".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f1eugkqs{-webkit-mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}", ".f1tlnv9o{--fui-Avatar-badgeAlign:right;}", ".f1y9kyih{--fui-Avatar-badgeAlign:left;}", ".f1uwoubl{--fui-Avatar-badgeRadius:3px;}", ".fid048z{--fui-Avatar-badgeGap:var(--strokeWidthThin);}", ".f13ar0e0{--fui-Avatar-badgeRadius:5px;}", ".fwwuruf{--fui-Avatar-badgeRadius:6px;}", ".f1af27q5{--fui-Avatar-badgeRadius:8px;}", ".f18yy57a{--fui-Avatar-badgeRadius:10px;}", ".f924bxt{--fui-Avatar-badgeGap:var(--strokeWidthThick);}", ".f2jg042{--fui-Avatar-badgeRadius:14px;}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f24l1pt{font-size:28px;}", ".ffl51b{font-size:32px;}", ".f18m8u13{font-size:48px;}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.f1onx1g3{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }]]
});
var useSizeStyles = __styles2({
  "16": {
    a9b677: "fjw5fx7",
    Bqenvij: "fd461yt"
  },
  "20": {
    a9b677: "f64fuq3",
    Bqenvij: "fjamq6b"
  },
  "24": {
    a9b677: "fq4mcun",
    Bqenvij: "frvgh55"
  },
  "28": {
    a9b677: "f1w9dchk",
    Bqenvij: "fxldao9"
  },
  "32": {
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10"
  },
  "36": {
    a9b677: "fpdz1er",
    Bqenvij: "f8ljn23"
  },
  "40": {
    a9b677: "feqmc2u",
    Bqenvij: "fbhnoac"
  },
  "48": {
    a9b677: "f124akge",
    Bqenvij: "ff2sm71"
  },
  "56": {
    a9b677: "f1u66zr1",
    Bqenvij: "fzki0ko"
  },
  "64": {
    a9b677: "fa9ln6p",
    Bqenvij: "f16k9i2m"
  },
  "72": {
    a9b677: "fhcae8x",
    Bqenvij: "f1shusfg"
  },
  "96": {
    a9b677: "f1kyr2gn",
    Bqenvij: "fypu0ge"
  },
  "120": {
    a9b677: "fwfqyga",
    Bqenvij: "fjr5b71"
  },
  "128": {
    a9b677: "f1iksgmy",
    Bqenvij: "fele2au"
  }
}, {
  d: [".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}", ".fpdz1er{width:36px;}", ".f8ljn23{height:36px;}", ".feqmc2u{width:40px;}", ".fbhnoac{height:40px;}", ".f124akge{width:48px;}", ".ff2sm71{height:48px;}", ".f1u66zr1{width:56px;}", ".fzki0ko{height:56px;}", ".fa9ln6p{width:64px;}", ".f16k9i2m{height:64px;}", ".fhcae8x{width:72px;}", ".f1shusfg{height:72px;}", ".f1kyr2gn{width:96px;}", ".fypu0ge{height:96px;}", ".fwfqyga{width:120px;}", ".fjr5b71{height:120px;}", ".f1iksgmy{width:128px;}", ".fele2au{height:128px;}"]
});
var useColorStyles = __styles2({
  neutral: {
    sj55zd: "f11d4kpn",
    De3pzq: "f18f03hv"
  },
  brand: {
    sj55zd: "fonrgv7",
    De3pzq: "f1blnnmj"
  },
  "dark-red": {
    sj55zd: "fqjd1y1",
    De3pzq: "f1vq2oo4"
  },
  cranberry: {
    sj55zd: "fg9gses",
    De3pzq: "f1lwxszt"
  },
  red: {
    sj55zd: "f23f7i0",
    De3pzq: "f1q9qhfq"
  },
  pumpkin: {
    sj55zd: "fjnan08",
    De3pzq: "fz91bi3"
  },
  peach: {
    sj55zd: "fknu15p",
    De3pzq: "f1b9nr51"
  },
  marigold: {
    sj55zd: "f9603vw",
    De3pzq: "f3z4w6d"
  },
  gold: {
    sj55zd: "fmq0uwp",
    De3pzq: "fg50kya"
  },
  brass: {
    sj55zd: "f28g5vo",
    De3pzq: "f4w2gd0"
  },
  brown: {
    sj55zd: "ftl572b",
    De3pzq: "f14wu1f4"
  },
  forest: {
    sj55zd: "f1gymlvd",
    De3pzq: "f19ut4y6"
  },
  seafoam: {
    sj55zd: "fnnb6wn",
    De3pzq: "f1n057jc"
  },
  "dark-green": {
    sj55zd: "ff58qw8",
    De3pzq: "f11t05wk"
  },
  "light-teal": {
    sj55zd: "f1up9qbj",
    De3pzq: "f42feg1"
  },
  teal: {
    sj55zd: "f135dsb4",
    De3pzq: "f6hvv1p"
  },
  steel: {
    sj55zd: "f151dlcp",
    De3pzq: "f1lnp8zf"
  },
  blue: {
    sj55zd: "f1rjv50u",
    De3pzq: "f1ggcpy6"
  },
  "royal-blue": {
    sj55zd: "f1emykk5",
    De3pzq: "f12rj61f"
  },
  cornflower: {
    sj55zd: "fqsigj7",
    De3pzq: "f8k7hur"
  },
  navy: {
    sj55zd: "f1nj97xi",
    De3pzq: "f19gw0ux"
  },
  lavender: {
    sj55zd: "fwctg0i",
    De3pzq: "ff379vm"
  },
  purple: {
    sj55zd: "fjrsgpu",
    De3pzq: "f1mzf1e1"
  },
  grape: {
    sj55zd: "f1fiiydq",
    De3pzq: "f1o4k8oy"
  },
  lilac: {
    sj55zd: "f1res9jt",
    De3pzq: "f1x6mz1o"
  },
  pink: {
    sj55zd: "fv3fbbi",
    De3pzq: "fydlv6t"
  },
  magenta: {
    sj55zd: "f1f1fwnz",
    De3pzq: "f4xb6j5"
  },
  plum: {
    sj55zd: "f8ptl6j",
    De3pzq: "fqo8e26"
  },
  beige: {
    sj55zd: "f1ntv3ld",
    De3pzq: "f101elhj"
  },
  mink: {
    sj55zd: "f1fscmp",
    De3pzq: "f13g8o5c"
  },
  platinum: {
    sj55zd: "f1dr00v2",
    De3pzq: "fkh7blw"
  },
  anchor: {
    sj55zd: "f1f3ti53",
    De3pzq: "fu4yj0j"
  }
}, {
  d: [".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f18f03hv{background-color:var(--colorNeutralBackground6);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1blnnmj{background-color:var(--colorBrandBackgroundStatic);}", ".fqjd1y1{color:var(--colorPaletteDarkRedForeground2);}", ".f1vq2oo4{background-color:var(--colorPaletteDarkRedBackground2);}", ".fg9gses{color:var(--colorPaletteCranberryForeground2);}", ".f1lwxszt{background-color:var(--colorPaletteCranberryBackground2);}", ".f23f7i0{color:var(--colorPaletteRedForeground2);}", ".f1q9qhfq{background-color:var(--colorPaletteRedBackground2);}", ".fjnan08{color:var(--colorPalettePumpkinForeground2);}", ".fz91bi3{background-color:var(--colorPalettePumpkinBackground2);}", ".fknu15p{color:var(--colorPalettePeachForeground2);}", ".f1b9nr51{background-color:var(--colorPalettePeachBackground2);}", ".f9603vw{color:var(--colorPaletteMarigoldForeground2);}", ".f3z4w6d{background-color:var(--colorPaletteMarigoldBackground2);}", ".fmq0uwp{color:var(--colorPaletteGoldForeground2);}", ".fg50kya{background-color:var(--colorPaletteGoldBackground2);}", ".f28g5vo{color:var(--colorPaletteBrassForeground2);}", ".f4w2gd0{background-color:var(--colorPaletteBrassBackground2);}", ".ftl572b{color:var(--colorPaletteBrownForeground2);}", ".f14wu1f4{background-color:var(--colorPaletteBrownBackground2);}", ".f1gymlvd{color:var(--colorPaletteForestForeground2);}", ".f19ut4y6{background-color:var(--colorPaletteForestBackground2);}", ".fnnb6wn{color:var(--colorPaletteSeafoamForeground2);}", ".f1n057jc{background-color:var(--colorPaletteSeafoamBackground2);}", ".ff58qw8{color:var(--colorPaletteDarkGreenForeground2);}", ".f11t05wk{background-color:var(--colorPaletteDarkGreenBackground2);}", ".f1up9qbj{color:var(--colorPaletteLightTealForeground2);}", ".f42feg1{background-color:var(--colorPaletteLightTealBackground2);}", ".f135dsb4{color:var(--colorPaletteTealForeground2);}", ".f6hvv1p{background-color:var(--colorPaletteTealBackground2);}", ".f151dlcp{color:var(--colorPaletteSteelForeground2);}", ".f1lnp8zf{background-color:var(--colorPaletteSteelBackground2);}", ".f1rjv50u{color:var(--colorPaletteBlueForeground2);}", ".f1ggcpy6{background-color:var(--colorPaletteBlueBackground2);}", ".f1emykk5{color:var(--colorPaletteRoyalBlueForeground2);}", ".f12rj61f{background-color:var(--colorPaletteRoyalBlueBackground2);}", ".fqsigj7{color:var(--colorPaletteCornflowerForeground2);}", ".f8k7hur{background-color:var(--colorPaletteCornflowerBackground2);}", ".f1nj97xi{color:var(--colorPaletteNavyForeground2);}", ".f19gw0ux{background-color:var(--colorPaletteNavyBackground2);}", ".fwctg0i{color:var(--colorPaletteLavenderForeground2);}", ".ff379vm{background-color:var(--colorPaletteLavenderBackground2);}", ".fjrsgpu{color:var(--colorPalettePurpleForeground2);}", ".f1mzf1e1{background-color:var(--colorPalettePurpleBackground2);}", ".f1fiiydq{color:var(--colorPaletteGrapeForeground2);}", ".f1o4k8oy{background-color:var(--colorPaletteGrapeBackground2);}", ".f1res9jt{color:var(--colorPaletteLilacForeground2);}", ".f1x6mz1o{background-color:var(--colorPaletteLilacBackground2);}", ".fv3fbbi{color:var(--colorPalettePinkForeground2);}", ".fydlv6t{background-color:var(--colorPalettePinkBackground2);}", ".f1f1fwnz{color:var(--colorPaletteMagentaForeground2);}", ".f4xb6j5{background-color:var(--colorPaletteMagentaBackground2);}", ".f8ptl6j{color:var(--colorPalettePlumForeground2);}", ".fqo8e26{background-color:var(--colorPalettePlumBackground2);}", ".f1ntv3ld{color:var(--colorPaletteBeigeForeground2);}", ".f101elhj{background-color:var(--colorPaletteBeigeBackground2);}", ".f1fscmp{color:var(--colorPaletteMinkForeground2);}", ".f13g8o5c{background-color:var(--colorPaletteMinkBackground2);}", ".f1dr00v2{color:var(--colorPalettePlatinumForeground2);}", ".fkh7blw{background-color:var(--colorPalettePlatinumBackground2);}", ".f1f3ti53{color:var(--colorPaletteAnchorForeground2);}", ".fu4yj0j{background-color:var(--colorPaletteAnchorBackground2);}"]
});
var useRingColorStyles = __styles2({
  neutral: {
    Bic5iru: "f1uuiafn"
  },
  brand: {
    Bic5iru: "f1uuiafn"
  },
  "dark-red": {
    Bic5iru: "f1t2x9on"
  },
  cranberry: {
    Bic5iru: "f1pvshc9"
  },
  red: {
    Bic5iru: "f1ectbk9"
  },
  pumpkin: {
    Bic5iru: "fvzpl0b"
  },
  peach: {
    Bic5iru: "fwj2kd7"
  },
  marigold: {
    Bic5iru: "fr120vy"
  },
  gold: {
    Bic5iru: "f8xmmar"
  },
  brass: {
    Bic5iru: "f1hbety2"
  },
  brown: {
    Bic5iru: "f1vg3s4g"
  },
  forest: {
    Bic5iru: "f1m3olm5"
  },
  seafoam: {
    Bic5iru: "f17xiqtr"
  },
  "dark-green": {
    Bic5iru: "fx32vyh"
  },
  "light-teal": {
    Bic5iru: "f1mkihwv"
  },
  teal: {
    Bic5iru: "fecnooh"
  },
  steel: {
    Bic5iru: "f15hfgzm"
  },
  blue: {
    Bic5iru: "fqproka"
  },
  "royal-blue": {
    Bic5iru: "f17v2w59"
  },
  cornflower: {
    Bic5iru: "fp0q1mo"
  },
  navy: {
    Bic5iru: "f1nlym55"
  },
  lavender: {
    Bic5iru: "f62vk8h"
  },
  purple: {
    Bic5iru: "f15zl69q"
  },
  grape: {
    Bic5iru: "f53w4j7"
  },
  lilac: {
    Bic5iru: "fu2771t"
  },
  pink: {
    Bic5iru: "fzflscs"
  },
  magenta: {
    Bic5iru: "fb6rmqc"
  },
  plum: {
    Bic5iru: "f1a4gm5b"
  },
  beige: {
    Bic5iru: "f1qpf9z1"
  },
  mink: {
    Bic5iru: "f1l7or83"
  },
  platinum: {
    Bic5iru: "fzrj0iu"
  },
  anchor: {
    Bic5iru: "f8oz6wf"
  }
}, {
  d: [".f1uuiafn::before{color:var(--colorBrandStroke1);}", ".f1t2x9on::before{color:var(--colorPaletteDarkRedBorderActive);}", ".f1pvshc9::before{color:var(--colorPaletteCranberryBorderActive);}", ".f1ectbk9::before{color:var(--colorPaletteRedBorderActive);}", ".fvzpl0b::before{color:var(--colorPalettePumpkinBorderActive);}", ".fwj2kd7::before{color:var(--colorPalettePeachBorderActive);}", ".fr120vy::before{color:var(--colorPaletteMarigoldBorderActive);}", ".f8xmmar::before{color:var(--colorPaletteGoldBorderActive);}", ".f1hbety2::before{color:var(--colorPaletteBrassBorderActive);}", ".f1vg3s4g::before{color:var(--colorPaletteBrownBorderActive);}", ".f1m3olm5::before{color:var(--colorPaletteForestBorderActive);}", ".f17xiqtr::before{color:var(--colorPaletteSeafoamBorderActive);}", ".fx32vyh::before{color:var(--colorPaletteDarkGreenBorderActive);}", ".f1mkihwv::before{color:var(--colorPaletteLightTealBorderActive);}", ".fecnooh::before{color:var(--colorPaletteTealBorderActive);}", ".f15hfgzm::before{color:var(--colorPaletteSteelBorderActive);}", ".fqproka::before{color:var(--colorPaletteBlueBorderActive);}", ".f17v2w59::before{color:var(--colorPaletteRoyalBlueBorderActive);}", ".fp0q1mo::before{color:var(--colorPaletteCornflowerBorderActive);}", ".f1nlym55::before{color:var(--colorPaletteNavyBorderActive);}", ".f62vk8h::before{color:var(--colorPaletteLavenderBorderActive);}", ".f15zl69q::before{color:var(--colorPalettePurpleBorderActive);}", ".f53w4j7::before{color:var(--colorPaletteGrapeBorderActive);}", ".fu2771t::before{color:var(--colorPaletteLilacBorderActive);}", ".fzflscs::before{color:var(--colorPalettePinkBorderActive);}", ".fb6rmqc::before{color:var(--colorPaletteMagentaBorderActive);}", ".f1a4gm5b::before{color:var(--colorPalettePlumBorderActive);}", ".f1qpf9z1::before{color:var(--colorPaletteBeigeBorderActive);}", ".f1l7or83::before{color:var(--colorPaletteMinkBorderActive);}", ".fzrj0iu::before{color:var(--colorPalettePlatinumBorderActive);}", ".f8oz6wf::before{color:var(--colorPaletteAnchorBorderActive);}"]
});
var useAvatarStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3,
    shape,
    active,
    activeAppearance,
    color: color2
  } = state;
  const rootClassName = useRootClassName3();
  const imageClassName = useImageClassName();
  const iconInitialsClassName = useIconInitialsClassName();
  const styles = useStyles6();
  const sizeStyles = useSizeStyles();
  const colorStyles = useColorStyles();
  const ringColorStyles = useRingColorStyles();
  const rootClasses = [rootClassName, size3 !== 32 && sizeStyles[size3]];
  if (state.badge) {
    rootClasses.push(styles.badgeAlign, styles[state.badge.size || "medium"]);
  }
  if (size3 <= 24) {
    rootClasses.push(styles.textCaption2Strong);
  } else if (size3 <= 28) {
    rootClasses.push(styles.textCaption1Strong);
  } else if (size3 <= 40) {
  } else if (size3 <= 56) {
    rootClasses.push(styles.textSubtitle2);
  } else if (size3 <= 96) {
    rootClasses.push(styles.textSubtitle1);
  } else {
    rootClasses.push(styles.textTitle3);
  }
  if (shape === "square") {
    if (size3 <= 24) {
      rootClasses.push(styles.squareSmall);
    } else if (size3 <= 48) {
      rootClasses.push(styles.squareMedium);
    } else if (size3 <= 72) {
      rootClasses.push(styles.squareLarge);
    } else {
      rootClasses.push(styles.squareXLarge);
    }
  }
  if (active === "active" || active === "inactive") {
    rootClasses.push(styles.activeOrInactive);
    if (activeAppearance === "ring" || activeAppearance === "ring-shadow") {
      rootClasses.push(styles.ring, ringColorStyles[color2]);
      if (state.badge) {
        rootClasses.push(styles.ringBadgeCutout);
      }
      if (size3 <= 48) {
        rootClasses.push(styles.ringThick);
      } else if (size3 <= 64) {
        rootClasses.push(styles.ringThicker);
      } else {
        rootClasses.push(styles.ringThickest);
      }
    }
    if (activeAppearance === "shadow" || activeAppearance === "ring-shadow") {
      rootClasses.push(styles.shadow);
      if (size3 <= 28) {
        rootClasses.push(styles.shadow4);
      } else if (size3 <= 48) {
        rootClasses.push(styles.shadow8);
      } else if (size3 <= 64) {
        rootClasses.push(styles.shadow16);
      } else {
        rootClasses.push(styles.shadow28);
      }
    }
    if (active === "inactive") {
      rootClasses.push(styles.inactive);
    }
  }
  state.root.className = mergeClasses(avatarClassNames.root, ...rootClasses, state.root.className);
  if (state.badge) {
    state.badge.className = mergeClasses(avatarClassNames.badge, styles.badge, state.badge.className);
  }
  if (state.image) {
    state.image.className = mergeClasses(avatarClassNames.image, imageClassName, colorStyles[color2], state.badge && styles.badgeCutout, state.image.className);
  }
  if (state.initials) {
    state.initials.className = mergeClasses(avatarClassNames.initials, iconInitialsClassName, colorStyles[color2], state.badge && styles.badgeCutout, state.initials.className);
  }
  if (state.icon) {
    let iconSizeClass;
    if (size3 <= 16) {
      iconSizeClass = styles.icon12;
    } else if (size3 <= 24) {
      iconSizeClass = styles.icon16;
    } else if (size3 <= 40) {
      iconSizeClass = styles.icon20;
    } else if (size3 <= 48) {
      iconSizeClass = styles.icon24;
    } else if (size3 <= 56) {
      iconSizeClass = styles.icon28;
    } else if (size3 <= 72) {
      iconSizeClass = styles.icon32;
    } else {
      iconSizeClass = styles.icon48;
    }
    state.icon.className = mergeClasses(avatarClassNames.icon, iconInitialsClassName, iconSizeClass, colorStyles[color2], state.badge && styles.badgeCutout, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-avatar/lib/components/Avatar/Avatar.js
var Avatar = React108.forwardRef((props, ref) => {
  const state = useAvatar_unstable(props, ref);
  useAvatarStyles_unstable(state);
  useCustomStyleHook("useAvatarStyles_unstable")(state);
  return renderAvatar_unstable(state);
});
Avatar.displayName = "Avatar";

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/AvatarGroup.js
var React110 = __toESM(require_react());

// node_modules/@fluentui/react-avatar/lib/contexts/AvatarGroupContext.js
var AvatarGroupContext = createContext13(void 0);
var avatarGroupContextDefaultValue = {};
var AvatarGroupProvider = AvatarGroupContext.Provider;
var useAvatarGroupContext_unstable = (selector) => useContextSelector(AvatarGroupContext, (ctx = avatarGroupContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/renderAvatarGroup.js
var renderAvatarGroup_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(AvatarGroupProvider, {
    value: contextValues.avatarGroup,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/useAvatarGroup.js
var React109 = __toESM(require_react());
var useAvatarGroup_unstable = (props, ref) => {
  const { layout = "spread", size: size3 = defaultAvatarGroupSize } = props;
  const root = slot_exports.always(getIntrinsicElementProps("div", {
    role: "group",
    ...props,
    // FIXME:
    // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
    // but since it would be a breaking change to fix it, we are casting ref to it's proper type
    ref
  }, [
    "size"
  ]), {
    elementType: "div"
  });
  return {
    layout,
    size: size3,
    components: {
      root: "div"
    },
    root
  };
};
var defaultAvatarGroupSize = 32;

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/useAvatarGroupContextValues.js
var useAvatarGroupContextValues = (state) => {
  const { layout, size: size3 } = state;
  const avatarGroup = {
    layout,
    size: size3
  };
  return {
    avatarGroup
  };
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/useAvatarGroupStyles.styles.js
var avatarGroupClassNames = {
  root: "fui-AvatarGroup"
};
var useStyles7 = __styles2({
  base: {
    mc9l5x: "ftuwxu6",
    qhf8xq: "f10pi13n"
  },
  pie: {
    Bgl5zvf: "f1uz6ud1",
    De3pzq: "f1ganh6p",
    Bsw6fvg: "fe2ae1k"
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".f10pi13n{position:relative;}", ".f1uz6ud1{clip-path:circle(50%);}", ".f1ganh6p{background-color:var(--colorTransparentStroke);}"],
  m: [["@media (forced-colors: active){.fe2ae1k{background-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useAvatarGroupStyles_unstable = (state) => {
  "use no memo";
  const {
    layout,
    size: size3
  } = state;
  const styles = useStyles7();
  const sizeStyles = useSizeStyles();
  state.root.className = mergeClasses(avatarGroupClassNames.root, styles.base, layout === "pie" && sizeStyles[size3], layout === "pie" && styles.pie, state.root.className);
  return state;
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/AvatarGroup.js
var AvatarGroup = React110.forwardRef((props, ref) => {
  const state = useAvatarGroup_unstable(props, ref);
  const contextValues = useAvatarGroupContextValues(state);
  useAvatarGroupStyles_unstable(state);
  useCustomStyleHook("useAvatarGroupStyles_unstable")(state);
  return renderAvatarGroup_unstable(state, contextValues);
});
AvatarGroup.displayName = "AvatarGroup";

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/AvatarGroupItem.js
var React112 = __toESM(require_react());

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/renderAvatarGroupItem.js
var renderAvatarGroupItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.avatar, {}),
      state.isOverflowItem && jsx(state.overflowLabel, {})
    ]
  });
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/useAvatarGroupItem.js
var React111 = __toESM(require_react());
var useAvatarGroupItem_unstable = (props, ref) => {
  const groupIsOverflow = useAvatarGroupContext_unstable((ctx) => ctx.isOverflow);
  const groupSize = useAvatarGroupContext_unstable((ctx) => ctx.size);
  const layout = useAvatarGroupContext_unstable((ctx) => ctx.layout);
  const { style, className, ...avatarSlotProps } = props;
  const size3 = groupSize !== null && groupSize !== void 0 ? groupSize : defaultAvatarGroupSize;
  const hasAvatarGroupContext = useHasParentContext(AvatarGroupContext);
  if (!hasAvatarGroupContext) {
    console.warn("AvatarGroupItem must only be used inside an AvatarGroup component.");
  }
  return {
    isOverflowItem: groupIsOverflow,
    layout,
    size: size3,
    components: {
      root: groupIsOverflow ? "li" : "div",
      avatar: Avatar,
      overflowLabel: "span"
    },
    root: slot_exports.always(props.root, {
      defaultProps: {
        style,
        className
      },
      elementType: groupIsOverflow ? "li" : "div"
    }),
    avatar: slot_exports.always(props.avatar, {
      defaultProps: {
        ref,
        size: size3,
        color: "colorful",
        ...avatarSlotProps
      },
      elementType: Avatar
    }),
    overflowLabel: slot_exports.always(props.overflowLabel, {
      defaultProps: {
        // Avatar already has its aria-label set to the name, this will prevent the name to be read twice.
        "aria-hidden": true,
        children: props.name
      },
      elementType: "span"
    })
  };
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/useAvatarGroupItemStyles.styles.js
var avatarGroupItemClassNames = {
  root: "fui-AvatarGroupItem",
  avatar: "fui-AvatarGroupItem__avatar",
  overflowLabel: "fui-AvatarGroupItem__overflowLabel"
};
var useRootStyles2 = __styles2({
  base: {
    Bt984gj: "f122n59",
    mc9l5x: "ftuwxu6",
    Bnnss6s: "fi64zpg",
    qhf8xq: "f10pi13n"
  },
  overflowItem: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f16d74zd"
  },
  nonOverflowItem: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9"
  }
}, {
  d: [".f122n59{align-items:center;}", ".ftuwxu6{display:inline-flex;}", ".fi64zpg{flex-shrink:0;}", ".f10pi13n{position:relative;}", [".f16d74zd{padding:var(--spacingVerticalXS) var(--spacingHorizontalXS);}", {
    p: -1
  }], [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }]]
});
var useAvatarStyles = __styles2({
  nonOverflowItem: {
    qhf8xq: "f1euv43f"
  },
  pie: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779"
  }
}, {
  d: [".f1euv43f{position:absolute;}", [".fokr779{border-radius:0;}", {
    p: -1
  }]]
});
var useOverflowLabelStyles = __styles2({
  base: {
    Frg6f3: ["foyynoy", "f1vcna3q"],
    sj55zd: "f19n0e5",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".foyynoy{margin-left:var(--spacingHorizontalS);}", ".f1vcna3q{margin-right:var(--spacingHorizontalS);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});
var useStackStyles = __styles2({
  thick: {
    E5pizo: "foiuzp5"
  },
  thicker: {
    E5pizo: "f1x6o7w7"
  },
  thickest: {
    E5pizo: "f2aml1u"
  },
  xxs: {
    jhia2w: ["f1cjco14", "f13dxjc9"]
  },
  xs: {
    jhia2w: ["f15p6bln", "f1bab3ru"]
  },
  s: {
    jhia2w: ["f1v53ncc", "f17pu8r8"]
  },
  l: {
    jhia2w: ["flv48ch", "fnh1ydj"]
  }
}, {
  d: [".foiuzp5{box-shadow:0 0 0 var(--strokeWidthThick) var(--colorNeutralBackground2);}", ".f1x6o7w7{box-shadow:0 0 0 var(--strokeWidthThicker) var(--colorNeutralBackground2);}", ".f2aml1u{box-shadow:0 0 0 var(--strokeWidthThickest) var(--colorNeutralBackground2);}", ".f1cjco14:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalXXS));}", ".f13dxjc9:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalXXS));}", ".f15p6bln:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalXS));}", ".f1bab3ru:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalXS));}", ".f1v53ncc:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalS));}", ".f17pu8r8:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalS));}", ".flv48ch:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalL));}", ".fnh1ydj:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalL));}"]
});
var useSpreadStyles = __styles2({
  s: {
    jhia2w: ["f7lhxv7", "f6ou2b0"]
  },
  mNudge: {
    jhia2w: ["f1h0okno", "fnnqava"]
  },
  m: {
    jhia2w: ["f1wkt588", "f1maio5g"]
  },
  l: {
    jhia2w: ["f1l333zn", "f1r41m4c"]
  },
  xl: {
    jhia2w: ["fahr13a", "f2n7rbo"]
  }
}, {
  d: [".f7lhxv7:not(:first-child){margin-left:var(--spacingHorizontalS);}", ".f6ou2b0:not(:first-child){margin-right:var(--spacingHorizontalS);}", ".f1h0okno:not(:first-child){margin-left:var(--spacingHorizontalMNudge);}", ".fnnqava:not(:first-child){margin-right:var(--spacingHorizontalMNudge);}", ".f1wkt588:not(:first-child){margin-left:var(--spacingHorizontalM);}", ".f1maio5g:not(:first-child){margin-right:var(--spacingHorizontalM);}", ".f1l333zn:not(:first-child){margin-left:var(--spacingHorizontalL);}", ".f1r41m4c:not(:first-child){margin-right:var(--spacingHorizontalL);}", ".fahr13a:not(:first-child){margin-left:var(--spacingHorizontalXL);}", ".f2n7rbo:not(:first-child){margin-right:var(--spacingHorizontalXL);}"]
});
var usePieStyles = __styles2({
  base: {
    qhf8xq: "f1euv43f"
  },
  slices: {
    B3gf25r: "f16m7w7k",
    Be2twx7: ["f1o4hhgz", "fb4gjrz"],
    Bvaow4n: "f1pgb5nx",
    Gpecfs: ["fugirid", "f4sk99m"],
    bhabj1: "fjreaf3",
    B7rc6i7: ["f1k4vw81", "f1w1xcy7"],
    Bwrfys5: "f1ef8vxk",
    Bwuzm9m: ["f1x2qbfv", "f1xwf4nz"],
    fflka: "ff6xuso",
    do7bja: "fzpvk6c",
    Be8zqhl: "f4onu7f",
    Bij0kh0: ["f1ydfez1", "fjensob"],
    Bwexnyt: "f1yv732j",
    Bhe5x6o: "fchq2fj",
    B3kv7bh: "ff5binh"
  },
  rtlSlices: {
    B3gf25r: "f5vdl61",
    Bvaow4n: "f1bnra92",
    bhabj1: "f4ibo7t",
    Bwrfys5: "f17heuis",
    Bwuzm9m: ["f64f2ud", "f1yjglu3"],
    Be8zqhl: "fa6l61x",
    Bij0kh0: ["f1w2396a", "f14ab3yo"]
  },
  thick: {
    uiicq7: "fnyfzln"
  },
  thicker: {
    uiicq7: "f1xdzzot"
  },
  thickest: {
    uiicq7: "f1auhru5"
  }
}, {
  d: [".f1euv43f{position:absolute;}", ".f16m7w7k:nth-of-type(1):nth-last-of-type(2){clip-path:inset(0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)) 0 25%);}", ".f1o4hhgz:nth-of-type(1):nth-last-of-type(2){left:-25%;}", ".fb4gjrz:nth-of-type(1):nth-last-of-type(2){right:-25%;}", ".f1pgb5nx:nth-of-type(2):nth-last-of-type(1){clip-path:inset(0 25% 0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)));}", ".fugirid:nth-of-type(2):nth-last-of-type(1){left:25%;}", ".f4sk99m:nth-of-type(2):nth-last-of-type(1){right:25%;}", ".fjreaf3:nth-of-type(1):nth-last-of-type(3){clip-path:inset(0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)) 0 25%);}", ".f1k4vw81:nth-of-type(1):nth-last-of-type(3){left:-25%;}", ".f1w1xcy7:nth-of-type(1):nth-last-of-type(3){right:-25%;}", ".f1ef8vxk:nth-of-type(2):nth-last-of-type(2){clip-path:inset(0 0 var(--fuiAvatarGroupItem__divider--width) var(--fuiAvatarGroupItem__divider--width));}", ".f1x2qbfv:nth-of-type(2):nth-last-of-type(2){left:50%;}", ".f1xwf4nz:nth-of-type(2):nth-last-of-type(2){right:50%;}", ".ff6xuso:nth-of-type(2):nth-last-of-type(2){transform:scale(0.5);}", ".fzpvk6c:nth-of-type(2):nth-last-of-type(2){transform-origin:0 0;}", ".f4onu7f:nth-of-type(3):nth-last-of-type(1){clip-path:inset(var(--fuiAvatarGroupItem__divider--width) 0 0 var(--fuiAvatarGroupItem__divider--width));}", ".f1ydfez1:nth-of-type(3):nth-last-of-type(1){left:50%;}", ".fjensob:nth-of-type(3):nth-last-of-type(1){right:50%;}", ".f1yv732j:nth-of-type(3):nth-last-of-type(1){top:50%;}", ".fchq2fj:nth-of-type(3):nth-last-of-type(1){transform:scale(0.5);}", ".ff5binh:nth-of-type(3):nth-last-of-type(1){transform-origin:0 0;}", ".f5vdl61:nth-of-type(1):nth-last-of-type(2){clip-path:inset(0 25% 0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)));}", ".f1bnra92:nth-of-type(2):nth-last-of-type(1){clip-path:inset(0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)) 0 25%);}", ".f4ibo7t:nth-of-type(1):nth-last-of-type(3){clip-path:inset(0 25% 0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)));}", ".f17heuis:nth-of-type(2):nth-last-of-type(2){clip-path:inset(0 var(--fuiAvatarGroupItem__divider--width) var(--fuiAvatarGroupItem__divider--width) 0);}", ".f64f2ud:nth-of-type(2):nth-last-of-type(2){left:0;}", ".f1yjglu3:nth-of-type(2):nth-last-of-type(2){right:0;}", ".fa6l61x:nth-of-type(3):nth-last-of-type(1){clip-path:inset(var(--fuiAvatarGroupItem__divider--width) var(--fuiAvatarGroupItem__divider--width) 0 0);}", ".f1w2396a:nth-of-type(3):nth-last-of-type(1){left:0;}", ".f14ab3yo:nth-of-type(3):nth-last-of-type(1){right:0;}", ".fnyfzln{--fuiAvatarGroupItem__divider--width:var(--strokeWidthThick);}", ".f1xdzzot{--fuiAvatarGroupItem__divider--width:var(--strokeWidthThicker);}", ".f1auhru5{--fuiAvatarGroupItem__divider--width:var(--strokeWidthThickest);}"]
});
var useAvatarGroupItemStyles_unstable = (state) => {
  "use no memo";
  const {
    isOverflowItem,
    layout,
    size: size3
  } = state;
  const {
    dir
  } = useFluent();
  const avatarStyles = useAvatarStyles();
  const overflowLabelStyles = useOverflowLabelStyles();
  const pieStyles = usePieStyles();
  const rootStyles = useRootStyles2();
  const sizeStyles = useSizeStyles();
  const groupChildClassName = useGroupChildClassName(layout, size3);
  const rootClasses = [rootStyles.base];
  if (!isOverflowItem) {
    rootClasses.push(rootStyles.nonOverflowItem);
    rootClasses.push(groupChildClassName);
    rootClasses.push(sizeStyles[size3]);
    if (layout === "pie") {
      rootClasses.push(pieStyles.base);
      if (size3 < 56) {
        rootClasses.push(pieStyles.thick);
      } else if (size3 < 72) {
        rootClasses.push(pieStyles.thicker);
      } else {
        rootClasses.push(pieStyles.thickest);
      }
      rootClasses.push(pieStyles.slices);
      if (dir === "rtl") {
        rootClasses.push(pieStyles.rtlSlices);
      }
    }
  } else {
    rootClasses.push(rootStyles.overflowItem);
  }
  state.root.className = mergeClasses(avatarGroupItemClassNames.root, ...rootClasses, state.root.className);
  state.avatar.className = mergeClasses(avatarGroupItemClassNames.avatar, !isOverflowItem && avatarStyles.nonOverflowItem, layout === "pie" && avatarStyles.pie, state.avatar.className);
  if (state.overflowLabel) {
    state.overflowLabel.className = mergeClasses(avatarGroupItemClassNames.overflowLabel, overflowLabelStyles.base, state.overflowLabel.className);
  }
  return state;
};
var useGroupChildClassName = (layout, size3) => {
  const stackStyles = useStackStyles();
  const spreadStyles = useSpreadStyles();
  const layoutClasses = [];
  if (size3) {
    if (layout === "stack") {
      if (size3 < 56) {
        layoutClasses.push(stackStyles.thick);
      } else if (size3 < 72) {
        layoutClasses.push(stackStyles.thicker);
      } else {
        layoutClasses.push(stackStyles.thickest);
      }
      if (size3 < 24) {
        layoutClasses.push(stackStyles.xxs);
      } else if (size3 < 48) {
        layoutClasses.push(stackStyles.xs);
      } else if (size3 < 96) {
        layoutClasses.push(stackStyles.s);
      } else {
        layoutClasses.push(stackStyles.l);
      }
    } else if (layout === "spread") {
      if (size3 < 20) {
        layoutClasses.push(spreadStyles.s);
      } else if (size3 < 32) {
        layoutClasses.push(spreadStyles.mNudge);
      } else if (size3 < 64) {
        layoutClasses.push(spreadStyles.l);
      } else {
        layoutClasses.push(spreadStyles.xl);
      }
    }
  }
  return mergeClasses(...layoutClasses);
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/AvatarGroupItem.js
var AvatarGroupItem = React112.forwardRef((props, ref) => {
  const state = useAvatarGroupItem_unstable(props, ref);
  useAvatarGroupItemStyles_unstable(state);
  useCustomStyleHook("useAvatarGroupItemStyles_unstable")(state);
  return renderAvatarGroupItem_unstable(state);
});
AvatarGroupItem.displayName = "AvatarGroupItem";

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/AvatarGroupPopover.js
var React135 = __toESM(require_react());

// node_modules/@fluentui/react-popover/lib/components/Popover/Popover.js
var React129 = __toESM(require_react());

// node_modules/@fluentui/react-popover/lib/components/Popover/usePopover.js
var React127 = __toESM(require_react());

// node_modules/@fluentui/react-positioning/lib/createVirtualElementFromClick.js
function createVirtualElementFromClick(nativeEvent) {
  const left2 = nativeEvent.clientX;
  const top = nativeEvent.clientY;
  const right2 = left2 + 1;
  const bottom = top + 1;
  function getBoundingClientRect2() {
    return {
      left: left2,
      top,
      right: right2,
      bottom,
      x: left2,
      y: top,
      height: 1,
      width: 1
    };
  }
  return {
    getBoundingClientRect: getBoundingClientRect2
  };
}

// node_modules/@fluentui/react-positioning/lib/constants.js
var DATA_POSITIONING_INTERSECTING = "data-popper-is-intersecting";
var DATA_POSITIONING_ESCAPED = "data-popper-escaped";
var DATA_POSITIONING_HIDDEN = "data-popper-reference-hidden";
var DATA_POSITIONING_PLACEMENT = "data-popper-placement";
var POSITIONING_END_EVENT = "fui-positioningend";

// node_modules/@fluentui/react-positioning/lib/PositioningConfigurationContext.js
var React113 = __toESM(require_react());
var DEFAULT_CONFIGURATION = ({ options }) => {
  return options;
};
var PositioningConfigurationContext = React113.createContext(void 0);
var PositioningConfigurationProvider = PositioningConfigurationContext.Provider;
var usePositioningConfiguration = () => {
  var _React_useContext;
  return (_React_useContext = React113.useContext(PositioningConfigurationContext)) !== null && _React_useContext !== void 0 ? _React_useContext : DEFAULT_CONFIGURATION;
};

// node_modules/@fluentui/react-positioning/lib/usePositioning.js
var React117 = __toESM(require_react());

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp2(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement3(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement3(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode2(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode2(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode2(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement3(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement3(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement3(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left2;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement3(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement3(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left2 = clientRect.left + element.clientLeft;
  const scale = isHTMLElement3(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left2 * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement3(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement3(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement3(element)) {
    let svgOffsetParent = getParentNode2(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode2(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
var detectOverflow2 = detectOverflow;
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@fluentui/react-positioning/lib/utils/parseFloatingUIPlacement.js
function parseFloatingUIPlacement(placement) {
  const tokens2 = placement.split("-");
  return {
    side: tokens2[0],
    alignment: tokens2[1]
  };
}

// node_modules/@fluentui/react-positioning/lib/utils/getScrollParent.js
var getParentNode3 = (node) => {
  if (node.nodeName === "HTML") {
    return node;
  }
  return node.parentNode || node.host;
};
var getStyleComputedProperty = (node) => {
  var _node_ownerDocument;
  if (node.nodeType !== 1) {
    return {};
  }
  const targetWindow = (_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.defaultView;
  if (targetWindow) {
    return targetWindow.getComputedStyle(node, null);
  }
  return {};
};
var getScrollParent = (node) => {
  const parentNode = node && getParentNode3(node);
  if (!parentNode) return document.body;
  switch (parentNode.nodeName) {
    case "HTML":
    case "BODY":
      return parentNode.ownerDocument.body;
    case "#document":
      return parentNode.body;
  }
  const { overflow, overflowX, overflowY } = getStyleComputedProperty(parentNode);
  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return parentNode;
  }
  return getScrollParent(parentNode);
};
var hasScrollParent = (node) => {
  var _scrollParentElement_ownerDocument;
  const scrollParentElement = getScrollParent(node);
  return scrollParentElement ? scrollParentElement !== ((_scrollParentElement_ownerDocument = scrollParentElement.ownerDocument) === null || _scrollParentElement_ownerDocument === void 0 ? void 0 : _scrollParentElement_ownerDocument.body) : false;
};

// node_modules/@fluentui/react-positioning/lib/utils/getBoundary.js
function getBoundary(element, boundary) {
  if (boundary === "window") {
    return element === null || element === void 0 ? void 0 : element.ownerDocument.documentElement;
  }
  if (boundary === "clippingParents") {
    return "clippingAncestors";
  }
  if (boundary === "scrollParent") {
    let boundariesNode = getScrollParent(element);
    if (boundariesNode.nodeName === "BODY") {
      boundariesNode = element === null || element === void 0 ? void 0 : element.ownerDocument.documentElement;
    }
    return boundariesNode;
  }
  return boundary;
}

// node_modules/@fluentui/react-positioning/lib/utils/getReactFiberFromNode.js
var React114 = __toESM(require_react());
var WorkTag = function(WorkTag2) {
  WorkTag2[WorkTag2["FunctionComponent"] = 0] = "FunctionComponent";
  WorkTag2[WorkTag2["ClassComponent"] = 1] = "ClassComponent";
  WorkTag2[WorkTag2["IndeterminateComponent"] = 2] = "IndeterminateComponent";
  WorkTag2[WorkTag2["HostRoot"] = 3] = "HostRoot";
  WorkTag2[WorkTag2["HostPortal"] = 4] = "HostPortal";
  WorkTag2[WorkTag2["HostComponent"] = 5] = "HostComponent";
  WorkTag2[WorkTag2["HostText"] = 6] = "HostText";
  WorkTag2[WorkTag2["Fragment"] = 7] = "Fragment";
  WorkTag2[WorkTag2["Mode"] = 8] = "Mode";
  WorkTag2[WorkTag2["ContextConsumer"] = 9] = "ContextConsumer";
  WorkTag2[WorkTag2["ContextProvider"] = 10] = "ContextProvider";
  WorkTag2[WorkTag2["ForwardRef"] = 11] = "ForwardRef";
  WorkTag2[WorkTag2["Profiler"] = 12] = "Profiler";
  WorkTag2[WorkTag2["SuspenseComponent"] = 13] = "SuspenseComponent";
  WorkTag2[WorkTag2["MemoComponent"] = 14] = "MemoComponent";
  WorkTag2[WorkTag2["SimpleMemoComponent"] = 15] = "SimpleMemoComponent";
  WorkTag2[WorkTag2["LazyComponent"] = 16] = "LazyComponent";
  WorkTag2[WorkTag2["IncompleteClassComponent"] = 17] = "IncompleteClassComponent";
  WorkTag2[WorkTag2["DehydratedFragment"] = 18] = "DehydratedFragment";
  WorkTag2[WorkTag2["SuspenseListComponent"] = 19] = "SuspenseListComponent";
  WorkTag2[WorkTag2["FundamentalComponent"] = 20] = "FundamentalComponent";
  WorkTag2[WorkTag2["ScopeComponent"] = 21] = "ScopeComponent";
  return WorkTag2;
}(WorkTag || {});
function getReactFiberFromNode(elm) {
  if (!elm) {
    return null;
  }
  for (const k in elm) {
    if (k.indexOf("__reactInternalInstance$") === 0 || k.indexOf("__reactFiber$") === 0) {
      return elm[k];
    }
  }
  throw new Error("getReactFiber(): Failed to find a React Fiber on a node");
}

// node_modules/@fluentui/react-positioning/lib/utils/mergeArrowOffset.js
function mergeArrowOffset(userOffset, arrowHeight2) {
  if (typeof userOffset === "number") {
    return addArrowOffset(userOffset, arrowHeight2);
  }
  if (typeof userOffset === "object" && userOffset !== null) {
    return addArrowOffset(userOffset, arrowHeight2);
  }
  if (typeof userOffset === "function") {
    return (offsetParams) => {
      const offset4 = userOffset(offsetParams);
      return addArrowOffset(offset4, arrowHeight2);
    };
  }
  return {
    mainAxis: arrowHeight2
  };
}
var addArrowOffset = (offset4, arrowHeight2) => {
  if (typeof offset4 === "number") {
    return {
      mainAxis: offset4 + arrowHeight2
    };
  }
  var _offset_mainAxis;
  return {
    ...offset4,
    mainAxis: ((_offset_mainAxis = offset4.mainAxis) !== null && _offset_mainAxis !== void 0 ? _offset_mainAxis : 0) + arrowHeight2
  };
};

// node_modules/@fluentui/react-positioning/lib/utils/toFloatingUIPadding.js
function toFloatingUIPadding(padding, isRtl) {
  if (typeof padding === "number") {
    return padding;
  }
  const { start, end, ...verticalPadding } = padding;
  const paddingObject = verticalPadding;
  const left2 = isRtl ? "end" : "start";
  const right2 = isRtl ? "start" : "end";
  if (padding[left2]) {
    paddingObject.left = padding[left2];
  }
  if (padding[right2]) {
    paddingObject.right = padding[right2];
  }
  return paddingObject;
}

// node_modules/@fluentui/react-positioning/lib/utils/toFloatingUIPlacement.js
var getPositionMap = (rtl) => ({
  above: "top",
  below: "bottom",
  before: rtl ? "right" : "left",
  after: rtl ? "left" : "right"
});
var getAlignmentMap = () => ({
  start: "start",
  end: "end",
  top: "start",
  bottom: "end",
  center: void 0
});
var shouldAlignToCenter = (p, a) => {
  const positionedVertically = p === "above" || p === "below";
  const alignedVertically = a === "top" || a === "bottom";
  return positionedVertically && alignedVertically || !positionedVertically && !alignedVertically;
};
var toFloatingUIPlacement = (align, position, rtl) => {
  const alignment = shouldAlignToCenter(position, align) ? "center" : align;
  const computedPosition = position && getPositionMap(rtl)[position];
  const computedAlignment = alignment && getAlignmentMap()[alignment];
  if (computedPosition && computedAlignment) {
    return `${computedPosition}-${computedAlignment}`;
  }
  return computedPosition;
};

// node_modules/@fluentui/react-positioning/lib/utils/fromFloatingUIPlacement.js
var getPositionMap2 = () => ({
  top: "above",
  bottom: "below",
  right: "after",
  left: "before"
});
var getAlignmentMap2 = (position) => {
  if (position === "above" || position === "below") {
    return {
      start: "start",
      end: "end"
    };
  }
  return {
    start: "top",
    end: "bottom"
  };
};
var fromFloatingUIPlacement = (placement) => {
  const { side, alignment: floatingUIAlignment } = parseFloatingUIPlacement(placement);
  const position = getPositionMap2()[side];
  const alignment = floatingUIAlignment && getAlignmentMap2(position)[floatingUIAlignment];
  return {
    position,
    alignment
  };
};

// node_modules/@fluentui/react-positioning/lib/utils/resolvePositioningShorthand.js
var shorthandLookup = {
  above: {
    position: "above",
    align: "center"
  },
  "above-start": {
    position: "above",
    align: "start"
  },
  "above-end": {
    position: "above",
    align: "end"
  },
  below: {
    position: "below",
    align: "center"
  },
  "below-start": {
    position: "below",
    align: "start"
  },
  "below-end": {
    position: "below",
    align: "end"
  },
  before: {
    position: "before",
    align: "center"
  },
  "before-top": {
    position: "before",
    align: "top"
  },
  "before-bottom": {
    position: "before",
    align: "bottom"
  },
  after: {
    position: "after",
    align: "center"
  },
  "after-top": {
    position: "after",
    align: "top"
  },
  "after-bottom": {
    position: "after",
    align: "bottom"
  }
};
function resolvePositioningShorthand(shorthand) {
  if (shorthand === void 0 || shorthand === null) {
    return {};
  }
  if (typeof shorthand === "string") {
    return shorthandLookup[shorthand];
  }
  return shorthand;
}

// node_modules/@fluentui/react-positioning/lib/utils/useCallbackRef.js
var React115 = __toESM(require_react());
function useCallbackRef(initialValue, callback, skipInitialResolve) {
  const isFirst = React115.useRef(true);
  const [ref] = React115.useState(() => ({
    // value
    value: initialValue,
    // last callback
    callback,
    // "memoized" public interface
    facade: {
      get current() {
        return ref.value;
      },
      set current(value) {
        const last = ref.value;
        if (last !== value) {
          ref.value = value;
          if (skipInitialResolve && isFirst.current) {
            return;
          }
          ref.callback(value, last);
        }
      }
    }
  }));
  useIsomorphicLayoutEffect(() => {
    isFirst.current = false;
  }, []);
  ref.callback = callback;
  return ref.facade;
}

// node_modules/@fluentui/react-positioning/lib/utils/debounce.js
function debounce(fn) {
  let pending;
  return () => {
    if (!pending) {
      pending = new Promise((resolve) => {
        Promise.resolve().then(() => {
          pending = void 0;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}

// node_modules/@fluentui/react-positioning/lib/utils/hasAutoFocusFilter.js
function hasAutofocusProp(node) {
  const isAutoFocusableElement = node.nodeName === "BUTTON" || node.nodeName === "INPUT" || node.nodeName === "SELECT" || node.nodeName === "TEXTAREA";
  if (isAutoFocusableElement) {
    var _getReactFiberFromNode;
    return !!((_getReactFiberFromNode = getReactFiberFromNode(node)) === null || _getReactFiberFromNode === void 0 ? void 0 : _getReactFiberFromNode.pendingProps.autoFocus);
  }
  return false;
}
function hasAutofocusFilter(node) {
  return hasAutofocusProp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
}

// node_modules/@fluentui/react-positioning/lib/utils/writeArrowUpdates.js
function writeArrowUpdates(options) {
  const { arrow: arrow3, middlewareData } = options;
  if (!middlewareData.arrow || !arrow3) {
    return;
  }
  const { x: arrowX, y: arrowY } = middlewareData.arrow;
  Object.assign(arrow3.style, {
    left: arrowX !== null && arrowX !== void 0 ? `${arrowX}px` : "",
    top: arrowY !== null && arrowY !== void 0 ? `${arrowY}px` : ""
  });
}

// node_modules/@fluentui/react-positioning/lib/utils/writeContainerupdates.js
function writeContainerUpdates(options) {
  var _middlewareData_hide, _middlewareData_hide1, _container_ownerDocument_defaultView;
  const { container, placement, middlewareData, strategy, lowPPI, coordinates, useTransform = true } = options;
  if (!container) {
    return;
  }
  container.setAttribute(DATA_POSITIONING_PLACEMENT, placement);
  container.removeAttribute(DATA_POSITIONING_INTERSECTING);
  if (middlewareData.intersectionObserver.intersecting) {
    container.setAttribute(DATA_POSITIONING_INTERSECTING, "");
  }
  container.removeAttribute(DATA_POSITIONING_ESCAPED);
  if ((_middlewareData_hide = middlewareData.hide) === null || _middlewareData_hide === void 0 ? void 0 : _middlewareData_hide.escaped) {
    container.setAttribute(DATA_POSITIONING_ESCAPED, "");
  }
  container.removeAttribute(DATA_POSITIONING_HIDDEN);
  if ((_middlewareData_hide1 = middlewareData.hide) === null || _middlewareData_hide1 === void 0 ? void 0 : _middlewareData_hide1.referenceHidden) {
    container.setAttribute(DATA_POSITIONING_HIDDEN, "");
  }
  const devicePixelRatio = ((_container_ownerDocument_defaultView = container.ownerDocument.defaultView) === null || _container_ownerDocument_defaultView === void 0 ? void 0 : _container_ownerDocument_defaultView.devicePixelRatio) || 1;
  const x = Math.round(coordinates.x * devicePixelRatio) / devicePixelRatio;
  const y = Math.round(coordinates.y * devicePixelRatio) / devicePixelRatio;
  Object.assign(container.style, {
    position: strategy
  });
  if (useTransform) {
    Object.assign(container.style, {
      transform: lowPPI ? `translate(${x}px, ${y}px)` : `translate3d(${x}px, ${y}px, 0)`
    });
    return;
  }
  Object.assign(container.style, {
    left: `${x}px`,
    top: `${y}px`
  });
}

// node_modules/@fluentui/react-positioning/lib/utils/normalizeAutoSize.js
var normalizeAutoSize = (autoSize) => {
  switch (autoSize) {
    case "always":
    case true:
      return {
        applyMaxWidth: true,
        applyMaxHeight: true
      };
    case "width-always":
    case "width":
      return {
        applyMaxWidth: true,
        applyMaxHeight: false
      };
    case "height-always":
    case "height":
      return {
        applyMaxWidth: false,
        applyMaxHeight: true
      };
    default:
      return false;
  }
};

// node_modules/@fluentui/react-positioning/lib/utils/listScrollParents.js
function listScrollParents(node) {
  const scrollParents = [];
  let cur = node;
  while (cur) {
    const scrollParent = getScrollParent(cur);
    if (node.ownerDocument.body === scrollParent) {
      scrollParents.push(scrollParent);
      break;
    }
    if (scrollParent.nodeName === "BODY" && scrollParent !== node.ownerDocument.body) {
      if (true) {
        console.error("@fluentui/react-positioning: You are comparing two different documents! This is an unexpected error, please report this as a bug to the Fluent UI team ");
      }
      break;
    }
    scrollParents.push(scrollParent);
    cur = scrollParent;
  }
  return scrollParents;
}

// node_modules/@fluentui/react-positioning/lib/utils/createResizeObserver.js
function createResizeObserver(targetWindow, callback) {
  if (false) {
    targetWindow.ResizeObserver = class ResizeObserver {
      observe() {
      }
      unobserve() {
      }
      disconnect() {
      }
    };
  }
  return new targetWindow.ResizeObserver(callback);
}

// node_modules/@fluentui/react-positioning/lib/createPositionManager.js
function createPositionManager(options) {
  let isDestroyed = false;
  const { container, target, arrow: arrow3, strategy, middleware, placement, useTransform = true, disableUpdateOnResize = false } = options;
  const targetWindow = container.ownerDocument.defaultView;
  if (!target || !container || !targetWindow) {
    return {
      updatePosition: () => void 0,
      dispose: () => void 0
    };
  }
  const resizeObserver = disableUpdateOnResize ? null : createResizeObserver(targetWindow, (entries) => {
    const shouldUpdateOnResize = entries.every((entry) => {
      return entry.contentRect.width > 0 && entry.contentRect.height > 0;
    });
    if (shouldUpdateOnResize) {
      updatePosition();
    }
  });
  let isFirstUpdate = true;
  const scrollParents = /* @__PURE__ */ new Set();
  Object.assign(container.style, {
    position: "fixed",
    left: 0,
    top: 0,
    margin: 0
  });
  const forceUpdate = () => {
    if (isDestroyed) {
      return;
    }
    if (isFirstUpdate) {
      listScrollParents(container).forEach((scrollParent) => scrollParents.add(scrollParent));
      if (isHTMLElement(target)) {
        listScrollParents(target).forEach((scrollParent) => scrollParents.add(scrollParent));
      }
      scrollParents.forEach((scrollParent) => {
        scrollParent.addEventListener("scroll", updatePosition, {
          passive: true
        });
      });
      resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.observe(container);
      if (isHTMLElement(target)) {
        resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.observe(target);
      }
      isFirstUpdate = false;
    }
    Object.assign(container.style, {
      position: strategy
    });
    computePosition2(target, container, {
      placement,
      middleware,
      strategy
    }).then(({ x, y, middlewareData, placement: computedPlacement }) => {
      if (isDestroyed) {
        return;
      }
      writeArrowUpdates({
        arrow: arrow3,
        middlewareData
      });
      writeContainerUpdates({
        container,
        middlewareData,
        placement: computedPlacement,
        coordinates: {
          x,
          y
        },
        lowPPI: ((targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.devicePixelRatio) || 1) <= 1,
        strategy,
        useTransform
      });
      container.dispatchEvent(new CustomEvent(POSITIONING_END_EVENT));
    }).catch((err) => {
      if (true) {
        console.error("[usePositioning]: Failed to calculate position", err);
      }
    });
  };
  const updatePosition = debounce(() => forceUpdate());
  const dispose = () => {
    isDestroyed = true;
    if (targetWindow) {
      targetWindow.removeEventListener("scroll", updatePosition);
      targetWindow.removeEventListener("resize", updatePosition);
    }
    scrollParents.forEach((scrollParent) => {
      scrollParent.removeEventListener("scroll", updatePosition);
    });
    scrollParents.clear();
    resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
  };
  if (targetWindow) {
    targetWindow.addEventListener("scroll", updatePosition, {
      passive: true
    });
    targetWindow.addEventListener("resize", updatePosition);
  }
  updatePosition();
  return {
    updatePosition,
    dispose
  };
}

// node_modules/@floating-ui/devtools/dist/floating-ui.devtools.mjs
var CONTROLLER = "__FUIDT_CONTROLLER__";
var ELEMENT_METADATA = "__FUIDT_ELEMENT_METADATA__";
var HTML_ELEMENT_REFERENCE = "__FUIDT_HTML_ELEMENT_REFERENCE__";
var SERIALIZED_DATA_CHANGE = "__FUIDT_SERIALIZED_DATA_CHANGE__";
function isHTMLElement4(element, options) {
  var _typedElement$ownerDo, _options$constructorN;
  const typedElement = element;
  return Boolean((typedElement == null || (_typedElement$ownerDo = typedElement.ownerDocument) == null ? void 0 : _typedElement$ownerDo.defaultView) && typedElement instanceof typedElement.ownerDocument.defaultView[(_options$constructorN = void 0) != null ? _options$constructorN : "HTMLElement"]);
}
var isHTMLElementWithMetadata = (element) => Boolean(isHTMLElement4(element) && ELEMENT_METADATA in element && element.parentElement !== null);
var createController = (defaultView) => {
  let selectedElement = null;
  const observer = new MutationObserver((mutations) => {
    if (!selectedElement) {
      return;
    }
    for (const mutation of mutations) {
      if (mutation.type === "childList" && Array.from(mutation.removedNodes).includes(selectedElement)) {
        controller.withdraw();
      }
    }
  });
  const controller = {
    get selectedElement() {
      return selectedElement;
    },
    select: (nextSelectedElement) => {
      if (isHTMLElementWithMetadata(nextSelectedElement)) {
        selectedElement = nextSelectedElement;
        observer.observe(nextSelectedElement.parentElement, {
          childList: true,
          subtree: false
        });
      }
      if (selectedElement && nextSelectedElement) {
        const metadata = selectedElement[ELEMENT_METADATA];
        if (metadata.references.has(nextSelectedElement)) {
          return selectedElement;
        }
      }
      controller.withdraw();
      return selectedElement;
    },
    withdraw: () => {
      selectedElement = null;
      observer.disconnect();
      defaultView.postMessage(SERIALIZED_DATA_CHANGE);
    }
  };
  return controller;
};
var injectController = (_ref) => {
  let {
    defaultView
  } = _ref;
  if (!defaultView) {
    return;
  }
  if (!defaultView[CONTROLLER]) {
    defaultView[CONTROLLER] = createController(defaultView);
  }
};
var getController = (targetDocument) => {
  var _targetDocument$defau, _targetDocument$defau2;
  injectController(targetDocument);
  return (_targetDocument$defau = (_targetDocument$defau2 = targetDocument.defaultView) == null ? void 0 : _targetDocument$defau2[CONTROLLER]) != null ? _targetDocument$defau : null;
};
var serialize = (data, references) => {
  const serializedData = JSON.parse(JSON.stringify(data, (_, value) => {
    if (isHTMLElement4(value)) return references.add(value);
    if (typeof value === "object" && value && Object.getPrototypeOf(value) !== Object.prototype && Object.getPrototypeOf(value) !== Array.prototype) {
      if ("toString" in value) {
        return value.toString();
      }
      return void 0;
    }
    return value;
  }));
  return serializedData;
};
var counter = 0;
var generateReferenceId = () => HTML_ELEMENT_REFERENCE + ":" + counter++;
var createReferences = () => {
  const map = /* @__PURE__ */ new Map();
  const weakMap = /* @__PURE__ */ new WeakMap();
  const references = {
    add: (element) => {
      if (weakMap.has(element)) {
        return weakMap.get(element);
      }
      const id = generateReferenceId();
      map.set(id, element);
      weakMap.set(element, id);
      return id;
    },
    get: (id) => {
      const element = map.get(id);
      if (element && weakMap.has(element)) {
        return element;
      }
    },
    has: (element) => {
      return weakMap.has(element);
    }
  };
  return references;
};
var devtools = function(targetDocument, middlewareDataCallback) {
  if (targetDocument === void 0) {
    targetDocument = document;
  }
  if (middlewareDataCallback === void 0) {
    middlewareDataCallback = floatingUIMiddlewareDataCallback;
  }
  return {
    name: "@floating-ui/devtools",
    fn: (state) => {
      const {
        [ELEMENT_METADATA]: metadata
      } = isHTMLElementWithMetadata(state.elements.floating) ? state.elements.floating : Object.assign(state.elements.floating, {
        [ELEMENT_METADATA]: {
          references: createReferences(),
          serializedData: []
        }
      });
      const serializedData = serialize(middlewareDataCallback(state), metadata.references);
      metadata.serializedData.unshift(serializedData);
      const controller = getController(targetDocument);
      if (metadata.serializedData.length > 1 && state.elements.floating === (controller == null ? void 0 : controller.selectedElement)) {
        var _targetDocument$defau;
        (_targetDocument$defau = targetDocument.defaultView) == null || _targetDocument$defau.postMessage(SERIALIZED_DATA_CHANGE);
      }
      return {};
    }
  };
};
var floatingUIMiddlewareDataCallback = (state) => ({
  ...state,
  type: "FloatingUIMiddleware"
});

// node_modules/@fluentui/react-positioning/lib/usePositioningOptions.js
var React116 = __toESM(require_react());

// node_modules/@fluentui/react-positioning/lib/middleware/coverTarget.js
function coverTarget() {
  return {
    name: "coverTarget",
    fn: (middlewareArguments) => {
      const { placement, rects, x, y } = middlewareArguments;
      const basePlacement = parseFloatingUIPlacement(placement).side;
      const newCoords = {
        x,
        y
      };
      switch (basePlacement) {
        case "bottom":
          newCoords.y -= rects.reference.height;
          break;
        case "top":
          newCoords.y += rects.reference.height;
          break;
        case "left":
          newCoords.x += rects.reference.width;
          break;
        case "right":
          newCoords.x -= rects.reference.width;
          break;
      }
      return newCoords;
    }
  };
}

// node_modules/@fluentui/react-positioning/lib/middleware/flip.js
function flip3(options) {
  const { hasScrollableElement, flipBoundary, container, fallbackPositions: fallbackPositions2 = [], isRtl } = options;
  const fallbackPlacements = fallbackPositions2.reduce((acc, shorthand) => {
    const { position, align } = resolvePositioningShorthand(shorthand);
    const placement = toFloatingUIPlacement(align, position, isRtl);
    if (placement) {
      acc.push(placement);
    }
    return acc;
  }, []);
  return flip2({
    ...hasScrollableElement && {
      boundary: "clippingAncestors"
    },
    ...flipBoundary && {
      altBoundary: true,
      boundary: getBoundary(container, flipBoundary)
    },
    fallbackStrategy: "bestFit",
    ...fallbackPlacements.length && {
      fallbackPlacements
    }
  });
}

// node_modules/@fluentui/react-positioning/lib/middleware/intersecting.js
function intersecting() {
  return {
    name: "intersectionObserver",
    fn: async (middlewareArguments) => {
      const floatingRect = middlewareArguments.rects.floating;
      const altOverflow = await detectOverflow2(middlewareArguments, {
        altBoundary: true
      });
      const isIntersectingTop = altOverflow.top < floatingRect.height && altOverflow.top > 0;
      const isIntersectingBottom = altOverflow.bottom < floatingRect.height && altOverflow.bottom > 0;
      const isIntersecting = isIntersectingTop || isIntersectingBottom;
      return {
        data: {
          intersecting: isIntersecting
        }
      };
    }
  };
}

// node_modules/@fluentui/react-positioning/lib/middleware/maxSize.js
var resetMaxSize = (autoSize) => ({
  name: "resetMaxSize",
  fn({ middlewareData, elements }) {
    var _middlewareData_resetMaxSize;
    if ((_middlewareData_resetMaxSize = middlewareData.resetMaxSize) === null || _middlewareData_resetMaxSize === void 0 ? void 0 : _middlewareData_resetMaxSize.maxSizeAlreadyReset) {
      return {};
    }
    const { applyMaxWidth, applyMaxHeight } = autoSize;
    if (applyMaxWidth) {
      elements.floating.style.removeProperty("box-sizing");
      elements.floating.style.removeProperty("max-width");
      elements.floating.style.removeProperty("width");
    }
    if (applyMaxHeight) {
      elements.floating.style.removeProperty("box-sizing");
      elements.floating.style.removeProperty("max-height");
      elements.floating.style.removeProperty("height");
    }
    return {
      data: {
        maxSizeAlreadyReset: true
      },
      reset: {
        rects: true
      }
    };
  }
});
function maxSize(autoSize, options) {
  const { container, overflowBoundary, overflowBoundaryPadding, isRtl } = options;
  return size2({
    ...overflowBoundaryPadding && {
      padding: toFloatingUIPadding(overflowBoundaryPadding, isRtl)
    },
    ...overflowBoundary && {
      altBoundary: true,
      boundary: getBoundary(container, overflowBoundary)
    },
    apply({ availableHeight, availableWidth, elements, rects }) {
      const applyMaxSizeStyles = (apply, dimension, availableSize) => {
        if (!apply) {
          return;
        }
        elements.floating.style.setProperty("box-sizing", "border-box");
        elements.floating.style.setProperty(`max-${dimension}`, `${availableSize}px`);
        if (rects.floating[dimension] > availableSize) {
          elements.floating.style.setProperty(dimension, `${availableSize}px`);
          const axis = dimension === "width" ? "x" : "y";
          if (!elements.floating.style.getPropertyValue(`overflow-${axis}`)) {
            elements.floating.style.setProperty(`overflow-${axis}`, "auto");
          }
        }
      };
      const { applyMaxWidth, applyMaxHeight } = autoSize;
      applyMaxSizeStyles(applyMaxWidth, "width", availableWidth);
      applyMaxSizeStyles(applyMaxHeight, "height", availableHeight);
    }
  });
}

// node_modules/@fluentui/react-positioning/lib/utils/getFloatingUIOffset.js
function getFloatingUIOffset(rawOffset) {
  if (!rawOffset) {
    return rawOffset;
  }
  if (typeof rawOffset === "number" || typeof rawOffset === "object") {
    return rawOffset;
  }
  return ({ rects: { floating, reference }, placement }) => {
    const { position, alignment } = fromFloatingUIPlacement(placement);
    return rawOffset({
      positionedRect: floating,
      targetRect: reference,
      position,
      alignment
    });
  };
}

// node_modules/@fluentui/react-positioning/lib/middleware/offset.js
function offset3(offsetValue) {
  const floatingUIOffset = getFloatingUIOffset(offsetValue);
  return offset2(floatingUIOffset);
}

// node_modules/@fluentui/react-positioning/lib/middleware/shift.js
function shift3(options) {
  const { hasScrollableElement, shiftToCoverTarget, disableTether, overflowBoundary, container, overflowBoundaryPadding, isRtl } = options;
  return shift2({
    ...hasScrollableElement && {
      boundary: "clippingAncestors"
    },
    ...shiftToCoverTarget && {
      crossAxis: true,
      limiter: limitShift2({
        crossAxis: true,
        mainAxis: false
      })
    },
    ...disableTether && {
      crossAxis: disableTether === "all",
      limiter: limitShift2({
        crossAxis: disableTether !== "all",
        mainAxis: false
      })
    },
    ...overflowBoundaryPadding && {
      padding: toFloatingUIPadding(overflowBoundaryPadding, isRtl)
    },
    ...overflowBoundary && {
      altBoundary: true,
      boundary: getBoundary(container, overflowBoundary)
    }
  });
}

// node_modules/@fluentui/react-positioning/lib/middleware/matchTargetSize.js
var matchTargetSizeCssVar = "--fui-match-target-size";
function matchTargetSize() {
  return {
    name: "matchTargetSize",
    fn: async (middlewareArguments) => {
      const { rects: { reference: referenceRect, floating: floatingRect }, elements: { floating: floatingElement }, middlewareData: { matchTargetSize: { matchTargetSizeAttempt = false } = {} } } = middlewareArguments;
      if (referenceRect.width === floatingRect.width || matchTargetSizeAttempt) {
        return {};
      }
      const { width } = referenceRect;
      floatingElement.style.setProperty(matchTargetSizeCssVar, `${width}px`);
      if (!floatingElement.style.width) {
        floatingElement.style.width = `var(${matchTargetSizeCssVar})`;
      }
      return {
        data: {
          matchTargetSizeAttempt: true
        },
        reset: {
          rects: true
        }
      };
    }
  };
}

// node_modules/@fluentui/react-positioning/lib/utils/devtools.js
var devtoolsCallback = (options) => (middlewareState) => {
  const { elements: { floating, reference } } = middlewareState;
  const scrollParentsSet = /* @__PURE__ */ new Set();
  if (isHTMLElement(reference)) {
    listScrollParents(reference).forEach((scrollParent) => scrollParentsSet.add(scrollParent));
  }
  listScrollParents(floating).forEach((scrollParent) => scrollParentsSet.add(scrollParent));
  const flipBoundaries = Array.isArray(options.flipBoundary) ? options.flipBoundary : isHTMLElement(options.flipBoundary) ? [
    options.flipBoundary
  ] : [];
  const overflowBoundaries = Array.isArray(options.overflowBoundary) ? options.overflowBoundary : isHTMLElement(options.overflowBoundary) ? [
    options.overflowBoundary
  ] : [];
  return {
    type: "FluentUIMiddleware",
    middlewareState,
    options,
    initialPlacement: fromFloatingUIPlacement(middlewareState.initialPlacement),
    placement: fromFloatingUIPlacement(middlewareState.placement),
    flipBoundaries,
    overflowBoundaries,
    scrollParents: Array.from(scrollParentsSet)
  };
};

// node_modules/@fluentui/react-positioning/lib/usePositioningOptions.js
function usePositioningConfigFn(configFn, options) {
  const {
    align,
    arrowPadding,
    autoSize,
    coverTarget: coverTarget2,
    disableUpdateOnResize,
    flipBoundary,
    offset: offset4,
    overflowBoundary,
    pinned,
    position,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_disableTether,
    strategy,
    overflowBoundaryPadding,
    fallbackPositions: fallbackPositions2,
    useTransform,
    matchTargetSize: matchTargetSize2,
    shiftToCoverTarget
  } = options;
  return React116.useCallback((container, arrow3) => {
    return configFn({
      container,
      arrow: arrow3,
      options: {
        autoSize,
        disableUpdateOnResize,
        matchTargetSize: matchTargetSize2,
        offset: offset4,
        strategy,
        coverTarget: coverTarget2,
        flipBoundary,
        overflowBoundary,
        useTransform,
        overflowBoundaryPadding,
        pinned,
        arrowPadding,
        align,
        fallbackPositions: fallbackPositions2,
        shiftToCoverTarget,
        position,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        unstable_disableTether
      }
    });
  }, [
    autoSize,
    disableUpdateOnResize,
    matchTargetSize2,
    offset4,
    strategy,
    coverTarget2,
    flipBoundary,
    overflowBoundary,
    useTransform,
    overflowBoundaryPadding,
    pinned,
    arrowPadding,
    align,
    fallbackPositions2,
    shiftToCoverTarget,
    position,
    unstable_disableTether,
    configFn
  ]);
}
function usePositioningOptions(options) {
  const { dir, targetDocument } = useFluent();
  const isRtl = dir === "rtl";
  const configFn = usePositioningConfigFn(usePositioningConfiguration(), options);
  const {
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    positionFixed
  } = options;
  return React116.useCallback((container, arrow3) => {
    const hasScrollableElement = hasScrollParent(container);
    const optionsAfterEnhancement = configFn(container, arrow3);
    const {
      autoSize,
      disableUpdateOnResize,
      matchTargetSize: matchTargetSize2,
      offset: offset4,
      coverTarget: coverTarget2,
      flipBoundary,
      overflowBoundary,
      useTransform,
      overflowBoundaryPadding,
      pinned,
      position,
      arrowPadding,
      strategy,
      align,
      fallbackPositions: fallbackPositions2,
      shiftToCoverTarget,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      unstable_disableTether
    } = optionsAfterEnhancement;
    const normalizedAutoSize = normalizeAutoSize(autoSize);
    const middleware = [
      normalizedAutoSize && resetMaxSize(normalizedAutoSize),
      matchTargetSize2 && matchTargetSize(),
      offset4 && offset3(offset4),
      coverTarget2 && coverTarget(),
      !pinned && flip3({
        container,
        flipBoundary,
        hasScrollableElement,
        isRtl,
        fallbackPositions: fallbackPositions2
      }),
      shift3({
        container,
        hasScrollableElement,
        overflowBoundary,
        disableTether: unstable_disableTether,
        overflowBoundaryPadding,
        isRtl,
        shiftToCoverTarget
      }),
      normalizedAutoSize && maxSize(normalizedAutoSize, {
        container,
        overflowBoundary,
        overflowBoundaryPadding,
        isRtl
      }),
      intersecting(),
      arrow3 && arrow2({
        element: arrow3,
        padding: arrowPadding
      }),
      hide2({
        strategy: "referenceHidden"
      }),
      hide2({
        strategy: "escaped"
      }),
      targetDocument && devtools(targetDocument, devtoolsCallback(optionsAfterEnhancement))
    ].filter(Boolean);
    const placement = toFloatingUIPlacement(align, position, isRtl);
    return {
      placement,
      middleware,
      strategy: (strategy !== null && strategy !== void 0 ? strategy : positionFixed) ? "fixed" : "absolute",
      disableUpdateOnResize,
      useTransform
    };
  }, [
    configFn,
    isRtl,
    targetDocument,
    positionFixed
  ]);
}

// node_modules/@fluentui/react-positioning/lib/usePositioning.js
function usePositioning(options) {
  "use no memo";
  const managerRef = React117.useRef(null);
  const targetRef = React117.useRef(null);
  const overrideTargetRef = React117.useRef(null);
  const containerRef = React117.useRef(null);
  const arrowRef = React117.useRef(null);
  const { enabled = true } = options;
  const resolvePositioningOptions = usePositioningOptions(options);
  const updatePositionManager = React117.useCallback(() => {
    if (managerRef.current) {
      managerRef.current.dispose();
    }
    managerRef.current = null;
    var _overrideTargetRef_current;
    const target = (_overrideTargetRef_current = overrideTargetRef.current) !== null && _overrideTargetRef_current !== void 0 ? _overrideTargetRef_current : targetRef.current;
    if (enabled && canUseDOM() && target && containerRef.current) {
      managerRef.current = createPositionManager({
        container: containerRef.current,
        target,
        arrow: arrowRef.current,
        ...resolvePositioningOptions(containerRef.current, arrowRef.current)
      });
    }
  }, [
    enabled,
    resolvePositioningOptions
  ]);
  const setOverrideTarget = useEventCallback((target) => {
    overrideTargetRef.current = target;
    updatePositionManager();
  });
  React117.useImperativeHandle(options.positioningRef, () => ({
    updatePosition: () => {
      var _managerRef_current;
      return (_managerRef_current = managerRef.current) === null || _managerRef_current === void 0 ? void 0 : _managerRef_current.updatePosition();
    },
    setTarget: (target) => {
      if (options.target && true) {
        const err = new Error();
        console.warn("Imperative setTarget should not be used at the same time as target option");
        console.warn(err.stack);
      }
      setOverrideTarget(target);
    }
  }), [
    options.target,
    setOverrideTarget
  ]);
  useIsomorphicLayoutEffect(() => {
    var _options_target;
    setOverrideTarget((_options_target = options.target) !== null && _options_target !== void 0 ? _options_target : null);
  }, [
    options.target,
    setOverrideTarget
  ]);
  useIsomorphicLayoutEffect(() => {
    updatePositionManager();
  }, [
    updatePositionManager
  ]);
  if (true) {
    React117.useEffect(() => {
      if (containerRef.current) {
        var _contentNode_ownerDocument;
        const contentNode = containerRef.current;
        const treeWalker = (_contentNode_ownerDocument = contentNode.ownerDocument) === null || _contentNode_ownerDocument === void 0 ? void 0 : _contentNode_ownerDocument.createTreeWalker(contentNode, NodeFilter.SHOW_ELEMENT, {
          acceptNode: hasAutofocusFilter
        });
        while (treeWalker.nextNode()) {
          const node = treeWalker.currentNode;
          console.warn("usePositioning():", node);
          console.warn([
            'usePositioning(): ^ this node contains "autoFocus" prop on a React element. This can break the initial',
            "positioning of an element and cause a window jump effect. This issue occurs because React polyfills",
            '"autoFocus" behavior to solve inconsistencies between different browsers:',
            "https://github.com/facebook/react/issues/11851#issuecomment-351787078",
            "\n",
            'However, ".focus()" in this case occurs before any other React effects will be executed',
            "(React.useEffect(), componentDidMount(), etc.) and we can not prevent this behavior. If you really",
            'want to use "autoFocus" please add "position: fixed" to styles of the element that is wrapped by',
            '"Popper".',
            `In general, it's not recommended to use "autoFocus" as it may break accessibility aspects:`,
            "https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-autofocus.md",
            "\n",
            'We suggest to use the "trapFocus" prop on Fluent components or a catch "ref" and then use',
            '"ref.current.focus" in React.useEffect():',
            "https://reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element"
          ].join(" "));
        }
      }
    }, []);
  }
  const setTarget = useCallbackRef(null, (target) => {
    if (targetRef.current !== target) {
      targetRef.current = target;
      updatePositionManager();
    }
  });
  const onPositioningEnd = useEventCallback(() => {
    var _options_onPositioningEnd;
    return (_options_onPositioningEnd = options.onPositioningEnd) === null || _options_onPositioningEnd === void 0 ? void 0 : _options_onPositioningEnd.call(options);
  });
  const setContainer = useCallbackRef(null, (container) => {
    if (containerRef.current !== container) {
      var _containerRef_current;
      (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.removeEventListener(POSITIONING_END_EVENT, onPositioningEnd);
      container === null || container === void 0 ? void 0 : container.addEventListener(POSITIONING_END_EVENT, onPositioningEnd);
      containerRef.current = container;
      updatePositionManager();
    }
  });
  const setArrow = useCallbackRef(null, (arrow3) => {
    if (arrowRef.current !== arrow3) {
      arrowRef.current = arrow3;
      updatePositionManager();
    }
  });
  return {
    targetRef: setTarget,
    containerRef: setContainer,
    arrowRef: setArrow
  };
}

// node_modules/@fluentui/react-positioning/lib/usePositioningMouseTarget.js
var React118 = __toESM(require_react());
var usePositioningMouseTarget = (initialState) => {
  const [virtualElement, setVirtualElement] = React118.useState(initialState);
  const setVirtualMouseTarget = (event) => {
    if (event === void 0 || event === null) {
      setVirtualElement(void 0);
      return;
    }
    let mouseevent;
    if (!(event instanceof MouseEvent)) {
      mouseevent = event.nativeEvent;
    } else {
      mouseevent = event;
    }
    if (!(mouseevent instanceof MouseEvent) && true) {
      console.error("usePositioningMouseTarget should only be used with MouseEvent");
    }
    const contextTarget = createVirtualElementFromClick(mouseevent);
    setVirtualElement(contextTarget);
  };
  return [
    virtualElement,
    setVirtualMouseTarget
  ];
};

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/useSafeZoneArea.js
var React120 = __toESM(require_react());

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/createSafeZoneAreaStateStore.js
function createSafeZoneAreaStateStore() {
  let isActive = false;
  const listeners = [];
  return {
    isActive() {
      return isActive;
    },
    toggleActive(newIsActive) {
      if (isActive === newIsActive) {
        return;
      }
      isActive = newIsActive;
      listeners.forEach((listener) => listener(isActive));
    },
    subscribe(listener) {
      listeners.push(listener);
      return () => {
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      };
    }
  };
}

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/SafeZoneArea.js
var React119 = __toESM(require_react());
var import_shim = __toESM(require_shim());

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/getRectCorners.js
function getRectCorners(rect, offset4) {
  return {
    topLeft: [
      rect.left - offset4[0],
      rect.top - offset4[1]
    ],
    topRight: [
      rect.right - offset4[0],
      rect.top - offset4[1]
    ],
    bottomRight: [
      rect.right - offset4[0],
      rect.bottom - offset4[1]
    ],
    bottomLeft: [
      rect.left - offset4[0],
      rect.bottom - offset4[1]
    ]
  };
}

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/getMouseAnchor.js
var OFFSET_DISTANCE = 20;
function measureDistance(a, b) {
  return Math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2);
}
function getUnitVector(a, b) {
  const distance = measureDistance(a, b);
  if (distance === 0) {
    return [
      0,
      0
    ];
  }
  return [
    (a[0] - b[0]) / distance,
    (a[1] - b[1]) / distance
  ];
}
function getMouseAnchor(topLeftCorner, bottomRightCorner, mouseCoordinates) {
  const containerCenter = [
    (topLeftCorner[0] + bottomRightCorner[0]) / 2,
    (topLeftCorner[1] + bottomRightCorner[1]) / 2
  ];
  const unitVector = getUnitVector([
    mouseCoordinates[0],
    mouseCoordinates[1]
  ], [
    containerCenter[0],
    containerCenter[1]
  ]);
  const distance = measureDistance([
    containerCenter[0],
    containerCenter[1]
  ], [
    mouseCoordinates[0],
    mouseCoordinates[1]
  ]);
  return [
    containerCenter[0] + unitVector[0] * (distance + OFFSET_DISTANCE),
    containerCenter[1] + unitVector[1] * (distance + OFFSET_DISTANCE)
  ];
}

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/pointsToSvgPath.js
function pointsToSvgPath(points) {
  return `M ${points} z`;
}

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/SafeZoneArea.styles.js
var useStyles8 = __styles2({
  wrapper: {
    mc9l5x: "fjseox",
    Bqenvij: "fniina8",
    a9b677: "f3tsq5r",
    Bkecrkj: "f1aehjj5"
  },
  wrapperActive: {
    mc9l5x: "ftgm304"
  },
  svg: {
    Bkfmm31: "f1au8mb3",
    Bkecrkj: "f1aehjj5",
    qhf8xq: "f19dog8a",
    Bhzewxz: "f15twtuk",
    oyh7mz: ["f1vgc2s3", "f1e31b4d"]
  },
  triangle: {
    Bkecrkj: "f1cguypg"
  },
  triangleDebug: {
    Bceei9c: "f7116n6",
    Bkfmm31: "f1xab38x"
  },
  rectDebug: {
    Bkfmm31: "fyegryc"
  }
}, {
  d: [".fjseox{display:none;}", ".fniina8{height:0;}", ".f3tsq5r{width:0;}", ".f1aehjj5{pointer-events:none;}", ".ftgm304{display:block;}", ".f1au8mb3{fill:transparent;}", ".f19dog8a{position:fixed;}", ".f15twtuk{top:0;}", ".f1vgc2s3{left:0;}", ".f1e31b4d{right:0;}", ".f1cguypg{pointer-events:auto;}", ".f7116n6{cursor:crosshair;}", ".f1xab38x{fill:color-mix(in srgb, var(--colorPaletteGreenBackground3) 20%, transparent);}", ".fyegryc{fill:color-mix(in srgb, var(--colorPaletteRedBackground3) 20%, transparent);}"]
});

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/computeOutsideClipPath.js
function drawRectangle(rect) {
  if (rect.width <= 0 || rect.height <= 0) {
    return "";
  }
  let pathData = "";
  pathData += `M ${rect.x},${rect.y} `;
  pathData += `V ${rect.y + rect.height} `;
  pathData += `H ${rect.x + rect.width} `;
  pathData += `V ${rect.y} `;
  pathData += `H ${rect.x} `;
  pathData += `Z `;
  return pathData;
}
function computeOutsideClipPath(svgWidth, svgHeight, targetRect, containerRect) {
  let pathData = `M 0,0 H ${svgWidth} V ${svgHeight} H 0 Z `;
  pathData += drawRectangle(targetRect);
  pathData += drawRectangle(containerRect);
  return pathData;
}

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/SafeZoneArea.js
var EMPTY_RECT = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0,
  x: 0,
  y: 0,
  toJSON() {
    return "";
  }
};
function isSameRect(a, b) {
  return a.top === b.top && a.right === b.right && a.bottom === b.bottom && a.left === b.left && a.width === b.width && a.height === b.height;
}
function isSameCoordinates(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
var SafeZoneArea = React119.memo((props) => {
  const { debug, onMouseEnter, onMouseMove, onMouseLeave, stateStore } = props;
  const clipPathId = useId2();
  const styles = useStyles8();
  const active = (0, import_shim.useSyncExternalStore)(stateStore.subscribe, stateStore.isActive);
  const svgRef = React119.useRef(null);
  const [state, setState] = React119.useState(() => ({
    containerRect: EMPTY_RECT,
    targetRect: EMPTY_RECT,
    mouseCoordinates: [
      0,
      0
    ]
  }));
  React119.useImperativeHandle(props.imperativeRef, () => ({
    updateSVG(newState) {
      setState((prevState) => {
        if (isSameRect(prevState.containerRect, newState.containerRect) && isSameRect(prevState.targetRect, newState.targetRect) && isSameCoordinates(prevState.mouseCoordinates, newState.mouseCoordinates)) {
          return prevState;
        }
        return newState;
      });
    }
  }), []);
  const { containerRect, targetRect, mouseCoordinates } = state;
  const topOffset = Math.min(targetRect.top, containerRect.top);
  const leftOffset = Math.min(targetRect.left, containerRect.left);
  const bottomOffset = Math.max(targetRect.bottom, containerRect.bottom);
  const rightOffset = Math.max(targetRect.right, containerRect.right);
  const containerCorners = getRectCorners(containerRect, [
    leftOffset,
    topOffset
  ]);
  const targetCorners = getRectCorners(targetRect, [
    leftOffset,
    topOffset
  ]);
  const relativeMouseCoordinates = [
    mouseCoordinates[0] - leftOffset,
    mouseCoordinates[1] - topOffset
  ];
  const mouseAnchor = getMouseAnchor(containerCorners.topLeft, containerCorners.bottomRight, relativeMouseCoordinates);
  const triangleA = [
    mouseAnchor,
    containerCorners.topLeft,
    containerCorners.topRight
  ];
  const triangleB = [
    mouseAnchor,
    containerCorners.topRight,
    containerCorners.bottomRight
  ];
  const triangleC = [
    mouseAnchor,
    containerCorners.bottomRight,
    containerCorners.bottomLeft
  ];
  const triangleD = [
    mouseAnchor,
    containerCorners.bottomLeft,
    containerCorners.topLeft
  ];
  const svgWidth = rightOffset - leftOffset;
  const svgHeight = bottomOffset - topOffset;
  const clipPath = computeOutsideClipPath(svgWidth, svgHeight, {
    x: targetCorners.topLeft[0],
    y: targetCorners.topLeft[1],
    width: targetRect.width,
    height: targetRect.height
  }, {
    x: containerCorners.topLeft[0],
    y: containerCorners.topLeft[1],
    width: containerRect.width,
    height: containerRect.height
  });
  return React119.createElement("div", {
    className: mergeClasses(styles.wrapper, active && styles.wrapperActive),
    "data-safe-zone": ""
  }, active ? React119.createElement("svg", {
    "aria-hidden": true,
    className: styles.svg,
    xmlns: "http://www.w3.org/2000/svg",
    ref: svgRef,
    style: {
      width: `${svgWidth}px`,
      height: `${svgHeight}px`,
      transform: `translate(${leftOffset}px, ${topOffset}px)`
    }
  }, React119.createElement("g", {
    className: mergeClasses(styles.triangle, debug && styles.triangleDebug),
    clipPath: `url(#${clipPathId})`,
    onMouseEnter,
    onMouseMove,
    onMouseLeave
  }, React119.createElement("path", {
    d: pointsToSvgPath(triangleA)
  }), React119.createElement("path", {
    d: pointsToSvgPath(triangleB)
  }), React119.createElement("path", {
    d: pointsToSvgPath(triangleC)
  }), React119.createElement("path", {
    d: pointsToSvgPath(triangleD)
  })), React119.createElement("clipPath", {
    id: clipPathId
  }, React119.createElement("path", {
    d: clipPath
  })), debug && React119.createElement("path", {
    className: styles.rectDebug,
    d: clipPath
  })) : null);
});

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/useSafeZoneArea.js
var MOUSE_MOVE_TARGET_POLLING_TIMEOUT = 2e3;
function useSafeZoneArea({ debug = false, disabled = false, onSafeZoneEnter, onSafeZoneMove, onSafeZoneLeave, onSafeZoneTimeout, timeout: timeout2 = 1500 } = {}) {
  const [stateStore] = React120.useState(createSafeZoneAreaStateStore);
  const safeZoneAreaRef = React120.useRef(null);
  const containerRef = React120.useRef(null);
  const targetRef = React120.useRef(null);
  const [setSafeZoneCloseTimeout, clearSafeZoneCloseTimeout] = useTimeout();
  const [requestUpdateFrame, clearUpdateFrame] = useAnimationFrame();
  const mouseCoordinatesRef = React120.useRef({
    x: 0,
    y: 0
  });
  const containerListenerRef = React120.useMemo(() => {
    if (disabled) {
      return () => {
      };
    }
    let containerEl = null;
    function onContainerMouseEnter() {
      clearSafeZoneCloseTimeout();
      stateStore.toggleActive(false);
    }
    return (el) => {
      if (el === null) {
        containerEl === null || containerEl === void 0 ? void 0 : containerEl.removeEventListener("mouseenter", onContainerMouseEnter);
      }
      containerEl = el;
      el === null || el === void 0 ? void 0 : el.addEventListener("mouseenter", onContainerMouseEnter);
    };
  }, [
    clearSafeZoneCloseTimeout,
    disabled,
    stateStore
  ]);
  const targetListenerRef = React120.useMemo(() => {
    if (disabled) {
      return () => {
      };
    }
    let targetEl = null;
    function onTargetMouseMove(e) {
      mouseCoordinatesRef.current = {
        x: e.clientX,
        y: e.clientY
      };
      if (!stateStore.isActive()) {
        stateStore.toggleActive(true);
      }
      setSafeZoneCloseTimeout(() => {
        stateStore.toggleActive(false);
      }, MOUSE_MOVE_TARGET_POLLING_TIMEOUT);
    }
    return (el) => {
      if (el === null) {
        clearUpdateFrame();
        clearSafeZoneCloseTimeout();
        targetEl === null || targetEl === void 0 ? void 0 : targetEl.removeEventListener("mousemove", onTargetMouseMove);
      }
      targetEl = el;
      el === null || el === void 0 ? void 0 : el.addEventListener("mousemove", onTargetMouseMove);
    };
  }, [
    clearUpdateFrame,
    clearSafeZoneCloseTimeout,
    disabled,
    stateStore,
    setSafeZoneCloseTimeout
  ]);
  const onSvgMouseEnter = useEventCallback((e) => {
    onSafeZoneEnter === null || onSafeZoneEnter === void 0 ? void 0 : onSafeZoneEnter(e);
    setSafeZoneCloseTimeout(() => {
      stateStore.toggleActive(false);
      onSafeZoneTimeout === null || onSafeZoneTimeout === void 0 ? void 0 : onSafeZoneTimeout();
    }, timeout2);
  });
  const onSvgMouseMove = useEventCallback((e) => {
    setSafeZoneCloseTimeout(() => {
      stateStore.toggleActive(false);
      onSafeZoneTimeout === null || onSafeZoneTimeout === void 0 ? void 0 : onSafeZoneTimeout();
    }, timeout2);
    onSafeZoneMove === null || onSafeZoneMove === void 0 ? void 0 : onSafeZoneMove(e);
  });
  const onSvgMouseLeave = useEventCallback((e) => {
    onSafeZoneLeave === null || onSafeZoneLeave === void 0 ? void 0 : onSafeZoneLeave(e);
  });
  React120.useEffect(() => {
    return stateStore.subscribe((isActive) => {
      if (isActive) {
        let updateSVGs = function() {
          const containerEl = containerRef.current;
          const targetEl = targetRef.current;
          if (containerEl && targetEl) {
            var _safeZoneAreaRef_current;
            (_safeZoneAreaRef_current = safeZoneAreaRef.current) === null || _safeZoneAreaRef_current === void 0 ? void 0 : _safeZoneAreaRef_current.updateSVG({
              containerRect: containerEl.getBoundingClientRect(),
              mouseCoordinates: [
                mouseCoordinatesRef.current.x,
                mouseCoordinatesRef.current.y
              ],
              targetRect: targetEl.getBoundingClientRect()
            });
          }
          requestUpdateFrame(updateSVGs);
        };
        updateSVGs();
        return;
      }
      clearUpdateFrame();
    });
  }, [
    clearUpdateFrame,
    requestUpdateFrame,
    stateStore
  ]);
  return {
    containerRef: useMergedRefs(containerRef, containerListenerRef),
    targetRef: useMergedRefs(targetRef, targetListenerRef),
    elementToRender: React120.useMemo(() => disabled ? null : React120.createElement(SafeZoneArea, {
      debug,
      onMouseEnter: onSvgMouseEnter,
      onMouseMove: onSvgMouseMove,
      onMouseLeave: onSvgMouseLeave,
      imperativeRef: safeZoneAreaRef,
      stateStore
    }), [
      disabled,
      debug,
      onSvgMouseEnter,
      onSvgMouseMove,
      onSvgMouseLeave,
      stateStore
    ])
  };
}

// node_modules/@fluentui/react-popover/lib/components/PopoverSurface/PopoverSurface.js
var React126 = __toESM(require_react());

// node_modules/@fluentui/react-popover/lib/components/PopoverSurface/usePopoverSurface.js
var React121 = __toESM(require_react());

// node_modules/@fluentui/react-popover/lib/popoverContext.js
var PopoverContext = createContext13(void 0);
var popoverContextDefaultValue = {
  open: false,
  setOpen: () => null,
  toggleOpen: () => null,
  triggerRef: {
    current: null
  },
  contentRef: {
    current: null
  },
  arrowRef: {
    current: null
  },
  openOnContext: false,
  openOnHover: false,
  size: "medium",
  trapFocus: false,
  inline: false
};
var PopoverProvider = PopoverContext.Provider;
var usePopoverContext_unstable = (selector) => useContextSelector(PopoverContext, (ctx = popoverContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-popover/lib/components/PopoverSurface/usePopoverSurface.js
var usePopoverSurface_unstable = (props, ref) => {
  const contentRef = usePopoverContext_unstable((context) => context.contentRef);
  const openOnHover = usePopoverContext_unstable((context) => context.openOnHover);
  const setOpen = usePopoverContext_unstable((context) => context.setOpen);
  const mountNode = usePopoverContext_unstable((context) => context.mountNode);
  const arrowRef = usePopoverContext_unstable((context) => context.arrowRef);
  const size3 = usePopoverContext_unstable((context) => context.size);
  const withArrow = usePopoverContext_unstable((context) => context.withArrow);
  const appearance = usePopoverContext_unstable((context) => context.appearance);
  const trapFocus = usePopoverContext_unstable((context) => context.trapFocus);
  const inertTrapFocus = usePopoverContext_unstable((context) => context.inertTrapFocus);
  const inline2 = usePopoverContext_unstable((context) => context.inline);
  const { modalAttributes } = useModalAttributes({
    trapFocus,
    legacyTrapFocus: !inertTrapFocus,
    alwaysFocusable: !trapFocus
  });
  const state = {
    inline: inline2,
    appearance,
    withArrow,
    size: size3,
    arrowRef,
    mountNode,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `contentRef` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, contentRef),
      role: trapFocus ? "dialog" : "group",
      "aria-modal": trapFocus ? true : void 0,
      ...modalAttributes,
      ...props
    }), {
      elementType: "div"
    })
  };
  const { onMouseEnter: onMouseEnterOriginal, onMouseLeave: onMouseLeaveOriginal, onKeyDown: onKeyDownOriginal } = state.root;
  state.root.onMouseEnter = (e) => {
    if (openOnHover) {
      setOpen(e, true);
    }
    onMouseEnterOriginal === null || onMouseEnterOriginal === void 0 ? void 0 : onMouseEnterOriginal(e);
  };
  state.root.onMouseLeave = (e) => {
    if (openOnHover) {
      setOpen(e, false);
    }
    onMouseLeaveOriginal === null || onMouseLeaveOriginal === void 0 ? void 0 : onMouseLeaveOriginal(e);
  };
  state.root.onKeyDown = (e) => {
    var _contentRef_current;
    if (e.key === "Escape" && ((_contentRef_current = contentRef.current) === null || _contentRef_current === void 0 ? void 0 : _contentRef_current.contains(e.target))) {
      e.preventDefault();
      setOpen(e, false);
    }
    onKeyDownOriginal === null || onKeyDownOriginal === void 0 ? void 0 : onKeyDownOriginal(e);
  };
  return state;
};

// node_modules/@fluentui/react-portal/lib/components/Portal/Portal.js
var React125 = __toESM(require_react());

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortal.js
var React123 = __toESM(require_react());

// node_modules/@fluentui/react-portal/lib/utils/toMountNodeProps.js
function toMountNodeProps(mountNode) {
  if (isHTMLElement(mountNode)) {
    return {
      element: mountNode
    };
  }
  if (typeof mountNode === "object") {
    if (mountNode === null) {
      return {
        element: null
      };
    }
    return mountNode;
  }
  return {};
}

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNode.js
var React122 = __toESM(require_react());

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNodeStyles.styles.js
var usePortalMountNodeStylesStyles = __styles2({
  root: {
    qhf8xq: "f1euv43f",
    Bhzewxz: "f15twtuk",
    oyh7mz: ["f1vgc2s3", "f1e31b4d"],
    j35jbq: ["f1e31b4d", "f1vgc2s3"],
    Bj3rh1h: "f494woh"
  }
}, {
  d: [".f1euv43f{position:absolute;}", ".f15twtuk{top:0;}", ".f1vgc2s3{left:0;}", ".f1e31b4d{right:0;}", ".f494woh{z-index:1000000;}"]
});

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNode.js
var useInsertionEffect4 = React122["useInsertionEffect"];
var useLegacyElementFactory = (options) => {
  "use no memo";
  const { className, dir, focusVisibleRef, targetNode } = options;
  const targetElement = React122.useMemo(() => {
    if (targetNode === void 0 || options.disabled) {
      return null;
    }
    const element = targetNode.ownerDocument.createElement("div");
    targetNode.appendChild(element);
    return element;
  }, [
    targetNode,
    options.disabled
  ]);
  React122.useMemo(() => {
    if (!targetElement) {
      return;
    }
    targetElement.className = className;
    targetElement.setAttribute("dir", dir);
    targetElement.setAttribute("data-portal-node", "true");
    focusVisibleRef.current = targetElement;
  }, [
    className,
    dir,
    targetElement,
    focusVisibleRef
  ]);
  React122.useEffect(() => {
    return () => {
      targetElement === null || targetElement === void 0 ? void 0 : targetElement.remove();
    };
  }, [
    targetElement
  ]);
  return targetElement;
};
var initializeElementFactory = () => {
  let currentElement = void 0;
  function get(targetRoot, forceCreation) {
    if (currentElement) {
      return currentElement;
    }
    if (forceCreation) {
      currentElement = targetRoot.ownerDocument.createElement("div");
      targetRoot.appendChild(currentElement);
    }
    return currentElement;
  }
  function dispose() {
    if (currentElement) {
      currentElement.remove();
      currentElement = void 0;
    }
  }
  return {
    get,
    dispose
  };
};
var useModernElementFactory = (options) => {
  "use no memo";
  const { className, dir, focusVisibleRef, targetNode } = options;
  const [elementFactory] = React122.useState(initializeElementFactory);
  const elementProxy = React122.useMemo(() => {
    if (targetNode === void 0 || options.disabled) {
      return null;
    }
    return new Proxy({}, {
      get(_, property) {
        if (property === "nodeType") {
          return Node.ELEMENT_NODE;
        }
        if (property === "remove") {
          const targetElement2 = elementFactory.get(targetNode, false);
          if (targetElement2) {
            const portalHasNoChildren = targetElement2.childNodes.length === 0;
            if (portalHasNoChildren) {
              elementFactory.dispose();
            }
          }
          return () => {
          };
        }
        const targetElement = elementFactory.get(targetNode, true);
        const targetProperty = targetElement ? targetElement[property] : void 0;
        if (typeof targetProperty === "function") {
          return targetProperty.bind(targetElement);
        }
        return targetProperty;
      },
      set(_, property, value) {
        const ignoredProperty = property === "_virtual" || property === "focusVisible";
        const targetElement = ignoredProperty ? elementFactory.get(targetNode, false) : elementFactory.get(targetNode, true);
        if (ignoredProperty && !targetElement) {
          return true;
        }
        if (targetElement) {
          Object.assign(targetElement, {
            [property]: value
          });
          return true;
        }
        return false;
      }
    });
  }, [
    elementFactory,
    targetNode,
    options.disabled
  ]);
  useInsertionEffect4(() => {
    if (!elementProxy) {
      return;
    }
    const classesToApply = className.split(" ").filter(Boolean);
    elementProxy.classList.add(...classesToApply);
    elementProxy.setAttribute("dir", dir);
    elementProxy.setAttribute("data-portal-node", "true");
    focusVisibleRef.current = elementProxy;
    return () => {
      elementProxy.classList.remove(...classesToApply);
      elementProxy.removeAttribute("dir");
    };
  }, [
    className,
    dir,
    elementProxy,
    focusVisibleRef
  ]);
  React122.useEffect(() => {
    return () => {
      elementProxy === null || elementProxy === void 0 ? void 0 : elementProxy.remove();
    };
  }, [
    elementProxy
  ]);
  return elementProxy;
};
var useElementFactory = useInsertionEffect4 ? useModernElementFactory : useLegacyElementFactory;
var usePortalMountNode2 = (options) => {
  "use no memo";
  const { targetDocument, dir } = useFluent();
  const mountNode = usePortalMountNode();
  const focusVisibleRef = useFocusVisible();
  const classes = usePortalMountNodeStylesStyles();
  const themeClassName = useThemeClassName();
  const factoryOptions = {
    dir,
    disabled: options.disabled,
    focusVisibleRef,
    className: mergeClasses(themeClassName, classes.root, options.className),
    targetNode: mountNode !== null && mountNode !== void 0 ? mountNode : targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body
  };
  return useElementFactory(factoryOptions);
};

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortal.js
var usePortal_unstable = (props) => {
  const { element, className } = toMountNodeProps(props.mountNode);
  const virtualParentRootRef = React123.useRef(null);
  const fallbackElement = usePortalMountNode2({
    disabled: !!element,
    className
  });
  const mountNode = element !== null && element !== void 0 ? element : fallbackElement;
  const state = {
    children: props.children,
    mountNode,
    virtualParentRootRef
  };
  React123.useEffect(() => {
    if (!mountNode) {
      return;
    }
    const virtualParent = virtualParentRootRef.current;
    const isVirtualParentInsideChild = mountNode.contains(virtualParent);
    if (virtualParent && !isVirtualParentInsideChild) {
      setVirtualParent(mountNode, virtualParent);
      return () => {
        setVirtualParent(mountNode, void 0);
      };
    }
  }, [
    virtualParentRootRef,
    mountNode
  ]);
  return state;
};

// node_modules/@fluentui/react-portal/lib/components/Portal/renderPortal.js
var ReactDOM = __toESM(require_react_dom());
var React124 = __toESM(require_react());
var renderPortal_unstable = (state) => {
  return React124.createElement("span", {
    hidden: true,
    ref: state.virtualParentRootRef
  }, state.mountNode && ReactDOM.createPortal(React124.createElement(React124.Fragment, null, state.children, React124.createElement("span", {
    hidden: true
  })), state.mountNode));
};

// node_modules/@fluentui/react-portal/lib/components/Portal/Portal.js
var Portal = (props) => {
  const state = usePortal_unstable(props);
  return renderPortal_unstable(state);
};
Portal.displayName = "Portal";

// node_modules/@fluentui/react-popover/lib/components/PopoverSurface/renderPopoverSurface.js
var renderPopoverSurface_unstable = (state) => {
  assertSlots(state);
  const surface = jsxs(state.root, {
    children: [
      state.withArrow && jsx("div", {
        ref: state.arrowRef,
        className: state.arrowClassName
      }),
      state.root.children
    ]
  });
  if (state.inline) {
    return surface;
  }
  return jsx(Portal, {
    mountNode: state.mountNode,
    children: surface
  });
};

// node_modules/@fluentui/react-popover/lib/components/PopoverSurface/usePopoverSurfaceStyles.styles.js
var popoverSurfaceClassNames = {
  root: "fui-PopoverSurface"
};
var arrowHeights = {
  small: 6,
  medium: 8,
  large: 8
};
var useStyles9 = __styles2({
  root: {
    sj55zd: "f19n0e5",
    De3pzq: "fxugw4r",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f9ggezi",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    B93otf3: "f18k4bn6",
    vin17d: "fo1kyvf",
    Ezkn3b: "fetxo7e",
    nyiy2g: "f8x1vz1",
    swvrvq: "f8g0anz",
    Bkovbt3: "fezwn9i",
    hgjdhn: "fz5efge",
    fsy9dk: "f1ydixl4",
    B3ogreh: "f8dgqj5",
    jv49x5: "fnyfnr8",
    Bk7o48c: "fgw77r4",
    Bv12yb3: "f1noc5he",
    z0t1cu: "fi19xcv",
    Bks05zx: "f1mxk9aa",
    Bvtglag: "ffzg62k",
    Bhu2qc9: "fymb6k8"
  },
  inline: {
    Bj3rh1h: "f19g0ac"
  },
  inverted: {
    De3pzq: "fg3r6xk",
    sj55zd: "fonrgv7"
  },
  brand: {
    De3pzq: "ffp7eso",
    sj55zd: "f1phragk"
  },
  smallPadding: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1sy4kr4"
  },
  mediumPadding: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f4zyqsv"
  },
  largePadding: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fop8ug2"
  },
  smallArrow: {
    rhnwrx: "f1s3jn22",
    Bdy53xb: "fv40uqz"
  },
  mediumLargeArrow: {
    rhnwrx: "f1f72gjr",
    Bdy53xb: "f69yoe5"
  },
  arrow: {
    B7ck84d: "f1ewtqcl",
    qhf8xq: "f1euv43f",
    Bj3rh1h: "f1bsuimh",
    De3pzq: "f1u2r49w",
    B2eet1l: "fqhgnl",
    Beyfa6y: "f17bz04i",
    Bz10aip: "f36o3x3",
    Bqenvij: "fzofk8q",
    a9b677: "f1wbx1ie",
    Ftih45: "f1wl9k8s",
    Br0sdwz: "f1aocrix",
    cmx5o7: "f1ljr5q2",
    susq4k: 0,
    Biibvgv: 0,
    Bicfajf: 0,
    qehafq: 0,
    Brs5u8j: "f155f1qt",
    Ccq8qp: "f9mhzq7",
    Baz25je: "fr6rhvx",
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f1kc0wz4",
    r59vdv: "fgq90dz",
    Bkw5xw4: "fq0y47f",
    hl6cv3: "f1pwrbz6",
    aea9ga: "f1hxxcvm",
    yayu3t: "fw8rgyo",
    Bhsv975: "f1wnzycx",
    rhl9o9: "f1730wal",
    B7gxrvb: "f1fy4ixr",
    B6q6orb: "fobkauc",
    B0lu1f8: "f16bqv1l"
  }
}, {
  d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f9ggezi{border:1px solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f18k4bn6{animation-composition:accumulate;}", ".fo1kyvf{animation-duration:var(--durationSlower);}", ".fetxo7e{animation-timing-function:var(--curveDecelerateMid);}", ".f8x1vz1{--fui-positioning-slide-distance-x:0px;}", ".f8g0anz{--fui-positioning-slide-distance-y:10px;}", ".fezwn9i[data-popper-placement^=right]{--fui-positioning-slide-distance-x:-10px;}", ".fz5efge[data-popper-placement^=right]{--fui-positioning-slide-distance-y:0px;}", ".f1ydixl4[data-popper-placement^=bottom]{--fui-positioning-slide-distance-x:0px;}", ".f8dgqj5[data-popper-placement^=bottom]{--fui-positioning-slide-distance-y:-10px;}", ".fnyfnr8[data-popper-placement^=left]{--fui-positioning-slide-distance-x:10px;}", ".fgw77r4[data-popper-placement^=left]{--fui-positioning-slide-distance-y:0px;}", ".f1noc5he{animation-name:f1m0q9mo,f79suad;}", ".fymb6k8{filter:drop-shadow(0 0 2px var(--colorNeutralShadowAmbient)) drop-shadow(0 8px 16px var(--colorNeutralShadowKey));}", ".f19g0ac{z-index:1;}", ".fg3r6xk{background-color:var(--colorNeutralBackgroundStatic);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", [".f1sy4kr4{padding:12px;}", {
    p: -1
  }], [".f4zyqsv{padding:16px;}", {
    p: -1
  }], [".fop8ug2{padding:20px;}", {
    p: -1
  }], ".f1s3jn22{--fui-positioning-arrow-height:8.484px;}", ".fv40uqz{--fui-positioning-arrow-offset:-4.242px;}", ".f1f72gjr{--fui-positioning-arrow-height:11.312px;}", ".f69yoe5{--fui-positioning-arrow-offset:-5.656px;}", ".f1ewtqcl{box-sizing:border-box;}", ".f1euv43f{position:absolute;}", ".f1bsuimh{z-index:-1;}", ".f1u2r49w{background-color:inherit;}", ".fqhgnl{background-clip:content-box;}", ".f17bz04i{border-bottom-left-radius:var(--borderRadiusSmall);}", ".f36o3x3{transform:rotate(var(--fui-positioning-arrow-angle));}", ".fzofk8q{height:var(--fui-positioning-arrow-height);}", ".f1wbx1ie{width:var(--fui-positioning-arrow-height);}", '.f1wl9k8s::before{content:"";}', ".f1aocrix::before{display:block;}", ".f1ljr5q2::before{background-color:inherit;}", [".f155f1qt::before{margin:-1px;}", {
    p: -1
  }], ".f9mhzq7::before{width:100%;}", ".fr6rhvx::before{height:100%;}", [".f1kc0wz4::before{border:1px solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".fgq90dz::before{border-bottom-left-radius:var(--borderRadiusSmall);}", ".fq0y47f::before{clip-path:polygon(0% 0%, 100% 100%, 0% 100%);}", '[data-popper-placement^="top"] .f1pwrbz6{bottom:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="top"] .f1hxxcvm{--fui-positioning-arrow-angle:-45deg;}', '[data-popper-placement^="right"] .fw8rgyo{left:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="right"] .f1wnzycx{--fui-positioning-arrow-angle:45deg;}', '[data-popper-placement^="bottom"] .f1730wal{top:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="bottom"] .f1fy4ixr{--fui-positioning-arrow-angle:135deg;}', '[data-popper-placement^="left"] .fobkauc{right:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="left"] .f16bqv1l{--fui-positioning-arrow-angle:225deg;}'],
  k: ["@keyframes f1m0q9mo{from{opacity:-1;}to{opacity:0;}}", "@keyframes f79suad{from{transform:translate(var(--fui-positioning-slide-distance-x), var(--fui-positioning-slide-distance-y));}}"],
  m: [["@media (prefers-reduced-motion){.fi19xcv[data-popper-placement]{animation-duration:1ms;}}", {
    m: "(prefers-reduced-motion)"
  }], ["@media (prefers-reduced-motion){.f1mxk9aa[data-popper-placement]{animation-name:f1m0q9mo;}}", {
    m: "(prefers-reduced-motion)"
  }]],
  t: ["@supports not (animation-composition: accumulate){.ffzg62k[data-popper-placement]{animation-name:f1m0q9mo;}}"]
});
var usePopoverSurfaceStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles9();
  state.root.className = mergeClasses(popoverSurfaceClassNames.root, styles.root, state.inline && styles.inline, state.size === "small" && styles.smallPadding, state.size === "medium" && styles.mediumPadding, state.size === "large" && styles.largePadding, state.appearance === "inverted" && styles.inverted, state.appearance === "brand" && styles.brand, state.root.className);
  state.arrowClassName = mergeClasses(styles.arrow, state.size === "small" ? styles.smallArrow : styles.mediumLargeArrow);
  return state;
};

// node_modules/@fluentui/react-popover/lib/components/PopoverSurface/PopoverSurface.js
var PopoverSurface = React126.forwardRef((props, ref) => {
  const state = usePopoverSurface_unstable(props, ref);
  usePopoverSurfaceStyles_unstable(state);
  useCustomStyleHook("usePopoverSurfaceStyles_unstable")(state);
  return renderPopoverSurface_unstable(state);
});
PopoverSurface.displayName = "PopoverSurface";

// node_modules/@fluentui/react-popover/lib/components/Popover/constants.js
var popoverSurfaceBorderRadius = 4;

// node_modules/@fluentui/react-popover/lib/components/Popover/usePopover.js
var usePopover_unstable = (props) => {
  const [contextTarget, setContextTarget] = usePositioningMouseTarget();
  const initialState = {
    size: "medium",
    contextTarget,
    setContextTarget,
    ...props
  };
  const children2 = React127.Children.toArray(props.children);
  if (true) {
    if (children2.length === 0) {
      console.warn("Popover must contain at least one child");
    }
    if (children2.length > 2) {
      console.warn("Popover must contain at most two children");
    }
  }
  let popoverTrigger = void 0;
  let popoverSurface = void 0;
  if (children2.length === 2) {
    popoverTrigger = children2[0];
    popoverSurface = children2[1];
  } else if (children2.length === 1) {
    popoverSurface = children2[0];
  }
  const [open, setOpenState] = useOpenState(initialState);
  const [setOpenTimeout, clearOpenTimeout] = useTimeout();
  const setOpen = useEventCallback((e, shouldOpen) => {
    clearOpenTimeout();
    if (!(e instanceof Event) && e.persist) {
      e.persist();
    }
    if (e.type === "mouseleave") {
      var _props_mouseLeaveDelay;
      setOpenTimeout(() => {
        setOpenState(e, shouldOpen);
      }, (_props_mouseLeaveDelay = props.mouseLeaveDelay) !== null && _props_mouseLeaveDelay !== void 0 ? _props_mouseLeaveDelay : 500);
    } else {
      setOpenState(e, shouldOpen);
    }
  });
  const toggleOpen = React127.useCallback((e) => {
    setOpen(e, !open);
  }, [
    setOpen,
    open
  ]);
  const positioningRefs = usePopoverRefs(initialState);
  const { targetDocument } = useFluent();
  var _props_closeOnIframeFocus;
  useOnClickOutside({
    contains: elementContains,
    element: targetDocument,
    callback: (ev) => setOpen(ev, false),
    refs: [
      positioningRefs.triggerRef,
      positioningRefs.contentRef
    ],
    disabled: !open,
    disabledFocusOnIframe: !((_props_closeOnIframeFocus = props.closeOnIframeFocus) !== null && _props_closeOnIframeFocus !== void 0 ? _props_closeOnIframeFocus : true)
  });
  const closeOnScroll = initialState.openOnContext || initialState.closeOnScroll;
  useOnScrollOutside({
    contains: elementContains,
    element: targetDocument,
    callback: (ev) => setOpen(ev, false),
    refs: [
      positioningRefs.triggerRef,
      positioningRefs.contentRef
    ],
    disabled: !open || !closeOnScroll
  });
  const { findFirstFocusable } = useFocusFinders();
  const activateModal = useActivateModal();
  React127.useEffect(() => {
    if (props.unstable_disableAutoFocus) {
      return;
    }
    const contentElement = positioningRefs.contentRef.current;
    if (open && contentElement) {
      var _contentElement_getAttribute;
      const shouldFocusContainer = !isNaN((_contentElement_getAttribute = contentElement.getAttribute("tabIndex")) !== null && _contentElement_getAttribute !== void 0 ? _contentElement_getAttribute : void 0);
      const firstFocusable = shouldFocusContainer ? contentElement : findFirstFocusable(contentElement);
      firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
      if (shouldFocusContainer) {
        activateModal(contentElement);
      }
    }
  }, [
    findFirstFocusable,
    activateModal,
    open,
    positioningRefs.contentRef,
    props.unstable_disableAutoFocus
  ]);
  var _props_inertTrapFocus, _props_inline;
  return {
    ...initialState,
    ...positioningRefs,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    inertTrapFocus: (_props_inertTrapFocus = props.inertTrapFocus) !== null && _props_inertTrapFocus !== void 0 ? _props_inertTrapFocus : props.legacyTrapFocus === void 0 ? false : !props.legacyTrapFocus,
    popoverTrigger,
    popoverSurface,
    open,
    setOpen,
    toggleOpen,
    setContextTarget,
    contextTarget,
    inline: (_props_inline = props.inline) !== null && _props_inline !== void 0 ? _props_inline : false
  };
};
function useOpenState(state) {
  "use no memo";
  const onOpenChange = useEventCallback((e, data) => {
    var _state_onOpenChange;
    return (_state_onOpenChange = state.onOpenChange) === null || _state_onOpenChange === void 0 ? void 0 : _state_onOpenChange.call(state, e, data);
  });
  const [open, setOpenState] = useControllableState({
    state: state.open,
    defaultState: state.defaultOpen,
    initialState: false
  });
  state.open = open !== void 0 ? open : state.open;
  const setContextTarget = state.setContextTarget;
  const setOpen = React127.useCallback((e, shouldOpen) => {
    if (shouldOpen && e.type === "contextmenu") {
      setContextTarget(e);
    }
    if (!shouldOpen) {
      setContextTarget(void 0);
    }
    setOpenState(shouldOpen);
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(e, {
      open: shouldOpen
    });
  }, [
    setOpenState,
    onOpenChange,
    setContextTarget
  ]);
  return [
    open,
    setOpen
  ];
}
function usePopoverRefs(state) {
  "use no memo";
  const positioningOptions = {
    position: "above",
    align: "center",
    arrowPadding: 2 * popoverSurfaceBorderRadius,
    target: state.openOnContext ? state.contextTarget : void 0,
    ...resolvePositioningShorthand(state.positioning)
  };
  if (positioningOptions.coverTarget) {
    state.withArrow = false;
  }
  if (state.withArrow) {
    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeights[state.size]);
  }
  const { targetRef: triggerRef, containerRef: contentRef, arrowRef } = usePositioning(positioningOptions);
  return {
    triggerRef,
    contentRef,
    arrowRef
  };
}

// node_modules/@fluentui/react-popover/lib/components/Popover/renderPopover.js
var React128 = __toESM(require_react());
var renderPopover_unstable = (state) => {
  const { appearance, arrowRef, contentRef, inline: inline2, mountNode, open, openOnContext, openOnHover, setOpen, size: size3, toggleOpen, trapFocus, triggerRef, withArrow, inertTrapFocus } = state;
  return React128.createElement(PopoverContext.Provider, {
    value: {
      appearance,
      arrowRef,
      contentRef,
      inline: inline2,
      mountNode,
      open,
      openOnContext,
      openOnHover,
      setOpen,
      toggleOpen,
      triggerRef,
      size: size3,
      trapFocus,
      inertTrapFocus,
      withArrow
    }
  }, state.popoverTrigger, state.open && state.popoverSurface);
};

// node_modules/@fluentui/react-popover/lib/components/Popover/Popover.js
var Popover = (props) => {
  const state = usePopover_unstable(props);
  return renderPopover_unstable(state);
};
Popover.displayName = "Popover";

// node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/PopoverTrigger.js
var React131 = __toESM(require_react());

// node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/usePopoverTrigger.js
var React130 = __toESM(require_react());
var usePopoverTrigger_unstable = (props) => {
  const { children: children2, disableButtonEnhancement = false } = props;
  const child = getTriggerChild(children2);
  const open = usePopoverContext_unstable((context) => context.open);
  const setOpen = usePopoverContext_unstable((context) => context.setOpen);
  const toggleOpen = usePopoverContext_unstable((context) => context.toggleOpen);
  const triggerRef = usePopoverContext_unstable((context) => context.triggerRef);
  const openOnHover = usePopoverContext_unstable((context) => context.openOnHover);
  const openOnContext = usePopoverContext_unstable((context) => context.openOnContext);
  const { triggerAttributes } = useModalAttributes();
  const onContextMenu = (e) => {
    if (openOnContext) {
      e.preventDefault();
      setOpen(e, true);
    }
  };
  const onClick = (e) => {
    if (!openOnContext) {
      toggleOpen(e);
    }
  };
  const onKeyDown = (e) => {
    if (e.key === Escape && open && !e.isDefaultPrevented()) {
      setOpen(e, false);
      e.preventDefault();
    }
  };
  const onMouseEnter = (e) => {
    if (openOnHover) {
      setOpen(e, true);
    }
  };
  const onMouseLeave = (e) => {
    if (openOnHover) {
      setOpen(e, false);
    }
  };
  const contextMenuProps = {
    ...triggerAttributes,
    "aria-expanded": `${open}`,
    ...child === null || child === void 0 ? void 0 : child.props,
    onMouseEnter: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseEnter, onMouseEnter)),
    onMouseLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseLeave, onMouseLeave)),
    onContextMenu: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onContextMenu, onContextMenu)),
    ref: useMergedRefs(triggerRef, getReactElementRef(child))
  };
  const triggerChildProps = {
    ...contextMenuProps,
    onClick: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onClick, onClick)),
    onKeyDown: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onKeyDown, onKeyDown))
  };
  const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", triggerChildProps);
  return {
    children: applyTriggerPropsToChildren(props.children, useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", openOnContext ? contextMenuProps : disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps))
  };
};

// node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/renderPopoverTrigger.js
var renderPopoverTrigger_unstable = (state) => {
  return state.children;
};

// node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/PopoverTrigger.js
var PopoverTrigger = (props) => {
  const state = usePopoverTrigger_unstable(props);
  return renderPopoverTrigger_unstable(state);
};
PopoverTrigger.displayName = "PopoverTrigger";
PopoverTrigger.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/renderAvatarGroupPopover.js
var renderAvatarGroupPopover_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(PopoverTrigger, {
        disableButtonEnhancement: true,
        children: jsx(state.tooltip, {
          children: jsx(state.triggerButton, {})
        })
      }),
      jsx(state.popoverSurface, {
        children: jsx(AvatarGroupProvider, {
          value: contextValues.avatarGroup,
          children: jsx(state.content, {})
        })
      })
    ]
  });
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopoverContextValues.js
var useAvatarGroupPopoverContextValues_unstable = (state) => {
  const avatarGroup = {
    isOverflow: true,
    size: 24
  };
  return {
    avatarGroup
  };
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopover.js
var React134 = __toESM(require_react());

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/Tooltip.js
var React133 = __toESM(require_react());

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/useTooltip.js
var React132 = __toESM(require_react());

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/private/constants.js
var arrowHeight = 6;
var tooltipBorderRadius = 4;

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/useTooltip.js
var useTooltip_unstable = (props) => {
  "use no memo";
  var _child_props, _child_props1, _child_props2, _child_props3, _child_props4, _child_props5;
  const context = useTooltipVisibility();
  const isServerSideRender = useIsSSR();
  const { targetDocument } = useFluent();
  const [setDelayTimeout, clearDelayTimeout] = useTimeout();
  const { appearance = "normal", children: children2, content, withArrow = false, positioning = "above", onVisibleChange, relationship, showDelay = 250, hideDelay = 250, mountNode } = props;
  const [visible, setVisibleInternal] = useControllableState({
    state: props.visible,
    initialState: false
  });
  const setVisible = React132.useCallback((ev, data) => {
    clearDelayTimeout();
    setVisibleInternal((oldVisible) => {
      if (data.visible !== oldVisible) {
        onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(ev, data);
      }
      return data.visible;
    });
  }, [
    clearDelayTimeout,
    setVisibleInternal,
    onVisibleChange
  ]);
  const state = {
    withArrow,
    positioning,
    showDelay,
    hideDelay,
    relationship,
    visible,
    shouldRenderTooltip: visible,
    appearance,
    mountNode,
    // Slots
    components: {
      content: "div"
    },
    content: slot_exports.always(content, {
      defaultProps: {
        role: "tooltip"
      },
      elementType: "div"
    })
  };
  state.content.id = useId2("tooltip-", state.content.id);
  const positioningOptions = {
    enabled: state.visible,
    arrowPadding: 2 * tooltipBorderRadius,
    position: "above",
    align: "center",
    offset: 4,
    ...resolvePositioningShorthand(state.positioning)
  };
  if (state.withArrow) {
    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeight);
  }
  const { targetRef, containerRef, arrowRef } = usePositioning(positioningOptions);
  state.content.ref = useMergedRefs(state.content.ref, containerRef);
  state.arrowRef = arrowRef;
  useIsomorphicLayoutEffect(() => {
    if (visible) {
      var _context_visibleTooltip;
      const thisTooltip = {
        hide: (ev) => setVisible(void 0, {
          visible: false,
          documentKeyboardEvent: ev
        })
      };
      (_context_visibleTooltip = context.visibleTooltip) === null || _context_visibleTooltip === void 0 ? void 0 : _context_visibleTooltip.hide();
      context.visibleTooltip = thisTooltip;
      const onDocumentKeyDown = (ev) => {
        if (ev.key === Escape && !ev.defaultPrevented) {
          thisTooltip.hide(ev);
          ev.preventDefault();
        }
      };
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("keydown", onDocumentKeyDown, {
        // As this event is added at targeted document,
        // we need to capture the event to be sure keydown handling from tooltip happens first
        capture: true
      });
      return () => {
        if (context.visibleTooltip === thisTooltip) {
          context.visibleTooltip = void 0;
        }
        targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("keydown", onDocumentKeyDown, {
          capture: true
        });
      };
    }
  }, [
    context,
    targetDocument,
    visible,
    setVisible
  ]);
  const ignoreNextFocusEventRef = React132.useRef(false);
  const onEnterTrigger = React132.useCallback((ev) => {
    if (ev.type === "focus" && ignoreNextFocusEventRef.current) {
      ignoreNextFocusEventRef.current = false;
      return;
    }
    const delay = context.visibleTooltip ? 0 : state.showDelay;
    setDelayTimeout(() => {
      setVisible(ev, {
        visible: true
      });
    }, delay);
    ev.persist();
  }, [
    setDelayTimeout,
    setVisible,
    state.showDelay,
    context
  ]);
  const isNavigatingWithKeyboard = useIsNavigatingWithKeyboard();
  const [keyborgListenerCallbackRef] = React132.useState(() => {
    const onKeyborgFocusIn = (ev) => {
      var _ev_detail;
      if (((_ev_detail = ev.detail) === null || _ev_detail === void 0 ? void 0 : _ev_detail.isFocusedProgrammatically) && !isNavigatingWithKeyboard()) {
        ignoreNextFocusEventRef.current = true;
      }
    };
    let current = null;
    return (element) => {
      current === null || current === void 0 ? void 0 : current.removeEventListener(KEYBORG_FOCUSIN, onKeyborgFocusIn);
      element === null || element === void 0 ? void 0 : element.addEventListener(KEYBORG_FOCUSIN, onKeyborgFocusIn);
      current = element;
    };
  });
  const onLeaveTrigger = React132.useCallback((ev) => {
    let delay = state.hideDelay;
    if (ev.type === "blur") {
      delay = 0;
      ignoreNextFocusEventRef.current = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === ev.target;
    }
    setDelayTimeout(() => {
      setVisible(ev, {
        visible: false
      });
    }, delay);
    ev.persist();
  }, [
    setDelayTimeout,
    setVisible,
    state.hideDelay,
    targetDocument
  ]);
  state.content.onPointerEnter = mergeCallbacks(state.content.onPointerEnter, clearDelayTimeout);
  state.content.onPointerLeave = mergeCallbacks(state.content.onPointerLeave, onLeaveTrigger);
  state.content.onFocus = mergeCallbacks(state.content.onFocus, clearDelayTimeout);
  state.content.onBlur = mergeCallbacks(state.content.onBlur, onLeaveTrigger);
  const child = getTriggerChild(children2);
  const triggerAriaProps = {};
  const isExpanded = (child === null || child === void 0 ? void 0 : (_child_props = child.props) === null || _child_props === void 0 ? void 0 : _child_props["aria-expanded"]) === true || (child === null || child === void 0 ? void 0 : (_child_props1 = child.props) === null || _child_props1 === void 0 ? void 0 : _child_props1["aria-expanded"]) === "true";
  if (relationship === "label") {
    if (typeof state.content.children === "string") {
      triggerAriaProps["aria-label"] = state.content.children;
    } else {
      triggerAriaProps["aria-labelledby"] = state.content.id;
      state.shouldRenderTooltip = true;
    }
  } else if (relationship === "description") {
    triggerAriaProps["aria-describedby"] = state.content.id;
    state.shouldRenderTooltip = true;
  }
  if (isServerSideRender || isExpanded) {
    state.shouldRenderTooltip = false;
  }
  state.children = applyTriggerPropsToChildren(children2, {
    ...triggerAriaProps,
    ...child === null || child === void 0 ? void 0 : child.props,
    ref: useMergedRefs(
      getReactElementRef(child),
      keyborgListenerCallbackRef,
      // If the target prop is not provided, attach targetRef to the trigger element's ref prop
      positioningOptions.target === void 0 ? targetRef : void 0
    ),
    onPointerEnter: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props2 = child.props) === null || _child_props2 === void 0 ? void 0 : _child_props2.onPointerEnter, onEnterTrigger)),
    onPointerLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props3 = child.props) === null || _child_props3 === void 0 ? void 0 : _child_props3.onPointerLeave, onLeaveTrigger)),
    onFocus: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props4 = child.props) === null || _child_props4 === void 0 ? void 0 : _child_props4.onFocus, onEnterTrigger)),
    onBlur: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props5 = child.props) === null || _child_props5 === void 0 ? void 0 : _child_props5.onBlur, onLeaveTrigger))
  });
  return state;
};

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/renderTooltip.js
var renderTooltip_unstable = (state) => {
  assertSlots(state);
  return jsxs(import_react.Fragment, {
    children: [
      state.children,
      state.shouldRenderTooltip && jsx(Portal, {
        mountNode: state.mountNode,
        children: jsxs(state.content, {
          children: [
            state.withArrow && jsx("div", {
              ref: state.arrowRef,
              className: state.arrowClassName
            }),
            state.content.children
          ]
        })
      })
    ]
  });
};

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/useTooltipStyles.styles.js
var tooltipClassNames = {
  content: "fui-Tooltip__content"
};
var useStyles10 = __styles2({
  root: {
    mc9l5x: "fjseox",
    B7ck84d: "f1ewtqcl",
    B2u0y6b: "f132xexn",
    Bceei9c: "f158kwzp",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bg96gwp: "fwrc4pm",
    Btd35i7: "fokg9q4",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f9ggezi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1bzqsji",
    De3pzq: "fxugw4r",
    sj55zd: "f19n0e5",
    Bhu2qc9: "fxeb0a7"
  },
  visible: {
    mc9l5x: "ftgm304"
  },
  inverted: {
    De3pzq: "fg3r6xk",
    sj55zd: "fonrgv7"
  },
  arrow: {
    B7ck84d: "f1ewtqcl",
    qhf8xq: "f1euv43f",
    Bj3rh1h: "f1bsuimh",
    rhnwrx: "f1s3jn22",
    Bdy53xb: "fv40uqz",
    De3pzq: "f1u2r49w",
    B2eet1l: "fqhgnl",
    Beyfa6y: "f17bz04i",
    Bz10aip: "f36o3x3",
    Bqenvij: "fzofk8q",
    a9b677: "f1wbx1ie",
    Ftih45: "f1wl9k8s",
    Br0sdwz: "f1aocrix",
    cmx5o7: "f1ljr5q2",
    susq4k: 0,
    Biibvgv: 0,
    Bicfajf: 0,
    qehafq: 0,
    Brs5u8j: "f155f1qt",
    Ccq8qp: "f9mhzq7",
    Baz25je: "fr6rhvx",
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f1kc0wz4",
    r59vdv: "fgq90dz",
    Bkw5xw4: "fq0y47f",
    hl6cv3: "f1pwrbz6",
    aea9ga: "f1hxxcvm",
    yayu3t: "fw8rgyo",
    Bhsv975: "f1wnzycx",
    rhl9o9: "f1730wal",
    B7gxrvb: "f1fy4ixr",
    B6q6orb: "fobkauc",
    B0lu1f8: "f16bqv1l"
  }
}, {
  d: [".fjseox{display:none;}", ".f1ewtqcl{box-sizing:border-box;}", ".f132xexn{max-width:240px;}", ".f158kwzp{cursor:default;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fokg9q4{overflow-wrap:break-word;}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f9ggezi{border:1px solid var(--colorTransparentStroke);}", {
    p: -2
  }], [".f1bzqsji{padding:4px 11px 6px 11px;}", {
    p: -1
  }], ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxeb0a7{filter:drop-shadow(0 0 2px var(--colorNeutralShadowAmbient)) drop-shadow(0 4px 8px var(--colorNeutralShadowKey));}", ".ftgm304{display:block;}", ".fg3r6xk{background-color:var(--colorNeutralBackgroundStatic);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1euv43f{position:absolute;}", ".f1bsuimh{z-index:-1;}", ".f1s3jn22{--fui-positioning-arrow-height:8.484px;}", ".fv40uqz{--fui-positioning-arrow-offset:-4.242px;}", ".f1u2r49w{background-color:inherit;}", ".fqhgnl{background-clip:content-box;}", ".f17bz04i{border-bottom-left-radius:var(--borderRadiusSmall);}", ".f36o3x3{transform:rotate(var(--fui-positioning-arrow-angle));}", ".fzofk8q{height:var(--fui-positioning-arrow-height);}", ".f1wbx1ie{width:var(--fui-positioning-arrow-height);}", '.f1wl9k8s::before{content:"";}', ".f1aocrix::before{display:block;}", ".f1ljr5q2::before{background-color:inherit;}", [".f155f1qt::before{margin:-1px;}", {
    p: -1
  }], ".f9mhzq7::before{width:100%;}", ".fr6rhvx::before{height:100%;}", [".f1kc0wz4::before{border:1px solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".fgq90dz::before{border-bottom-left-radius:var(--borderRadiusSmall);}", ".fq0y47f::before{clip-path:polygon(0% 0%, 100% 100%, 0% 100%);}", '[data-popper-placement^="top"] .f1pwrbz6{bottom:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="top"] .f1hxxcvm{--fui-positioning-arrow-angle:-45deg;}', '[data-popper-placement^="right"] .fw8rgyo{left:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="right"] .f1wnzycx{--fui-positioning-arrow-angle:45deg;}', '[data-popper-placement^="bottom"] .f1730wal{top:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="bottom"] .f1fy4ixr{--fui-positioning-arrow-angle:135deg;}', '[data-popper-placement^="left"] .fobkauc{right:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="left"] .f16bqv1l{--fui-positioning-arrow-angle:225deg;}']
});
var useTooltipStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles10();
  state.content.className = mergeClasses(tooltipClassNames.content, styles.root, state.appearance === "inverted" && styles.inverted, state.visible && styles.visible, state.content.className);
  state.arrowClassName = styles.arrow;
  return state;
};

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/Tooltip.js
var Tooltip = (props) => {
  const state = useTooltip_unstable(props);
  useTooltipStyles_unstable(state);
  useCustomStyleHook("useTooltipStyles_unstable")(state);
  return renderTooltip_unstable(state);
};
Tooltip.displayName = "Tooltip";
Tooltip.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopover.js
var useAvatarGroupPopover_unstable = (props) => {
  var _useAvatarGroupContext_unstable;
  const size3 = (_useAvatarGroupContext_unstable = useAvatarGroupContext_unstable((ctx) => ctx.size)) !== null && _useAvatarGroupContext_unstable !== void 0 ? _useAvatarGroupContext_unstable : defaultAvatarGroupSize;
  const layout = useAvatarGroupContext_unstable((ctx) => ctx.layout);
  const { indicator = size3 < 24 ? "icon" : "count", count = React134.Children.count(props.children), children: children2, ...restOfProps } = props;
  const [popoverOpen, setPopoverOpen] = useControllableState({
    state: props.open,
    defaultState: props.defaultOpen,
    initialState: false
  });
  const handleOnPopoverChange = (e, data) => {
    var _restOfProps_onOpenChange;
    (_restOfProps_onOpenChange = restOfProps.onOpenChange) === null || _restOfProps_onOpenChange === void 0 ? void 0 : _restOfProps_onOpenChange.call(restOfProps, e, data);
    setPopoverOpen(data.open);
  };
  let triggerButtonChildren;
  if (layout === "pie") {
    triggerButtonChildren = null;
  } else if (indicator === "icon") {
    triggerButtonChildren = React134.createElement(MoreHorizontalRegular, null);
  } else {
    triggerButtonChildren = count > 99 ? "99+" : `+${count}`;
  }
  return {
    count,
    indicator,
    layout,
    popoverOpen,
    size: size3,
    components: {
      root: Popover,
      triggerButton: "button",
      content: "ul",
      popoverSurface: PopoverSurface,
      tooltip: Tooltip
    },
    root: slot_exports.always({
      // Popover expects a child for its children. The children are added in the renderAvatarGroupPopover.
      children: React134.createElement(React134.Fragment, null),
      size: "small",
      trapFocus: true,
      ...restOfProps,
      open: popoverOpen,
      onOpenChange: handleOnPopoverChange
    }, {
      elementType: Popover
    }),
    triggerButton: slot_exports.always(props.triggerButton, {
      defaultProps: {
        children: triggerButtonChildren,
        type: "button"
      },
      elementType: "button"
    }),
    content: slot_exports.always(props.content, {
      defaultProps: {
        children: children2,
        role: "list"
      },
      elementType: "ul"
    }),
    popoverSurface: slot_exports.always(props.popoverSurface, {
      defaultProps: {
        "aria-label": "Overflow",
        tabIndex: 0
      },
      elementType: PopoverSurface
    }),
    tooltip: slot_exports.always(props.tooltip, {
      defaultProps: {
        content: "View more people.",
        relationship: "label"
      },
      elementType: Tooltip
    })
  };
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopoverStyles.styles.js
var avatarGroupPopoverClassNames = {
  root: "fui-AvatarGroupPopover",
  content: "fui-AvatarGroupPopover__content",
  popoverSurface: "fui-AvatarGroupPopover__popoverSurface",
  tooltip: "fui-AvatarGroupPopover__tooltip",
  triggerButton: "fui-AvatarGroupPopover__triggerButton"
};
var useContentStyles = __styles2({
  base: {
    dclx09: "ftrb29c",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62"
  }
}, {
  d: [".ftrb29c{list-style-type:none;}", [".f1s184ao{margin:0;}", {
    p: -1
  }], [".f1mk8lai{padding:0;}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}"]
});
var usePopoverSurfaceStyles = __styles2({
  base: {
    Bxyxcbc: "fopcw2o",
    sshi5w: "f1n5o1gx",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f19r5mr9",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1f5q0n8",
    a9b677: "f13dwy2t"
  }
}, {
  d: [".fopcw2o{max-height:220px;}", ".f1n5o1gx{min-height:80px;}", [".f19r5mr9{overflow:hidden scroll;}", {
    p: -1
  }], [".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], ".f13dwy2t{width:220px;}"]
});
var useTriggerButtonStyles = __styles2({
  base: {
    mc9l5x: "ftuwxu6",
    qhf8xq: "f10pi13n",
    Bnnss6s: "fi64zpg",
    Brf1p80: "f4d9j23",
    Bt984gj: "f122n59",
    sj55zd: "f19n0e5",
    De3pzq: "fxugw4r",
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"],
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    icvyot: "fzkkow9",
    vrafjx: ["fcdblym", "fjik90z"],
    oivjwe: "fg706s2",
    wvpqe5: ["fjik90z", "fcdblym"],
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    Bjwas2f: "fw33nwi",
    Bn1d65q: ["f1ptkjjm", "fmzzjfk"],
    Bxeuatn: "f15j0dln",
    n51gp8: ["fmzzjfk", "f1ptkjjm"]
  },
  pie: {
    De3pzq: "f1c21dwh",
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"],
    sj55zd: "f44pa96"
  },
  focusIndicator: {
    Byu6kyc: 0,
    n8qw10: 0,
    Bbjhlyh: 0,
    i2cumq: 0,
    Bunx835: 0,
    Bdrgwmp: 0,
    mqozju: 0,
    lbo84a: 0,
    Bksnhdo: 0,
    Bci5o5g: 0,
    u5e7qz: 0,
    Bn40d3w: 0,
    B7b6zxw: 0,
    B8q5s1w: 0,
    B5gfjzb: 0,
    Bbcte9g: 0,
    Bqz3imu: "f1j9b7x8",
    g9k6zt: "f1nev41a"
  },
  states: {
    Bi91k9c: "feu1g3u",
    Jwef8y: "f1knas48",
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "f1xlaoq0",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    lj723h: "f1g4hkjv",
    ecr2s2: "fb40n2d",
    B6oc9vd: "fvs00aa",
    ak43y8: ["f1assf6x", "f4ruux4"],
    wmxk5l: "fumykes",
    B50zh58: ["f4ruux4", "f1assf6x"]
  },
  selected: {
    sj55zd: "f14nttnl",
    De3pzq: "f1nfm20t",
    g2u3we: "f1ly1fcm",
    h3c5rm: ["fi8bssc", "fj6btzu"],
    B9xav0g: "f1s9tnsa",
    zhjwy3: ["fj6btzu", "fi8bssc"]
  },
  icon12: {
    Be2twd7: "f1ugzwwg"
  },
  icon16: {
    Be2twd7: "f4ybsrx"
  },
  icon20: {
    Be2twd7: "fe5j1ua"
  },
  icon24: {
    Be2twd7: "f1rt2boy"
  },
  icon28: {
    Be2twd7: "f24l1pt"
  },
  icon32: {
    Be2twd7: "ffl51b"
  },
  icon48: {
    Be2twd7: "f18m8u13"
  },
  caption2Strong: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f13mqy1h",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fcpl73t"
  },
  caption1Strong: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fwrc4pm"
  },
  body1Strong: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1i3iumi"
  },
  subtitle2: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  subtitle1: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f1pp30po",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f106mvju"
  },
  title3: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f1x0m3f5",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fb86gi6"
  },
  borderThin: {
    B4j52fo: "f192inf7",
    Bekrc4i: ["f5tn483", "f1ojsxk5"],
    Bn0qgzm: "f1vxd6vx",
    ibv6hh: ["f1ojsxk5", "f5tn483"]
  },
  borderThick: {
    B4j52fo: "f18zi460",
    Bekrc4i: ["f1wpluaz", "fsfsuhs"],
    Bn0qgzm: "fmklw6v",
    ibv6hh: ["fsfsuhs", "f1wpluaz"]
  },
  borderThicker: {
    B4j52fo: "fgx37oo",
    Bekrc4i: ["f130t4y6", "f1efpmoh"],
    Bn0qgzm: "fv51ejd",
    ibv6hh: ["f1efpmoh", "f130t4y6"]
  },
  borderThickest: {
    B4j52fo: "fwn6jck",
    Bekrc4i: ["figl7jc", "f1g0iy8l"],
    Bn0qgzm: "f1b8shu7",
    ibv6hh: ["f1g0iy8l", "figl7jc"]
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".f10pi13n{position:relative;}", ".fi64zpg{flex-shrink:0;}", ".f4d9j23{justify-content:center;}", ".f122n59{align-items:center;}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".fzkkow9{border-top-style:solid;}", ".fcdblym{border-right-style:solid;}", ".fjik90z{border-left-style:solid;}", ".fg706s2{border-bottom-style:solid;}", [".f1mk8lai{padding:0;}", {
    p: -1
  }], ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".f44pa96{color:transparent;}", [".f1j9b7x8[data-fui-focus-visible]{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -2
  }], ".f1nev41a[data-fui-focus-visible]{outline-style:none;}", ".f14nttnl{color:var(--colorNeutralForeground1Selected);}", ".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}", ".f1ly1fcm{border-top-color:var(--colorNeutralStroke1Selected);}", ".fi8bssc{border-right-color:var(--colorNeutralStroke1Selected);}", ".fj6btzu{border-left-color:var(--colorNeutralStroke1Selected);}", ".f1s9tnsa{border-bottom-color:var(--colorNeutralStroke1Selected);}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f24l1pt{font-size:28px;}", ".ffl51b{font-size:32px;}", ".f18m8u13{font-size:48px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fcpl73t{line-height:var(--lineHeightBase100);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f106mvju{line-height:var(--lineHeightBase500);}", ".f1x0m3f5{font-size:var(--fontSizeBase600);}", ".fb86gi6{line-height:var(--lineHeightBase600);}", ".f192inf7{border-top-width:var(--strokeWidthThin);}", ".f5tn483{border-right-width:var(--strokeWidthThin);}", ".f1ojsxk5{border-left-width:var(--strokeWidthThin);}", ".f1vxd6vx{border-bottom-width:var(--strokeWidthThin);}", ".f18zi460{border-top-width:var(--strokeWidthThick);}", ".f1wpluaz{border-right-width:var(--strokeWidthThick);}", ".fsfsuhs{border-left-width:var(--strokeWidthThick);}", ".fmklw6v{border-bottom-width:var(--strokeWidthThick);}", ".fgx37oo{border-top-width:var(--strokeWidthThicker);}", ".f130t4y6{border-right-width:var(--strokeWidthThicker);}", ".f1efpmoh{border-left-width:var(--strokeWidthThicker);}", ".fv51ejd{border-bottom-width:var(--strokeWidthThicker);}", ".fwn6jck{border-top-width:var(--strokeWidthThickest);}", ".figl7jc{border-right-width:var(--strokeWidthThickest);}", ".f1g0iy8l{border-left-width:var(--strokeWidthThickest);}", ".f1b8shu7{border-bottom-width:var(--strokeWidthThickest);}"],
  m: [["@media (forced-colors: active){.fw33nwi{border-top-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ptkjjm{border-right-color:CanvasText;}.fmzzjfk{border-left-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f15j0dln{border-bottom-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}", ".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1xlaoq0:hover{border-bottom-color:var(--colorNeutralStroke1Hover);}"],
  a: [".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}", ".fb40n2d:active{background-color:var(--colorNeutralBackground1Pressed);}", ".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".fumykes:active{border-bottom-color:var(--colorNeutralStroke1Pressed);}"]
});
var useAvatarGroupPopoverStyles_unstable = (state) => {
  "use no memo";
  const {
    indicator,
    size: size3,
    layout,
    popoverOpen
  } = state;
  const sizeStyles = useSizeStyles();
  const triggerButtonStyles = useTriggerButtonStyles();
  const contentStyles = useContentStyles();
  const popoverSurfaceStyles = usePopoverSurfaceStyles();
  const groupChildClassName = useGroupChildClassName(layout, size3);
  const triggerButtonClasses = [];
  if (size3 < 36) {
    triggerButtonClasses.push(triggerButtonStyles.borderThin);
  } else if (size3 < 56) {
    triggerButtonClasses.push(triggerButtonStyles.borderThick);
  } else if (size3 < 72) {
    triggerButtonClasses.push(triggerButtonStyles.borderThicker);
  } else {
    triggerButtonClasses.push(triggerButtonStyles.borderThickest);
  }
  if (indicator === "count") {
    if (size3 <= 24) {
      triggerButtonClasses.push(triggerButtonStyles.caption2Strong);
    } else if (size3 <= 28) {
      triggerButtonClasses.push(triggerButtonStyles.caption1Strong);
    } else if (size3 <= 40) {
      triggerButtonClasses.push(triggerButtonStyles.body1Strong);
    } else if (size3 <= 56) {
      triggerButtonClasses.push(triggerButtonStyles.subtitle2);
    } else if (size3 <= 96) {
      triggerButtonClasses.push(triggerButtonStyles.subtitle1);
    } else {
      triggerButtonClasses.push(triggerButtonStyles.title3);
    }
  } else {
    if (size3 <= 16) {
      triggerButtonClasses.push(triggerButtonStyles.icon12);
    } else if (size3 <= 24) {
      triggerButtonClasses.push(triggerButtonStyles.icon16);
    } else if (size3 <= 40) {
      triggerButtonClasses.push(triggerButtonStyles.icon20);
    } else if (size3 <= 48) {
      triggerButtonClasses.push(triggerButtonStyles.icon24);
    } else if (size3 <= 56) {
      triggerButtonClasses.push(triggerButtonStyles.icon28);
    } else if (size3 <= 72) {
      triggerButtonClasses.push(triggerButtonStyles.icon32);
    } else {
      triggerButtonClasses.push(triggerButtonStyles.icon48);
    }
  }
  state.triggerButton.className = mergeClasses(avatarGroupPopoverClassNames.triggerButton, groupChildClassName, sizeStyles[size3], triggerButtonStyles.base, layout === "pie" && triggerButtonStyles.pie, triggerButtonStyles.focusIndicator, layout !== "pie" && triggerButtonStyles.states, layout !== "pie" && popoverOpen && triggerButtonStyles.selected, ...triggerButtonClasses, state.triggerButton.className);
  state.content.className = mergeClasses(avatarGroupPopoverClassNames.content, contentStyles.base, state.content.className);
  state.popoverSurface.className = mergeClasses(avatarGroupPopoverClassNames.popoverSurface, popoverSurfaceStyles.base, state.popoverSurface.className);
  return state;
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/AvatarGroupPopover.js
var AvatarGroupPopover = (props) => {
  const state = useAvatarGroupPopover_unstable(props);
  const contextValues = useAvatarGroupPopoverContextValues_unstable(state);
  useAvatarGroupPopoverStyles_unstable(state);
  useCustomStyleHook("useAvatarGroupPopoverStyles_unstable")(state);
  return renderAvatarGroupPopover_unstable(state, contextValues);
};
AvatarGroupPopover.displayName = "AvatarGroupPopover";

// node_modules/@fluentui/react-button/lib/components/Button/Button.js
var React138 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/Button/renderButton.js
var renderButton_unstable = (state) => {
  assertSlots(state);
  const { iconOnly, iconPosition } = state;
  return jsxs(state.root, {
    children: [
      iconPosition !== "after" && state.icon && jsx(state.icon, {}),
      !iconOnly && state.root.children,
      iconPosition === "after" && state.icon && jsx(state.icon, {})
    ]
  });
};

// node_modules/@fluentui/react-button/lib/components/Button/useButton.js
var React137 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/contexts/ButtonContext.js
var React136 = __toESM(require_react());
var buttonContext = React136.createContext(void 0);
var buttonContextDefaultValue = {};
var ButtonContextProvider = buttonContext.Provider;
var useButtonContext = () => {
  var _React_useContext;
  return (_React_useContext = React136.useContext(buttonContext)) !== null && _React_useContext !== void 0 ? _React_useContext : buttonContextDefaultValue;
};

// node_modules/@fluentui/react-button/lib/components/Button/useButton.js
var useButton_unstable = (props, ref) => {
  const { size: contextSize } = useButtonContext();
  const { appearance = "secondary", as = "button", disabled = false, disabledFocusable = false, icon, iconPosition = "before", shape = "rounded", size: size3 = contextSize !== null && contextSize !== void 0 ? contextSize : "medium" } = props;
  const iconShorthand = slot_exports.optional(icon, {
    elementType: "span"
  });
  return {
    // Props passed at the top-level
    appearance,
    disabled,
    disabledFocusable,
    iconPosition,
    shape,
    size: size3,
    iconOnly: Boolean((iconShorthand === null || iconShorthand === void 0 ? void 0 : iconShorthand.children) && !props.children),
    components: {
      root: "button",
      icon: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
      elementType: "button",
      defaultProps: {
        ref,
        type: as === "button" ? "button" : void 0
      }
    }),
    icon: iconShorthand
  };
};

// node_modules/@fluentui/react-button/lib/components/Button/useButtonStyles.styles.js
var buttonClassNames = {
  root: "fui-Button",
  icon: "fui-Button__icon"
};
var boxShadowStrokeWidthThinMoz = `calc(${tokens.strokeWidthThin} + 0.25px)`;
var useRootBaseClassName = __resetStyles("r1alrhcs", null, {
  r: [".r1alrhcs{align-items:center;box-sizing:border-box;display:inline-flex;justify-content:center;text-decoration-line:none;vertical-align:middle;margin:0;overflow:hidden;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);font-family:var(--fontFamilyBase);outline-style:none;padding:5px var(--spacingHorizontalM);min-width:96px;border-radius:var(--borderRadiusMedium);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase300);transition-duration:var(--durationFaster);transition-property:background,border,color;transition-timing-function:var(--curveEasyEase);}", ".r1alrhcs:hover{background-color:var(--colorNeutralBackground1Hover);border-color:var(--colorNeutralStroke1Hover);color:var(--colorNeutralForeground1Hover);cursor:pointer;}", ".r1alrhcs:hover:active{background-color:var(--colorNeutralBackground1Pressed);border-color:var(--colorNeutralStroke1Pressed);color:var(--colorNeutralForeground1Pressed);outline-style:none;}", ".r1alrhcs[data-fui-focus-visible]{border-color:var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);border-width:1px;outline:var(--strokeWidthThick) solid var(--colorTransparentStroke);box-shadow:0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset;z-index:1;}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.r1alrhcs{transition-duration:0.01ms;}}", "@media (forced-colors: active){.r1alrhcs:focus{border-color:ButtonText;}.r1alrhcs:hover{background-color:HighlightText;border-color:Highlight;color:Highlight;forced-color-adjust:none;}.r1alrhcs:hover:active{background-color:HighlightText;border-color:Highlight;color:Highlight;forced-color-adjust:none;}}", "@supports (-moz-appearance:button){.r1alrhcs[data-fui-focus-visible]{box-shadow:0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset;}}"]
});
var useIconBaseClassName = __resetStyles("rywnvv2", null, [".rywnvv2{align-items:center;display:inline-flex;justify-content:center;font-size:20px;height:20px;width:20px;--fui-Button__icon--spacing:var(--spacingHorizontalSNudge);}"]);
var useRootStyles3 = __styles2({
  outline: {
    De3pzq: "f1c21dwh",
    Jwef8y: "fjxutwb",
    iro3zm: "fwiml72"
  },
  primary: {
    De3pzq: "ffp7eso",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    sj55zd: "f1phragk",
    Jwef8y: "f15wkkf3",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bi91k9c: "f1rq72xc",
    iro3zm: "fnp9lpt",
    b661bw: "f1h0usnq",
    Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
    B9zn80p: "f16h9ulv",
    Bpld233: ["fx2bmrt", "fs4ktlq"],
    B2d53fq: "f1d6v5y2",
    Bsw6fvg: "f1rirnrt",
    Bjwas2f: "f1uu00uk",
    Bn1d65q: ["fkvaka8", "f9a0qzu"],
    Bxeuatn: "f1ux7til",
    n51gp8: ["f9a0qzu", "fkvaka8"],
    Bbusuzp: "f1lkg8j3",
    ycbfsm: "fkc42ay",
    Bqrx1nm: "fq7113v",
    pgvf35: "ff1wgvm",
    Bh7lczh: ["fiob0tu", "f1x4h75k"],
    dpv3f4: "f1j6scgf",
    Bpnjhaq: ["f1x4h75k", "fiob0tu"],
    ze5xyy: "f4xjyn1",
    g2kj27: "fbgcvur",
    Bf756sw: "f1ks1yx8",
    Bow2dr7: ["f1o6qegi", "fmxjhhp"],
    Bvhedfk: "fcnxywj",
    Gye4lf: ["fmxjhhp", "f1o6qegi"],
    pc6evw: "f9ddjv3"
  },
  secondary: {},
  subtle: {
    De3pzq: "fhovq9v",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    sj55zd: "fkfq4zb",
    Jwef8y: "f1t94bn6",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bi91k9c: "fnwyq0v",
    Bk3fhr4: "ft1hn21",
    Bmfj8id: "fuxngvv",
    Bbdnnc7: "fy5bs14",
    iro3zm: "fsv2rcd",
    b661bw: "f1h0usnq",
    Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
    B9zn80p: "f16h9ulv",
    Bpld233: ["fx2bmrt", "fs4ktlq"],
    B2d53fq: "f1omzyqd",
    em6i61: "f1dfjoow",
    vm6p8p: "f1j98vj9",
    x3br3k: "fj8yq94",
    ze5xyy: "f4xjyn1",
    Bx3q9su: "f1et0tmh",
    pc6evw: "f9ddjv3",
    xd2cci: "f1wi8ngl"
  },
  transparent: {
    De3pzq: "f1c21dwh",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    sj55zd: "fkfq4zb",
    Jwef8y: "fjxutwb",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bi91k9c: "f139oj5f",
    Bk3fhr4: "ft1hn21",
    Bmfj8id: "fuxngvv",
    iro3zm: "fwiml72",
    b661bw: "f1h0usnq",
    Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
    B9zn80p: "f16h9ulv",
    Bpld233: ["fx2bmrt", "fs4ktlq"],
    B2d53fq: "f1fg1p5m",
    em6i61: "f1dfjoow",
    vm6p8p: "f1j98vj9",
    Bqrx1nm: "f1tme0vf",
    ze5xyy: "f4xjyn1",
    g2kj27: "f18onu3q",
    pc6evw: "f9ddjv3"
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9"
  },
  rounded: {},
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw"
  },
  small: {
    Bf4jedk: "fh7ncta",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fneth5b",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  smallWithIcon: {
    Byoj8tv: "f1brlhvm",
    z8tnut: "f1sl3k7w"
  },
  medium: {},
  large: {
    Bf4jedk: "f14es27b",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f4db1ww",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  largeWithIcon: {
    Byoj8tv: "fy7v416",
    z8tnut: "f1a1bwwz"
  }
}, {
  d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], ".fh7ncta{min-width:64px;}", [".fneth5b{padding:3px var(--spacingHorizontalS);}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1brlhvm{padding-bottom:1px;}", ".f1sl3k7w{padding-top:1px;}", ".f14es27b{min-width:96px;}", [".f4db1ww{padding:8px var(--spacingHorizontalL);}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fy7v416{padding-bottom:7px;}", ".f1a1bwwz{padding-top:7px;}"],
  h: [".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".fwiml72:hover:active{background-color:var(--colorTransparentBackgroundPressed);}", ".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}", ".fnp9lpt:hover:active{background-color:var(--colorBrandBackgroundPressed);}", ".f1h0usnq:hover:active{border-top-color:transparent;}", ".fs4ktlq:hover:active{border-right-color:transparent;}", ".fx2bmrt:hover:active{border-left-color:transparent;}", ".f16h9ulv:hover:active{border-bottom-color:transparent;}", ".f1d6v5y2:hover:active{color:var(--colorNeutralForegroundOnBrand);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".ft1hn21:hover .fui-Icon-filled{display:inline;}", ".fuxngvv:hover .fui-Icon-regular{display:none;}", ".fy5bs14:hover .fui-Button__icon{color:var(--colorNeutralForeground2BrandHover);}", ".fsv2rcd:hover:active{background-color:var(--colorSubtleBackgroundPressed);}", ".f1omzyqd:hover:active{color:var(--colorNeutralForeground2Pressed);}", ".f1dfjoow:hover:active .fui-Icon-filled{display:inline;}", ".f1j98vj9:hover:active .fui-Icon-regular{display:none;}", ".fj8yq94:hover:active .fui-Button__icon{color:var(--colorNeutralForeground2BrandPressed);}", ".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}", ".f1fg1p5m:hover:active{color:var(--colorNeutralForeground2BrandPressed);}"],
  m: [["@media (forced-colors: active){.f1rirnrt{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1uu00uk{border-top-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f9a0qzu{border-left-color:HighlightText;}.fkvaka8{border-right-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ux7til{border-bottom-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1lkg8j3{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fkc42ay{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fq7113v:hover{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.ff1wgvm:hover{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1x4h75k:hover{border-left-color:Highlight;}.fiob0tu:hover{border-right-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1j6scgf:hover{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f4xjyn1:hover{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fbgcvur:hover:active{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ks1yx8:hover:active{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1o6qegi:hover:active{border-right-color:Highlight;}.fmxjhhp:hover:active{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fcnxywj:hover:active{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f9ddjv3:hover:active{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1et0tmh:hover .fui-Button__icon{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1wi8ngl:hover:active .fui-Button__icon{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1tme0vf:hover{background-color:var(--colorTransparentBackground);}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f18onu3q:hover:active{background-color:var(--colorTransparentBackground);}}", {
    m: "(forced-colors: active)"
  }]]
});
var useRootDisabledStyles = __styles2({
  base: {
    De3pzq: "f1bg9a2p",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr",
    Bfinmwp: "f15x8b5r",
    Jwef8y: "f1falr9n",
    Bgoe8wy: "f12mpcsy",
    Bwzppfd: ["f1gwvigk", "f18rmfxp"],
    oetu4i: "f1jnshp0",
    gg5e9n: ["f18rmfxp", "f1gwvigk"],
    Bi91k9c: "fvgxktp",
    eoavqd: "fphbwmw",
    Bk3fhr4: "f19vpps7",
    Bmfj8id: "fv5swzo",
    Bbdnnc7: "f1al02dq",
    iro3zm: "f1t6o4dc",
    b661bw: "f10ztigi",
    Bk6r4ia: ["f1ft5sdu", "f1gzf82w"],
    B9zn80p: "f12zbtn2",
    Bpld233: ["f1gzf82w", "f1ft5sdu"],
    B2d53fq: "fcvwxyo",
    c3iz72: "f8w4c43",
    em6i61: "f1ol4fw6",
    vm6p8p: "f1q1lw4e",
    x3br3k: "f1dwjv2g"
  },
  highContrast: {
    Bsw6fvg: "f4lkoma",
    Bjwas2f: "fg455y9",
    Bn1d65q: ["f1rvyvqg", "f14g86mu"],
    Bxeuatn: "f1cwzwz",
    n51gp8: ["f14g86mu", "f1rvyvqg"],
    Bbusuzp: "f1dcs8yz",
    Bm2fdqk: "fuigjrg",
    G867l3: "fjwq6ea",
    gdbnj: ["f1lr3nhc", "f1mbxvi6"],
    mxns5l: "fn5gmvv",
    o3nasb: ["f1mbxvi6", "f1lr3nhc"],
    Bqrx1nm: "f1vmkb5g",
    pgvf35: "f53ppgq",
    Bh7lczh: ["f1663y11", "f80fkiy"],
    dpv3f4: "f18v5270",
    Bpnjhaq: ["f80fkiy", "f1663y11"],
    ze5xyy: "f1kc2mi9",
    Bx3q9su: "f4dhi0o",
    g2kj27: "f1y0svfh",
    Bf756sw: "fihuait",
    Bow2dr7: ["fnxhupq", "fyd6l6x"],
    Bvhedfk: "fx507ft",
    Gye4lf: ["fyd6l6x", "fnxhupq"],
    pc6evw: "fb3rf2x",
    xd2cci: "fequ9m0"
  },
  outline: {
    De3pzq: "f1c21dwh",
    Jwef8y: "f9ql6rf",
    iro3zm: "f3h1zc4"
  },
  primary: {
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    b661bw: "f1h0usnq",
    Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
    B9zn80p: "f16h9ulv",
    Bpld233: ["fx2bmrt", "fs4ktlq"]
  },
  secondary: {},
  subtle: {
    De3pzq: "f1c21dwh",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    Jwef8y: "f9ql6rf",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    iro3zm: "f3h1zc4",
    b661bw: "f1h0usnq",
    Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
    B9zn80p: "f16h9ulv",
    Bpld233: ["fx2bmrt", "fs4ktlq"]
  },
  transparent: {
    De3pzq: "f1c21dwh",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    Jwef8y: "f9ql6rf",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    iro3zm: "f3h1zc4",
    b661bw: "f1h0usnq",
    Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
    B9zn80p: "f16h9ulv",
    Bpld233: ["fx2bmrt", "fs4ktlq"]
  }
}, {
  d: [".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".f15x8b5r .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}"],
  h: [".f1falr9n:hover{background-color:var(--colorNeutralBackgroundDisabled);}", ".f12mpcsy:hover{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1gwvigk:hover{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f18rmfxp:hover{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1jnshp0:hover{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".fphbwmw:hover{cursor:not-allowed;}", ".f19vpps7:hover .fui-Icon-filled{display:none;}", ".fv5swzo:hover .fui-Icon-regular{display:inline;}", ".f1al02dq:hover .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f1t6o4dc:hover:active{background-color:var(--colorNeutralBackgroundDisabled);}", ".f10ztigi:hover:active{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1ft5sdu:hover:active{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f1gzf82w:hover:active{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f12zbtn2:hover:active{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fcvwxyo:hover:active{color:var(--colorNeutralForegroundDisabled);}", ".f8w4c43:hover:active{cursor:not-allowed;}", ".f1ol4fw6:hover:active .fui-Icon-filled{display:none;}", ".f1q1lw4e:hover:active .fui-Icon-regular{display:inline;}", ".f1dwjv2g:hover:active .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f9ql6rf:hover{background-color:var(--colorTransparentBackground);}", ".f3h1zc4:hover:active{background-color:var(--colorTransparentBackground);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".f1h0usnq:hover:active{border-top-color:transparent;}", ".fs4ktlq:hover:active{border-right-color:transparent;}", ".fx2bmrt:hover:active{border-left-color:transparent;}", ".f16h9ulv:hover:active{border-bottom-color:transparent;}"],
  m: [["@media (forced-colors: active){.f4lkoma{background-color:ButtonFace;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fuigjrg .fui-Button__icon{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fjwq6ea:focus{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1lr3nhc:focus{border-right-color:GrayText;}.f1mbxvi6:focus{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fn5gmvv:focus{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1vmkb5g:hover{background-color:ButtonFace;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f53ppgq:hover{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1663y11:hover{border-right-color:GrayText;}.f80fkiy:hover{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f18v5270:hover{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1kc2mi9:hover{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f4dhi0o:hover .fui-Button__icon{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1y0svfh:hover:active{background-color:ButtonFace;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fihuait:hover:active{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fnxhupq:hover:active{border-right-color:GrayText;}.fyd6l6x:hover:active{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fx507ft:hover:active{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fb3rf2x:hover:active{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fequ9m0:hover:active .fui-Button__icon{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useRootFocusStyles = __styles2({
  circular: {
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f1062rbf"
  },
  rounded: {},
  square: {
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "fj0ryk1"
  },
  primary: {
    B8q5s1w: "f17t0x8g",
    Bci5o5g: ["f194v5ow", "fk7jm04"],
    n8qw10: "f1qgg65p",
    Bdrgwmp: ["fk7jm04", "f194v5ow"],
    j6ew2k: ["fhgccpy", "fjo7pq6"],
    he4mth: "f32wu9k",
    Byr4aka: "fu5nqqq",
    lks7q5: ["f13prjl2", "f1nl83rv"],
    Bnan3qt: "f1czftr5",
    k1dn9: ["f1nl83rv", "f13prjl2"],
    Boium3a: ["f12k37oa", "fdnykm2"],
    tm8e47: "fr96u23"
  },
  small: {
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "fazmxh"
  },
  medium: {},
  large: {
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f1b6alqh"
  }
}, {
  d: [[".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], ".f17t0x8g[data-fui-focus-visible]{border-top-color:var(--colorStrokeFocus2);}", ".f194v5ow[data-fui-focus-visible]{border-right-color:var(--colorStrokeFocus2);}", ".fk7jm04[data-fui-focus-visible]{border-left-color:var(--colorStrokeFocus2);}", ".f1qgg65p[data-fui-focus-visible]{border-bottom-color:var(--colorStrokeFocus2);}", ".fhgccpy[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}", ".fjo7pq6[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}", ".f32wu9k[data-fui-focus-visible]:hover{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset;}", ".fu5nqqq[data-fui-focus-visible]:hover{border-top-color:var(--colorStrokeFocus2);}", ".f13prjl2[data-fui-focus-visible]:hover{border-right-color:var(--colorStrokeFocus2);}", ".f1nl83rv[data-fui-focus-visible]:hover{border-left-color:var(--colorStrokeFocus2);}", ".f1czftr5[data-fui-focus-visible]:hover{border-bottom-color:var(--colorStrokeFocus2);}", [".fazmxh[data-fui-focus-visible]{border-radius:var(--borderRadiusSmall);}", {
    p: -1
  }], [".f1b6alqh[data-fui-focus-visible]{border-radius:var(--borderRadiusLarge);}", {
    p: -1
  }]],
  t: ["@supports (-moz-appearance:button){.f12k37oa[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}.fdnykm2[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}}", "@supports (-moz-appearance:button){.fr96u23[data-fui-focus-visible]:hover{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset;}}"]
});
var useRootIconOnlyStyles = __styles2({
  small: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fu97m5z",
    Bf4jedk: "f17fgpbq",
    B2u0y6b: "f1jt17bm"
  },
  medium: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f18ktai2",
    Bf4jedk: "fwbmr0d",
    B2u0y6b: "f44c6la"
  },
  large: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1hbd1aw",
    Bf4jedk: "f12clzc2",
    B2u0y6b: "fjy1crr"
  }
}, {
  d: [[".fu97m5z{padding:1px;}", {
    p: -1
  }], ".f17fgpbq{min-width:24px;}", ".f1jt17bm{max-width:24px;}", [".f18ktai2{padding:5px;}", {
    p: -1
  }], ".fwbmr0d{min-width:32px;}", ".f44c6la{max-width:32px;}", [".f1hbd1aw{padding:7px;}", {
    p: -1
  }], ".f12clzc2{min-width:40px;}", ".fjy1crr{max-width:40px;}"]
});
var useIconStyles2 = __styles2({
  small: {
    Be2twd7: "fe5j1ua",
    Bqenvij: "fjamq6b",
    a9b677: "f64fuq3",
    Bqrlyyl: "fbaiahx"
  },
  medium: {},
  large: {
    Be2twd7: "f1rt2boy",
    Bqenvij: "frvgh55",
    a9b677: "fq4mcun",
    Bqrlyyl: "f1exjqw5"
  },
  before: {
    t21cq0: ["f1nizpg2", "f1a695kz"]
  },
  after: {
    Frg6f3: ["f1a695kz", "f1nizpg2"]
  }
}, {
  d: [".fe5j1ua{font-size:20px;}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".fbaiahx{--fui-Button__icon--spacing:var(--spacingHorizontalXS);}", ".f1rt2boy{font-size:24px;}", ".frvgh55{height:24px;}", ".fq4mcun{width:24px;}", ".f1exjqw5{--fui-Button__icon--spacing:var(--spacingHorizontalSNudge);}", ".f1nizpg2{margin-right:var(--fui-Button__icon--spacing);}", ".f1a695kz{margin-left:var(--fui-Button__icon--spacing);}"]
});
var useButtonStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName();
  const iconBaseClassName = useIconBaseClassName();
  const rootStyles = useRootStyles3();
  const rootDisabledStyles = useRootDisabledStyles();
  const rootFocusStyles = useRootFocusStyles();
  const rootIconOnlyStyles = useRootIconOnlyStyles();
  const iconStyles = useIconStyles2();
  const {
    appearance,
    disabled,
    disabledFocusable,
    icon,
    iconOnly,
    iconPosition,
    shape,
    size: size3
  } = state;
  state.root.className = mergeClasses(
    buttonClassNames.root,
    rootBaseClassName,
    appearance && rootStyles[appearance],
    rootStyles[size3],
    icon && size3 === "small" && rootStyles.smallWithIcon,
    icon && size3 === "large" && rootStyles.largeWithIcon,
    rootStyles[shape],
    // Disabled styles
    (disabled || disabledFocusable) && rootDisabledStyles.base,
    (disabled || disabledFocusable) && rootDisabledStyles.highContrast,
    appearance && (disabled || disabledFocusable) && rootDisabledStyles[appearance],
    // Focus styles
    appearance === "primary" && rootFocusStyles.primary,
    rootFocusStyles[size3],
    rootFocusStyles[shape],
    // Icon-only styles
    iconOnly && rootIconOnlyStyles[size3],
    // User provided class name
    state.root.className
  );
  if (state.icon) {
    state.icon.className = mergeClasses(buttonClassNames.icon, iconBaseClassName, !!state.root.children && iconStyles[iconPosition], iconStyles[size3], state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-button/lib/components/Button/Button.js
var Button = React138.forwardRef((props, ref) => {
  const state = useButton_unstable(props, ref);
  useButtonStyles_unstable(state);
  useCustomStyleHook("useButtonStyles_unstable")(state);
  return renderButton_unstable(state);
});
Button.displayName = "Button";

// node_modules/@fluentui/react-button/lib/components/CompoundButton/CompoundButton.js
var React140 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/CompoundButton/renderCompoundButton.js
var renderCompoundButton_unstable = (state) => {
  assertSlots(state);
  const { iconOnly, iconPosition } = state;
  return jsxs(state.root, {
    children: [
      iconPosition !== "after" && state.icon && jsx(state.icon, {}),
      !iconOnly && jsxs(state.contentContainer, {
        children: [
          state.root.children,
          state.secondaryContent && jsx(state.secondaryContent, {})
        ]
      }),
      iconPosition === "after" && state.icon && jsx(state.icon, {})
    ]
  });
};

// node_modules/@fluentui/react-button/lib/components/CompoundButton/useCompoundButton.js
var React139 = __toESM(require_react());
var useCompoundButton_unstable = ({ contentContainer, secondaryContent, ...props }, ref) => {
  var _state_icon, _state_secondaryContent;
  const state = {
    // Button state
    ...useButton_unstable(props, ref),
    // Slots definition
    components: {
      root: "button",
      icon: "span",
      contentContainer: "span",
      secondaryContent: "span"
    },
    contentContainer: slot_exports.always(contentContainer, {
      elementType: "span"
    }),
    secondaryContent: slot_exports.optional(secondaryContent, {
      elementType: "span"
    })
  };
  state.iconOnly = Boolean(((_state_icon = state.icon) === null || _state_icon === void 0 ? void 0 : _state_icon.children) && !props.children && !((_state_secondaryContent = state.secondaryContent) === null || _state_secondaryContent === void 0 ? void 0 : _state_secondaryContent.children));
  return state;
};

// node_modules/@fluentui/react-button/lib/components/CompoundButton/useCompoundButtonStyles.styles.js
var compoundButtonClassNames = {
  root: "fui-CompoundButton",
  icon: "fui-CompoundButton__icon",
  contentContainer: "fui-CompoundButton__contentContainer",
  secondaryContent: "fui-CompoundButton__secondaryContent"
};
var useRootStyles4 = __styles2({
  base: {
    Bqenvij: "f11ysow2",
    J657lq: "f1um431h",
    Jlnjib: "fte7hqw",
    Bc29nj9: "f1yh8ef3"
  },
  highContrast: {
    pu7qz5: "fi3u9nm",
    B10010i: "f1tdgb9w"
  },
  outline: {},
  primary: {
    J657lq: "foe7gw6",
    Jlnjib: "fvxlz81",
    Bc29nj9: "f1c2mdy",
    B8ia98v: "f1r39r2s"
  },
  secondary: {},
  subtle: {
    J657lq: "f1um431h",
    Jlnjib: "fte7hqw",
    Bc29nj9: "f1yh8ef3",
    pu7qz5: "f1xoeh18",
    B10010i: "f1ca1nd7"
  },
  transparent: {
    J657lq: "f1um431h",
    Jlnjib: "f1wn9xqz",
    Bc29nj9: "f1a8q4d0"
  },
  small: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1ge6w2w",
    Be2twd7: "fkhj508",
    Bg96gwp: "f1i3iumi"
  },
  medium: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fnnf4v2",
    Be2twd7: "fkhj508",
    Bg96gwp: "f1i3iumi"
  },
  large: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f14s4sho",
    Be2twd7: "fod5ikn",
    Bg96gwp: "faaz57k"
  },
  disabled: {
    J657lq: "f1rlv8bf",
    Jlnjib: "fd1dbtm",
    Bc29nj9: "f1vqmdmi"
  },
  disabledHighContrast: {
    B8ia98v: "f1csacz4",
    pu7qz5: "f1s5tkfe",
    B10010i: "fs0rda3"
  }
}, {
  d: [".f11ysow2{height:auto;}", ".f1um431h .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2);}", ".foe7gw6 .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundOnBrand);}", [".f1ge6w2w{padding:var(--spacingHorizontalS) var(--spacingHorizontalS) var(--spacingHorizontalMNudge) var(--spacingHorizontalS);}", {
    p: -1
  }], ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".fnnf4v2{padding:14px var(--spacingHorizontalM) var(--spacingHorizontalL) var(--spacingHorizontalM);}", {
    p: -1
  }], [".f14s4sho{padding:18px var(--spacingHorizontalL) var(--spacingHorizontalXL) var(--spacingHorizontalL);}", {
    p: -1
  }], ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f1rlv8bf .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundDisabled);}"],
  h: [".fte7hqw:hover .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2Hover);}", ".f1yh8ef3:hover:active .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2Pressed);}", ".fvxlz81:hover .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundOnBrand);}", ".f1c2mdy:hover:active .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundOnBrand);}", ".f1wn9xqz:hover .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2BrandHover);}", ".f1a8q4d0:hover:active .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2BrandPressed);}", ".fd1dbtm:hover .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundDisabled);}", ".f1vqmdmi:hover:active .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundDisabled);}"],
  m: [["@media (forced-colors: active){.fi3u9nm:hover .fui-CompoundButton__secondaryContent{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1tdgb9w:hover:active .fui-CompoundButton__secondaryContent{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1r39r2s .fui-CompoundButton__secondaryContent{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1xoeh18:hover .fui-CompoundButton__secondaryContent{color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ca1nd7:hover:active .fui-CompoundButton__secondaryContent{color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1csacz4 .fui-CompoundButton__secondaryContent{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1s5tkfe:hover .fui-CompoundButton__secondaryContent{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fs0rda3:hover:active .fui-CompoundButton__secondaryContent{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useRootIconOnlyStyles2 = __styles2({
  small: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1t35pdg",
    B2u0y6b: "ft5vyj6",
    Bf4jedk: "f17suaiq"
  },
  medium: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1r1wyb6",
    B2u0y6b: "fdczgix",
    Bf4jedk: "fjdcg9m"
  },
  large: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1bnz8pu",
    B2u0y6b: "fww51uw",
    Bf4jedk: "f1qhsl2h"
  }
}, {
  d: [[".f1t35pdg{padding:var(--spacingHorizontalXS);}", {
    p: -1
  }], ".ft5vyj6{max-width:48px;}", ".f17suaiq{min-width:48px;}", [".f1r1wyb6{padding:var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".fdczgix{max-width:52px;}", ".fjdcg9m{min-width:52px;}", [".f1bnz8pu{padding:var(--spacingHorizontalS);}", {
    p: -1
  }], ".fww51uw{max-width:56px;}", ".f1qhsl2h{min-width:56px;}"]
});
var useIconStyles3 = __styles2({
  base: {
    Be2twd7: "fndrnj9",
    Bqenvij: "fbhnoac",
    a9b677: "feqmc2u"
  },
  before: {
    t21cq0: ["fkujibs", "f199hnxi"]
  },
  after: {
    Frg6f3: ["f199hnxi", "fkujibs"]
  }
}, {
  d: [".fndrnj9{font-size:40px;}", ".fbhnoac{height:40px;}", ".feqmc2u{width:40px;}", ".fkujibs{margin-right:var(--spacingHorizontalM);}", ".f199hnxi{margin-left:var(--spacingHorizontalM);}"]
});
var useContentContainerStyles = __styles2({
  base: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    fsow6f: ["f1o700av", "fes3tcz"]
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}"]
});
var useSecondaryContentStyles = __styles2({
  base: {
    Bg96gwp: "flkuc6h",
    Bhrd7zp: "figsok6"
  },
  small: {
    Be2twd7: "fy9rknc"
  },
  medium: {
    Be2twd7: "fy9rknc"
  },
  large: {
    Be2twd7: "fkhj508"
  }
}, {
  d: [".flkuc6h{line-height:100%;}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fkhj508{font-size:var(--fontSizeBase300);}"]
});
var useCompoundButtonStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles4();
  const rootIconOnlyStyles = useRootIconOnlyStyles2();
  const iconStyles = useIconStyles3();
  const contentContainerStyles = useContentContainerStyles();
  const secondaryContentStyles = useSecondaryContentStyles();
  const {
    appearance,
    disabled,
    disabledFocusable,
    iconOnly,
    iconPosition,
    size: size3
  } = state;
  state.root.className = mergeClasses(
    compoundButtonClassNames.root,
    // Root styles
    rootStyles.base,
    rootStyles.highContrast,
    appearance && rootStyles[appearance],
    rootStyles[size3],
    // Disabled styles
    (disabled || disabledFocusable) && rootStyles.disabled,
    (disabled || disabledFocusable) && rootStyles.disabledHighContrast,
    // Icon-only styles
    iconOnly && rootIconOnlyStyles[size3],
    // User provided class name
    state.root.className
  );
  state.contentContainer.className = mergeClasses(compoundButtonClassNames.contentContainer, contentContainerStyles.base, state.contentContainer.className);
  if (state.icon) {
    state.icon.className = mergeClasses(compoundButtonClassNames.icon, iconStyles.base, state.root.children !== void 0 && state.root.children !== null && iconStyles[iconPosition], state.icon.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(compoundButtonClassNames.secondaryContent, secondaryContentStyles.base, secondaryContentStyles[size3], state.secondaryContent.className);
  }
  useButtonStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-button/lib/components/CompoundButton/CompoundButton.js
var CompoundButton = React140.forwardRef((props, ref) => {
  const state = useCompoundButton_unstable(props, ref);
  useCompoundButtonStyles_unstable(state);
  useCustomStyleHook("useCompoundButtonStyles_unstable")(state);
  return renderCompoundButton_unstable(state);
});
CompoundButton.displayName = "CompoundButton";

// node_modules/@fluentui/react-button/lib/components/MenuButton/MenuButton.js
var React142 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/MenuButton/renderMenuButton.js
var renderMenuButton_unstable = (state) => {
  assertSlots(state);
  const { icon, iconOnly } = state;
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      !iconOnly && state.root.children,
      (!iconOnly || !(icon === null || icon === void 0 ? void 0 : icon.children)) && state.menuIcon && jsx(state.menuIcon, {})
    ]
  });
};

// node_modules/@fluentui/react-button/lib/components/MenuButton/useMenuButton.js
var React141 = __toESM(require_react());
var useMenuButton_unstable = ({ menuIcon, ...props }, ref) => {
  "use no memo";
  const buttonState = useButton_unstable(props, ref);
  buttonState.root["aria-expanded"] = props["aria-expanded"] ? props["aria-expanded"] === "true" || props["aria-expanded"] === true : false;
  return {
    // Button state
    ...buttonState,
    // State calculated from a set of props
    iconOnly: Boolean(!props.children),
    // Slots definition
    components: {
      root: "button",
      icon: "span",
      menuIcon: "span"
    },
    menuIcon: slot_exports.optional(menuIcon, {
      defaultProps: {
        children: React141.createElement(ChevronDownRegular, null)
      },
      renderByDefault: true,
      elementType: "span"
    })
  };
};

// node_modules/@fluentui/react-button/lib/components/MenuButton/useMenuButtonStyles.styles.js
var menuButtonClassNames = {
  root: "fui-MenuButton",
  icon: "fui-MenuButton__icon",
  menuIcon: "fui-MenuButton__menuIcon"
};
var useRootExpandedStyles = __styles2({
  base: {
    D0sxk3: "fxoiby5",
    t6yez3: "f15q0o9g"
  },
  outline: {
    g2u3we: "f1ly1fcm",
    h3c5rm: ["fi8bssc", "fj6btzu"],
    B9xav0g: "f1s9tnsa",
    zhjwy3: ["fj6btzu", "fi8bssc"],
    B4j52fo: "fgx37oo",
    Bekrc4i: ["f130t4y6", "f1efpmoh"],
    Bn0qgzm: "fv51ejd",
    ibv6hh: ["f1efpmoh", "f130t4y6"],
    sj55zd: "f14nttnl"
  },
  primary: {
    De3pzq: "f8w4g0q"
  },
  secondary: {
    De3pzq: "f1nfm20t",
    g2u3we: "f1ly1fcm",
    h3c5rm: ["fi8bssc", "fj6btzu"],
    B9xav0g: "f1s9tnsa",
    zhjwy3: ["fj6btzu", "fi8bssc"],
    sj55zd: "f14nttnl"
  },
  subtle: {
    De3pzq: "fq5gl1p",
    sj55zd: "f1eryozh"
  },
  transparent: {
    De3pzq: "f1q9pm1r",
    sj55zd: "f1qj7y59"
  }
}, {
  d: [".fxoiby5 .fui-Icon-filled{display:inline;}", ".f15q0o9g .fui-Icon-regular{display:none;}", ".f1ly1fcm{border-top-color:var(--colorNeutralStroke1Selected);}", ".fi8bssc{border-right-color:var(--colorNeutralStroke1Selected);}", ".fj6btzu{border-left-color:var(--colorNeutralStroke1Selected);}", ".f1s9tnsa{border-bottom-color:var(--colorNeutralStroke1Selected);}", ".fgx37oo{border-top-width:var(--strokeWidthThicker);}", ".f130t4y6{border-right-width:var(--strokeWidthThicker);}", ".f1efpmoh{border-left-width:var(--strokeWidthThicker);}", ".fv51ejd{border-bottom-width:var(--strokeWidthThicker);}", ".f14nttnl{color:var(--colorNeutralForeground1Selected);}", ".f8w4g0q{background-color:var(--colorBrandBackgroundSelected);}", ".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}", ".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1eryozh{color:var(--colorNeutralForeground2Selected);}", ".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}", ".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"]
});
var useIconExpandedStyles = __styles2({
  outline: {
    sj55zd: "f14nttnl"
  },
  primary: {},
  secondary: {
    sj55zd: "f14nttnl"
  },
  subtle: {
    sj55zd: "f1qj7y59"
  },
  transparent: {
    sj55zd: "f1qj7y59"
  },
  highContrast: {
    ze5xyy: "f4xjyn1"
  }
}, {
  d: [".f14nttnl{color:var(--colorNeutralForeground1Selected);}", ".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"],
  m: [["@media (forced-colors: active){.f4xjyn1:hover{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useMenuIconStyles = __styles2({
  base: {
    Bg96gwp: "fez10in"
  },
  small: {
    Be2twd7: "f1ugzwwg",
    Bqenvij: "fvblgha",
    Bg96gwp: "fwrc4pm",
    a9b677: "frx94fk"
  },
  medium: {
    Be2twd7: "f1ugzwwg",
    Bqenvij: "fvblgha",
    Bg96gwp: "fwrc4pm",
    a9b677: "frx94fk"
  },
  large: {
    Be2twd7: "f4ybsrx",
    Bqenvij: "fd461yt",
    Bg96gwp: "faaz57k",
    a9b677: "fjw5fx7"
  },
  notIconOnly: {
    Frg6f3: ["fbyavb5", "fm0x6gh"]
  }
}, {
  d: [".fez10in{line-height:0;}", ".f1ugzwwg{font-size:12px;}", ".fvblgha{height:12px;}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".frx94fk{width:12px;}", ".f4ybsrx{font-size:16px;}", ".fd461yt{height:16px;}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fjw5fx7{width:16px;}", ".fbyavb5{margin-left:var(--spacingHorizontalXS);}", ".fm0x6gh{margin-right:var(--spacingHorizontalXS);}"]
});
var useMenuButtonStyles_unstable = (state) => {
  "use no memo";
  const rootExpandedStyles = useRootExpandedStyles();
  const iconExpandedStyles = useIconExpandedStyles();
  const menuIconStyles = useMenuIconStyles();
  state.root.className = mergeClasses(menuButtonClassNames.root, state.root["aria-expanded"] && rootExpandedStyles.base, state.root["aria-expanded"] && rootExpandedStyles[state.appearance], state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(menuButtonClassNames.icon, state.root["aria-expanded"] && iconExpandedStyles[state.appearance] && iconExpandedStyles.highContrast, state.icon.className);
  }
  if (state.menuIcon) {
    state.menuIcon.className = mergeClasses(menuButtonClassNames.menuIcon, menuIconStyles.base, menuIconStyles[state.size], !state.iconOnly && menuIconStyles.notIconOnly, state.menuIcon.className);
  }
  useButtonStyles_unstable({
    ...state,
    iconPosition: "before"
  });
  return state;
};

// node_modules/@fluentui/react-button/lib/components/MenuButton/MenuButton.js
var MenuButton = React142.forwardRef((props, ref) => {
  const state = useMenuButton_unstable(props, ref);
  useMenuButtonStyles_unstable(state);
  useCustomStyleHook("useMenuButtonStyles_unstable")(state);
  return renderMenuButton_unstable(state);
});
MenuButton.displayName = "MenuButton";

// node_modules/@fluentui/react-button/lib/components/SplitButton/SplitButton.js
var React144 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/SplitButton/renderSplitButton.js
var renderSplitButton_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.primaryActionButton && jsx(state.primaryActionButton, {}),
      state.menuButton && jsx(state.menuButton, {})
    ]
  });
};

// node_modules/@fluentui/react-button/lib/components/SplitButton/useSplitButton.js
var React143 = __toESM(require_react());
var useSplitButton_unstable = (props, ref) => {
  const { appearance = "secondary", children: children2, disabled = false, disabledFocusable = false, icon, iconPosition = "before", menuButton: menuButton2, menuIcon, primaryActionButton, shape = "rounded", size: size3 = "medium" } = props;
  const baseId = useId2("splitButton-");
  const menuButtonShorthand = slot_exports.optional(menuButton2, {
    defaultProps: {
      appearance,
      disabled,
      disabledFocusable,
      menuIcon,
      shape,
      size: size3
    },
    renderByDefault: true,
    elementType: MenuButton
  });
  const primaryActionButtonShorthand = slot_exports.optional(primaryActionButton, {
    defaultProps: {
      appearance,
      children: children2,
      disabled,
      disabledFocusable,
      icon,
      iconPosition,
      id: baseId + "__primaryActionButton",
      shape,
      size: size3
    },
    renderByDefault: true,
    elementType: Button
  });
  if (menuButtonShorthand && primaryActionButtonShorthand && !menuButtonShorthand["aria-label"] && !menuButtonShorthand["aria-labelledby"]) {
    menuButtonShorthand["aria-labelledby"] = primaryActionButtonShorthand.id;
  }
  return {
    // Props passed at the top-level
    appearance,
    disabled,
    disabledFocusable,
    iconPosition,
    shape,
    size: size3,
    components: {
      root: "div",
      menuButton: MenuButton,
      primaryActionButton: Button
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    menuButton: menuButtonShorthand,
    primaryActionButton: primaryActionButtonShorthand
  };
};

// node_modules/@fluentui/react-button/lib/components/SplitButton/useSplitButtonStyles.styles.js
var splitButtonClassNames = {
  root: "fui-SplitButton",
  menuButton: "fui-SplitButton__menuButton",
  primaryActionButton: "fui-SplitButton__primaryActionButton"
};
var useFocusStyles = __styles2({
  primaryActionButton: {
    B6xbmo0: ["f1x37qnr", "f1um7c6d"],
    kdpuga: ["fn4c73s", "f6pwzcr"]
  },
  menuButton: {
    lbo84a: ["frrbwxo", "f1rgcpbv"],
    dm238s: ["f1um7c6d", "f1x37qnr"],
    Bw81rd7: ["f6pwzcr", "fn4c73s"]
  }
}, {
  d: [".f1x37qnr[data-fui-focus-visible]{border-top-right-radius:0;}", ".f1um7c6d[data-fui-focus-visible]{border-top-left-radius:0;}", ".fn4c73s[data-fui-focus-visible]{border-bottom-right-radius:0;}", ".f6pwzcr[data-fui-focus-visible]{border-bottom-left-radius:0;}", ".frrbwxo[data-fui-focus-visible]{border-left-width:0;}", ".f1rgcpbv[data-fui-focus-visible]{border-right-width:0;}"]
});
var useRootStyles5 = __styles2({
  base: {
    mc9l5x: "ftuwxu6",
    Brf1p80: "fsxf2b5",
    qhf8xq: "f10pi13n",
    ha4doy: "fmrv4ls",
    kn2xc0: ["f14uur2j", "fc1btbj"],
    Bs76p8a: ["fye5tvs", "fc597qq"],
    cuxpm9: ["f1e8brtx", "fr36rk3"],
    Biffepf: ["fxp12j1", "f1m6nt2y"],
    Defnvf: ["fr7y8no", "f1dn0c6m"],
    z0pv9t: "f1b65x5h"
  },
  outline: {},
  primary: {
    B1l9wao: ["f4rm5b0", "f1tuwo13"],
    lcnrd8: ["fdwdeeo", "f1ezdslh"],
    Brbpp8k: ["fckzjn8", "f8ohr2i"],
    Bcsxniv: ["ff0tx2l", "fnrj3rw"],
    tl7e51: ["f3jppgx", "f1m2s8ie"],
    mba178: ["f96h41g", "fdxf0pi"]
  },
  secondary: {},
  subtle: {
    B1l9wao: ["f16kf41h", "fxiafvi"],
    lcnrd8: ["ffl6mx9", "f1t5sw6t"],
    Brbpp8k: ["f1t42bc8", "fsw5hli"]
  },
  transparent: {
    B1l9wao: ["f16kf41h", "fxiafvi"],
    lcnrd8: ["ffl6mx9", "f1t5sw6t"],
    Brbpp8k: ["f1t42bc8", "fsw5hli"]
  },
  circular: {},
  rounded: {},
  square: {},
  disabled: {
    B1l9wao: ["f10xrnr8", "f15nylwb"],
    lcnrd8: ["f11fwhjz", "f18vtcsx"],
    Brbpp8k: ["f31btwb", "fzgm9gq"]
  },
  disabledHighContrast: {
    Bcsxniv: ["fj2q5vi", "f13tct40"],
    tl7e51: ["fb2mzc7", "f179dhpp"],
    mba178: ["f1ma39qa", "f1nzpdru"]
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".fsxf2b5{justify-content:stretch;}", ".f10pi13n{position:relative;}", ".fmrv4ls{vertical-align:middle;}", ".f14uur2j .fui-SplitButton__primaryActionButton{border-top-right-radius:0;}", ".fc1btbj .fui-SplitButton__primaryActionButton{border-top-left-radius:0;}", ".fye5tvs .fui-SplitButton__primaryActionButton{border-bottom-right-radius:0;}", ".fc597qq .fui-SplitButton__primaryActionButton{border-bottom-left-radius:0;}", ".f1e8brtx .fui-SplitButton__menuButton{border-left-width:0;}", ".fr36rk3 .fui-SplitButton__menuButton{border-right-width:0;}", ".fxp12j1 .fui-SplitButton__menuButton{border-top-left-radius:0;}", ".f1m6nt2y .fui-SplitButton__menuButton{border-top-right-radius:0;}", ".fr7y8no .fui-SplitButton__menuButton{border-bottom-left-radius:0;}", ".f1dn0c6m .fui-SplitButton__menuButton{border-bottom-right-radius:0;}", ".f1b65x5h .fui-SplitButton__menuButton{min-width:24px;}", ".f4rm5b0 .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeOnBrand);}", ".f1tuwo13 .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeOnBrand);}", ".f16kf41h .fui-SplitButton__primaryActionButton{border-right-color:var(--colorTransparentBackground);}", ".fxiafvi .fui-SplitButton__primaryActionButton{border-left-color:var(--colorTransparentBackground);}", ".f10xrnr8 .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f15nylwb .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeDisabled);}"],
  h: [".fdwdeeo:hover .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeOnBrand);}", ".f1ezdslh:hover .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeOnBrand);}", ".fckzjn8:hover:active .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeOnBrand);}", ".f8ohr2i:hover:active .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeOnBrand);}", ".ffl6mx9:hover .fui-SplitButton__primaryActionButton{border-right-color:var(--colorTransparentBackgroundHover);}", ".f1t5sw6t:hover .fui-SplitButton__primaryActionButton{border-left-color:var(--colorTransparentBackgroundHover);}", ".f1t42bc8:hover:active .fui-SplitButton__primaryActionButton{border-right-color:var(--colorTransparentBackgroundPressed);}", ".fsw5hli:hover:active .fui-SplitButton__primaryActionButton{border-left-color:var(--colorTransparentBackgroundPressed);}", ".f11fwhjz:hover .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f18vtcsx:hover .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f31btwb:hover:active .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fzgm9gq:hover:active .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeDisabled);}"],
  m: [["@media (forced-colors: active){.ff0tx2l .fui-SplitButton__primaryActionButton{border-right-color:HighlightText;}.fnrj3rw .fui-SplitButton__primaryActionButton{border-left-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1m2s8ie:hover .fui-SplitButton__primaryActionButton{border-left-color:Highlight;}.f3jppgx:hover .fui-SplitButton__primaryActionButton{border-right-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f96h41g:hover:active .fui-SplitButton__primaryActionButton{border-right-color:Highlight;}.fdxf0pi:hover:active .fui-SplitButton__primaryActionButton{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f13tct40 .fui-SplitButton__primaryActionButton{border-left-color:GrayText;}.fj2q5vi .fui-SplitButton__primaryActionButton{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f179dhpp:hover .fui-SplitButton__primaryActionButton{border-left-color:GrayText;}.fb2mzc7:hover .fui-SplitButton__primaryActionButton{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ma39qa:hover:active .fui-SplitButton__primaryActionButton{border-right-color:GrayText;}.f1nzpdru:hover:active .fui-SplitButton__primaryActionButton{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useSplitButtonStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles5();
  const focusStyles = useFocusStyles();
  const {
    appearance,
    disabled,
    disabledFocusable
  } = state;
  state.root.className = mergeClasses(splitButtonClassNames.root, rootStyles.base, appearance && rootStyles[appearance], (disabled || disabledFocusable) && rootStyles.disabled, (disabled || disabledFocusable) && rootStyles.disabledHighContrast, state.root.className);
  if (state.menuButton) {
    state.menuButton.className = mergeClasses(splitButtonClassNames.menuButton, focusStyles.menuButton, state.menuButton.className);
  }
  if (state.primaryActionButton) {
    state.primaryActionButton.className = mergeClasses(splitButtonClassNames.primaryActionButton, focusStyles.primaryActionButton, state.primaryActionButton.className);
  }
  return state;
};

// node_modules/@fluentui/react-button/lib/components/SplitButton/SplitButton.js
var SplitButton = React144.forwardRef((props, ref) => {
  const state = useSplitButton_unstable(props, ref);
  useSplitButtonStyles_unstable(state);
  useCustomStyleHook("useSplitButtonStyles_unstable")(state);
  return renderSplitButton_unstable(state);
});
SplitButton.displayName = "SplitButton";

// node_modules/@fluentui/react-button/lib/components/ToggleButton/ToggleButton.js
var React147 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/ToggleButton/useToggleButton.js
var React146 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/utils/useToggleState.js
var React145 = __toESM(require_react());
function useToggleState(props, state) {
  const { checked, defaultChecked, disabled, disabledFocusable } = props;
  const { onClick, role } = state.root;
  const [checkedValue, setCheckedValue] = useControllableState({
    state: checked,
    defaultState: defaultChecked,
    initialState: false
  });
  const isCheckboxTypeRole = role === "menuitemcheckbox" || role === "checkbox";
  const onToggleClick = React145.useCallback((ev) => {
    if (!disabled && !disabledFocusable) {
      if (ev.defaultPrevented) {
        return;
      }
      setCheckedValue(!checkedValue);
    }
  }, [
    checkedValue,
    disabled,
    disabledFocusable,
    setCheckedValue
  ]);
  return {
    ...state,
    checked: checkedValue,
    root: {
      ...state.root,
      [isCheckboxTypeRole ? "aria-checked" : "aria-pressed"]: checkedValue,
      onClick: useEventCallback(mergeCallbacks(onClick, onToggleClick))
    }
  };
}

// node_modules/@fluentui/react-button/lib/components/ToggleButton/useToggleButton.js
var useToggleButton_unstable = (props, ref) => {
  const buttonState = useButton_unstable(props, ref);
  return useToggleState(props, buttonState);
};

// node_modules/@fluentui/react-button/lib/components/ToggleButton/useToggleButtonStyles.styles.js
var toggleButtonClassNames = {
  root: "fui-ToggleButton",
  icon: "fui-ToggleButton__icon"
};
var useRootCheckedStyles = __styles2({
  base: {
    De3pzq: "f1nfm20t",
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"],
    sj55zd: "f14nttnl",
    B4j52fo: "f192inf7",
    Bekrc4i: ["f5tn483", "f1ojsxk5"],
    Bn0qgzm: "f1vxd6vx",
    ibv6hh: ["f1ojsxk5", "f5tn483"],
    D0sxk3: "fxoiby5",
    t6yez3: "f15q0o9g",
    Jwef8y: "f1knas48",
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "f1xlaoq0",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    Bi91k9c: "feu1g3u",
    iro3zm: "f141de4g",
    b661bw: "f11v6sdu",
    Bk6r4ia: ["f9yn8i4", "f1ajwf28"],
    B9zn80p: "f1uwu36w",
    Bpld233: ["f1ajwf28", "f9yn8i4"],
    B2d53fq: "f9olfzr"
  },
  highContrast: {
    Bsw6fvg: "f1rirnrt",
    Bjwas2f: "f132fbg1",
    Bn1d65q: ["f1ene5x0", "fzbc999"],
    Bxeuatn: "f6jgcol",
    n51gp8: ["fzbc999", "f1ene5x0"],
    Bbusuzp: "f1lkg8j3",
    ycbfsm: "fkc42ay",
    Bqrx1nm: "fq7113v",
    pgvf35: "ff1wgvm",
    Bh7lczh: ["fiob0tu", "f1x4h75k"],
    dpv3f4: "f1j6scgf",
    Bpnjhaq: ["f1x4h75k", "fiob0tu"],
    ze5xyy: "f4xjyn1",
    g2kj27: "fbgcvur",
    Bf756sw: "f1ks1yx8",
    Bow2dr7: ["f1o6qegi", "fmxjhhp"],
    Bvhedfk: "fcnxywj",
    Gye4lf: ["fmxjhhp", "f1o6qegi"],
    pc6evw: "f9ddjv3",
    F3bflw: 0,
    mxns5l: 0,
    B0tp99d: 0,
    l9kbep: 0,
    Bg4echp: 0,
    o3nasb: 0,
    B55dcl7: 0,
    By5cl00: 0,
    Bnk1xnq: 0,
    gdbnj: 0,
    Bw5jppy: 0,
    B8jyv7h: 0,
    ka51wi: 0,
    G867l3: 0,
    abbn9y: 0,
    Btyszwp: 0,
    Bi9mhhg: "f1mh9o5k",
    B7d2ofm: "fkom8lu"
  },
  outline: {
    De3pzq: "f1q9pm1r",
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"],
    B4j52fo: "fgx37oo",
    Bekrc4i: ["f130t4y6", "f1efpmoh"],
    Bn0qgzm: "fv51ejd",
    ibv6hh: ["f1efpmoh", "f130t4y6"],
    Jwef8y: "fjxutwb",
    iro3zm: "fwiml72",
    B8q5s1w: "fcaw57c",
    Bci5o5g: ["fpwd27e", "f1999bjr"],
    n8qw10: "f1hi52o4",
    Bdrgwmp: ["f1999bjr", "fpwd27e"]
  },
  primary: {
    De3pzq: "f8w4g0q",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    sj55zd: "f1phragk",
    Jwef8y: "f15wkkf3",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bi91k9c: "f1rq72xc",
    iro3zm: "fnp9lpt",
    b661bw: "f1h0usnq",
    Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
    B9zn80p: "f16h9ulv",
    Bpld233: ["fx2bmrt", "fs4ktlq"],
    B2d53fq: "f1d6v5y2"
  },
  secondary: {},
  subtle: {
    De3pzq: "fq5gl1p",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    sj55zd: "f1eryozh",
    Jwef8y: "f1t94bn6",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bi91k9c: "fnwyq0v",
    iro3zm: "fsv2rcd",
    b661bw: "f1h0usnq",
    Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
    B9zn80p: "f16h9ulv",
    Bpld233: ["fx2bmrt", "fs4ktlq"],
    B2d53fq: "f1omzyqd"
  },
  transparent: {
    De3pzq: "f1q9pm1r",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    sj55zd: "f1qj7y59",
    Jwef8y: "fjxutwb",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bi91k9c: "f139oj5f",
    iro3zm: "fwiml72",
    b661bw: "f1h0usnq",
    Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
    B9zn80p: "f16h9ulv",
    Bpld233: ["fx2bmrt", "fs4ktlq"],
    B2d53fq: "f1fg1p5m"
  }
}, {
  d: [".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}", ".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", ".f14nttnl{color:var(--colorNeutralForeground1Selected);}", ".f192inf7{border-top-width:var(--strokeWidthThin);}", ".f5tn483{border-right-width:var(--strokeWidthThin);}", ".f1ojsxk5{border-left-width:var(--strokeWidthThin);}", ".f1vxd6vx{border-bottom-width:var(--strokeWidthThin);}", ".fxoiby5 .fui-Icon-filled{display:inline;}", ".f15q0o9g .fui-Icon-regular{display:none;}", ".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}", ".fgx37oo{border-top-width:var(--strokeWidthThicker);}", ".f130t4y6{border-right-width:var(--strokeWidthThicker);}", ".f1efpmoh{border-left-width:var(--strokeWidthThicker);}", ".fv51ejd{border-bottom-width:var(--strokeWidthThicker);}", ".fcaw57c[data-fui-focus-visible]{border-top-color:var(--colorNeutralStroke1);}", ".fpwd27e[data-fui-focus-visible]{border-right-color:var(--colorNeutralStroke1);}", ".f1999bjr[data-fui-focus-visible]{border-left-color:var(--colorNeutralStroke1);}", ".f1hi52o4[data-fui-focus-visible]{border-bottom-color:var(--colorNeutralStroke1);}", ".f8w4g0q{background-color:var(--colorBrandBackgroundSelected);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1eryozh{color:var(--colorNeutralForeground2Selected);}", ".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"],
  h: [".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}", ".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1xlaoq0:hover{border-bottom-color:var(--colorNeutralStroke1Hover);}", ".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f141de4g:hover:active{background-color:var(--colorNeutralBackground1Pressed);}", ".f11v6sdu:hover:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f9yn8i4:hover:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f1ajwf28:hover:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1uwu36w:hover:active{border-bottom-color:var(--colorNeutralStroke1Pressed);}", ".f9olfzr:hover:active{color:var(--colorNeutralForeground1Pressed);}", ".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".fwiml72:hover:active{background-color:var(--colorTransparentBackgroundPressed);}", ".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}", ".fnp9lpt:hover:active{background-color:var(--colorBrandBackgroundPressed);}", ".f1h0usnq:hover:active{border-top-color:transparent;}", ".fs4ktlq:hover:active{border-right-color:transparent;}", ".fx2bmrt:hover:active{border-left-color:transparent;}", ".f16h9ulv:hover:active{border-bottom-color:transparent;}", ".f1d6v5y2:hover:active{color:var(--colorNeutralForegroundOnBrand);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".fsv2rcd:hover:active{background-color:var(--colorSubtleBackgroundPressed);}", ".f1omzyqd:hover:active{color:var(--colorNeutralForeground2Pressed);}", ".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}", ".f1fg1p5m:hover:active{color:var(--colorNeutralForeground2BrandPressed);}"],
  m: [["@media (forced-colors: active){.f1rirnrt{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f132fbg1{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ene5x0{border-right-color:Highlight;}.fzbc999{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f6jgcol{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1lkg8j3{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fkc42ay{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fq7113v:hover{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.ff1wgvm:hover{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1x4h75k:hover{border-left-color:Highlight;}.fiob0tu:hover{border-right-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1j6scgf:hover{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f4xjyn1:hover{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fbgcvur:hover:active{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ks1yx8:hover:active{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1o6qegi:hover:active{border-right-color:Highlight;}.fmxjhhp:hover:active{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fcnxywj:hover:active{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f9ddjv3:hover:active{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1mh9o5k:focus{border:1px solid HighlightText;}}", {
    p: -2,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fkom8lu:focus{outline-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useRootDisabledStyles2 = __styles2({
  base: {
    De3pzq: "f1bg9a2p",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    sj55zd: "f1s2aq7o",
    Jwef8y: "f1falr9n",
    Bgoe8wy: "f12mpcsy",
    Bwzppfd: ["f1gwvigk", "f18rmfxp"],
    oetu4i: "f1jnshp0",
    gg5e9n: ["f18rmfxp", "f1gwvigk"],
    Bi91k9c: "fvgxktp",
    iro3zm: "f1t6o4dc",
    b661bw: "f10ztigi",
    Bk6r4ia: ["f1ft5sdu", "f1gzf82w"],
    B9zn80p: "f12zbtn2",
    Bpld233: ["f1gzf82w", "f1ft5sdu"],
    B2d53fq: "fcvwxyo"
  },
  outline: {},
  primary: {
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    b661bw: "f1h0usnq",
    Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
    B9zn80p: "f16h9ulv",
    Bpld233: ["fx2bmrt", "fs4ktlq"]
  },
  secondary: {},
  subtle: {
    De3pzq: "f1c21dwh",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    Jwef8y: "fjxutwb",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    iro3zm: "fwiml72",
    b661bw: "f1h0usnq",
    Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
    B9zn80p: "f16h9ulv",
    Bpld233: ["fx2bmrt", "fs4ktlq"]
  },
  transparent: {
    De3pzq: "f1c21dwh",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    Jwef8y: "fjxutwb",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    iro3zm: "fwiml72",
    b661bw: "f1h0usnq",
    Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
    B9zn80p: "f16h9ulv",
    Bpld233: ["fx2bmrt", "fs4ktlq"]
  }
}, {
  d: [".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}"],
  h: [".f1falr9n:hover{background-color:var(--colorNeutralBackgroundDisabled);}", ".f12mpcsy:hover{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1gwvigk:hover{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f18rmfxp:hover{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1jnshp0:hover{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".f1t6o4dc:hover:active{background-color:var(--colorNeutralBackgroundDisabled);}", ".f10ztigi:hover:active{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1ft5sdu:hover:active{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f1gzf82w:hover:active{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f12zbtn2:hover:active{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fcvwxyo:hover:active{color:var(--colorNeutralForegroundDisabled);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".f1h0usnq:hover:active{border-top-color:transparent;}", ".fs4ktlq:hover:active{border-right-color:transparent;}", ".fx2bmrt:hover:active{border-left-color:transparent;}", ".f16h9ulv:hover:active{border-bottom-color:transparent;}", ".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".fwiml72:hover:active{background-color:var(--colorTransparentBackgroundPressed);}"]
});
var useIconCheckedStyles = __styles2({
  subtleOrTransparent: {
    sj55zd: "f1qj7y59"
  },
  highContrast: {
    ycbfsm: "fg4l7m0"
  }
}, {
  d: [".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"],
  m: [["@media (forced-colors: active){.fg4l7m0{forced-color-adjust:auto;}}", {
    m: "(forced-colors: active)"
  }]]
});
var usePrimaryHighContrastStyles = __styles2({
  base: {
    Bsw6fvg: "f4lkoma",
    Bjwas2f: "f1bauw5b",
    Bn1d65q: ["fbpknfk", "fedl69w"],
    Bxeuatn: "f15s25nd",
    n51gp8: ["fedl69w", "fbpknfk"],
    Bbusuzp: "f1e4kh5",
    ycbfsm: "fg4l7m0"
  },
  disabled: {
    Bjwas2f: "fg455y9",
    Bn1d65q: ["f1rvyvqg", "f14g86mu"],
    Bxeuatn: "f1cwzwz",
    n51gp8: ["f14g86mu", "f1rvyvqg"],
    Bbusuzp: "f1dcs8yz",
    G867l3: "fjwq6ea",
    gdbnj: ["f1lr3nhc", "f1mbxvi6"],
    mxns5l: "fn5gmvv",
    o3nasb: ["f1mbxvi6", "f1lr3nhc"]
  }
}, {
  m: [["@media (forced-colors: active){.f4lkoma{background-color:ButtonFace;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1bauw5b{border-top-color:ButtonBorder;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fbpknfk{border-right-color:ButtonBorder;}.fedl69w{border-left-color:ButtonBorder;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f15s25nd{border-bottom-color:ButtonBorder;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1e4kh5{color:ButtonText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fg4l7m0{forced-color-adjust:auto;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fjwq6ea:focus{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1lr3nhc:focus{border-right-color:GrayText;}.f1mbxvi6:focus{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fn5gmvv:focus{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useToggleButtonStyles_unstable = (state) => {
  "use no memo";
  const rootCheckedStyles = useRootCheckedStyles();
  const rootDisabledStyles = useRootDisabledStyles2();
  const iconCheckedStyles = useIconCheckedStyles();
  const primaryHighContrastStyles = usePrimaryHighContrastStyles();
  const {
    appearance,
    checked,
    disabled,
    disabledFocusable
  } = state;
  state.root.className = mergeClasses(
    toggleButtonClassNames.root,
    // Primary high contrast styles
    appearance === "primary" && primaryHighContrastStyles.base,
    appearance === "primary" && (disabled || disabledFocusable) && primaryHighContrastStyles.disabled,
    // Checked styles
    checked && rootCheckedStyles.base,
    checked && rootCheckedStyles.highContrast,
    appearance && checked && rootCheckedStyles[appearance],
    // Disabled styles
    (disabled || disabledFocusable) && rootDisabledStyles.base,
    appearance && (disabled || disabledFocusable) && rootDisabledStyles[appearance],
    // User provided class name
    state.root.className
  );
  if (state.icon) {
    state.icon.className = mergeClasses(toggleButtonClassNames.icon, checked && (appearance === "subtle" || appearance === "transparent") && iconCheckedStyles.subtleOrTransparent, iconCheckedStyles.highContrast, state.icon.className);
  }
  useButtonStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-button/lib/components/ToggleButton/ToggleButton.js
var ToggleButton = React147.forwardRef((props, ref) => {
  const state = useToggleButton_unstable(props, ref);
  useToggleButtonStyles_unstable(state);
  useCustomStyleHook("useToggleButtonStyles_unstable")(state);
  return renderButton_unstable(state);
});
ToggleButton.displayName = "ToggleButton";

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/Checkbox.js
var React155 = __toESM(require_react());

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/useCheckbox.js
var React154 = __toESM(require_react());

// node_modules/@fluentui/react-field/lib/components/Field/Field.js
var React153 = __toESM(require_react());

// node_modules/@fluentui/react-field/lib/contexts/FieldContext.js
var React148 = __toESM(require_react());
var FieldContext = React148.createContext(void 0);
var FieldContextProvider = FieldContext.Provider;
var useFieldContext_unstable = () => React148.useContext(FieldContext);

// node_modules/@fluentui/react-field/lib/contexts/useFieldContextValues.js
var React149 = __toESM(require_react());
var useFieldContextValues_unstable = (state) => {
  var _state_label, _state_label1, _state_validationMessage, _state_hint;
  const { generatedControlId, orientation, required, size: size3, validationState } = state;
  const labelFor = (_state_label = state.label) === null || _state_label === void 0 ? void 0 : _state_label.htmlFor;
  const labelId = (_state_label1 = state.label) === null || _state_label1 === void 0 ? void 0 : _state_label1.id;
  const validationMessageId = (_state_validationMessage = state.validationMessage) === null || _state_validationMessage === void 0 ? void 0 : _state_validationMessage.id;
  const hintId = (_state_hint = state.hint) === null || _state_hint === void 0 ? void 0 : _state_hint.id;
  const field = React149.useMemo(() => ({
    generatedControlId,
    hintId,
    labelFor,
    labelId,
    orientation,
    required,
    size: size3,
    validationMessageId,
    validationState
  }), [
    generatedControlId,
    hintId,
    labelFor,
    labelId,
    orientation,
    required,
    size3,
    validationMessageId,
    validationState
  ]);
  return {
    field
  };
};

// node_modules/@fluentui/react-field/lib/contexts/useFieldControlProps.js
function useFieldControlProps_unstable(props, options) {
  return getFieldControlProps(useFieldContext_unstable(), props, options);
}
function getFieldControlProps(context, props, options) {
  if (!context) {
    return props;
  }
  props = {
    ...props
  };
  const { generatedControlId, hintId, labelFor, labelId, required, validationMessageId, validationState } = context;
  if (generatedControlId) {
    var _props;
    var _id;
    (_id = (_props = props).id) !== null && _id !== void 0 ? _id : _props.id = generatedControlId;
  }
  if (labelId && (!(options === null || options === void 0 ? void 0 : options.supportsLabelFor) || labelFor !== props.id)) {
    var _props1, _arialabelledby;
    var _;
    (_ = (_props1 = props)[_arialabelledby = "aria-labelledby"]) !== null && _ !== void 0 ? _ : _props1[_arialabelledby] = labelId;
  }
  if (validationMessageId || hintId) {
    props["aria-describedby"] = [
      validationMessageId,
      hintId,
      props === null || props === void 0 ? void 0 : props["aria-describedby"]
    ].filter(Boolean).join(" ");
  }
  if (validationState === "error") {
    var _props2, _ariainvalid;
    var _1;
    (_1 = (_props2 = props)[_ariainvalid = "aria-invalid"]) !== null && _1 !== void 0 ? _1 : _props2[_ariainvalid] = true;
  }
  if (required) {
    if (options === null || options === void 0 ? void 0 : options.supportsRequired) {
      var _props3;
      var _required;
      (_required = (_props3 = props).required) !== null && _required !== void 0 ? _required : _props3.required = true;
    } else {
      var _props4, _ariarequired;
      var _2;
      (_2 = (_props4 = props)[_ariarequired = "aria-required"]) !== null && _2 !== void 0 ? _2 : _props4[_ariarequired] = true;
    }
  }
  if (options === null || options === void 0 ? void 0 : options.supportsSize) {
    var _props5;
    var _size;
    (_size = (_props5 = props).size) !== null && _size !== void 0 ? _size : _props5.size = context.size;
  }
  return props;
}

// node_modules/@fluentui/react-field/lib/components/Field/renderField.js
var renderField_unstable = (state, contextValues) => {
  assertSlots(state);
  let { children: children2 } = state;
  if (typeof children2 === "function") {
    children2 = children2(getFieldControlProps(contextValues.field) || {});
  }
  return jsx(FieldContextProvider, {
    value: contextValues === null || contextValues === void 0 ? void 0 : contextValues.field,
    children: jsxs(state.root, {
      children: [
        state.label && jsx(state.label, {}),
        children2,
        state.validationMessage && jsxs(state.validationMessage, {
          children: [
            state.validationMessageIcon && jsx(state.validationMessageIcon, {}),
            state.validationMessage.children
          ]
        }),
        state.hint && jsx(state.hint, {})
      ]
    })
  });
};

// node_modules/@fluentui/react-field/lib/components/Field/useField.js
var React152 = __toESM(require_react());

// node_modules/@fluentui/react-label/lib/components/Label/Label.js
var React151 = __toESM(require_react());

// node_modules/@fluentui/react-label/lib/components/Label/useLabel.js
var React150 = __toESM(require_react());
var useLabel_unstable = (props, ref) => {
  const { disabled = false, required = false, weight = "regular", size: size3 = "medium" } = props;
  return {
    disabled,
    required: slot_exports.optional(required === true ? "*" : required || void 0, {
      defaultProps: {
        "aria-hidden": "true"
      },
      elementType: "span"
    }),
    weight,
    size: size3,
    components: {
      root: "label",
      required: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("label", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLLabelElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "label"
    })
  };
};

// node_modules/@fluentui/react-label/lib/components/Label/renderLabel.js
var renderLabel_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.root.children,
      state.required && jsx(state.required, {})
    ]
  });
};

// node_modules/@fluentui/react-label/lib/components/Label/useLabelStyles.styles.js
var labelClassNames = {
  root: "fui-Label",
  required: "fui-Label__required"
};
var useStyles11 = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    sj55zd: "f19n0e5"
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    Bbusuzp: "f1dcs8yz"
  },
  required: {
    sj55zd: "f1whyuy6",
    uwmqm3: ["fruq291", "f7x41pl"]
  },
  small: {
    Be2twd7: "fy9rknc",
    Bg96gwp: "fwrc4pm"
  },
  medium: {
    Be2twd7: "fkhj508",
    Bg96gwp: "f1i3iumi"
  },
  large: {
    Be2twd7: "fod5ikn",
    Bg96gwp: "faaz57k",
    Bhrd7zp: "fl43uef"
  },
  semibold: {
    Bhrd7zp: "fl43uef"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1whyuy6{color:var(--colorPaletteRedForeground3);}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}"],
  m: [["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useLabelStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles11();
  state.root.className = mergeClasses(labelClassNames.root, styles.root, state.disabled && styles.disabled, styles[state.size], state.weight === "semibold" && styles.semibold, state.root.className);
  if (state.required) {
    state.required.className = mergeClasses(labelClassNames.required, styles.required, state.disabled && styles.disabled, state.required.className);
  }
  return state;
};

// node_modules/@fluentui/react-label/lib/components/Label/Label.js
var Label = React151.forwardRef((props, ref) => {
  const state = useLabel_unstable(props, ref);
  useLabelStyles_unstable(state);
  useCustomStyleHook("useLabelStyles_unstable")(state);
  return renderLabel_unstable(state);
});
Label.displayName = "Label";

// node_modules/@fluentui/react-field/lib/components/Field/useField.js
var validationMessageIcons = {
  error: React152.createElement(ErrorCircle12Filled, null),
  warning: React152.createElement(Warning12Filled, null),
  success: React152.createElement(CheckmarkCircle12Filled, null),
  none: void 0
};
var useField_unstable = (props, ref) => {
  const { children: children2, orientation = "vertical", required = false, validationState = props.validationMessage ? "error" : "none", size: size3 = "medium" } = props;
  const baseId = useId2("field-");
  const generatedControlId = baseId + "__control";
  const root = slot_exports.always(getIntrinsicElementProps(
    "div",
    {
      ...props,
      ref
    },
    /*excludedPropNames:*/
    [
      "children"
    ]
  ), {
    elementType: "div"
  });
  const label = slot_exports.optional(props.label, {
    defaultProps: {
      htmlFor: generatedControlId,
      id: baseId + "__label",
      required,
      size: size3
    },
    elementType: Label
  });
  const validationMessage = slot_exports.optional(props.validationMessage, {
    defaultProps: {
      id: baseId + "__validationMessage",
      role: validationState === "error" || validationState === "warning" ? "alert" : void 0
    },
    elementType: "div"
  });
  const hint = slot_exports.optional(props.hint, {
    defaultProps: {
      id: baseId + "__hint"
    },
    elementType: "div"
  });
  const defaultIcon = validationMessageIcons[validationState];
  const validationMessageIcon = slot_exports.optional(props.validationMessageIcon, {
    renderByDefault: !!defaultIcon,
    defaultProps: {
      children: defaultIcon
    },
    elementType: "span"
  });
  return {
    children: children2,
    generatedControlId,
    orientation,
    required,
    size: size3,
    validationState,
    components: {
      root: "div",
      label: Label,
      validationMessage: "div",
      validationMessageIcon: "span",
      hint: "div"
    },
    root,
    label,
    validationMessageIcon,
    validationMessage,
    hint
  };
};

// node_modules/@fluentui/react-field/lib/components/Field/useFieldStyles.styles.js
var fieldClassNames = {
  root: `fui-Field`,
  label: `fui-Field__label`,
  validationMessage: `fui-Field__validationMessage`,
  validationMessageIcon: `fui-Field__validationMessageIcon`,
  hint: `fui-Field__hint`
};
var useRootStyles6 = __styles2({
  base: {
    mc9l5x: "f13qh94s"
  },
  horizontal: {
    Budl1dq: "f2wwaib",
    wkccdc: "f1645dqt"
  },
  horizontalNoLabel: {
    uwmqm3: ["f15jqgz8", "fggqkej"],
    Budl1dq: "f1c2z91y"
  }
}, {
  d: [".f13qh94s{display:grid;}", ".f2wwaib{grid-template-columns:33% 1fr;}", ".f1645dqt{grid-template-rows:auto auto auto 1fr;}", ".f15jqgz8{padding-left:33%;}", ".fggqkej{padding-right:33%;}", ".f1c2z91y{grid-template-columns:1fr;}"]
});
var useLabelStyles = __styles2({
  vertical: {
    z8tnut: "fclwglc",
    Byoj8tv: "fywfov9",
    jrapky: "fyacil5"
  },
  verticalLarge: {
    z8tnut: "f1sl3k7w",
    Byoj8tv: "f1brlhvm",
    jrapky: "f8l5zjj"
  },
  horizontal: {
    z8tnut: "fp2oml8",
    Byoj8tv: "f1tdddsa",
    t21cq0: ["fkujibs", "f199hnxi"],
    Ijaq50: "f16hsg94",
    nk6f5a: "f1nzqi2z"
  },
  horizontalSmall: {
    z8tnut: "f1ywm7hm",
    Byoj8tv: "f14wxoun"
  },
  horizontalLarge: {
    z8tnut: "f1hqyr95",
    Byoj8tv: "fm4hlj0"
  }
}, {
  d: [".fclwglc{padding-top:var(--spacingVerticalXXS);}", ".fywfov9{padding-bottom:var(--spacingVerticalXXS);}", ".fyacil5{margin-bottom:var(--spacingVerticalXXS);}", ".f1sl3k7w{padding-top:1px;}", ".f1brlhvm{padding-bottom:1px;}", ".f8l5zjj{margin-bottom:var(--spacingVerticalXS);}", ".fp2oml8{padding-top:var(--spacingVerticalSNudge);}", ".f1tdddsa{padding-bottom:var(--spacingVerticalSNudge);}", ".fkujibs{margin-right:var(--spacingHorizontalM);}", ".f199hnxi{margin-left:var(--spacingHorizontalM);}", ".f16hsg94{grid-row-start:1;}", ".f1nzqi2z{grid-row-end:-1;}", ".f1ywm7hm{padding-top:var(--spacingVerticalXS);}", ".f14wxoun{padding-bottom:var(--spacingVerticalXS);}", ".f1hqyr95{padding-top:9px;}", ".fm4hlj0{padding-bottom:9px;}"]
});
var useSecondaryTextBaseClassName = __resetStyles("r5c4z9l", null, [".r5c4z9l{margin-top:var(--spacingVerticalXXS);color:var(--colorNeutralForeground3);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
var useSecondaryTextStyles = __styles2({
  error: {
    sj55zd: "f1hcrxcs"
  },
  withIcon: {
    uwmqm3: ["frawy03", "fg4c52"]
  }
}, {
  d: [".f1hcrxcs{color:var(--colorPaletteRedForeground1);}", ".frawy03{padding-left:calc(12px + var(--spacingHorizontalXS));}", ".fg4c52{padding-right:calc(12px + var(--spacingHorizontalXS));}"]
});
var useValidationMessageIconBaseClassName = __resetStyles("ra7h1uk", "r1rh6bd7", [".ra7h1uk{display:inline-block;font-size:12px;margin-left:calc(-12px - var(--spacingHorizontalXS));margin-right:var(--spacingHorizontalXS);line-height:0;vertical-align:-1px;}", ".r1rh6bd7{display:inline-block;font-size:12px;margin-right:calc(-12px - var(--spacingHorizontalXS));margin-left:var(--spacingHorizontalXS);line-height:0;vertical-align:-1px;}"]);
var useValidationMessageIconStyles = __styles2({
  error: {
    sj55zd: "f1hcrxcs"
  },
  warning: {
    sj55zd: "f1k5f75o"
  },
  success: {
    sj55zd: "ffmvakt"
  }
}, {
  d: [".f1hcrxcs{color:var(--colorPaletteRedForeground1);}", ".f1k5f75o{color:var(--colorPaletteDarkOrangeForeground1);}", ".ffmvakt{color:var(--colorPaletteGreenForeground1);}"]
});
var useFieldStyles_unstable = (state) => {
  "use no memo";
  const {
    validationState,
    size: size3
  } = state;
  const horizontal = state.orientation === "horizontal";
  const rootStyles = useRootStyles6();
  state.root.className = mergeClasses(fieldClassNames.root, rootStyles.base, horizontal && rootStyles.horizontal, horizontal && !state.label && rootStyles.horizontalNoLabel, state.root.className);
  const labelStyles = useLabelStyles();
  if (state.label) {
    state.label.className = mergeClasses(fieldClassNames.label, horizontal && labelStyles.horizontal, horizontal && size3 === "small" && labelStyles.horizontalSmall, horizontal && size3 === "large" && labelStyles.horizontalLarge, !horizontal && labelStyles.vertical, !horizontal && size3 === "large" && labelStyles.verticalLarge, state.label.className);
  }
  const validationMessageIconBaseClassName = useValidationMessageIconBaseClassName();
  const validationMessageIconStyles = useValidationMessageIconStyles();
  if (state.validationMessageIcon) {
    state.validationMessageIcon.className = mergeClasses(fieldClassNames.validationMessageIcon, validationMessageIconBaseClassName, validationState !== "none" && validationMessageIconStyles[validationState], state.validationMessageIcon.className);
  }
  const secondaryTextBaseClassName = useSecondaryTextBaseClassName();
  const secondaryTextStyles = useSecondaryTextStyles();
  if (state.validationMessage) {
    state.validationMessage.className = mergeClasses(fieldClassNames.validationMessage, secondaryTextBaseClassName, validationState === "error" && secondaryTextStyles.error, !!state.validationMessageIcon && secondaryTextStyles.withIcon, state.validationMessage.className);
  }
  if (state.hint) {
    state.hint.className = mergeClasses(fieldClassNames.hint, secondaryTextBaseClassName, state.hint.className);
  }
  return state;
};

// node_modules/@fluentui/react-field/lib/components/Field/Field.js
var Field = React153.forwardRef((props, ref) => {
  const state = useField_unstable(props, ref);
  useFieldStyles_unstable(state);
  useCustomStyleHook("useFieldStyles_unstable")(state);
  const context = useFieldContextValues_unstable(state);
  return renderField_unstable(state, context);
});
Field.displayName = "Field";

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/useCheckbox.js
var useCheckbox_unstable = (props, ref) => {
  "use no memo";
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true
  });
  const { disabled = false, required, shape = "square", size: size3 = "medium", labelPosition = "after", onChange } = props;
  const [checked, setChecked] = useControllableState({
    defaultState: props.defaultChecked,
    state: props.checked,
    initialState: false
  });
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "checked",
      "defaultChecked",
      "size",
      "onChange"
    ]
  });
  const mixed = checked === "mixed";
  const id = useId2("checkbox-", nativeProps.primary.id);
  let checkmarkIcon;
  if (mixed) {
    if (shape === "circular") {
      checkmarkIcon = React154.createElement(CircleFilled, null);
    } else {
      checkmarkIcon = size3 === "large" ? React154.createElement(Square16Filled, null) : React154.createElement(Square12Filled, null);
    }
  } else if (checked) {
    checkmarkIcon = size3 === "large" ? React154.createElement(Checkmark16Filled, null) : React154.createElement(Checkmark12Filled, null);
  }
  const state = {
    shape,
    checked,
    disabled,
    size: size3,
    labelPosition,
    components: {
      root: "span",
      input: "input",
      indicator: "div",
      label: Label
    },
    root: slot_exports.always(props.root, {
      defaultProps: {
        ref: useFocusWithin(),
        ...nativeProps.root
      },
      elementType: "span"
    }),
    input: slot_exports.always(props.input, {
      defaultProps: {
        type: "checkbox",
        id,
        ref,
        checked: checked === true,
        ...nativeProps.primary
      },
      elementType: "input"
    }),
    label: slot_exports.optional(props.label, {
      defaultProps: {
        htmlFor: id,
        disabled,
        required,
        size: "medium"
      },
      elementType: Label
    }),
    indicator: slot_exports.optional(props.indicator, {
      renderByDefault: true,
      defaultProps: {
        "aria-hidden": true,
        children: checkmarkIcon
      },
      elementType: "div"
    })
  };
  state.input.onChange = useEventCallback((ev) => {
    const val = ev.currentTarget.indeterminate ? "mixed" : ev.currentTarget.checked;
    onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
      checked: val
    });
    setChecked(val);
  });
  const inputRef = useMergedRefs(state.input.ref);
  state.input.ref = inputRef;
  useIsomorphicLayoutEffect(() => {
    if (inputRef.current) {
      inputRef.current.indeterminate = mixed;
    }
  }, [
    inputRef,
    mixed
  ]);
  return state;
};

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/renderCheckbox.js
var renderCheckbox_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      state.labelPosition === "before" && state.label && jsx(state.label, {}),
      state.indicator && jsx(state.indicator, {}),
      state.labelPosition === "after" && state.label && jsx(state.label, {})
    ]
  });
};

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/useCheckboxStyles.styles.js
var checkboxClassNames = {
  root: "fui-Checkbox",
  label: "fui-Checkbox__label",
  input: "fui-Checkbox__input",
  indicator: "fui-Checkbox__indicator"
};
var useRootBaseClassName2 = __resetStyles("r1q22k1j", "r18ze4k2", {
  r: [".r1q22k1j{position:relative;display:inline-flex;cursor:pointer;vertical-align:middle;color:var(--colorNeutralForeground3);}", ".r1q22k1j:focus{outline-style:none;}", ".r1q22k1j:focus-visible{outline-style:none;}", ".r1q22k1j[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r1q22k1j[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".r18ze4k2{position:relative;display:inline-flex;cursor:pointer;vertical-align:middle;color:var(--colorNeutralForeground3);}", ".r18ze4k2:focus{outline-style:none;}", ".r18ze4k2:focus-visible{outline-style:none;}", ".r18ze4k2[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.r18ze4k2[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.r1q22k1j[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.r18ze4k2[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useRootStyles7 = __styles2({
  unchecked: {
    Bi91k9c: "f3p8bqa",
    pv5h1i: "fium13f",
    lj723h: "f1r2dosr",
    Hnthvo: "f1729es6"
  },
  checked: {
    sj55zd: "f19n0e5",
    wkncrt: "f35ds98",
    zxk7z7: "f12mnkne",
    Hmsnfy: "fei9a8h",
    e6czan: "fix56y3",
    pv5h1i: "f1bcv2js",
    qbydtz: "f7dr4go",
    Hnthvo: "f1r5cpua"
  },
  mixed: {
    sj55zd: "f19n0e5",
    Hmsnfy: "f1l27tf0",
    zxk7z7: "fcilktj",
    pv5h1i: "f1lphd54",
    Bunfa6h: "f1obkvq7",
    Hnthvo: "f2gmbuh",
    B15ykmv: "f1oy4fa1"
  },
  disabled: {
    Bceei9c: "f158kwzp",
    sj55zd: "f1s2aq7o",
    Hmsnfy: "f1w7mfl5",
    zxk7z7: "fcoafq6",
    Bbusuzp: "f1dcs8yz",
    mrqfp9: "fxb3eh3"
  }
}, {
  h: [".f3p8bqa:hover{color:var(--colorNeutralForeground2);}", ".fium13f:hover{--fui-Checkbox__indicator--borderColor:var(--colorNeutralStrokeAccessibleHover);}", ".fix56y3:hover{--fui-Checkbox__indicator--backgroundColor:var(--colorCompoundBrandBackgroundHover);}", ".f1bcv2js:hover{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandBackgroundHover);}", ".f1lphd54:hover{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandStrokeHover);}", ".f1obkvq7:hover{--fui-Checkbox__indicator--color:var(--colorCompoundBrandForeground1Hover);}"],
  a: [".f1r2dosr:active{color:var(--colorNeutralForeground1);}", ".f1729es6:active{--fui-Checkbox__indicator--borderColor:var(--colorNeutralStrokeAccessiblePressed);}", ".f7dr4go:active{--fui-Checkbox__indicator--backgroundColor:var(--colorCompoundBrandBackgroundPressed);}", ".f1r5cpua:active{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandBackgroundPressed);}", ".f2gmbuh:active{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandStrokePressed);}", ".f1oy4fa1:active{--fui-Checkbox__indicator--color:var(--colorCompoundBrandForeground1Pressed);}"],
  d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".f35ds98{--fui-Checkbox__indicator--backgroundColor:var(--colorCompoundBrandBackground);}", ".f12mnkne{--fui-Checkbox__indicator--color:var(--colorNeutralForegroundInverted);}", ".fei9a8h{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandBackground);}", ".f1l27tf0{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandStroke);}", ".fcilktj{--fui-Checkbox__indicator--color:var(--colorCompoundBrandForeground1);}", ".f158kwzp{cursor:default;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1w7mfl5{--fui-Checkbox__indicator--borderColor:var(--colorNeutralStrokeDisabled);}", ".fcoafq6{--fui-Checkbox__indicator--color:var(--colorNeutralForegroundDisabled);}"],
  m: [["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fxb3eh3{--fui-Checkbox__indicator--color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useInputBaseClassName = __resetStyles("ruo9svu", null, [".ruo9svu{box-sizing:border-box;cursor:inherit;height:100%;margin:0;opacity:0;position:absolute;top:0;width:calc(16px + 2 * var(--spacingHorizontalS));}"]);
var useInputStyles = __styles2({
  before: {
    j35jbq: ["f1e31b4d", "f1vgc2s3"]
  },
  after: {
    oyh7mz: ["f1vgc2s3", "f1e31b4d"]
  },
  large: {
    a9b677: "f1mq5jt6"
  }
}, {
  d: [".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f1mq5jt6{width:calc(20px + 2 * var(--spacingHorizontalS));}"]
});
var useIndicatorBaseClassName = __resetStyles("rl7ci6d", null, [".rl7ci6d{align-self:flex-start;box-sizing:border-box;flex-shrink:0;display:flex;align-items:center;justify-content:center;overflow:hidden;color:var(--fui-Checkbox__indicator--color);background-color:var(--fui-Checkbox__indicator--backgroundColor);border-color:var(--fui-Checkbox__indicator--borderColor, var(--colorNeutralStrokeAccessible));border-style:solid;border-width:var(--strokeWidthThin);border-radius:var(--borderRadiusSmall);margin:var(--spacingVerticalS) var(--spacingHorizontalS);fill:currentColor;pointer-events:none;font-size:12px;height:16px;width:16px;}"]);
var useIndicatorStyles = __styles2({
  large: {
    Be2twd7: "f4ybsrx",
    Bqenvij: "fjamq6b",
    a9b677: "f64fuq3"
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9"
  }
}, {
  d: [".f4ybsrx{font-size:16px;}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }]]
});
var useLabelStyles2 = __styles2({
  base: {
    qb2dma: "f7nlbp4",
    sj55zd: "f1ym3bx4",
    Bceei9c: "fpo1scq",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1f5q0n8"
  },
  before: {
    z189sj: ["f7x41pl", "fruq291"]
  },
  after: {
    uwmqm3: ["fruq291", "f7x41pl"]
  },
  medium: {
    B6of3ja: "fjzwpt6",
    jrapky: "fh6j2fo"
  },
  large: {
    B6of3ja: "f1xlvstr",
    jrapky: "f49ad5g"
  }
}, {
  d: [".f7nlbp4{align-self:center;}", ".f1ym3bx4{color:inherit;}", ".fpo1scq{cursor:inherit;}", [".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".fjzwpt6{margin-top:calc((16px - var(--lineHeightBase300)) / 2);}", ".fh6j2fo{margin-bottom:calc((16px - var(--lineHeightBase300)) / 2);}", ".f1xlvstr{margin-top:calc((20px - var(--lineHeightBase300)) / 2);}", ".f49ad5g{margin-bottom:calc((20px - var(--lineHeightBase300)) / 2);}"]
});
var useCheckboxStyles_unstable = (state) => {
  "use no memo";
  const {
    checked,
    disabled,
    labelPosition,
    shape,
    size: size3
  } = state;
  const rootBaseClassName = useRootBaseClassName2();
  const rootStyles = useRootStyles7();
  state.root.className = mergeClasses(checkboxClassNames.root, rootBaseClassName, disabled ? rootStyles.disabled : checked === "mixed" ? rootStyles.mixed : checked ? rootStyles.checked : rootStyles.unchecked, state.root.className);
  const inputBaseClassName = useInputBaseClassName();
  const inputStyles = useInputStyles();
  state.input.className = mergeClasses(checkboxClassNames.input, inputBaseClassName, size3 === "large" && inputStyles.large, inputStyles[labelPosition], state.input.className);
  const indicatorBaseClassName = useIndicatorBaseClassName();
  const indicatorStyles = useIndicatorStyles();
  if (state.indicator) {
    state.indicator.className = mergeClasses(checkboxClassNames.indicator, indicatorBaseClassName, size3 === "large" && indicatorStyles.large, shape === "circular" && indicatorStyles.circular, state.indicator.className);
  }
  const labelStyles = useLabelStyles2();
  if (state.label) {
    state.label.className = mergeClasses(checkboxClassNames.label, labelStyles.base, labelStyles[size3], labelStyles[labelPosition], state.label.className);
  }
  return state;
};

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/Checkbox.js
var Checkbox = React155.forwardRef((props, ref) => {
  const state = useCheckbox_unstable(props, ref);
  useCheckboxStyles_unstable(state);
  useCustomStyleHook("useCheckboxStyles_unstable")(state);
  return renderCheckbox_unstable(state);
});
Checkbox.displayName = "Checkbox";

// node_modules/@fluentui/react-combobox/lib/contexts/ComboboxContext.js
var ComboboxContext = createContext13({
  activeOption: void 0,
  appearance: "outline",
  focusVisible: false,
  open: false,
  registerOption() {
    return () => void 0;
  },
  selectedOptions: [],
  selectOption() {
  },
  setActiveOption() {
  },
  setOpen() {
  },
  size: "medium"
});
var ComboboxProvider = ComboboxContext.Provider;

// node_modules/@fluentui/react-combobox/lib/contexts/ListboxContext.js
var React156 = __toESM(require_react());
var listboxContextDefaultValue = {
  activeOption: void 0,
  focusVisible: false,
  multiselect: false,
  getOptionById() {
    return void 0;
  },
  getOptionsMatchingValue() {
    return [];
  },
  registerOption() {
    return () => void 0;
  },
  selectedOptions: [],
  onOptionClick() {
  },
  onActiveDescendantChange() {
  },
  selectOption() {
  },
  setActiveOption() {
  }
};
var ListboxContext = createContext13(void 0);
var useListboxContext_unstable = (selector) => useContextSelector(ListboxContext, (ctx = listboxContextDefaultValue) => selector(ctx));
var ListboxProvider = ListboxContext.Provider;

// node_modules/@fluentui/react-combobox/lib/contexts/useComboboxContextValues.js
var React157 = __toESM(require_react());
function useComboboxContextValues(state) {
  const { appearance, open, getOptionById, getOptionsMatchingValue, registerOption, selectedOptions, selectOption, setOpen, size: size3, activeDescendantController, onOptionClick, onActiveDescendantChange } = state;
  const combobox = {
    activeOption: void 0,
    appearance,
    focusVisible: false,
    open,
    registerOption,
    selectedOptions,
    selectOption,
    setActiveOption: () => null,
    setOpen,
    size: size3
  };
  const listbox = {
    activeOption: void 0,
    focusVisible: false,
    getOptionById,
    getOptionsMatchingValue,
    registerOption,
    selectedOptions,
    selectOption,
    setActiveOption: () => null,
    onOptionClick,
    onActiveDescendantChange
  };
  const activeDescendant = React157.useMemo(() => ({
    controller: activeDescendantController
  }), [
    activeDescendantController
  ]);
  return {
    combobox,
    activeDescendant,
    listbox
  };
}

// node_modules/@fluentui/react-combobox/lib/contexts/useListboxContextValues.js
var React158 = __toESM(require_react());
function useListboxContextValues(state) {
  const hasListboxContext = useHasParentContext(ListboxContext);
  const { getOptionById, getOptionsMatchingValue, multiselect, registerOption, selectedOptions, selectOption, activeDescendantController } = state;
  const parentRegisterOption = useListboxContext_unstable((ctx) => ctx.registerOption);
  const onOptionClick = useListboxContext_unstable((ctx) => ctx.onOptionClick);
  const onActiveDescendantChange = useListboxContext_unstable((ctx) => ctx.onActiveDescendantChange);
  const registerOptionValue = hasListboxContext ? parentRegisterOption : registerOption;
  const listbox = {
    activeOption: void 0,
    focusVisible: false,
    getOptionById,
    getOptionsMatchingValue,
    multiselect,
    registerOption: registerOptionValue,
    selectedOptions,
    selectOption,
    setActiveOption: () => void 0,
    onOptionClick,
    onActiveDescendantChange
  };
  const activeDescendant = React158.useMemo(() => ({
    controller: activeDescendantController
  }), [
    activeDescendantController
  ]);
  return {
    listbox,
    activeDescendant
  };
}

// node_modules/@fluentui/react-combobox/lib/components/Listbox/Listbox.js
var React163 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/components/Listbox/useListbox.js
var React162 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/utils/dropdownKeyActions.js
var React159 = __toESM(require_react());
function getDropdownActionFromKey(e, options = {}) {
  const { open = true, multiselect = false } = options;
  const code = e.key;
  const { altKey, ctrlKey, key, metaKey } = e;
  if (key.length === 1 && code !== Space && !altKey && !ctrlKey && !metaKey) {
    return "Type";
  }
  if (!open) {
    if (code === ArrowDown || code === ArrowUp || code === Enter || code === Space) {
      return "Open";
    }
    return "None";
  }
  if (code === ArrowUp && altKey || code === Enter || !multiselect && code === Space) {
    return "CloseSelect";
  }
  if (multiselect && code === Space) {
    return "Select";
  }
  if (code === Escape) {
    return "Close";
  }
  if (code === ArrowDown) {
    return "Next";
  }
  if (code === ArrowUp) {
    return "Previous";
  }
  if (code === Home) {
    return "First";
  }
  if (code === End) {
    return "Last";
  }
  if (code === PageUp) {
    return "PageUp";
  }
  if (code === PageDown) {
    return "PageDown";
  }
  if (code === Tab) {
    return "Tab";
  }
  return "None";
}

// node_modules/@fluentui/react-combobox/lib/utils/useOptionCollection.js
var React160 = __toESM(require_react());
var useOptionCollection = () => {
  const optionsById = React160.useRef(/* @__PURE__ */ new Map());
  const collectionAPI = React160.useMemo(() => {
    const getCount = () => optionsById.current.size;
    const getOptionAtIndex = () => void 0;
    const getIndexOfId = () => -1;
    const getOptionById = (id) => {
      return optionsById.current.get(id);
    };
    const getOptionsMatchingText = (matcher) => {
      return Array.from(optionsById.current.values()).filter(({ text }) => matcher(text));
    };
    const getOptionsMatchingValue = (matcher) => {
      const matches = [];
      for (const option of optionsById.current.values()) {
        if (matcher(option.value)) {
          matches.push(option);
        }
      }
      return matches;
    };
    return {
      getCount,
      getOptionAtIndex,
      getIndexOfId,
      getOptionById,
      getOptionsMatchingText,
      getOptionsMatchingValue
    };
  }, []);
  const registerOption = React160.useCallback((option) => {
    optionsById.current.set(option.id, option);
    return () => optionsById.current.delete(option.id);
  }, []);
  return {
    ...collectionAPI,
    options: Array.from(optionsById.current.values()),
    registerOption
  };
};

// node_modules/@fluentui/react-combobox/lib/utils/useSelection.js
var React161 = __toESM(require_react());
var useSelection2 = (props) => {
  const { defaultSelectedOptions, multiselect, onOptionSelect } = props;
  const [selectedOptions, setSelectedOptions] = useControllableState({
    state: props.selectedOptions,
    defaultState: defaultSelectedOptions,
    initialState: []
  });
  const selectOption = React161.useCallback((event, option) => {
    if (option.disabled) {
      return;
    }
    let newSelection = [
      option.value
    ];
    if (multiselect) {
      const selectedIndex = selectedOptions.findIndex((o) => o === option.value);
      if (selectedIndex > -1) {
        newSelection = [
          ...selectedOptions.slice(0, selectedIndex),
          ...selectedOptions.slice(selectedIndex + 1)
        ];
      } else {
        newSelection = [
          ...selectedOptions,
          option.value
        ];
      }
    }
    setSelectedOptions(newSelection);
    onOptionSelect === null || onOptionSelect === void 0 ? void 0 : onOptionSelect(event, {
      optionValue: option.value,
      optionText: option.text,
      selectedOptions: newSelection
    });
  }, [
    onOptionSelect,
    multiselect,
    selectedOptions,
    setSelectedOptions
  ]);
  const clearSelection = (event) => {
    setSelectedOptions([]);
    onOptionSelect === null || onOptionSelect === void 0 ? void 0 : onOptionSelect(event, {
      optionValue: void 0,
      optionText: void 0,
      selectedOptions: []
    });
  };
  return {
    clearSelection,
    selectOption,
    selectedOptions
  };
};

// node_modules/@fluentui/react-combobox/lib/components/Option/useOptionStyles.styles.js
var optionClassNames = {
  root: "fui-Option",
  checkIcon: "fui-Option__checkIcon"
};
var useStyles12 = __styles2({
  root: {
    Bt984gj: "f122n59",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    sj55zd: "f19n0e5",
    i8kkvl: "f1ufnopg",
    Bceei9c: "f1k6fduh",
    mc9l5x: "f22iagw",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fm5eomj",
    qhf8xq: "f10pi13n",
    Jwef8y: "f1knas48",
    Bi91k9c: "feu1g3u",
    zqbkvg: "fo79ri9",
    h82x05: ["f1osiabc", "f1e8le25"],
    cqj998: "f1yusjty",
    j3hlsh: ["f1e8le25", "f1osiabc"],
    ecr2s2: "fb40n2d",
    lj723h: "f1g4hkjv",
    Btxx2vb: "f1lnr2zp",
    sltcwy: ["f1ogfk9z", "f1g7j8ec"],
    dnwvvm: "fiuf46r",
    Blyvkvs: ["f1g7j8ec", "f1ogfk9z"]
  },
  active: {
    Bowz1zl: "f11vrvdw",
    oxogb1: "f17hxjb7",
    Ix2sn8: "f1dha69c",
    q7v32p: "f1lm7500",
    B7cbj04: 0,
    Bewtojm: 0,
    b50fsz: 0,
    B1wzb3v: 0,
    Bqwk70n: 0,
    B37u8z8: 0,
    avt0cx: 0,
    f0sref: 0,
    B9fkznv: 0,
    Be3o27t: 0,
    Bertapg: 0,
    B53xpsf: 0,
    Bsv72rj: 0,
    B39dzdd: 0,
    Btq9bd3: 0,
    Bqfxd14: 0,
    atup0s: "fo7xqb",
    Fffuxt: 0,
    Bttcd12: 0,
    Beitzug: 0,
    Bqougee: 0,
    B86i8pi: "f1kurthe",
    Bhijsxg: "fwq15dy",
    kktds4: "f1pb3wry",
    Bmau3bo: ["ftjv2f4", "f1flhb1f"],
    npektv: ["f1flhb1f", "ftjv2f4"]
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    Jwef8y: "f9ql6rf",
    Bi91k9c: "fvgxktp",
    zqbkvg: "f185j3qj",
    h82x05: ["f1dligi3", "f1vydzie"],
    cqj998: "fjw1di3",
    j3hlsh: ["f1vydzie", "f1dligi3"],
    ecr2s2: "fgj9um3",
    lj723h: "f19wldhg",
    Btxx2vb: "f1ss0kt2",
    sltcwy: ["f1t6oli3", "fjy9ci8"],
    dnwvvm: "fresaxk",
    Blyvkvs: ["fjy9ci8", "f1t6oli3"],
    Bbusuzp: "f1dcs8yz"
  },
  selected: {},
  checkIcon: {
    Bnnss6s: "fi64zpg",
    Be2twd7: "fod5ikn",
    Frg6f3: ["f18b9hdq", "fn6qj8t"],
    t21cq0: ["f1xk557c", "f1h9en5y"],
    Bcdw1i0: "fd7fpy0",
    Bo70h7d: "fvc9v3g"
  },
  selectedCheck: {
    Bcdw1i0: "f1022m68"
  },
  multiselectCheck: {
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f1l3cf7o",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fq9zq91",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Brf1p80: "f4d9j23",
    Bkfmm31: "f1w9h62z",
    Be2twd7: "f1ugzwwg",
    Bqenvij: "fd461yt",
    a9b677: "fjw5fx7",
    Bcdw1i0: "f1022m68"
  },
  selectedMultiselectCheck: {
    De3pzq: "ftywsgz",
    sj55zd: "fqpbvvt",
    g2u3we: "f3xi7mh",
    h3c5rm: ["ftovhe4", "f1wczvin"],
    B9xav0g: "f68vbr6",
    zhjwy3: ["f1wczvin", "ftovhe4"]
  },
  checkDisabled: {
    sj55zd: "f1s2aq7o",
    Bbusuzp: "f1dcs8yz"
  },
  multiselectCheckDisabled: {
    g2u3we: "f1r1t4y1",
    h3c5rm: ["fmj8ijw", "figx54m"],
    B9xav0g: "f360ss8",
    zhjwy3: ["figx54m", "fmj8ijw"]
  }
}, {
  d: [".f122n59{align-items:center;}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1ufnopg{column-gap:var(--spacingHorizontalXS);}", ".f1k6fduh{cursor:pointer;}", ".f22iagw{display:flex;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".fm5eomj{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalS);}", {
    p: -1
  }], ".f10pi13n{position:relative;}", '.f11vrvdw[data-activedescendant-focusvisible]::after{content:"";}', ".f17hxjb7[data-activedescendant-focusvisible]::after{position:absolute;}", ".f1dha69c[data-activedescendant-focusvisible]::after{pointer-events:none;}", ".f1lm7500[data-activedescendant-focusvisible]::after{z-index:1;}", [".fo7xqb[data-activedescendant-focusvisible]::after{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1kurthe[data-activedescendant-focusvisible]::after{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fwq15dy[data-activedescendant-focusvisible]::after{top:-2px;}", ".f1pb3wry[data-activedescendant-focusvisible]::after{bottom:-2px;}", ".ftjv2f4[data-activedescendant-focusvisible]::after{left:-2px;}", ".f1flhb1f[data-activedescendant-focusvisible]::after{right:-2px;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fi64zpg{flex-shrink:0;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".f18b9hdq{margin-left:calc(var(--spacingHorizontalXXS) * -1);}", ".fn6qj8t{margin-right:calc(var(--spacingHorizontalXXS) * -1);}", ".f1xk557c{margin-right:var(--spacingHorizontalXXS);}", ".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}", ".fd7fpy0{visibility:hidden;}", ".fvc9v3g svg{display:block;}", ".f1022m68{visibility:visible;}", [".f1l3cf7o{border:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", {
    p: -2
  }], [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
    p: -1
  }], ".f1ewtqcl{box-sizing:border-box;}", ".f4d9j23{justify-content:center;}", ".f1w9h62z{fill:currentColor;}", ".f1ugzwwg{font-size:12px;}", ".fd461yt{height:16px;}", ".fjw5fx7{width:16px;}", ".ftywsgz{background-color:var(--colorCompoundBrandBackground);}", ".fqpbvvt{color:var(--colorNeutralForegroundInverted);}", ".f3xi7mh{border-top-color:var(--colorCompoundBrandBackground);}", ".ftovhe4{border-right-color:var(--colorCompoundBrandBackground);}", ".f1wczvin{border-left-color:var(--colorCompoundBrandBackground);}", ".f68vbr6{border-bottom-color:var(--colorCompoundBrandBackground);}", ".f1r1t4y1{border-top-color:var(--colorNeutralForegroundDisabled);}", ".fmj8ijw{border-right-color:var(--colorNeutralForegroundDisabled);}", ".figx54m{border-left-color:var(--colorNeutralForegroundDisabled);}", ".f360ss8{border-bottom-color:var(--colorNeutralForegroundDisabled);}"],
  h: [".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}", ".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".fo79ri9:hover .fui-Option__checkIcon{border-top-color:var(--colorNeutralForeground1Hover);}", ".f1osiabc:hover .fui-Option__checkIcon{border-right-color:var(--colorNeutralForeground1Hover);}", ".f1e8le25:hover .fui-Option__checkIcon{border-left-color:var(--colorNeutralForeground1Hover);}", ".f1yusjty:hover .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForeground1Hover);}", ".f9ql6rf:hover{background-color:var(--colorTransparentBackground);}", ".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".f185j3qj:hover .fui-Option__checkIcon{border-top-color:var(--colorNeutralForegroundDisabled);}", ".f1dligi3:hover .fui-Option__checkIcon{border-right-color:var(--colorNeutralForegroundDisabled);}", ".f1vydzie:hover .fui-Option__checkIcon{border-left-color:var(--colorNeutralForegroundDisabled);}", ".fjw1di3:hover .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForegroundDisabled);}"],
  a: [".fb40n2d:active{background-color:var(--colorNeutralBackground1Pressed);}", ".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}", ".f1lnr2zp:active .fui-Option__checkIcon{border-top-color:var(--colorNeutralForeground1Hover);}", ".f1ogfk9z:active .fui-Option__checkIcon{border-right-color:var(--colorNeutralForeground1Hover);}", ".f1g7j8ec:active .fui-Option__checkIcon{border-left-color:var(--colorNeutralForeground1Hover);}", ".fiuf46r:active .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForeground1Hover);}", ".fgj9um3:active{background-color:var(--colorTransparentBackground);}", ".f19wldhg:active{color:var(--colorNeutralForegroundDisabled);}", ".f1ss0kt2:active .fui-Option__checkIcon{border-top-color:var(--colorNeutralForegroundDisabled);}", ".f1t6oli3:active .fui-Option__checkIcon{border-right-color:var(--colorNeutralForegroundDisabled);}", ".fjy9ci8:active .fui-Option__checkIcon{border-left-color:var(--colorNeutralForegroundDisabled);}", ".fresaxk:active .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForegroundDisabled);}"],
  m: [["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useOptionStyles_unstable = (state) => {
  "use no memo";
  const {
    disabled,
    multiselect,
    selected
  } = state;
  const styles = useStyles12();
  state.root.className = mergeClasses(optionClassNames.root, styles.root, styles.active, disabled && styles.disabled, selected && styles.selected, state.root.className);
  if (state.checkIcon) {
    state.checkIcon.className = mergeClasses(optionClassNames.checkIcon, styles.checkIcon, multiselect && styles.multiselectCheck, selected && styles.selectedCheck, selected && multiselect && styles.selectedMultiselectCheck, disabled && styles.checkDisabled, disabled && multiselect && styles.multiselectCheckDisabled, state.checkIcon.className);
  }
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Listbox/useListbox.js
var UNSAFE_noLongerUsed = {
  activeOption: void 0,
  focusVisible: false,
  setActiveOption: () => null
};
var useListbox_unstable = (props, ref) => {
  "use no memo";
  const { multiselect, disableAutoFocus = false } = props;
  const optionCollection = useOptionCollection();
  const { listboxRef: activeDescendantListboxRef, activeParentRef, controller } = useActiveDescendant({
    matchOption: (el) => el.classList.contains(optionClassNames.root)
  });
  const hasListboxContext = useHasParentContext(ListboxContext);
  const onActiveDescendantChange = useListboxContext_unstable((ctx) => ctx.onActiveDescendantChange);
  const contextGetOptionById = useListboxContext_unstable((ctx) => ctx.getOptionById);
  const contextGetOptionsMatchingValue = useListboxContext_unstable((ctx) => ctx.getOptionsMatchingValue);
  const getOptionById = hasListboxContext ? contextGetOptionById : optionCollection.getOptionById;
  const getOptionsMatchingValue = hasListboxContext ? contextGetOptionsMatchingValue : optionCollection.getOptionsMatchingValue;
  const listenerRef = React162.useMemo(() => {
    let element = null;
    const listener = (untypedEvent) => {
      const event = untypedEvent;
      onActiveDescendantChange === null || onActiveDescendantChange === void 0 ? void 0 : onActiveDescendantChange(event);
    };
    return (el) => {
      if (!el) {
        element === null || element === void 0 ? void 0 : element.removeEventListener("activedescendantchange", listener);
        return;
      }
      element = el;
      element.addEventListener("activedescendantchange", listener);
    };
  }, [
    onActiveDescendantChange
  ]);
  const [isNavigatingWithKeyboard, setIsNavigatingWithKeyboard] = React162.useState(false);
  useOnKeyboardNavigationChange(setIsNavigatingWithKeyboard);
  const activeDescendantContext = useActiveDescendantContext();
  const hasParentActiveDescendantContext = useHasParentActiveDescendantContext();
  const activeDescendantController = hasParentActiveDescendantContext ? activeDescendantContext.controller : controller;
  const { clearSelection, selectedOptions, selectOption } = useSelection2(props);
  const onKeyDown = (event) => {
    const action = getDropdownActionFromKey(event, {
      open: true
    });
    const activeOptionId = activeDescendantController.active();
    const activeOption = activeOptionId ? getOptionById(activeOptionId) : null;
    switch (action) {
      case "First":
      case "Last":
      case "Next":
      case "Previous":
      case "PageDown":
      case "PageUp":
      case "CloseSelect":
      case "Select":
        event.preventDefault();
        break;
    }
    switch (action) {
      case "Next":
        if (activeOption) {
          activeDescendantController.next();
        } else {
          activeDescendantController.first();
        }
        break;
      case "Previous":
        if (activeOption) {
          activeDescendantController.prev();
        } else {
          activeDescendantController.first();
        }
        break;
      case "PageUp":
      case "First":
        activeDescendantController.first();
        break;
      case "PageDown":
      case "Last":
        activeDescendantController.last();
        break;
      case "Select":
      case "CloseSelect":
        activeOption && selectOption(event, activeOption);
        break;
    }
  };
  const contextSelectedOptions = useListboxContext_unstable((ctx) => ctx.selectedOptions);
  const contextSelectOption = useListboxContext_unstable((ctx) => ctx.selectOption);
  const optionContextValues = hasListboxContext ? {
    selectedOptions: contextSelectedOptions,
    selectOption: contextSelectOption,
    ...UNSAFE_noLongerUsed
  } : {
    selectedOptions,
    selectOption,
    ...UNSAFE_noLongerUsed
  };
  React162.useEffect(() => {
    if (hasParentActiveDescendantContext) {
      return;
    }
    activeDescendantController.hideFocusVisibleAttributes();
    if (!disableAutoFocus) {
      if (!multiselect && optionContextValues.selectedOptions.length > 0) {
        const selectedOption = getOptionsMatchingValue((v) => v === optionContextValues.selectedOptions[0]).pop();
        if (selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.id) {
          activeDescendantController.focus(selectedOption.id);
        }
      } else {
        activeDescendantController.first();
      }
    }
    return () => {
      activeDescendantController.blur();
    };
  }, []);
  const onFocus = React162.useCallback(() => {
    if (hasParentActiveDescendantContext) {
      return;
    }
    activeDescendantController.showFocusVisibleAttributes();
    if (isNavigatingWithKeyboard) {
      activeDescendantController.scrollActiveIntoView();
    }
  }, [
    activeDescendantController,
    hasParentActiveDescendantContext,
    isNavigatingWithKeyboard
  ]);
  const onBlur = React162.useCallback(() => {
    if (hasParentActiveDescendantContext) {
      return;
    }
    activeDescendantController.hideFocusVisibleAttributes();
  }, [
    activeDescendantController,
    hasParentActiveDescendantContext
  ]);
  const state = {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, activeParentRef, activeDescendantListboxRef, listenerRef),
      role: multiselect ? "menu" : "listbox",
      tabIndex: 0,
      ...props
    }), {
      elementType: "div"
    }),
    standalone: !hasListboxContext,
    multiselect,
    clearSelection,
    activeDescendantController,
    onActiveDescendantChange,
    ...optionCollection,
    ...optionContextValues
  };
  state.root.onKeyDown = useEventCallback(mergeCallbacks(state.root.onKeyDown, onKeyDown));
  state.root.onFocus = useEventCallback(mergeCallbacks(state.root.onFocus, onFocus));
  state.root.onBlur = useEventCallback(mergeCallbacks(state.root.onBlur, onBlur));
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Listbox/renderListbox.js
var renderListbox_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(ActiveDescendantContextProvider, {
    value: contextValues.activeDescendant,
    children: jsx(ListboxContext.Provider, {
      value: contextValues.listbox,
      children: jsx(state.root, {})
    })
  });
};

// node_modules/@fluentui/react-combobox/lib/components/Listbox/useListboxStyles.styles.js
var listboxClassNames = {
  root: "fui-Listbox"
};
var useStyles13 = __styles2({
  root: {
    De3pzq: "fxugw4r",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    Bf4jedk: "f3hsy1e",
    Bmxbyg5: "f5zp4f",
    Bw0xxkn: 0,
    oeaueh: 0,
    Bpd4iqm: 0,
    Befb4lg: "f1iepc6i",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1t35pdg",
    Belr9w4: "fiut8dr"
  }
}, {
  d: [".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1ewtqcl{box-sizing:border-box;}", ".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".f3hsy1e{min-width:160px;}", ".f5zp4f{overflow-y:auto;}", [".f1iepc6i{outline:1px solid var(--colorTransparentStroke);}", {
    p: -1
  }], [".f1t35pdg{padding:var(--spacingHorizontalXS);}", {
    p: -1
  }], ".fiut8dr{row-gap:var(--spacingHorizontalXXS);}"]
});
var useListboxStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles13();
  state.root.className = mergeClasses(listboxClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Listbox/Listbox.js
var Listbox = React163.forwardRef((props, ref) => {
  const state = useListbox_unstable(props, ref);
  const contextValues = useListboxContextValues(state);
  useListboxStyles_unstable(state);
  useCustomStyleHook("useListboxStyles_unstable")(state);
  return renderListbox_unstable(state, contextValues);
});
Listbox.displayName = "Listbox";

// node_modules/@fluentui/react-combobox/lib/components/Option/Option.js
var React165 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/components/Option/useOption.js
var React164 = __toESM(require_react());
function getTextString(text, children2) {
  if (text !== void 0) {
    return text;
  }
  let textString = "";
  let hasNonStringChild = false;
  React164.Children.forEach(children2, (child) => {
    if (typeof child === "string") {
      textString += child;
    } else {
      hasNonStringChild = true;
    }
  });
  if (hasNonStringChild) {
    console.warn("Provide a `text` prop to Option components when they contain non-string children.");
  }
  return textString;
}
var useOption_unstable = (props, ref) => {
  const { children: children2, disabled, text, value } = props;
  const optionRef = React164.useRef(null);
  const optionText = getTextString(text, children2);
  const optionValue = value !== null && value !== void 0 ? value : optionText;
  const id = useId2("fluent-option", props.id);
  const optionData = React164.useMemo(() => ({
    id,
    disabled,
    text: optionText,
    value: optionValue
  }), [
    id,
    disabled,
    optionText,
    optionValue
  ]);
  const { controller: activeDescendantController } = useActiveDescendantContext();
  const multiselect = useListboxContext_unstable((ctx) => ctx.multiselect);
  const registerOption = useListboxContext_unstable((ctx) => ctx.registerOption);
  const selected = useListboxContext_unstable((ctx) => {
    const selectedOptions = ctx.selectedOptions;
    return optionValue !== void 0 && selectedOptions.find((o) => o === optionValue) !== void 0;
  });
  const selectOption = useListboxContext_unstable((ctx) => ctx.selectOption);
  const onOptionClick = useListboxContext_unstable((ctx) => ctx.onOptionClick);
  let CheckIcon = React164.createElement(CheckmarkFilled, null);
  if (multiselect) {
    CheckIcon = selected ? React164.createElement(Checkmark12Filled, null) : "";
  }
  const onClick = (event) => {
    var _props_onClick;
    if (disabled) {
      event.preventDefault();
      return;
    }
    activeDescendantController.focus(id);
    selectOption(event, optionData);
    onOptionClick(event);
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, event);
  };
  React164.useEffect(() => {
    if (id && optionRef.current) {
      return registerOption(optionData, optionRef.current);
    }
  }, [
    id,
    optionData,
    registerOption
  ]);
  const semanticProps = multiselect ? {
    role: "menuitemcheckbox",
    "aria-checked": selected
  } : {
    role: "option",
    "aria-selected": selected
  };
  return {
    components: {
      root: "div",
      checkIcon: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, optionRef),
      "aria-disabled": disabled ? "true" : void 0,
      id,
      ...semanticProps,
      ...props,
      onClick
    }), {
      elementType: "div"
    }),
    checkIcon: slot_exports.optional(props.checkIcon, {
      renderByDefault: true,
      defaultProps: {
        "aria-hidden": "true",
        children: CheckIcon
      },
      elementType: "span"
    }),
    disabled,
    multiselect,
    selected,
    // no longer used
    focusVisible: false,
    active: false
  };
};

// node_modules/@fluentui/react-combobox/lib/components/Option/renderOption.js
var renderOption_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.checkIcon && jsx(state.checkIcon, {}),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-combobox/lib/components/Option/Option.js
var Option = React165.forwardRef((props, ref) => {
  const state = useOption_unstable(props, ref);
  useOptionStyles_unstable(state);
  useCustomStyleHook("useOptionStyles_unstable")(state);
  return renderOption_unstable(state);
});
Option.displayName = "Option";

// node_modules/@fluentui/react-combobox/lib/components/Combobox/Combobox.js
var React172 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/components/Combobox/useCombobox.js
var React171 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/utils/useComboboxBaseState.js
var React166 = __toESM(require_react());
var ReactDOM2 = __toESM(require_react_dom());
var useComboboxBaseState = (props) => {
  "use no memo";
  const { appearance = "outline", disableAutoFocus, children: children2, clearable = false, editable = false, inlinePopup = false, mountNode = void 0, multiselect, onOpenChange, size: size3 = "medium", activeDescendantController, freeform = false, disabled = false, onActiveOptionChange = null } = props;
  const optionCollection = useOptionCollection();
  const { getOptionsMatchingValue } = optionCollection;
  const { getOptionById } = optionCollection;
  const getActiveOption = React166.useCallback(() => {
    const activeOptionId = activeDescendantController.active();
    return activeOptionId ? getOptionById(activeOptionId) : void 0;
  }, [
    activeDescendantController,
    getOptionById
  ]);
  const UNSAFE_activeOption = getActiveOption();
  const UNSAFE_setActiveOption = React166.useCallback((option) => {
    let nextOption = void 0;
    if (typeof option === "function") {
      const activeOption = getActiveOption();
      nextOption = option(activeOption);
    }
    if (nextOption) {
      activeDescendantController.focus(nextOption.id);
    } else {
      activeDescendantController.blur();
    }
  }, [
    activeDescendantController,
    getActiveOption
  ]);
  const [focusVisible, setFocusVisible] = React166.useState(false);
  const [hasFocus, setHasFocus] = React166.useState(false);
  const ignoreNextBlur = React166.useRef(false);
  const isFirstMount = useFirstMount();
  const [controllableValue, setValue] = useControllableState({
    state: props.value,
    initialState: void 0
  });
  const { selectedOptions, selectOption: baseSelectOption, clearSelection } = useSelection2(props);
  const selectOption = React166.useCallback((ev, option) => {
    ReactDOM2.unstable_batchedUpdates(() => {
      setValue(void 0);
      baseSelectOption(ev, option);
    });
  }, [
    setValue,
    baseSelectOption
  ]);
  const value = React166.useMemo(() => {
    if (controllableValue !== void 0) {
      return controllableValue;
    }
    if (isFirstMount && props.defaultValue !== void 0) {
      return props.defaultValue;
    }
    const selectedOptionsText = getOptionsMatchingValue((optionValue) => {
      return selectedOptions.includes(optionValue);
    }).map((option) => option.text);
    if (multiselect) {
      return editable ? "" : selectedOptionsText.join(", ");
    }
    return selectedOptionsText[0];
  }, [
    controllableValue,
    editable,
    getOptionsMatchingValue,
    multiselect,
    selectedOptions
  ]);
  const [open, setOpenState] = useControllableState({
    state: props.open,
    defaultState: props.defaultOpen,
    initialState: false
  });
  const setOpen = React166.useCallback((event, newState) => {
    if (disabled) {
      return;
    }
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(event, {
      open: newState
    });
    ReactDOM2.unstable_batchedUpdates(() => {
      if (!newState && !freeform) {
        setValue(void 0);
      }
      setOpenState(newState);
    });
  }, [
    onOpenChange,
    setOpenState,
    setValue,
    freeform,
    disabled
  ]);
  React166.useEffect(() => {
    if (open) {
      if (!multiselect && selectedOptions.length > 0) {
        const selectedOption = getOptionsMatchingValue((v) => v === selectedOptions[0]).pop();
        if (selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.id) {
          activeDescendantController.focus(selectedOption.id);
        }
      }
    } else {
      activeDescendantController.blur();
    }
  }, [
    open,
    activeDescendantController
  ]);
  React166.useEffect(() => {
    if (open && !disableAutoFocus && !activeDescendantController.active()) {
      activeDescendantController.first();
    }
  }, [
    open,
    children2,
    disableAutoFocus,
    activeDescendantController,
    getOptionById
  ]);
  const onActiveDescendantChange = useEventCallback((event) => {
    const previousOption = event.detail.previousId ? optionCollection.getOptionById(event.detail.previousId) : null;
    const nextOption = optionCollection.getOptionById(event.detail.id);
    onActiveOptionChange === null || onActiveOptionChange === void 0 ? void 0 : onActiveOptionChange(event, {
      event,
      type: "change",
      previousOption,
      nextOption
    });
  });
  return {
    ...optionCollection,
    freeform,
    disabled,
    selectOption,
    clearSelection,
    selectedOptions,
    activeOption: UNSAFE_activeOption,
    appearance,
    clearable,
    focusVisible,
    ignoreNextBlur,
    inlinePopup,
    mountNode,
    open,
    hasFocus,
    setActiveOption: UNSAFE_setActiveOption,
    setFocusVisible,
    setHasFocus,
    setOpen,
    setValue,
    size: size3,
    value,
    multiselect,
    onOptionClick: useEventCallback((e) => {
      if (!multiselect) {
        setOpen(e, false);
      }
    }),
    onActiveDescendantChange
  };
};

// node_modules/@fluentui/react-combobox/lib/utils/useComboboxPositioning.js
var React167 = __toESM(require_react());
function useComboboxPositioning(props) {
  const { positioning } = props;
  const fallbackPositions2 = [
    "above",
    "after",
    "after-top",
    "before",
    "before-top"
  ];
  const popperOptions = {
    position: "below",
    align: "start",
    offset: {
      crossAxis: 0,
      mainAxis: 2
    },
    fallbackPositions: fallbackPositions2,
    matchTargetSize: "width",
    autoSize: true,
    ...resolvePositioningShorthand(positioning)
  };
  const { targetRef, containerRef } = usePositioning(popperOptions);
  return [
    containerRef,
    targetRef
  ];
}

// node_modules/@fluentui/react-combobox/lib/utils/useListboxSlot.js
var React168 = __toESM(require_react());
function useListboxSlot(listboxSlotFromProp, ref, options) {
  const { state: { multiselect }, triggerRef, defaultProps: defaultProps2 } = options;
  const listboxId = useId2("fluent-listbox", isResolvedShorthand(listboxSlotFromProp) ? listboxSlotFromProp.id : void 0);
  const listboxSlot = slot_exports.optional(listboxSlotFromProp, {
    renderByDefault: true,
    elementType: Listbox,
    defaultProps: {
      id: listboxId,
      multiselect,
      tabIndex: void 0,
      ...defaultProps2
    }
  });
  const fieldControlProps = useFieldControlProps_unstable({
    id: listboxId
  }, {
    supportsLabelFor: true
  });
  if (listboxSlot && !listboxSlot["aria-label"] && !listboxSlot["aria-labelledby"] && fieldControlProps["aria-labelledby"]) {
    listboxSlot["aria-labelledby"] = fieldControlProps["aria-labelledby"];
  }
  const onMouseDown = useEventCallback(mergeCallbacks((event) => {
    event.preventDefault();
  }, listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.onMouseDown));
  const onClick = useEventCallback(mergeCallbacks((event) => {
    var _triggerRef_current;
    event.preventDefault();
    (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
  }, listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.onClick));
  const listboxRef = useMergedRefs(listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.ref, ref);
  if (listboxSlot) {
    listboxSlot.ref = listboxRef;
    listboxSlot.onMouseDown = onMouseDown;
    listboxSlot.onClick = onClick;
  }
  return listboxSlot;
}

// node_modules/@fluentui/react-combobox/lib/components/Combobox/useInputTriggerSlot.js
var React170 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/utils/useTriggerSlot.js
var React169 = __toESM(require_react());
function useTriggerSlot(triggerSlotFromProp, ref, options) {
  const { state: { open, setOpen, setHasFocus }, defaultProps: defaultProps2, elementType, activeDescendantController } = options;
  const trigger = slot_exports.always(triggerSlotFromProp, {
    defaultProps: {
      type: "text",
      "aria-expanded": open,
      role: "combobox",
      ...typeof defaultProps2 === "object" && defaultProps2
    },
    elementType
  });
  const triggerRef = React169.useRef(null);
  trigger.ref = useMergedRefs(triggerRef, trigger.ref, ref);
  trigger.onBlur = mergeCallbacks((event) => {
    setOpen(event, false);
    setHasFocus(false);
  }, trigger.onBlur);
  trigger.onFocus = mergeCallbacks((event) => {
    if (event.target === event.currentTarget) {
      setHasFocus(true);
    }
  }, trigger.onFocus);
  trigger.onClick = mergeCallbacks((event) => {
    setOpen(event, !open);
  }, trigger.onClick);
  trigger.onKeyDown = mergeCallbacks(useTriggerKeydown({
    activeDescendantController,
    ...options.state
  }), trigger.onKeyDown);
  return trigger;
}
function useTriggerKeydown(options) {
  const { activeDescendantController, getOptionById, setOpen, selectOption, multiselect, open } = options;
  const getActiveOption = React169.useCallback(() => {
    const activeOptionId = activeDescendantController.active();
    return activeOptionId ? getOptionById(activeOptionId) : void 0;
  }, [
    activeDescendantController,
    getOptionById
  ]);
  const first = () => {
    activeDescendantController.first();
  };
  const last = () => {
    activeDescendantController.last();
  };
  const next = (activeOption) => {
    if (activeOption) {
      activeDescendantController.next();
    } else {
      activeDescendantController.first();
    }
  };
  const previous = (activeOption) => {
    if (activeOption) {
      activeDescendantController.prev();
    } else {
      activeDescendantController.first();
    }
  };
  const pageUp = () => {
    for (let i = 0; i < 10; i++) {
      activeDescendantController.prev();
    }
  };
  const pageDown = () => {
    for (let i = 0; i < 10; i++) {
      activeDescendantController.next();
    }
  };
  const setKeyboardNavigation = useSetKeyboardNavigation();
  return useEventCallback((e) => {
    const action = getDropdownActionFromKey(e, {
      open,
      multiselect
    });
    const activeOption = getActiveOption();
    switch (action) {
      case "First":
      case "Last":
      case "Next":
      case "Previous":
      case "PageDown":
      case "PageUp":
      case "Open":
      case "Close":
      case "CloseSelect":
      case "Select":
        e.preventDefault();
        break;
    }
    setKeyboardNavigation(true);
    switch (action) {
      case "First":
        first();
        break;
      case "Last":
        last();
        break;
      case "Next":
        next(activeOption);
        break;
      case "Previous":
        previous(activeOption);
        break;
      case "PageDown":
        pageDown();
        break;
      case "PageUp":
        pageUp();
        break;
      case "Open":
        setOpen(e, true);
        break;
      case "Close":
        e.stopPropagation();
        setOpen(e, false);
        break;
      case "CloseSelect":
        !multiselect && !(activeOption === null || activeOption === void 0 ? void 0 : activeOption.disabled) && setOpen(e, false);
      case "Select":
        activeOption && selectOption(e, activeOption);
        break;
      case "Tab":
        !multiselect && activeOption && selectOption(e, activeOption);
        break;
    }
  });
}

// node_modules/@fluentui/react-combobox/lib/components/Combobox/useInputTriggerSlot.js
function useInputTriggerSlot(triggerFromProps, ref, options) {
  "use no memo";
  const { state: { open, value, selectOption, setValue, multiselect, selectedOptions, clearSelection, getOptionById, setOpen }, freeform, defaultProps: defaultProps2, activeDescendantController } = options;
  const onBlur = (event) => {
    if (!open && !freeform) {
      const activeOptionId = activeDescendantController.active();
      const activeOption = activeOptionId ? getOptionById(activeOptionId) : null;
      if (value && activeOption && value.trim().toLowerCase() === (activeOption === null || activeOption === void 0 ? void 0 : activeOption.text.toLowerCase())) {
        selectOption(event, activeOption);
      }
      setValue(void 0);
    }
  };
  const getOptionFromInput = (inputValue) => {
    const searchString = inputValue === null || inputValue === void 0 ? void 0 : inputValue.trim().toLowerCase();
    if (!searchString || searchString.length === 0) {
      activeDescendantController.blur();
      return;
    }
    const matcher = (optionText) => optionText.toLowerCase().indexOf(searchString) === 0;
    const match = activeDescendantController.find((id) => {
      const option = getOptionById(id);
      return !!option && matcher(option.text);
    });
    if (!match) {
      activeDescendantController.blur();
      return void 0;
    }
    return getOptionById(match);
  };
  const onChange = (event) => {
    const inputValue = event.target.value;
    setValue(inputValue);
    const matchingOption = getOptionFromInput(inputValue);
    if (!multiselect && selectedOptions.length === 1 && (inputValue.length < 1 || !matchingOption)) {
      clearSelection(event);
    }
  };
  const trigger = useTriggerSlot(triggerFromProps, ref, {
    state: options.state,
    defaultProps: defaultProps2,
    elementType: "input",
    activeDescendantController
  });
  trigger.onChange = mergeCallbacks(trigger.onChange, onChange);
  trigger.onBlur = mergeCallbacks(trigger.onBlur, onBlur);
  const [hideActiveDescendant, setHideActiveDescendant] = React170.useState(false);
  const isTyping = React170.useRef(false);
  const defaultOnKeyDown = trigger.onKeyDown;
  const onKeyDown = useEventCallback((event) => {
    if (!open && getDropdownActionFromKey(event) === "Type") {
      setOpen(event, true);
    }
    if (event.key === ArrowLeft || event.key === ArrowRight) {
      setHideActiveDescendant(true);
    } else {
      setHideActiveDescendant(false);
    }
    const action = getDropdownActionFromKey(event, {
      open,
      multiselect
    });
    if (action === "Type") {
      isTyping.current = true;
    } else if (action === "Open" && event.key !== " " || action === "Next" || action === "Previous" || action === "First" || action === "Last" || action === "PageUp" || action === "PageDown") {
      isTyping.current = false;
    }
    if ((isTyping.current || !open) && event.key === " ") {
      var _triggerFromProps_onKeyDown;
      triggerFromProps === null || triggerFromProps === void 0 ? void 0 : (_triggerFromProps_onKeyDown = triggerFromProps.onKeyDown) === null || _triggerFromProps_onKeyDown === void 0 ? void 0 : _triggerFromProps_onKeyDown.call(triggerFromProps, event);
      return;
    }
    defaultOnKeyDown === null || defaultOnKeyDown === void 0 ? void 0 : defaultOnKeyDown(event);
  });
  trigger.onKeyDown = onKeyDown;
  if (hideActiveDescendant) {
    trigger["aria-activedescendant"] = void 0;
  }
  return trigger;
}

// node_modules/@fluentui/react-combobox/lib/components/Combobox/useCombobox.js
var useCombobox_unstable = (props, ref) => {
  "use no memo";
  var _state_clearIcon, _state_clearIcon1;
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true,
    supportsSize: true
  });
  const { listboxRef: activeDescendantListboxRef, activeParentRef, controller: activeDescendantController } = useActiveDescendant({
    matchOption: (el) => el.classList.contains(optionClassNames.root)
  });
  const baseState = useComboboxBaseState({
    ...props,
    editable: true,
    activeDescendantController
  });
  const { clearable, clearSelection, disabled, multiselect, open, selectedOptions, setOpen, value, hasFocus } = baseState;
  const [comboboxPopupRef, comboboxTargetRef] = useComboboxPositioning(props);
  const { disableAutoFocus = false, freeform, inlinePopup } = props;
  const comboId = useId2("combobox-");
  const { primary: triggerNativeProps, root: rootNativeProps } = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "children",
      "size"
    ]
  });
  const triggerRef = React171.useRef(null);
  const listbox = useListboxSlot(props.listbox, useMergedRefs(comboboxPopupRef, activeDescendantListboxRef), {
    state: baseState,
    triggerRef,
    defaultProps: {
      children: props.children,
      disableAutoFocus
    }
  });
  var _props_input;
  const triggerSlot = useInputTriggerSlot((_props_input = props.input) !== null && _props_input !== void 0 ? _props_input : {}, useMergedRefs(triggerRef, activeParentRef, ref), {
    state: baseState,
    freeform,
    defaultProps: {
      type: "text",
      value: value !== null && value !== void 0 ? value : "",
      "aria-controls": open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
      ...triggerNativeProps
    },
    activeDescendantController
  });
  const rootSlot = slot_exports.always(props.root, {
    defaultProps: {
      "aria-owns": !inlinePopup && open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
      ...rootNativeProps
    },
    elementType: "div"
  });
  rootSlot.ref = useMergedRefs(rootSlot.ref, comboboxTargetRef);
  const showClearIcon = selectedOptions.length > 0 && !disabled && clearable && !multiselect;
  const state = {
    components: {
      root: "div",
      input: "input",
      expandIcon: "span",
      listbox: Listbox,
      clearIcon: "span"
    },
    root: rootSlot,
    input: triggerSlot,
    listbox: open || hasFocus ? listbox : void 0,
    clearIcon: slot_exports.optional(props.clearIcon, {
      defaultProps: {
        "aria-hidden": "true",
        children: React171.createElement(DismissRegular, null)
      },
      elementType: "span",
      renderByDefault: true
    }),
    expandIcon: slot_exports.optional(props.expandIcon, {
      renderByDefault: true,
      defaultProps: {
        "aria-disabled": disabled ? "true" : void 0,
        "aria-expanded": open,
        children: React171.createElement(ChevronDownRegular, null),
        role: "button"
      },
      elementType: "span"
    }),
    showClearIcon,
    activeDescendantController,
    ...baseState
  };
  const { targetDocument } = useFluent();
  useOnClickOutside({
    element: targetDocument,
    callback: (event) => setOpen(event, false),
    refs: [
      triggerRef,
      comboboxPopupRef,
      comboboxTargetRef
    ],
    disabled: !open
  });
  const { onMouseDown: onIconMouseDown } = state.expandIcon || {};
  const onExpandIconMouseDown = useEventCallback(mergeCallbacks(onIconMouseDown, (event) => {
    var _triggerRef_current;
    event.preventDefault();
    state.setOpen(event, !state.open);
    (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
  }));
  if (state.expandIcon) {
    state.expandIcon.onMouseDown = onExpandIconMouseDown;
    const hasExpandLabel = state.expandIcon["aria-label"] || state.expandIcon["aria-labelledby"];
    const defaultOpenString = "Open";
    if (!hasExpandLabel) {
      if (props["aria-labelledby"]) {
        var _state_expandIcon_id;
        const chevronId = (_state_expandIcon_id = state.expandIcon.id) !== null && _state_expandIcon_id !== void 0 ? _state_expandIcon_id : `${comboId}-chevron`;
        const chevronLabelledBy = `${chevronId} ${state.input["aria-labelledby"]}`;
        state.expandIcon["aria-label"] = defaultOpenString;
        state.expandIcon.id = chevronId;
        state.expandIcon["aria-labelledby"] = chevronLabelledBy;
      } else if (props["aria-label"]) {
        state.expandIcon["aria-label"] = `${defaultOpenString} ${props["aria-label"]}`;
      } else {
        state.expandIcon["aria-label"] = defaultOpenString;
      }
    }
  }
  const onClearIconMouseDown = useEventCallback(mergeCallbacks((_state_clearIcon = state.clearIcon) === null || _state_clearIcon === void 0 ? void 0 : _state_clearIcon.onMouseDown, (ev) => {
    ev.preventDefault();
  }));
  const onClearIconClick = useEventCallback(mergeCallbacks((_state_clearIcon1 = state.clearIcon) === null || _state_clearIcon1 === void 0 ? void 0 : _state_clearIcon1.onClick, (ev) => {
    clearSelection(ev);
  }));
  if (state.clearIcon) {
    state.clearIcon.onMouseDown = onClearIconMouseDown;
    state.clearIcon.onClick = onClearIconClick;
  }
  if (multiselect) {
    state.clearIcon = void 0;
  }
  if (true) {
    React171.useEffect(() => {
      if (clearable && multiselect) {
        console.error(`[@fluentui/react-combobox] "clearable" prop is not supported in multiselect mode.`);
      }
    }, [
      clearable,
      multiselect
    ]);
  }
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Combobox/renderCombobox.js
var renderCombobox_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(ActiveDescendantContextProvider, {
      value: contextValues.activeDescendant,
      children: jsx(ListboxProvider, {
        value: contextValues.listbox,
        children: jsxs(ComboboxContext.Provider, {
          value: contextValues.combobox,
          children: [
            jsx(state.input, {}),
            state.clearIcon && jsx(state.clearIcon, {}),
            state.expandIcon && jsx(state.expandIcon, {}),
            state.listbox && (state.inlinePopup ? jsx(state.listbox, {}) : jsx(Portal, {
              mountNode: state.mountNode,
              children: jsx(state.listbox, {})
            }))
          ]
        })
      })
    })
  });
};

// node_modules/@fluentui/react-combobox/lib/components/Combobox/useComboboxStyles.styles.js
var comboboxClassNames = {
  root: "fui-Combobox",
  input: "fui-Combobox__input",
  expandIcon: "fui-Combobox__expandIcon",
  clearIcon: "fui-Combobox__clearIcon",
  listbox: "fui-Combobox__listbox"
};
var useStyles14 = __styles2({
  root: {
    Bt984gj: "f122n59",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    B7ck84d: "f1ewtqcl",
    i8kkvl: "f14mj54c",
    mc9l5x: "fwk3njj",
    Budl1dq: "fz17x9o",
    Brf1p80: "f1869bpl",
    Bf4jedk: "f1exfvgq",
    qhf8xq: "f10pi13n",
    ha4doy: "fmrv4ls",
    Bbr2w1p: "f14a1fxs",
    Bduesf4: "f3e99gv",
    Bpq79vn: "fhljsf7",
    li1rpt: "f1gw3sf2",
    Bsft5z2: "f13zj6fq",
    E3zdtr: "f1mdlcz9",
    Eqx8gd: ["f1a7op3", "f1cjjd47"],
    By385i5: "f1gboi2j",
    B1piin3: ["f1cjjd47", "f1a7op3"],
    Dlnsje: "f145g4dw",
    d9w3h3: ["f1kp91vd", "f1ibwz09"],
    B3778ie: ["f1ibwz09", "f1kp91vd"],
    B1q35kw: 0,
    Bw17bha: 0,
    Bcgy8vk: 0,
    Bjuhk93: "f1mnjydx",
    Gjdm7m: "f13evtba",
    b1kco5: "f1yk9hq",
    Ba2ppi3: "fhwpy7i",
    F2fol1: "f14ee0xe",
    lck23g: "f1xhbsuh",
    df92cz: "fv8e3ye",
    I188md: "ftb5wc6",
    umuwi5: "fjw5xc1",
    Blcqepd: "f1xdyd5c",
    nplu4u: "fatpbeo",
    Bioka5o: "fb7uyps",
    H713fs: "f1cmft4k",
    B9ooomg: "f1x58t8o",
    Bercvud: "f1ibeo51"
  },
  listbox: {
    E5pizo: "f1hg901r",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bxyxcbc: "fmmk62d",
    B7ck84d: "f1ewtqcl"
  },
  listboxCollapsed: {
    mc9l5x: "fjseox"
  },
  inlineListbox: {
    Bj3rh1h: "f19g0ac"
  },
  small: {
    Bqenvij: "frvgh55",
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  medium: {
    Bqenvij: "f1d2rq10",
    z189sj: ["f11gcy0p", "f1ng84yb"]
  },
  large: {
    i8kkvl: "f1rjii52",
    Bqenvij: "fbhnoac",
    z189sj: ["fw5db7e", "f1uw59to"]
  },
  outline: {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: "f1c1zstj",
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fhz96rm"
  },
  outlineInteractive: {
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "f1l4zc64",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    B6oc9vd: "fvs00aa",
    ak43y8: ["f1assf6x", "f4ruux4"],
    wmxk5l: "f1z0osm6",
    B50zh58: ["f4ruux4", "f1assf6x"],
    Bvq3b66: "f1b473iu",
    Brahy3i: ["f381qr8", "ft4skwv"],
    zoxjo1: "f1qzcrsd",
    an54nd: ["ft4skwv", "f381qr8"]
  },
  underline: {
    De3pzq: "f1c21dwh",
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f9ez7ne",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w"
  },
  "filled-darker": {
    De3pzq: "f16xq7d1",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w"
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  },
  invalidUnderline: {
    hhx65j: "f1fgmyf4"
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    Bjwas2f: "fg455y9",
    Bn1d65q: ["f1rvyvqg", "f14g86mu"],
    Bxeuatn: "f1cwzwz",
    n51gp8: ["f14g86mu", "f1rvyvqg"]
  }
}, {
  d: [".f122n59{align-items:center;}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1ewtqcl{box-sizing:border-box;}", ".f14mj54c{column-gap:var(--spacingHorizontalXXS);}", ".fwk3njj{display:inline-grid;}", ".fz17x9o{grid-template-columns:1fr auto;}", ".f1869bpl{justify-content:space-between;}", ".f1exfvgq{min-width:250px;}", ".f10pi13n{position:relative;}", ".fmrv4ls{vertical-align:middle;}", ".f1gw3sf2::after{box-sizing:border-box;}", '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1a7op3::after{left:-1px;}", ".f1cjjd47::after{right:-1px;}", ".f1gboi2j::after{bottom:-1px;}", ".f145g4dw::after{height:max(2px, var(--borderRadiusMedium));}", ".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}", [".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", {
    p: -1
  }], ".f13evtba::after{clip-path:inset(calc(100% - 2px) 0 0 0);}", ".f1yk9hq::after{transform:scaleX(0);}", ".fhwpy7i::after{transition-property:transform;}", ".f14ee0xe::after{transition-duration:var(--durationUltraFast);}", ".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}", ".f1hg901r{box-shadow:var(--shadow16);}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fmmk62d{max-height:80vh;}", ".fjseox{display:none;}", ".f19g0ac{z-index:1;}", ".frvgh55{height:24px;}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".f1d2rq10{height:32px;}", ".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}", ".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}", ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", ".fbhnoac{height:40px;}", ".fw5db7e{padding-right:var(--spacingHorizontalM);}", ".f1uw59to{padding-left:var(--spacingHorizontalM);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", {
    p: -2
  }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".f9ez7ne{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", {
    p: -1
  }], [".fokr779{border-radius:0;}", {
    p: -1
  }], [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"],
  w: [".f14a1fxs:focus-within{outline-width:2px;}", ".f3e99gv:focus-within{outline-style:solid;}", ".fhljsf7:focus-within{outline-color:transparent;}", ".fjw5xc1:focus-within::after{transform:scaleX(1);}", ".f1xdyd5c:focus-within::after{transition-property:transform;}", ".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}", ".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}", ".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".f1b473iu:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f381qr8:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}", ".ft4skwv:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1qzcrsd:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.fv8e3ye::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.ftb5wc6::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1cmft4k:focus-within::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1x58t8o:focus-within::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"],
  a: [".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"]
});
var useInputStyles2 = __styles2({
  input: {
    qb2dma: "f1ub7u0d",
    De3pzq: "f1c21dwh",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    sj55zd: "f19n0e5",
    Bahqtrf: "fk6fouc",
    Brovlpu: "ftqa4ok",
    yvdlaj: "fwyc1cq",
    B3o7kgh: "f13ta7ih"
  },
  small: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["fxe2rs", "f1gflqzi"]
  },
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["fzy81xo", "f58b53b"]
  },
  large: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1kdav7a", "footqm6"]
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    De3pzq: "f1c21dwh",
    Bceei9c: "fdrzuqr",
    yvdlaj: "fahhnxm"
  }
}, {
  d: [".f1ub7u0d{align-self:stretch;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".f3bhgqh{border:none;}", {
    p: -2
  }], ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fwyc1cq::-webkit-input-placeholder{color:var(--colorNeutralForeground4);}", ".fwyc1cq::-moz-placeholder{color:var(--colorNeutralForeground4);}", ".f13ta7ih::-webkit-input-placeholder{opacity:1;}", ".f13ta7ih::-moz-placeholder{opacity:1;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", [".fxe2rs{padding:0 0 0 calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f1gflqzi{padding:0 calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS)) 0 0;}", {
    p: -1
  }], ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".fzy81xo{padding:0 0 0 calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f58b53b{padding:0 calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS)) 0 0;}", {
    p: -1
  }], ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f1kdav7a{padding:0 0 0 calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", {
    p: -1
  }], [".footqm6{padding:0 calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge)) 0 0;}", {
    p: -1
  }], ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"],
  f: [".ftqa4ok:focus{outline-style:none;}"]
});
var useIconStyles4 = __styles2({
  icon: {
    B7ck84d: "f1ewtqcl",
    sj55zd: "fxkbij4",
    Bceei9c: "f1k6fduh",
    mc9l5x: "ftgm304",
    Be2twd7: "f1pp30po",
    Bo70h7d: "fvc9v3g"
  },
  hidden: {
    mc9l5x: "fjseox"
  },
  visuallyHidden: {
    Bh84pgu: "f1ekcaio",
    Bqenvij: "f1mpe4l3",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1jlpb2r",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1c5fvqg",
    a9b677: "frkrog8",
    qhf8xq: "f1euv43f"
  },
  small: {
    Be2twd7: "f4ybsrx",
    Frg6f3: ["f1h9en5y", "f1xk557c"]
  },
  medium: {
    Be2twd7: "fe5j1ua",
    Frg6f3: ["f1h9en5y", "f1xk557c"]
  },
  large: {
    Be2twd7: "f1rt2boy",
    Frg6f3: ["f1t5qyk5", "f1ikr372"]
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr"
  }
}, {
  d: [".f1ewtqcl{box-sizing:border-box;}", ".fxkbij4{color:var(--colorNeutralStrokeAccessible);}", ".f1k6fduh{cursor:pointer;}", ".ftgm304{display:block;}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".fvc9v3g svg{display:block;}", ".fjseox{display:none;}", ".f1ekcaio{clip:rect(0px, 0px, 0px, 0px);}", ".f1mpe4l3{height:1px;}", [".f1jlpb2r{margin:-1px;}", {
    p: -1
  }], [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], [".f1c5fvqg{padding:0px;}", {
    p: -1
  }], ".frkrog8{width:1px;}", ".f1euv43f{position:absolute;}", ".f4ybsrx{font-size:16px;}", ".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}", ".f1xk557c{margin-right:var(--spacingHorizontalXXS);}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f1t5qyk5{margin-left:var(--spacingHorizontalSNudge);}", ".f1ikr372{margin-right:var(--spacingHorizontalSNudge);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}"]
});
var useComboboxStyles_unstable = (state) => {
  "use no memo";
  const {
    appearance,
    open,
    size: size3,
    showClearIcon
  } = state;
  const invalid = `${state.input["aria-invalid"]}` === "true";
  const disabled = state.input.disabled;
  const styles = useStyles14();
  const iconStyles = useIconStyles4();
  const inputStyles = useInputStyles2();
  state.root.className = mergeClasses(comboboxClassNames.root, styles.root, styles[appearance], styles[size3], !disabled && appearance === "outline" && styles.outlineInteractive, invalid && appearance !== "underline" && styles.invalid, invalid && appearance === "underline" && styles.invalidUnderline, disabled && styles.disabled, state.root.className);
  state.input.className = mergeClasses(comboboxClassNames.input, inputStyles.input, inputStyles[size3], disabled && inputStyles.disabled, state.input.className);
  if (state.listbox) {
    state.listbox.className = mergeClasses(comboboxClassNames.listbox, styles.listbox, state.inlinePopup && styles.inlineListbox, !open && styles.listboxCollapsed, state.listbox.className);
  }
  if (state.expandIcon) {
    state.expandIcon.className = mergeClasses(comboboxClassNames.expandIcon, iconStyles.icon, iconStyles[size3], disabled && iconStyles.disabled, showClearIcon && iconStyles.visuallyHidden, state.expandIcon.className);
  }
  if (state.clearIcon) {
    state.clearIcon.className = mergeClasses(comboboxClassNames.clearIcon, iconStyles.icon, iconStyles[size3], disabled && iconStyles.disabled, !showClearIcon && iconStyles.hidden, state.clearIcon.className);
  }
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Combobox/Combobox.js
var Combobox = React172.forwardRef((props, ref) => {
  const state = useCombobox_unstable(props, ref);
  const contextValues = useComboboxContextValues(state);
  useComboboxStyles_unstable(state);
  useCustomStyleHook("useComboboxStyles_unstable")(state);
  return renderCombobox_unstable(state, contextValues);
});
Combobox.displayName = "Combobox";

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/Dropdown.js
var React175 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/useDropdown.js
var React174 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/useButtonTriggerSlot.js
var React173 = __toESM(require_react());
function useButtonTriggerSlot(triggerFromProps, ref, options) {
  "use no memo";
  const { state: { open, setOpen, getOptionById }, defaultProps: defaultProps2, activeDescendantController } = options;
  const searchString = React173.useRef("");
  const [setKeyTimeout, clearKeyTimeout] = useTimeout();
  const moveToNextMatchingOption = (matcher, opt = {
    startFromNext: false
  }) => {
    const { startFromNext } = opt;
    const activeOptionId = activeDescendantController.active();
    const nextInOrder = activeDescendantController.find((id) => {
      const option = getOptionById(id);
      return !!option && matcher(option.text);
    }, {
      startFrom: startFromNext ? activeDescendantController.next({
        passive: true
      }) : activeOptionId
    });
    if (nextInOrder) {
      return nextInOrder;
    }
    return activeDescendantController.find((id) => {
      const option = getOptionById(id);
      return !!option && matcher(option.text);
    });
  };
  const moveToNextMatchingOptionWithSameCharacterHandling = () => {
    if (moveToNextMatchingOption((optionText) => {
      return optionText.toLocaleLowerCase().indexOf(searchString.current) === 0;
    }, {
      // Slowly pressing the same key will cycle through options
      startFromNext: searchString.current.length === 1
    })) {
      return;
    }
    if (allCharactersSame(searchString.current) && moveToNextMatchingOption((optionText) => {
      return optionText.toLocaleLowerCase().indexOf(searchString.current[0]) === 0;
    }, {
      // if the search is all the same letter, cycle through options starting with that letter
      startFromNext: true
    })) {
      return;
    }
    activeDescendantController.blur();
  };
  const onTriggerKeyDown = (ev) => {
    clearKeyTimeout();
    if (getDropdownActionFromKey(ev) === "Type") {
      searchString.current += ev.key.toLowerCase();
      setKeyTimeout(() => {
        searchString.current = "";
      }, 500);
      if (open) {
        moveToNextMatchingOptionWithSameCharacterHandling();
      }
      !open && setOpen(ev, true);
    }
  };
  const trigger = useTriggerSlot(triggerFromProps, ref, {
    state: options.state,
    defaultProps: defaultProps2,
    elementType: "button",
    activeDescendantController
  });
  trigger.onKeyDown = mergeCallbacks(onTriggerKeyDown, trigger.onKeyDown);
  return trigger;
}
function allCharactersSame(str) {
  for (let i = 1; i < str.length; i++) {
    if (str[i] !== str[i - 1]) {
      return false;
    }
  }
  return true;
}

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/useDropdown.js
var useDropdown_unstable = (props, ref) => {
  "use no memo";
  var _state_clearButton;
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsSize: true
  });
  const { listboxRef: activeDescendantListboxRef, activeParentRef, controller: activeDescendantController } = useActiveDescendant({
    matchOption: (el) => el.classList.contains(optionClassNames.root)
  });
  const baseState = useComboboxBaseState({
    ...props,
    activeDescendantController,
    freeform: false
  });
  const { clearable, clearSelection, disabled, hasFocus, multiselect, open, selectedOptions, setOpen } = baseState;
  const { primary: triggerNativeProps, root: rootNativeProps } = getPartitionedNativeProps({
    props,
    primarySlotTagName: "button",
    excludedPropNames: [
      "children"
    ]
  });
  const [comboboxPopupRef, comboboxTargetRef] = useComboboxPositioning(props);
  const triggerRef = React174.useRef(null);
  const listbox = useListboxSlot(props.listbox, useMergedRefs(comboboxPopupRef, activeDescendantListboxRef), {
    state: baseState,
    triggerRef,
    defaultProps: {
      children: props.children
    }
  });
  const { targetDocument } = useFluent();
  useOnClickOutside({
    element: targetDocument,
    callback: (event) => setOpen(event, false),
    refs: [
      triggerRef,
      comboboxPopupRef,
      comboboxTargetRef
    ],
    disabled: !open
  });
  var _props_button;
  const trigger = useButtonTriggerSlot((_props_button = props.button) !== null && _props_button !== void 0 ? _props_button : {}, useMergedRefs(triggerRef, activeParentRef, ref), {
    state: baseState,
    defaultProps: {
      type: "button",
      // tabster navigation breaks if the button is disabled and tabIndex is 0
      tabIndex: triggerNativeProps.disabled ? void 0 : 0,
      children: baseState.value || props.placeholder,
      "aria-controls": open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
      ...triggerNativeProps
    },
    activeDescendantController
  });
  const rootSlot = slot_exports.always(props.root, {
    defaultProps: {
      "aria-owns": !props.inlinePopup && open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
      children: props.children,
      ...rootNativeProps
    },
    elementType: "div"
  });
  rootSlot.ref = useMergedRefs(rootSlot.ref, comboboxTargetRef);
  const showClearButton = selectedOptions.length > 0 && !disabled && clearable && !multiselect;
  const state = {
    components: {
      root: "div",
      button: "button",
      clearButton: "button",
      expandIcon: "span",
      listbox: Listbox
    },
    root: rootSlot,
    button: trigger,
    listbox: open || hasFocus ? listbox : void 0,
    clearButton: slot_exports.optional(props.clearButton, {
      defaultProps: {
        "aria-label": "Clear selection",
        children: React174.createElement(DismissRegular, null),
        // Safari doesn't allow to focus an element with this
        // when the element is not visible (display: none) we need to remove it to avoid tabster issues
        tabIndex: showClearButton ? 0 : void 0,
        type: "button"
      },
      elementType: "button",
      renderByDefault: true
    }),
    expandIcon: slot_exports.optional(props.expandIcon, {
      renderByDefault: true,
      defaultProps: {
        children: React174.createElement(ChevronDownRegular, null)
      },
      elementType: "span"
    }),
    placeholderVisible: !baseState.value && !!props.placeholder,
    showClearButton,
    activeDescendantController,
    ...baseState
  };
  const onClearButtonClick = useEventCallback(mergeCallbacks((_state_clearButton = state.clearButton) === null || _state_clearButton === void 0 ? void 0 : _state_clearButton.onClick, (ev) => {
    var _triggerRef_current;
    clearSelection(ev);
    (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
  }));
  if (state.clearButton) {
    state.clearButton.onClick = onClearButtonClick;
  }
  if (multiselect) {
    state.clearButton = void 0;
  }
  if (true) {
    React174.useEffect(() => {
      if (clearable && multiselect) {
        console.error(`[@fluentui/react-combobox] "clearable" prop is not supported in multiselect mode.`);
      }
    }, [
      clearable,
      multiselect
    ]);
  }
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/renderDropdown.js
var renderDropdown_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(ActiveDescendantContextProvider, {
      value: contextValues.activeDescendant,
      children: jsx(ListboxContext.Provider, {
        value: contextValues.listbox,
        children: jsxs(ComboboxContext.Provider, {
          value: contextValues.combobox,
          children: [
            jsxs(state.button, {
              children: [
                state.button.children,
                state.expandIcon && jsx(state.expandIcon, {})
              ]
            }),
            state.clearButton && jsx(state.clearButton, {}),
            state.listbox && (state.inlinePopup ? jsx(state.listbox, {}) : jsx(Portal, {
              mountNode: state.mountNode,
              children: jsx(state.listbox, {})
            }))
          ]
        })
      })
    })
  });
};

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/useDropdownStyles.styles.js
var dropdownClassNames = {
  root: "fui-Dropdown",
  button: "fui-Dropdown__button",
  clearButton: "fui-Dropdown__clearButton",
  expandIcon: "fui-Dropdown__expandIcon",
  listbox: "fui-Dropdown__listbox"
};
var useStyles15 = __styles2({
  root: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "ftuwxu6",
    Bf4jedk: "f1exfvgq",
    qhf8xq: "f10pi13n",
    ha4doy: "fmrv4ls",
    Bbr2w1p: "f14a1fxs",
    Bduesf4: "f3e99gv",
    Bpq79vn: "fhljsf7",
    li1rpt: "f1gw3sf2",
    Bsft5z2: "f13zj6fq",
    E3zdtr: "f1mdlcz9",
    Eqx8gd: ["f1a7op3", "f1cjjd47"],
    By385i5: "f1gboi2j",
    B1piin3: ["f1cjjd47", "f1a7op3"],
    Dlnsje: "ffyw7fx",
    d9w3h3: ["f1kp91vd", "f1ibwz09"],
    B3778ie: ["f1ibwz09", "f1kp91vd"],
    B1q35kw: 0,
    Bw17bha: 0,
    Bcgy8vk: 0,
    Bjuhk93: "f1mnjydx",
    Gjdm7m: "f13evtba",
    b1kco5: "f1yk9hq",
    Ba2ppi3: "fhwpy7i",
    F2fol1: "f14ee0xe",
    lck23g: "f1xhbsuh",
    df92cz: "fv8e3ye",
    I188md: "ftb5wc6",
    umuwi5: "fjw5xc1",
    Blcqepd: "f1xdyd5c",
    nplu4u: "fatpbeo",
    Bioka5o: "fb7uyps",
    H713fs: "f1cmft4k",
    B9ooomg: "f1x58t8o",
    Bercvud: "f1ibeo51",
    Bz04dq9: "f132nw8t",
    Budl3uf: "f1htdosj"
  },
  listbox: {
    B7ck84d: "f1ewtqcl",
    E5pizo: "f1hg901r",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bxyxcbc: "fmmk62d"
  },
  listboxCollapsed: {
    mc9l5x: "fjseox"
  },
  inlineListbox: {
    Bj3rh1h: "f19g0ac"
  },
  button: {
    Bt984gj: "f122n59",
    De3pzq: "f1c21dwh",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    B7ck84d: "f1ewtqcl",
    sj55zd: "f19n0e5",
    i8kkvl: "f14mj54c",
    Bceei9c: "f1k6fduh",
    mc9l5x: "f13qh94s",
    Bahqtrf: "fk6fouc",
    Budl1dq: "f12nh0o2",
    Brf1p80: "f1869bpl",
    fsow6f: ["f1o700av", "fes3tcz"],
    a9b677: "fly5x3f",
    Brovlpu: "ftqa4ok"
  },
  placeholder: {
    sj55zd: "fxc4j92"
  },
  small: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["fye6m5k", "f3cq2dl"]
  },
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f14ev680", "f58uxzw"]
  },
  large: {
    i8kkvl: "f1rjii52",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f139mn7i", "f1v3q0m"]
  },
  outline: {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: "f1c1zstj",
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fhz96rm"
  },
  outlineInteractive: {
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "f1l4zc64",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    B6oc9vd: "fvs00aa",
    ak43y8: ["f1assf6x", "f4ruux4"],
    wmxk5l: "f1z0osm6",
    B50zh58: ["f4ruux4", "f1assf6x"],
    Bvq3b66: "f1b473iu",
    Brahy3i: ["f381qr8", "ft4skwv"],
    zoxjo1: "f1qzcrsd",
    an54nd: ["ft4skwv", "f381qr8"]
  },
  underline: {
    De3pzq: "f1c21dwh",
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f9ez7ne",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fs2rfia"
  },
  "filled-darker": {
    De3pzq: "f16xq7d1",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fs2rfia"
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  },
  invalidUnderline: {
    hhx65j: "f1fgmyf4"
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    Bjwas2f: "fg455y9",
    Bn1d65q: ["f1rvyvqg", "f14g86mu"],
    Bxeuatn: "f1cwzwz",
    n51gp8: ["f14g86mu", "f1rvyvqg"]
  },
  disabledText: {
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr"
  },
  hidden: {
    mc9l5x: "fjseox"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1ewtqcl{box-sizing:border-box;}", ".ftuwxu6{display:inline-flex;}", ".f1exfvgq{min-width:250px;}", ".f10pi13n{position:relative;}", ".fmrv4ls{vertical-align:middle;}", ".f1gw3sf2::after{box-sizing:border-box;}", '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1a7op3::after{left:-1px;}", ".f1cjjd47::after{right:-1px;}", ".f1gboi2j::after{bottom:-1px;}", ".ffyw7fx::after{height:max(var(--strokeWidthThick), var(--borderRadiusMedium));}", ".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}", [".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", {
    p: -1
  }], ".f13evtba::after{clip-path:inset(calc(100% - 2px) 0 0 0);}", ".f1yk9hq::after{transform:scaleX(0);}", ".fhwpy7i::after{transition-property:transform;}", ".f14ee0xe::after{transition-duration:var(--durationUltraFast);}", ".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}", ".f1hg901r{box-shadow:var(--shadow16);}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fmmk62d{max-height:80vh;}", ".fjseox{display:none;}", ".f19g0ac{z-index:1;}", ".f122n59{align-items:center;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".f3bhgqh{border:none;}", {
    p: -2
  }], ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f14mj54c{column-gap:var(--spacingHorizontalXXS);}", ".f1k6fduh{cursor:pointer;}", ".f13qh94s{display:grid;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f12nh0o2{grid-template-columns:[content] 1fr [icon] auto [end];}", ".f1869bpl{justify-content:space-between;}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".fly5x3f{width:100%;}", ".fxc4j92{color:var(--colorNeutralForeground4);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", [".fye6m5k{padding:3px var(--spacingHorizontalSNudge) 3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f3cq2dl{padding:3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS)) 3px var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f14ev680{padding:5px var(--spacingHorizontalMNudge) 5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f58uxzw{padding:5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS)) 5px var(--spacingHorizontalMNudge);}", {
    p: -1
  }], ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f139mn7i{padding:7px var(--spacingHorizontalM) 7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", {
    p: -1
  }], [".f1v3q0m{padding:7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge)) 7px var(--spacingHorizontalM);}", {
    p: -1
  }], ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", {
    p: -2
  }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", [".f9ez7ne{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", {
    p: -1
  }], [".fokr779{border-radius:0;}", {
    p: -1
  }], [".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", [".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", {
    p: -2
  }], ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"],
  w: [".f14a1fxs:focus-within{outline-width:2px;}", ".f3e99gv:focus-within{outline-style:solid;}", ".fhljsf7:focus-within{outline-color:transparent;}", ".fjw5xc1:focus-within::after{transform:scaleX(1);}", ".f1xdyd5c:focus-within::after{transition-property:transform;}", ".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}", ".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}", ".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".f1b473iu:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f381qr8:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}", ".ft4skwv:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1qzcrsd:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.fv8e3ye::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.ftb5wc6::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1cmft4k:focus-within::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1x58t8o:focus-within::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]],
  t: ["@supports selector(:has(*)){.f132nw8t:has(.fui-Dropdown__clearButton:focus)::after{border-bottom-color:initial;}}", "@supports selector(:has(*)){.f1htdosj:has(.fui-Dropdown__clearButton:focus)::after{transform:scaleX(0);}}"],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"],
  a: [".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"]
});
var useIconStyles5 = __styles2({
  icon: {
    B7ck84d: "f1ewtqcl",
    sj55zd: "fxkbij4",
    mc9l5x: "ftgm304",
    Be2twd7: "f1pp30po",
    Br312pm: "f12w6cgp",
    Bw0ie65: "f8bv1bt",
    Bo70h7d: "fvc9v3g"
  },
  small: {
    Be2twd7: "f4ybsrx",
    Frg6f3: ["f1h9en5y", "f1xk557c"]
  },
  medium: {
    Be2twd7: "fe5j1ua",
    Frg6f3: ["f1h9en5y", "f1xk557c"]
  },
  large: {
    Be2twd7: "f1rt2boy",
    Frg6f3: ["f1t5qyk5", "f1ikr372"]
  },
  disabled: {
    sj55zd: "f1s2aq7o"
  }
}, {
  d: [".f1ewtqcl{box-sizing:border-box;}", ".fxkbij4{color:var(--colorNeutralStrokeAccessible);}", ".ftgm304{display:block;}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f12w6cgp{grid-column-start:icon;}", ".f8bv1bt{grid-column-end:end;}", ".fvc9v3g svg{display:block;}", ".f4ybsrx{font-size:16px;}", ".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}", ".f1xk557c{margin-right:var(--spacingHorizontalXXS);}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f1t5qyk5{margin-left:var(--spacingHorizontalSNudge);}", ".f1ikr372{margin-right:var(--spacingHorizontalSNudge);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"]
});
var useBaseClearButtonStyle = __resetStyles("rticfuj", "r1vp6jef", {
  r: [".rticfuj{align-self:center;background-color:var(--colorTransparentBackground);border:none;cursor:pointer;height:fit-content;margin:0;margin-right:var(--spacingHorizontalMNudge);padding:0;position:relative;}", ".rticfuj:focus{outline-style:none;}", ".rticfuj:focus-visible{outline-style:none;}", ".rticfuj[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.rticfuj[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".r1vp6jef{align-self:center;background-color:var(--colorTransparentBackground);border:none;cursor:pointer;height:fit-content;margin:0;margin-left:var(--spacingHorizontalMNudge);padding:0;position:relative;}", ".r1vp6jef:focus{outline-style:none;}", ".r1vp6jef:focus-visible{outline-style:none;}", ".r1vp6jef[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.r1vp6jef[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.rticfuj[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.r1vp6jef[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useDropdownStyles_unstable = (state) => {
  "use no memo";
  const {
    appearance,
    open,
    placeholderVisible,
    showClearButton,
    size: size3
  } = state;
  const invalid = `${state.button["aria-invalid"]}` === "true";
  const disabled = state.button.disabled;
  const styles = useStyles15();
  const iconStyles = useIconStyles5();
  const clearButtonStyle = useBaseClearButtonStyle();
  state.root.className = mergeClasses(dropdownClassNames.root, styles.root, styles[appearance], !disabled && appearance === "outline" && styles.outlineInteractive, invalid && appearance !== "underline" && styles.invalid, invalid && appearance === "underline" && styles.invalidUnderline, disabled && styles.disabled, state.root.className);
  state.button.className = mergeClasses(dropdownClassNames.button, styles.button, styles[size3], placeholderVisible && styles.placeholder, disabled && styles.disabledText, state.button.className);
  if (state.listbox) {
    state.listbox.className = mergeClasses(dropdownClassNames.listbox, styles.listbox, state.inlinePopup && styles.inlineListbox, !open && styles.listboxCollapsed, state.listbox.className);
  }
  if (state.expandIcon) {
    state.expandIcon.className = mergeClasses(dropdownClassNames.expandIcon, iconStyles.icon, iconStyles[size3], disabled && iconStyles.disabled, showClearButton && styles.hidden, state.expandIcon.className);
  }
  if (state.clearButton) {
    state.clearButton.className = mergeClasses(dropdownClassNames.clearButton, clearButtonStyle, iconStyles.icon, iconStyles[size3], disabled && iconStyles.disabled, !showClearButton && styles.hidden, state.clearButton.className);
  }
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/Dropdown.js
var Dropdown = React175.forwardRef((props, ref) => {
  const state = useDropdown_unstable(props, ref);
  const contextValues = useComboboxContextValues(state);
  useDropdownStyles_unstable(state);
  useCustomStyleHook("useDropdownStyles_unstable")(state);
  return renderDropdown_unstable(state, contextValues);
});
Dropdown.displayName = "Dropdown";

// node_modules/@fluentui/react-combobox/lib/components/OptionGroup/OptionGroup.js
var React177 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/components/OptionGroup/useOptionGroup.js
var React176 = __toESM(require_react());
var useOptionGroup_unstable = (props, ref) => {
  const labelId = useId2("group-label");
  const { label } = props;
  return {
    components: {
      root: "div",
      label: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: "group",
      "aria-labelledby": label ? labelId : void 0,
      ...props
    }), {
      elementType: "div"
    }),
    label: slot_exports.optional(label, {
      defaultProps: {
        id: labelId,
        role: "presentation"
      },
      elementType: "span"
    })
  };
};

// node_modules/@fluentui/react-combobox/lib/components/OptionGroup/renderOptionGroup.js
var renderOptionGroup_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.label && jsx(state.label, {
        children: state.label.children
      }),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-combobox/lib/components/OptionGroup/useOptionGroupStyles.styles.js
var optionGroupClassNames = {
  root: "fui-OptionGroup",
  label: "fui-OptionGroup__label"
};
var useStyles16 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    Belr9w4: "fiut8dr",
    B8lkq7l: "f1xxzjds",
    eii1in: 0,
    H93o2g: 0,
    Gwp8xu: 0,
    Bd39igo: "f16cmn8k",
    om0q45: "f5642y",
    Hl9o3s: "ffdf81h",
    sl1c2c: 0,
    z4hxbw: 0,
    B0i58d9: 0,
    Bi9x0x4: 0,
    Bgurq3m: "f1bsn9kn"
  },
  label: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    sj55zd: "f11d4kpn",
    mc9l5x: "ftgm304",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fwrc4pm",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mpq0zz"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".fiut8dr{row-gap:var(--spacingHorizontalXXS);}", '.f1xxzjds:not(:last-child)::after{content:"";}', [".f16cmn8k:not(:last-child)::after{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStroke2);}", {
    p: -1
  }], ".f5642y:not(:last-child)::after{display:block;}", ".ffdf81h:not(:last-child)::after{padding-bottom:var(--spacingHorizontalXS);}", [".f1bsn9kn:not(:last-child)::after{margin:0 calc(var(--spacingHorizontalXS) * -1) var(--spacingVerticalXS);}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".ftgm304{display:block;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", [".f1mpq0zz{padding:var(--spacingHorizontalS) var(--spacingHorizontalSNudge);}", {
    p: -1
  }]]
});
var useOptionGroupStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles16();
  state.root.className = mergeClasses(optionGroupClassNames.root, styles.root, state.root.className);
  if (state.label) {
    state.label.className = mergeClasses(optionGroupClassNames.label, styles.label, state.label.className);
  }
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/OptionGroup/OptionGroup.js
var OptionGroup = React177.forwardRef((props, ref) => {
  const state = useOptionGroup_unstable(props, ref);
  useOptionGroupStyles_unstable(state);
  useCustomStyleHook("useOptionGroupStyles_unstable")(state);
  return renderOptionGroup_unstable(state);
});
OptionGroup.displayName = "OptionGroup";

// node_modules/@fluentui/react-combobox/lib/hooks/useComboboxFilter.js
var React178 = __toESM(require_react());
function defaultFilter(optionText, query) {
  if (query === "") {
    return true;
  }
  return optionText.toLowerCase().includes(query.toLowerCase());
}
function defaultToString(option) {
  return typeof option === "string" ? option : option.value;
}
function useComboboxFilter(query, options, config) {
  const { filter = defaultFilter, noOptionsMessage = "We couldn't find any matches.", optionToReactKey = defaultToString, optionToText = defaultToString, renderOption = (option) => {
    if (typeof option === "string") {
      return React178.createElement(Option, {
        key: option
      }, option);
    }
    return React178.createElement(Option, {
      ...option,
      key: optionToReactKey(option),
      text: optionToText(option),
      value: option.value
    }, option.children);
  } } = config;
  const filteredOptions = React178.useMemo(() => {
    const searchValue = query.trim();
    return options.filter((option) => filter(optionToText(option), searchValue));
  }, [
    options,
    optionToText,
    filter,
    query
  ]);
  if (filteredOptions.length === 0) {
    return [
      React178.createElement(Option, {
        "aria-disabled": "true",
        key: "no-results",
        text: ""
      }, noOptionsMessage)
    ];
  }
  return filteredOptions.map((option) => renderOption(option));
}

// node_modules/@fluentui/react-divider/lib/components/Divider/Divider.js
var React180 = __toESM(require_react());

// node_modules/@fluentui/react-divider/lib/components/Divider/renderDivider.js
var renderDivider_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: state.root.children !== void 0 && jsx(state.wrapper, {
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-divider/lib/components/Divider/useDivider.js
var React179 = __toESM(require_react());
var useDivider_unstable = (props, ref) => {
  const { alignContent = "center", appearance = "default", inset = false, vertical = false, wrapper } = props;
  const dividerId = useId2("divider-");
  return {
    // Props passed at the top-level
    alignContent,
    appearance,
    inset,
    vertical,
    // Slots definition
    components: {
      root: "div",
      wrapper: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      role: "separator",
      "aria-orientation": vertical ? "vertical" : "horizontal",
      "aria-labelledby": props.children ? dividerId : void 0,
      ...props,
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref
    }), {
      elementType: "div"
    }),
    wrapper: slot_exports.always(wrapper, {
      defaultProps: {
        id: dividerId,
        children: props.children
      },
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-divider/lib/components/Divider/useDividerStyles.styles.js
var dividerClassNames = {
  root: "fui-Divider",
  wrapper: "fui-Divider__wrapper"
};
var useBaseStyles = __styles2({
  base: {
    Bt984gj: "f122n59",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    Bh6795r: "fqerorx",
    qhf8xq: "f10pi13n",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    fsow6f: "f17mccla",
    Bcvre1j: "fyl8oag",
    Br0sdwz: "f16vkdww",
    Bn78ew0: "fhsnbul",
    li1rpt: "f1gw3sf2",
    ap17g6: "f1ly5f7u",
    B771hl4: "f1s3tz6t"
  },
  childless: {
    susq4k: "f1kyqvp9",
    Bicfajf: ["fzynn9s", "f1z0ukd1"],
    jwcpgy: ["fekrn8e", "ftdg338"],
    B4rk6o: "fesgyo"
  },
  start: {
    Bsft5z2: "f13zj6fq"
  },
  center: {
    Ftih45: "f1wl9k8s",
    Bsft5z2: "f13zj6fq"
  },
  end: {
    Ftih45: "f1wl9k8s"
  },
  brand: {
    sj55zd: "f16muhyy",
    Bq4z7u6: "fcbuu2a",
    Bk5zm6e: ["f1wdw2dr", "f1ttio3w"],
    Bqjgrrk: "f1582fpk",
    Bm6vgfq: ["f1ttio3w", "f1wdw2dr"],
    B0n5ga8: "f1ahrvm8",
    s924m2: ["f1cd3wbc", "f17hbk9y"],
    B1q35kw: "fvrapl0",
    Gp14am: ["f17hbk9y", "f1cd3wbc"]
  },
  "default": {
    sj55zd: "fkfq4zb",
    Bq4z7u6: "f1vccso1",
    Bk5zm6e: ["f1geml7w", "fjml6kk"],
    Bqjgrrk: "f1r7kh1m",
    Bm6vgfq: ["fjml6kk", "f1geml7w"],
    B0n5ga8: "f16j7guv",
    s924m2: ["fx01ahm", "fj1a37q"],
    B1q35kw: "fl8d8yv",
    Gp14am: ["fj1a37q", "fx01ahm"]
  },
  subtle: {
    sj55zd: "f11d4kpn",
    Bq4z7u6: "f5g06un",
    Bk5zm6e: ["f13sxdku", "f1n015lb"],
    Bqjgrrk: "f1x6bl8t",
    Bm6vgfq: ["f1n015lb", "f13sxdku"],
    B0n5ga8: "fvod1wy",
    s924m2: ["fwslg65", "flk0e17"],
    B1q35kw: "f103fvts",
    Gp14am: ["flk0e17", "fwslg65"]
  },
  strong: {
    sj55zd: "f19n0e5",
    Bq4z7u6: "f10tv6oz",
    Bk5zm6e: ["f16xp3sf", "f1seuxxq"],
    Bqjgrrk: "fwrmqbx",
    Bm6vgfq: ["f1seuxxq", "f16xp3sf"],
    B0n5ga8: "ft83z1f",
    s924m2: ["f1g4150c", "f192dr6e"],
    B1q35kw: "f1qnawh6",
    Gp14am: ["f192dr6e", "f1g4150c"]
  }
}, {
  d: [".f122n59{align-items:center;}", ".f1ewtqcl{box-sizing:border-box;}", ".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".fqerorx{flex-grow:1;}", ".f10pi13n{position:relative;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f17mccla{text-align:center;}", ".fyl8oag::before{box-sizing:border-box;}", ".f16vkdww::before{display:flex;}", ".fhsnbul::before{flex-grow:1;}", ".f1gw3sf2::after{box-sizing:border-box;}", ".f1ly5f7u::after{display:flex;}", ".f1s3tz6t::after{flex-grow:1;}", ".f1kyqvp9::before{margin-bottom:0;}", ".fzynn9s::before{margin-right:0;}", ".f1z0ukd1::before{margin-left:0;}", ".fekrn8e::after{margin-left:0;}", ".ftdg338::after{margin-right:0;}", ".fesgyo::after{margin-top:0;}", '.f13zj6fq::after{content:"";}', '.f1wl9k8s::before{content:"";}', ".f16muhyy{color:var(--colorBrandForeground1);}", ".fcbuu2a::before{border-top-color:var(--colorBrandStroke1);}", ".f1wdw2dr::before{border-right-color:var(--colorBrandStroke1);}", ".f1ttio3w::before{border-left-color:var(--colorBrandStroke1);}", ".f1582fpk::before{border-bottom-color:var(--colorBrandStroke1);}", ".f1ahrvm8::after{border-top-color:var(--colorBrandStroke1);}", ".f1cd3wbc::after{border-right-color:var(--colorBrandStroke1);}", ".f17hbk9y::after{border-left-color:var(--colorBrandStroke1);}", ".fvrapl0::after{border-bottom-color:var(--colorBrandStroke1);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f1vccso1::before{border-top-color:var(--colorNeutralStroke2);}", ".f1geml7w::before{border-right-color:var(--colorNeutralStroke2);}", ".fjml6kk::before{border-left-color:var(--colorNeutralStroke2);}", ".f1r7kh1m::before{border-bottom-color:var(--colorNeutralStroke2);}", ".f16j7guv::after{border-top-color:var(--colorNeutralStroke2);}", ".fx01ahm::after{border-right-color:var(--colorNeutralStroke2);}", ".fj1a37q::after{border-left-color:var(--colorNeutralStroke2);}", ".fl8d8yv::after{border-bottom-color:var(--colorNeutralStroke2);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f5g06un::before{border-top-color:var(--colorNeutralStroke3);}", ".f13sxdku::before{border-right-color:var(--colorNeutralStroke3);}", ".f1n015lb::before{border-left-color:var(--colorNeutralStroke3);}", ".f1x6bl8t::before{border-bottom-color:var(--colorNeutralStroke3);}", ".fvod1wy::after{border-top-color:var(--colorNeutralStroke3);}", ".fwslg65::after{border-right-color:var(--colorNeutralStroke3);}", ".flk0e17::after{border-left-color:var(--colorNeutralStroke3);}", ".f103fvts::after{border-bottom-color:var(--colorNeutralStroke3);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f10tv6oz::before{border-top-color:var(--colorNeutralStroke1);}", ".f16xp3sf::before{border-right-color:var(--colorNeutralStroke1);}", ".f1seuxxq::before{border-left-color:var(--colorNeutralStroke1);}", ".fwrmqbx::before{border-bottom-color:var(--colorNeutralStroke1);}", ".ft83z1f::after{border-top-color:var(--colorNeutralStroke1);}", ".f1g4150c::after{border-right-color:var(--colorNeutralStroke1);}", ".f192dr6e::after{border-left-color:var(--colorNeutralStroke1);}", ".f1qnawh6::after{border-bottom-color:var(--colorNeutralStroke1);}"]
});
var useHorizontalStyles = __styles2({
  base: {
    a9b677: "fly5x3f",
    Bdkvgpv: "f163fonl",
    B0qfbqy: "f51yk4v",
    pbipgd: "f13rof3u",
    Bm2nyyq: "f8rth92",
    xrcqlc: "f6czdpx",
    i5u598: "f1iyka9k"
  },
  inset: {
    uwmqm3: ["fjlbh76", "f11qrl6u"],
    z189sj: ["f11qrl6u", "fjlbh76"]
  },
  start: {
    fsow6f: ["f1o700av", "fes3tcz"],
    Ftih45: "f1wl9k8s",
    Bicfajf: ["f1ojjlep", "fk1kexq"],
    Bxwl2t9: "f1he2m4d",
    jwcpgy: ["f12w1bnb", "f1558wlj"]
  },
  center: {
    fsow6f: "f17mccla",
    Bicfajf: ["f1ojjlep", "fk1kexq"],
    jwcpgy: ["f12w1bnb", "f1558wlj"]
  },
  end: {
    fsow6f: ["fes3tcz", "f1o700av"],
    Bicfajf: ["f1ojjlep", "fk1kexq"],
    Bsft5z2: "f13zj6fq",
    jwcpgy: ["f12w1bnb", "f1558wlj"],
    Iy66sp: "f1ayce8x"
  }
}, {
  d: [".fly5x3f{width:100%;}", ".f163fonl::before{border-top-style:solid;}", ".f51yk4v::before{border-top-width:var(--strokeWidthThin);}", ".f13rof3u::before{min-width:8px;}", ".f8rth92::after{border-top-style:solid;}", ".f6czdpx::after{border-top-width:var(--strokeWidthThin);}", ".f1iyka9k::after{min-width:8px;}", ".fjlbh76{padding-left:12px;}", ".f11qrl6u{padding-right:12px;}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", '.f1wl9k8s::before{content:"";}', ".f1ojjlep::before{margin-right:12px;}", ".fk1kexq::before{margin-left:12px;}", ".f1he2m4d::before{max-width:8px;}", ".f12w1bnb::after{margin-left:12px;}", ".f1558wlj::after{margin-right:12px;}", ".f17mccla{text-align:center;}", '.f13zj6fq::after{content:"";}', ".f1ayce8x::after{max-width:8px;}"]
});
var useVerticalStyles = __styles2({
  base: {
    Beiy3e4: "f1vx9l62",
    sshi5w: "f16gbxbe",
    m598lv: ["f1yq6w5o", "f1jpmc5p"],
    B4f6apu: ["f9sc749", "f1x8pvcy"],
    zkzzav: "fhkwbjy",
    Barhvk9: ["flthirb", "ftkbnf5"],
    Ihftqj: ["f13hvwk3", "f1en4csx"],
    Bde111x: "f19onpk6"
  },
  inset: {
    B6of3ja: "f1xdg43u",
    jrapky: "f1jlhsmd"
  },
  withChildren: {
    sshi5w: "f1tjaq3g"
  },
  start: {
    Ftih45: "f1wl9k8s",
    susq4k: "fg2pwug",
    Bbdr6tz: "fkjtzyi",
    B4rk6o: "f8vk40g"
  },
  center: {
    susq4k: "fg2pwug",
    B4rk6o: "f8vk40g"
  },
  end: {
    susq4k: "fg2pwug",
    Bsft5z2: "f13zj6fq",
    B4rk6o: "f8vk40g",
    gn64ia: "fqg5mu5"
  }
}, {
  d: [".f1vx9l62{flex-direction:column;}", ".f16gbxbe{min-height:20px;}", ".f1yq6w5o::before{border-right-style:solid;}", ".f1jpmc5p::before{border-left-style:solid;}", ".f9sc749::before{border-right-width:var(--strokeWidthThin);}", ".f1x8pvcy::before{border-left-width:var(--strokeWidthThin);}", ".fhkwbjy::before{min-height:8px;}", ".flthirb::after{border-right-style:solid;}", ".ftkbnf5::after{border-left-style:solid;}", ".f13hvwk3::after{border-right-width:var(--strokeWidthThin);}", ".f1en4csx::after{border-left-width:var(--strokeWidthThin);}", ".f19onpk6::after{min-height:8px;}", ".f1xdg43u{margin-top:12px;}", ".f1jlhsmd{margin-bottom:12px;}", ".f1tjaq3g{min-height:84px;}", '.f1wl9k8s::before{content:"";}', ".fg2pwug::before{margin-bottom:12px;}", ".fkjtzyi::before{max-height:8px;}", ".f8vk40g::after{margin-top:12px;}", '.f13zj6fq::after{content:"";}', ".fqg5mu5::after{max-height:8px;}"]
});
var useDividerStyles_unstable = (state) => {
  "use no memo";
  const baseStyles3 = useBaseStyles();
  const horizontalStyles = useHorizontalStyles();
  const verticalStyles = useVerticalStyles();
  const {
    alignContent,
    appearance,
    inset,
    vertical
  } = state;
  state.root.className = mergeClasses(
    dividerClassNames.root,
    // Base styles
    baseStyles3.base,
    baseStyles3[alignContent],
    appearance && baseStyles3[appearance],
    // Horizontal styles
    !vertical && horizontalStyles.base,
    !vertical && inset && horizontalStyles.inset,
    !vertical && horizontalStyles[alignContent],
    // Vertical styles
    vertical && verticalStyles.base,
    vertical && inset && verticalStyles.inset,
    vertical && verticalStyles[alignContent],
    vertical && state.root.children !== void 0 && verticalStyles.withChildren,
    // Childless styles
    state.root.children === void 0 && baseStyles3.childless,
    // User provided class name
    state.root.className
  );
  if (state.wrapper) {
    state.wrapper.className = mergeClasses(dividerClassNames.wrapper, state.wrapper.className);
  }
  return state;
};

// node_modules/@fluentui/react-divider/lib/components/Divider/Divider.js
var Divider = React180.forwardRef((props, ref) => {
  const state = useDivider_unstable(props, ref);
  useDividerStyles_unstable(state);
  useCustomStyleHook("useDividerStyles_unstable")(state);
  return renderDivider_unstable(state);
});
Divider.displayName = "Divider";

// node_modules/@fluentui/react-input/lib/components/Input/Input.js
var React182 = __toESM(require_react());

// node_modules/@fluentui/react-input/lib/components/Input/useInput.js
var React181 = __toESM(require_react());
var useInput_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true,
    supportsSize: true
  });
  const overrides = useOverrides();
  var _overrides_inputDefaultAppearance;
  const { size: size3 = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", onChange } = props;
  if (appearance === "filled-darker-shadow" || appearance === "filled-lighter-shadow") {
    console.error("The 'filled-darker-shadow' and 'filled-lighter-shadow' appearances are deprecated and will be removed in the future.");
  }
  const [value, setValue] = useControllableState({
    state: props.value,
    defaultState: props.defaultValue,
    initialState: ""
  });
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "size",
      "onChange",
      "value",
      "defaultValue"
    ]
  });
  const state = {
    size: size3,
    appearance,
    components: {
      root: "span",
      input: "input",
      contentBefore: "span",
      contentAfter: "span"
    },
    input: slot_exports.always(props.input, {
      defaultProps: {
        type: "text",
        ref,
        ...nativeProps.primary
      },
      elementType: "input"
    }),
    contentAfter: slot_exports.optional(props.contentAfter, {
      elementType: "span"
    }),
    contentBefore: slot_exports.optional(props.contentBefore, {
      elementType: "span"
    }),
    root: slot_exports.always(props.root, {
      defaultProps: nativeProps.root,
      elementType: "span"
    })
  };
  state.input.value = value;
  state.input.onChange = useEventCallback((ev) => {
    const newValue = ev.target.value;
    onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
      value: newValue
    });
    setValue(newValue);
  });
  return state;
};

// node_modules/@fluentui/react-input/lib/components/Input/renderInput.js
var renderInput_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.contentBefore && jsx(state.contentBefore, {}),
      jsx(state.input, {}),
      state.contentAfter && jsx(state.contentAfter, {})
    ]
  });
};

// node_modules/@fluentui/react-input/lib/components/Input/useInputStyles.styles.js
var inputClassNames = {
  root: "fui-Input",
  input: "fui-Input__input",
  contentBefore: "fui-Input__contentBefore",
  contentAfter: "fui-Input__contentAfter"
};
var horizontalPadding = {
  root: {
    small: tokens.spacingHorizontalSNudge,
    medium: tokens.spacingHorizontalMNudge,
    large: tokens.spacingHorizontalM
  },
  input: {
    small: tokens.spacingHorizontalXXS,
    medium: tokens.spacingHorizontalXXS,
    large: tokens.spacingHorizontalSNudge
  },
  combined: {
    small: tokens.spacingHorizontalS,
    medium: tokens.spacingHorizontalM,
    large: `calc(${tokens.spacingHorizontalM} + ${tokens.spacingHorizontalSNudge})`
  }
};
var useRootClassName4 = __resetStyles("r1oeeo9n", "r9sxh5", {
  r: [".r1oeeo9n{display:inline-flex;align-items:center;flex-wrap:nowrap;gap:var(--spacingHorizontalXXS);border-radius:var(--borderRadiusMedium);position:relative;box-sizing:border-box;vertical-align:middle;min-height:32px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);background-color:var(--colorNeutralBackground1);border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);}", '.r1oeeo9n::after{box-sizing:border-box;content:"";position:absolute;left:-1px;bottom:-1px;right:-1px;height:max(2px, var(--borderRadiusMedium));border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".r1oeeo9n:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".r1oeeo9n:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".r1oeeo9n:focus-within{outline:2px solid transparent;}", ".r9sxh5{display:inline-flex;align-items:center;flex-wrap:nowrap;gap:var(--spacingHorizontalXXS);border-radius:var(--borderRadiusMedium);position:relative;box-sizing:border-box;vertical-align:middle;min-height:32px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);background-color:var(--colorNeutralBackground1);border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);}", '.r9sxh5::after{box-sizing:border-box;content:"";position:absolute;right:-1px;bottom:-1px;left:-1px;height:max(2px, var(--borderRadiusMedium));border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".r9sxh5:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".r9sxh5:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".r9sxh5:focus-within{outline:2px solid transparent;}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.r1oeeo9n::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1oeeo9n:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r9sxh5::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r9sxh5:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}"]
});
var useRootStyles8 = __styles2({
  small: {
    sshi5w: "f1pha7fy",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  medium: {},
  large: {
    sshi5w: "f1w5jphr",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1eyhf9v"
  },
  outline: {},
  outlineInteractive: {
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "f1l4zc64",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    Drbcw7: "f8vnjqi",
    udz0bu: ["fz1etlk", "f1hc16gm"],
    Be8ivqh: "f1klwx88",
    ofdepl: ["f1hc16gm", "fz1etlk"]
  },
  underline: {
    De3pzq: "f1c21dwh",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779",
    icvyot: "f1ern45e",
    vrafjx: ["f1n71otn", "f1deefiw"],
    wvpqe5: ["f1deefiw", "f1n71otn"],
    Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
    B1piin3: ["f15yvnhg", "f1n6gb5g"]
  },
  underlineInteractive: {
    oetu4i: "f1l4zc64",
    Be8ivqh: "f1klwx88",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "f2ale1x"
  },
  filled: {
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"]
  },
  filledInteractive: {
    q7v0qe: "ftmjh5b",
    kmh5ft: ["f17blpuu", "fsrcdbj"],
    nagaa4: "f1tpwn32",
    B1yhkcb: ["fsrcdbj", "f17blpuu"]
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  },
  "filled-darker": {
    De3pzq: "f16xq7d1"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r"
  },
  "filled-darker-shadow": {
    De3pzq: "f16xq7d1",
    E5pizo: "fyed02w"
  },
  "filled-lighter-shadow": {
    De3pzq: "fxugw4r",
    E5pizo: "fyed02w"
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    Bjwas2f: "fg455y9",
    Bn1d65q: ["f1rvyvqg", "f14g86mu"],
    Bxeuatn: "f1cwzwz",
    n51gp8: ["f14g86mu", "f1rvyvqg"],
    Bsft5z2: "fhr9occ",
    Bduesf4: "f99w1ws"
  },
  smallWithContentBefore: {
    uwmqm3: ["fk8j09s", "fdw0yi8"]
  },
  smallWithContentAfter: {
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  mediumWithContentBefore: {
    uwmqm3: ["f1ng84yb", "f11gcy0p"]
  },
  mediumWithContentAfter: {
    z189sj: ["f11gcy0p", "f1ng84yb"]
  },
  largeWithContentBefore: {
    uwmqm3: ["f1uw59to", "fw5db7e"]
  },
  largeWithContentAfter: {
    z189sj: ["fw5db7e", "f1uw59to"]
  }
}, {
  d: [".f1pha7fy{min-height:24px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1w5jphr{min-height:40px;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".fokr779{border-radius:0;}", {
    p: -1
  }], ".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1n6gb5g::after{left:0;}", ".f15yvnhg::after{right:0;}", [".f2ale1x::after{border-radius:0;}", {
    p: -1
  }], ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".fyed02w{box-shadow:var(--shadow2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fhr9occ::after{content:unset;}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}", ".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}", ".f1uw59to{padding-left:var(--spacingHorizontalM);}", ".fw5db7e{padding-right:var(--spacingHorizontalM);}"],
  h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}", ".ftmjh5b:hover,.ftmjh5b:focus-within{border-top-color:var(--colorTransparentStrokeInteractive);}", ".f17blpuu:hover,.f17blpuu:focus-within{border-right-color:var(--colorTransparentStrokeInteractive);}", ".fsrcdbj:hover,.fsrcdbj:focus-within{border-left-color:var(--colorTransparentStrokeInteractive);}", ".f1tpwn32:hover,.f1tpwn32:focus-within{border-bottom-color:var(--colorTransparentStrokeInteractive);}"],
  a: [".f8vnjqi:active,.f8vnjqi:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}", ".fz1etlk:active,.fz1etlk:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f1hc16gm:active,.f1hc16gm:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1klwx88:active,.f1klwx88:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
  m: [["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]],
  w: [".f99w1ws:focus-within{outline-style:none;}"]
});
var useInputClassName = __resetStyles("r12stul0", null, [".r12stul0{align-self:stretch;box-sizing:border-box;flex-grow:1;min-width:0;border-style:none;padding:0 var(--spacingHorizontalM);color:var(--colorNeutralForeground1);background-color:transparent;outline-style:none;font-family:inherit;font-size:inherit;font-weight:inherit;line-height:inherit;}", ".r12stul0::-webkit-input-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r12stul0::-moz-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r12stul0::placeholder{color:var(--colorNeutralForeground4);opacity:1;}"]);
var useInputElementStyles = __styles2({
  small: {
    uwmqm3: ["f1f5gg8d", "f1vdfbxk"],
    z189sj: ["f1vdfbxk", "f1f5gg8d"]
  },
  medium: {},
  large: {
    uwmqm3: ["fnphzt9", "flt1dlf"],
    z189sj: ["flt1dlf", "fnphzt9"]
  },
  smallWithContentBefore: {
    uwmqm3: ["fgiv446", "ffczdla"]
  },
  smallWithContentAfter: {
    z189sj: ["ffczdla", "fgiv446"]
  },
  mediumWithContentBefore: {
    uwmqm3: ["fgiv446", "ffczdla"]
  },
  mediumWithContentAfter: {
    z189sj: ["ffczdla", "fgiv446"]
  },
  largeWithContentBefore: {
    uwmqm3: ["fk8j09s", "fdw0yi8"]
  },
  largeWithContentAfter: {
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    De3pzq: "f1c21dwh",
    Bceei9c: "fdrzuqr",
    yvdlaj: "fahhnxm"
  }
}, {
  d: [".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".fnphzt9{padding-left:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", ".flt1dlf{padding-right:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fdrzuqr{cursor:not-allowed;}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"]
});
var useContentClassName = __resetStyles("r1572tok", null, [".r1572tok{box-sizing:border-box;color:var(--colorNeutralForeground3);display:flex;}", ".r1572tok>svg{font-size:20px;}"]);
var useContentStyles2 = __styles2({
  disabled: {
    sj55zd: "f1s2aq7o"
  },
  small: {
    Duoase: "f3qv9w"
  },
  medium: {},
  large: {
    Duoase: "f16u2scb"
  }
}, {
  d: [".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f3qv9w>svg{font-size:16px;}", ".f16u2scb>svg{font-size:24px;}"]
});
var useInputStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3,
    appearance
  } = state;
  const disabled = state.input.disabled;
  const invalid = `${state.input["aria-invalid"]}` === "true";
  const filled = appearance.startsWith("filled");
  const rootStyles = useRootStyles8();
  const inputStyles = useInputElementStyles();
  const contentStyles = useContentStyles2();
  state.root.className = mergeClasses(inputClassNames.root, useRootClassName4(), rootStyles[size3], state.contentBefore && rootStyles[`${size3}WithContentBefore`], state.contentAfter && rootStyles[`${size3}WithContentAfter`], rootStyles[appearance], !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && appearance === "underline" && rootStyles.underlineInteractive, !disabled && filled && rootStyles.filledInteractive, filled && rootStyles.filled, !disabled && invalid && rootStyles.invalid, disabled && rootStyles.disabled, state.root.className);
  state.input.className = mergeClasses(inputClassNames.input, useInputClassName(), inputStyles[size3], state.contentBefore && inputStyles[`${size3}WithContentBefore`], state.contentAfter && inputStyles[`${size3}WithContentAfter`], disabled && inputStyles.disabled, state.input.className);
  const contentClasses = [useContentClassName(), disabled && contentStyles.disabled, contentStyles[size3]];
  if (state.contentBefore) {
    state.contentBefore.className = mergeClasses(inputClassNames.contentBefore, ...contentClasses, state.contentBefore.className);
  }
  if (state.contentAfter) {
    state.contentAfter.className = mergeClasses(inputClassNames.contentAfter, ...contentClasses, state.contentAfter.className);
  }
  return state;
};

// node_modules/@fluentui/react-input/lib/components/Input/Input.js
var Input = React182.forwardRef((props, ref) => {
  const state = useInput_unstable(props, ref);
  useInputStyles_unstable(state);
  useCustomStyleHook("useInputStyles_unstable")(state);
  return renderInput_unstable(state);
});
Input.displayName = "Input";

// node_modules/@fluentui/react-image/lib/components/Image/Image.js
var React184 = __toESM(require_react());

// node_modules/@fluentui/react-image/lib/components/Image/renderImage.js
var renderImage_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-image/lib/components/Image/useImage.js
var React183 = __toESM(require_react());
var useImage_unstable = (props, ref) => {
  const { bordered = false, fit = "default", block = false, shape = "square", shadow = false } = props;
  const state = {
    bordered,
    fit,
    block,
    shape,
    shadow,
    components: {
      root: "img"
    },
    root: slot_exports.always(getIntrinsicElementProps("img", {
      ref,
      ...props
    }), {
      elementType: "img"
    })
  };
  return state;
};

// node_modules/@fluentui/react-image/lib/components/Image/useImageStyles.styles.js
var imageClassNames = {
  root: "fui-Image"
};
var useStyles17 = __styles2({
  base: {
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"],
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "f14t3ns0"
  },
  bordered: {
    icvyot: "fzkkow9",
    vrafjx: ["fcdblym", "fjik90z"],
    oivjwe: "fg706s2",
    wvpqe5: ["fjik90z", "fcdblym"],
    B4j52fo: "f192inf7",
    Bekrc4i: ["f5tn483", "f1ojsxk5"],
    Bn0qgzm: "f1vxd6vx",
    ibv6hh: ["f1ojsxk5", "f5tn483"]
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9"
  },
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  square: {},
  shadow: {
    E5pizo: "f1whvlc6"
  },
  center: {
    st4lth: "f1plgu50",
    Ermj5k: "f14xojzb",
    Bqenvij: "f1l02sjl",
    a9b677: "fly5x3f"
  },
  contain: {
    st4lth: "f1kle4es",
    Ermj5k: "f14xojzb",
    Bqenvij: "f1l02sjl",
    a9b677: "fly5x3f"
  },
  "default": {},
  cover: {
    st4lth: "f1ps3kmd",
    Ermj5k: "f14xojzb",
    Bqenvij: "f1l02sjl",
    a9b677: "fly5x3f"
  },
  none: {
    st4lth: "f1plgu50",
    Ermj5k: ["f13uwng7", "fjmyj0p"],
    Bqenvij: "f1l02sjl",
    a9b677: "fly5x3f"
  },
  block: {
    a9b677: "fly5x3f"
  }
}, {
  d: [".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], ".f1ewtqcl{box-sizing:border-box;}", ".f14t3ns0{display:inline-block;}", ".fzkkow9{border-top-style:solid;}", ".fcdblym{border-right-style:solid;}", ".fjik90z{border-left-style:solid;}", ".fg706s2{border-bottom-style:solid;}", ".f192inf7{border-top-width:var(--strokeWidthThin);}", ".f5tn483{border-right-width:var(--strokeWidthThin);}", ".f1ojsxk5{border-left-width:var(--strokeWidthThin);}", ".f1vxd6vx{border-bottom-width:var(--strokeWidthThin);}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1whvlc6{box-shadow:var(--shadow4);}", ".f1plgu50{object-fit:none;}", ".f14xojzb{object-position:center;}", ".f1l02sjl{height:100%;}", ".fly5x3f{width:100%;}", ".f1kle4es{object-fit:contain;}", ".f1ps3kmd{object-fit:cover;}", ".f13uwng7{object-position:left top;}", ".fjmyj0p{object-position:right top;}"]
});
var useImageStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles17();
  state.root.className = mergeClasses(imageClassNames.root, styles.base, state.block && styles.block, state.bordered && styles.bordered, state.shadow && styles.shadow, styles[state.fit], styles[state.shape], state.root.className);
  return state;
};

// node_modules/@fluentui/react-image/lib/components/Image/Image.js
var Image = React184.forwardRef((props, ref) => {
  const state = useImage_unstable(props, ref);
  useImageStyles_unstable(state);
  useCustomStyleHook("useImageStyles_unstable")(state);
  return renderImage_unstable(state);
});
Image.displayName = "Image";

// node_modules/@fluentui/react-link/lib/components/Link/Link.js
var React188 = __toESM(require_react());

// node_modules/@fluentui/react-link/lib/components/Link/useLink.js
var React187 = __toESM(require_react());

// node_modules/@fluentui/react-link/lib/components/Link/useLinkState.js
var React185 = __toESM(require_react());
var useLinkState_unstable = (state) => {
  const { disabled, disabledFocusable } = state;
  const { onClick, onKeyDown, role, tabIndex } = state.root;
  if (state.root.as === "a") {
    state.root.href = disabled ? void 0 : state.root.href;
    if (disabled || disabledFocusable) {
      state.root.role = role || "link";
    }
  }
  if (state.root.as === "a" || state.root.as === "span") {
    state.root.tabIndex = tabIndex !== null && tabIndex !== void 0 ? tabIndex : disabled && !disabledFocusable ? void 0 : 0;
  }
  state.root.onClick = (ev) => {
    if (disabled || disabledFocusable) {
      ev.preventDefault();
    } else {
      onClick === null || onClick === void 0 ? void 0 : onClick(ev);
    }
  };
  state.root.onKeyDown = (ev) => {
    const keyPressed = ev.key === Enter || ev.key === Space;
    if ((disabled || disabledFocusable) && keyPressed) {
      ev.preventDefault();
      ev.stopPropagation();
    } else {
      onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);
      if (state.root.as === "span" && !!state.root.onClick && !onKeyDown && keyPressed) {
        ev.preventDefault();
        ev.currentTarget.click();
      }
    }
  };
  state.disabled = disabled || disabledFocusable;
  state.root["aria-disabled"] = disabled || disabledFocusable || void 0;
  if (state.root.as === "button") {
    state.root.disabled = disabled && !disabledFocusable;
  }
  return state;
};

// node_modules/@fluentui/react-link/lib/contexts/linkContext.js
var React186 = __toESM(require_react());
var LinkContext = React186.createContext(void 0);
var linkContextDefaultValue = {
  inline: false
};
var LinkContextProvider = LinkContext.Provider;
var useLinkContext = () => {
  var _React_useContext;
  return (_React_useContext = React186.useContext(LinkContext)) !== null && _React_useContext !== void 0 ? _React_useContext : linkContextDefaultValue;
};

// node_modules/@fluentui/react-link/lib/components/Link/useLink.js
var useLink_unstable = (props, ref) => {
  const backgroundAppearance = useBackgroundAppearance();
  const { inline: inlineContext } = useLinkContext();
  const { appearance = "default", disabled = false, disabledFocusable = false, inline: inline2 = false } = props;
  const elementType = props.as || (props.href ? "a" : "button");
  const propsWithAssignedAs = {
    role: elementType === "span" ? "button" : void 0,
    type: elementType === "button" ? "button" : void 0,
    ...props,
    as: elementType
  };
  const state = {
    // Props passed at the top-level
    appearance,
    disabled,
    disabledFocusable,
    inline: inline2 !== null && inline2 !== void 0 ? inline2 : !!inlineContext,
    // Slots definition
    components: {
      root: elementType
    },
    root: slot_exports.always(getIntrinsicElementProps(elementType, {
      ref,
      ...propsWithAssignedAs
    }), {
      elementType
    }),
    backgroundAppearance
  };
  useLinkState_unstable(state);
  return state;
};

// node_modules/@fluentui/react-link/lib/components/Link/useLinkStyles.styles.js
var linkClassNames = {
  root: "fui-Link"
};
var useStyles18 = __styles2({
  focusIndicator: {
    Bttzg6e: "fhgqx19",
    B3uz8dt: "f1olyrje",
    B6ihwck: "f1p93eir",
    g9k6zt: "f1nev41a"
  },
  root: {
    B486eqv: "f2hkw1w",
    De3pzq: "f3rmtva",
    B7ck84d: "f1ewtqcl",
    sj55zd: "fyind8e",
    Bceei9c: "f1k6fduh",
    mc9l5x: "f1w7gpdv",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "fnbmjn9",
    fsow6f: ["f1o700av", "fes3tcz"],
    w71qe1: "f1iuv45f",
    Bkioxbp: "f1cmlufx",
    ygn44y: "f9n3di6",
    famaaq: "f1ids18y",
    Bde5pd6: "f1tx3yz7",
    Bi91k9c: "f1deo86v",
    i089h6: "f1eh06m1",
    lj723h: "f1iescvh"
  },
  button: {
    icvyot: "f1ern45e",
    vrafjx: ["f1n71otn", "f1deefiw"],
    oivjwe: "f1h8hb77",
    wvpqe5: ["f1deefiw", "f1n71otn"]
  },
  href: {
    Be2twd7: "fjoy568"
  },
  subtle: {
    sj55zd: "fkfq4zb",
    Bde5pd6: "f1tx3yz7",
    Bi91k9c: "fnwyq0v",
    i089h6: "f1eh06m1",
    lj723h: "flvvhsy"
  },
  inline: {
    w71qe1: "f13mvf36"
  },
  disabled: {
    w71qe1: "f1iuv45f",
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr",
    Bde5pd6: "fbnuktb",
    Bi91k9c: "fvgxktp",
    i089h6: "fljg2da",
    lj723h: "f19wldhg"
  },
  inverted: {
    sj55zd: "f179xftw",
    Bi91k9c: "f1sk1dtk",
    lj723h: "f182g21t"
  }
}, {
  d: [".fhgqx19[data-fui-focus-visible]{text-decoration-color:var(--colorStrokeFocus2);}", ".f1olyrje[data-fui-focus-visible]{text-decoration-line:underline;}", ".f1p93eir[data-fui-focus-visible]{text-decoration-style:double;}", ".f1nev41a[data-fui-focus-visible]{outline-style:none;}", ".f3rmtva{background-color:transparent;}", ".f1ewtqcl{box-sizing:border-box;}", ".fyind8e{color:var(--colorBrandForegroundLink);}", ".f1k6fduh{cursor:pointer;}", ".f1w7gpdv{display:inline;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", [".f1s184ao{margin:0;}", {
    p: -1
  }], [".f1mk8lai{padding:0;}", {
    p: -1
  }], [".fnbmjn9{overflow:inherit;}", {
    p: -1
  }], ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".f1iuv45f{text-decoration-line:none;}", ".f1cmlufx{text-decoration-thickness:var(--strokeWidthThin);}", ".f9n3di6{text-overflow:inherit;}", ".f1ids18y{-webkit-user-select:text;-moz-user-select:text;user-select:text;}", ".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1h8hb77{border-bottom-style:none;}", ".fjoy568{font-size:inherit;}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f13mvf36{text-decoration-line:underline;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".f179xftw{color:var(--colorNeutralForegroundInvertedLink);}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"],
  h: [".f1tx3yz7:hover{text-decoration-line:underline;}", ".f1deo86v:hover{color:var(--colorBrandForegroundLinkHover);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".fbnuktb:hover{text-decoration-line:none;}", ".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".f1sk1dtk:hover{color:var(--colorNeutralForegroundInvertedLinkHover);}"],
  a: [".f1eh06m1:active{text-decoration-line:underline;}", ".f1iescvh:active{color:var(--colorBrandForegroundLinkPressed);}", ".flvvhsy:active{color:var(--colorNeutralForeground2Pressed);}", ".fljg2da:active{text-decoration-line:none;}", ".f19wldhg:active{color:var(--colorNeutralForegroundDisabled);}", ".f182g21t:active{color:var(--colorNeutralForegroundInvertedLinkPressed);}"]
});
var useLinkStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles18();
  const {
    appearance,
    disabled,
    inline: inline2,
    root,
    backgroundAppearance
  } = state;
  state.root.className = mergeClasses(linkClassNames.root, styles.root, styles.focusIndicator, root.as === "a" && root.href && styles.href, root.as === "button" && styles.button, appearance === "subtle" && styles.subtle, backgroundAppearance === "inverted" && styles.inverted, inline2 && styles.inline, disabled && styles.disabled, state.root.className);
  return state;
};

// node_modules/@fluentui/react-link/lib/components/Link/renderLink.js
var renderLink_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-link/lib/components/Link/Link.js
var Link2 = React188.forwardRef((props, ref) => {
  const state = useLink_unstable(props, ref);
  useLinkStyles_unstable(state);
  useCustomStyleHook("useLinkStyles_unstable")(state);
  return renderLink_unstable(state);
});
Link2.displayName = "Link";

// node_modules/@fluentui/react-menu/lib/contexts/menuContext.js
var React189 = __toESM(require_react());
var MenuContext = createContext13(void 0);
var menuContextDefaultValue = {
  open: false,
  setOpen: () => false,
  checkedValues: {},
  onCheckedValueChange: () => null,
  isSubmenu: false,
  triggerRef: {
    current: null
  },
  menuPopoverRef: {
    current: null
  },
  mountNode: null,
  triggerId: "",
  openOnContext: false,
  openOnHover: false,
  hasIcons: false,
  hasCheckmarks: false,
  inline: false,
  persistOnItemClick: false
};
var MenuProvider = MenuContext.Provider;
var useMenuContext_unstable = (selector) => useContextSelector(MenuContext, (ctx = menuContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-menu/lib/contexts/menuTriggerContext.js
var React190 = __toESM(require_react());
var MenuTriggerContext = React190.createContext(void 0);
var menuTriggerContextDefaultValue = false;
var MenuTriggerContextProvider = MenuTriggerContext.Provider;
var useMenuTriggerContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React190.useContext(MenuTriggerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : menuTriggerContextDefaultValue;
};

// node_modules/@fluentui/react-menu/lib/contexts/menuGroupContext.js
var React191 = __toESM(require_react());
var MenuGroupContext = React191.createContext(void 0);
var menuGroupContextDefaultValue = {
  headerId: ""
};
var MenuGroupContextProvider = MenuGroupContext.Provider;
var useMenuGroupContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React191.useContext(MenuGroupContext)) !== null && _React_useContext !== void 0 ? _React_useContext : menuGroupContextDefaultValue;
};

// node_modules/@fluentui/react-menu/lib/contexts/menuListContext.js
var React192 = __toESM(require_react());
var MenuListContext = createContext13(void 0);
var menuListContextDefaultValue = {
  checkedValues: {},
  setFocusByFirstCharacter: () => null,
  toggleCheckbox: () => null,
  selectRadio: () => null,
  hasIcons: false,
  hasCheckmarks: false
};
var MenuListProvider = MenuListContext.Provider;
var useMenuListContext_unstable = (selector) => useContextSelector(MenuListContext, (ctx = menuListContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-menu/lib/components/Menu/Menu.js
var React197 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/Menu/useMenu.js
var React195 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/utils/useOnMenuEnter.js
var React193 = __toESM(require_react());
var MENU_ENTER_EVENT = "fuimenuenter";
var useOnMenuMouseEnter = (options) => {
  const { refs, callback, element, disabled } = options;
  const listener = useEventCallback((ev) => {
    const popoverRef = refs[0];
    const someMenuPopover = ev.target;
    var _popoverRef_current;
    const isOutsidePopover = !elementContains((_popoverRef_current = popoverRef.current) !== null && _popoverRef_current !== void 0 ? _popoverRef_current : null, someMenuPopover);
    if (isOutsidePopover && !disabled) {
      callback(ev);
    }
  });
  React193.useEffect(() => {
    if (element == null) {
      return;
    }
    if (!disabled) {
      element.addEventListener(MENU_ENTER_EVENT, listener);
    }
    return () => {
      element.removeEventListener(MENU_ENTER_EVENT, listener);
    };
  }, [
    listener,
    element,
    disabled
  ]);
};
var dispatchMenuEnterEvent = (el, nativeEvent) => {
  el.dispatchEvent(new CustomEvent(MENU_ENTER_EVENT, {
    bubbles: true,
    detail: {
      nativeEvent
    }
  }));
};

// node_modules/@fluentui/react-menu/lib/utils/useIsSubmenu.js
function useIsSubmenu() {
  const menuContextValue = useMenuContext_unstable((context) => context.isSubmenu);
  const hasMenuListContext = useHasParentContext(MenuListContext);
  return menuContextValue || hasMenuListContext;
}

// node_modules/@fluentui/react-menu/lib/utils/useOnMenuSafeZoneTimeout.js
var React194 = __toESM(require_react());
var MENU_SAFEZONE_TIMEOUT_EVENT = "fuimenusafezonetimeout";
var useOnMenuSafeZoneTimeout = (listener) => {
  const elementRef = React194.useRef(null);
  return React194.useCallback((element) => {
    var _elementRef_current;
    (_elementRef_current = elementRef.current) === null || _elementRef_current === void 0 ? void 0 : _elementRef_current.removeEventListener(MENU_SAFEZONE_TIMEOUT_EVENT, listener);
    element === null || element === void 0 ? void 0 : element.addEventListener(MENU_SAFEZONE_TIMEOUT_EVENT, listener);
    elementRef.current = element;
  }, [
    listener
  ]);
};

// node_modules/@fluentui/react-menu/lib/selectable/useCheckmarkStyles.styles.js
var useStyles19 = __styles2({
  root: {
    a9b677: "fjw5fx7",
    Bqenvij: "fd461yt",
    Bcdw1i0: "fd7fpy0",
    Bnnss6s: "fi64zpg"
  },
  rootChecked: {
    Bcdw1i0: "f1022m68",
    Bnnss6s: "fi64zpg"
  }
}, {
  d: [".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".fd7fpy0{visibility:hidden;}", ".fi64zpg{flex-shrink:0;}", ".f1022m68{visibility:visible;}"]
});
var useCheckmarkStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles19();
  if (state.checkmark) {
    state.checkmark.className = mergeClasses(styles.root, state.checked && styles.rootChecked, state.checkmark.className);
  }
};

// node_modules/@fluentui/react-menu/lib/components/MenuItem/useMenuItemStyles.styles.js
var menuItemClassNames = {
  root: "fui-MenuItem",
  icon: "fui-MenuItem__icon",
  checkmark: "fui-MenuItem__checkmark",
  submenuIndicator: "fui-MenuItem__submenuIndicator",
  content: "fui-MenuItem__content",
  secondaryContent: "fui-MenuItem__secondaryContent",
  subText: "fui-MenuItem__subText"
};
var useRootBaseStyles = __resetStyles("rfoezjv", "r8lt3v0", {
  r: [".rfoezjv{border-radius:var(--borderRadiusMedium);position:relative;color:var(--colorNeutralForeground2);background-color:var(--colorNeutralBackground1);padding-right:var(--spacingVerticalSNudge);padding-left:var(--spacingVerticalSNudge);padding-top:var(--spacingVerticalSNudge);padding-bottom:var(--spacingVerticalSNudge);box-sizing:border-box;max-width:290px;min-height:32px;flex-shrink:0;display:flex;align-items:start;font-size:var(--fontSizeBase300);cursor:pointer;gap:4px;-webkit-user-select:none;-moz-user-select:none;user-select:none;}", ".rfoezjv:hover{background-color:var(--colorNeutralBackground1Hover);color:var(--colorNeutralForeground2Hover);}", ".rfoezjv:hover .fui-Icon-filled{display:inline;}", ".rfoezjv:hover .fui-Icon-regular{display:none;}", ".rfoezjv:hover .fui-MenuItem__icon{color:var(--colorNeutralForeground2BrandSelected);}", ".rfoezjv:hover .fui-MenuItem__subText{color:var(--colorNeutralForeground3Hover);}", ".rfoezjv:hover:active{background-color:var(--colorNeutralBackground1Pressed);color:var(--colorNeutralForeground2Pressed);}", ".rfoezjv:hover:active .fui-MenuItem__subText{color:var(--colorNeutralForeground3Pressed);}", ".rfoezjv:focus{outline-style:none;}", ".rfoezjv:focus-visible{outline-style:none;}", ".rfoezjv[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.rfoezjv[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".r8lt3v0{border-radius:var(--borderRadiusMedium);position:relative;color:var(--colorNeutralForeground2);background-color:var(--colorNeutralBackground1);padding-left:var(--spacingVerticalSNudge);padding-right:var(--spacingVerticalSNudge);padding-top:var(--spacingVerticalSNudge);padding-bottom:var(--spacingVerticalSNudge);box-sizing:border-box;max-width:290px;min-height:32px;flex-shrink:0;display:flex;align-items:start;font-size:var(--fontSizeBase300);cursor:pointer;gap:4px;-webkit-user-select:none;-moz-user-select:none;user-select:none;}", ".r8lt3v0:hover{background-color:var(--colorNeutralBackground1Hover);color:var(--colorNeutralForeground2Hover);}", ".r8lt3v0:hover .fui-Icon-filled{display:inline;}", ".r8lt3v0:hover .fui-Icon-regular{display:none;}", ".r8lt3v0:hover .fui-MenuItem__icon{color:var(--colorNeutralForeground2BrandSelected);}", ".r8lt3v0:hover .fui-MenuItem__subText{color:var(--colorNeutralForeground3Hover);}", ".r8lt3v0:hover:active{background-color:var(--colorNeutralBackground1Pressed);color:var(--colorNeutralForeground2Pressed);}", ".r8lt3v0:hover:active .fui-MenuItem__subText{color:var(--colorNeutralForeground3Pressed);}", ".r8lt3v0:focus{outline-style:none;}", ".r8lt3v0:focus-visible{outline-style:none;}", ".r8lt3v0[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.r8lt3v0[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ['@media (forced-colors: active){.rfoezjv:hover{background-color:Canvas;border-color:Highlight;color:Highlight;}.rfoezjv:focus{outline-style:none;}.rfoezjv:focus-visible{outline-style:none;}.rfoezjv[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}@media (forced-colors: active){.rfoezjv[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}.rfoezjv[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid Highlight;border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}}', "@media (forced-colors: active){.rfoezjv[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", '@media (forced-colors: active){.r8lt3v0:hover{background-color:Canvas;border-color:Highlight;color:Highlight;}.r8lt3v0:focus{outline-style:none;}.r8lt3v0:focus-visible{outline-style:none;}.r8lt3v0[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}@media (forced-colors: active){.r8lt3v0[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}.r8lt3v0[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid Highlight;border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}}', "@media (forced-colors: active){.r8lt3v0[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useContentBaseStyles = __resetStyles("r1ls86vo", "rpbc5dr", [".r1ls86vo{padding-left:2px;padding-right:2px;background-color:transparent;flex-grow:1;}", ".rpbc5dr{padding-right:2px;padding-left:2px;background-color:transparent;flex-grow:1;}"]);
var useSecondaryContentBaseStyles = __resetStyles("r12mwwux", "r1ewgu5j", [".r12mwwux{padding-left:2px;padding-right:2px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);color:var(--colorNeutralForeground3);}", ".r12mwwux:hover{color:var(--colorNeutralForeground3Hover);}", ".r12mwwux:focus{color:var(--colorNeutralForeground3Hover);}", ".r1ewgu5j{padding-right:2px;padding-left:2px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);color:var(--colorNeutralForeground3);}", ".r1ewgu5j:hover{color:var(--colorNeutralForeground3Hover);}", ".r1ewgu5j:focus{color:var(--colorNeutralForeground3Hover);}"]);
var useIconBaseStyles = __resetStyles("ro9koqv", null, [".ro9koqv{width:20px;height:20px;font-size:20px;line-height:0;align-items:center;display:inline-flex;justify-content:center;flex-shrink:0;}"]);
var useSubmenuIndicatorBaseStyles = __resetStyles("r9c34qo", null, [".r9c34qo{width:20px;height:20px;font-size:20px;line-height:0;align-items:center;display:inline-flex;justify-content:center;}"]);
var useSubtextBaseStyles = __resetStyles("rk2ppru", null, [".rk2ppru{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase100);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase100);color:var(--colorNeutralForeground3);}"]);
var useStyles20 = __styles2({
  checkmark: {
    B6of3ja: "fmnzpld"
  },
  splitItemMain: {
    Bh6795r: "fqerorx"
  },
  splitItemTrigger: {
    Btl43ni: ["f1ozlkrg", "f10ostut"],
    Beyfa6y: ["f1deotkl", "f1krrbdw"],
    uwmqm3: ["f1cnd47f", "fhxju0i"],
    Ftih45: "f1wl9k8s",
    Ccq8qp: "f1yn80uh",
    Baz25je: "f68mna0",
    cmx5o7: "f1p5zmk"
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    Bi91k9c: "fvgxktp",
    Jwef8y: "f1ijtazh",
    eoavqd: "fphbwmw",
    Bk3fhr4: "f19vpps7",
    Bmfj8id: "fv5swzo",
    Bg7n49j: "f1q1x1ba",
    c7f7en: "ff3wrqt",
    B2d53fq: "fcvwxyo",
    iro3zm: "f1to34ca",
    Bumww26: "fszh5vc",
    t0hwav: "ft33916",
    Bbusuzp: "f1dcs8yz",
    ze5xyy: "f1kc2mi9",
    Bqrx1nm: "fkavljg",
    Bctn1xl: "fk56vqo",
    h5esng: "ff3wi9b",
    Bsk3rfj: "fduv4kr",
    pc6evw: "fb3rf2x",
    g2kj27: "f183y0b2",
    evg1t5: "f12is0ou",
    Bh6z0a4: "f1ikwg0d",
    Bh953qp: "f10l1t5h"
  }
}, {
  d: [".fmnzpld{margin-top:2px;}", ".fqerorx{flex-grow:1;}", ".f1ozlkrg{border-top-left-radius:0;}", ".f10ostut{border-top-right-radius:0;}", ".f1deotkl{border-bottom-left-radius:0;}", ".f1krrbdw{border-bottom-right-radius:0;}", ".f1cnd47f{padding-left:0;}", ".fhxju0i{padding-right:0;}", '.f1wl9k8s::before{content:"";}', ".f1yn80uh::before{width:var(--strokeWidthThin);}", ".f68mna0::before{height:24px;}", ".f1p5zmk::before{background-color:var(--colorNeutralStroke1);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"],
  h: [".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".f1ijtazh:hover{background-color:var(--colorNeutralBackground1);}", ".fphbwmw:hover{cursor:not-allowed;}", ".f19vpps7:hover .fui-Icon-filled{display:none;}", ".fv5swzo:hover .fui-Icon-regular{display:inline;}", ".f1q1x1ba:hover .fui-MenuItem__icon{color:var(--colorNeutralForegroundDisabled);}", ".ff3wrqt:hover .fui-MenuItem__subText{color:var(--colorNeutralForegroundDisabled);}", ".fcvwxyo:hover:active{color:var(--colorNeutralForegroundDisabled);}", ".f1to34ca:hover:active{background-color:var(--colorNeutralBackground1);}", ".fszh5vc:hover:active .fui-MenuItem__subText{color:var(--colorNeutralForegroundDisabled);}"],
  f: [".ft33916:focus{color:var(--colorNeutralForegroundDisabled);}"],
  m: [["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1kc2mi9:hover{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fkavljg:hover{background-color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fk56vqo:hover .fui-MenuItem__icon{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.ff3wi9b:hover .fui-MenuItem__icon{background-color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fduv4kr:hover .fui-MenuItem__subText{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fb3rf2x:hover:active{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f183y0b2:hover:active{background-color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f12is0ou:hover:active .fui-MenuItem__subText{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ikwg0d:focus{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f10l1t5h:focus{background-color:Canvas;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useSubTextStyles = __styles2({
  disabled: {
    sj55zd: "f1s2aq7o",
    Bbusuzp: "f1dcs8yz"
  }
}, {
  d: [".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"],
  m: [["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useMultilineStyles = __styles2({
  content: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62"
  },
  secondaryContent: {
    qb2dma: "f7nlbp4"
  },
  submenuIndicator: {
    qb2dma: "f7nlbp4"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".f7nlbp4{align-self:center;}"]
});
var useMenuItemStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles20();
  const rootBaseStyles = useRootBaseStyles();
  const contentBaseStyles = useContentBaseStyles();
  const secondaryContentBaseStyles = useSecondaryContentBaseStyles();
  const iconBaseStyles = useIconBaseStyles();
  const submenuIndicatorBaseStyles = useSubmenuIndicatorBaseStyles();
  const multilineStyles = useMultilineStyles();
  const subtextBaseStyles = useSubtextBaseStyles();
  const subTextStyles = useSubTextStyles();
  const multiline = !!state.subText;
  state.root.className = mergeClasses(menuItemClassNames.root, rootBaseStyles, state.disabled && styles.disabled, state.root.className);
  if (state.content) {
    state.content.className = mergeClasses(menuItemClassNames.content, contentBaseStyles, state.content.className, multiline && multilineStyles.content);
  }
  if (state.checkmark) {
    state.checkmark.className = mergeClasses(menuItemClassNames.checkmark, styles.checkmark, state.checkmark.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(menuItemClassNames.secondaryContent, secondaryContentBaseStyles, state.disabled && styles.disabled, state.secondaryContent.className, multiline && multilineStyles.secondaryContent);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(menuItemClassNames.icon, iconBaseStyles, state.icon.className);
  }
  if (state.submenuIndicator) {
    state.submenuIndicator.className = mergeClasses(menuItemClassNames.submenuIndicator, submenuIndicatorBaseStyles, state.submenuIndicator.className, multiline && multilineStyles.submenuIndicator);
  }
  if (state.subText) {
    state.subText.className = mergeClasses(menuItemClassNames.subText, state.disabled && subTextStyles.disabled, state.subText.className, subtextBaseStyles);
  }
  useCheckmarkStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/Menu/useMenu.js
var submenuFallbackPositions = [
  "after",
  "after-bottom",
  "before-top",
  "before",
  "before-bottom",
  "above"
];
var useMenu_unstable = (props) => {
  const isSubmenu = useIsSubmenu();
  const { hoverDelay = 500, inline: inline2 = false, hasCheckmarks = false, hasIcons = false, closeOnScroll = false, openOnContext = false, persistOnItemClick = false, openOnHover = isSubmenu, defaultCheckedValues, mountNode = null, safeZone } = props;
  const { targetDocument } = useFluent();
  const triggerId = useId2("menu");
  const [contextTarget, setContextTarget] = usePositioningMouseTarget();
  const positioningOptions = {
    position: isSubmenu ? "after" : "below",
    align: isSubmenu ? "top" : "start",
    target: props.openOnContext ? contextTarget : void 0,
    fallbackPositions: isSubmenu ? submenuFallbackPositions : void 0,
    ...resolvePositioningShorthand(props.positioning)
  };
  const children2 = React195.Children.toArray(props.children);
  if (true) {
    if (children2.length === 0) {
      console.warn("Menu must contain at least one child");
    }
    if (children2.length > 2) {
      console.warn("Menu must contain at most two children");
    }
  }
  let menuTrigger = void 0;
  let menuPopover = void 0;
  if (children2.length === 2) {
    menuTrigger = children2[0];
    menuPopover = children2[1];
  } else if (children2.length === 1) {
    menuPopover = children2[0];
  }
  const { targetRef, containerRef } = usePositioning(positioningOptions);
  const enableSafeZone = safeZone && openOnHover;
  const safeZoneDescriptorRef = React195.useRef({
    isInside: false,
    mouseCoordinates: {
      x: 0,
      y: 0
    }
  });
  const safeZoneHandle = useSafeZoneArea({
    disabled: !enableSafeZone,
    timeout: typeof safeZone === "object" ? safeZone.timeout : 300,
    onSafeZoneEnter: (e) => {
      setOpen(e, {
        open: true,
        keyboard: false,
        type: "menuSafeZoneMouseEnter",
        event: e
      });
      safeZoneDescriptorRef.current.isInside = true;
    },
    onSafeZoneLeave: () => {
      safeZoneDescriptorRef.current.isInside = false;
    },
    onSafeZoneMove: (e) => {
      safeZoneDescriptorRef.current.mouseCoordinates = {
        x: e.clientX,
        y: e.clientY
      };
    },
    onSafeZoneTimeout: () => {
      const event = new CustomEvent(MENU_SAFEZONE_TIMEOUT_EVENT);
      setOpen(event, {
        open: false,
        keyboard: false,
        type: "menuSafeZoneTimeout",
        event
      });
      if (safeZoneDescriptorRef.current.isInside && targetDocument) {
        const elementsInPoint = targetDocument.elementsFromPoint(safeZoneDescriptorRef.current.mouseCoordinates.x, safeZoneDescriptorRef.current.mouseCoordinates.y);
        const menuItemEl = elementsInPoint.find((el) => {
          return el.classList.contains(menuItemClassNames.root);
        });
        menuItemEl === null || menuItemEl === void 0 ? void 0 : menuItemEl.dispatchEvent(event);
      }
    }
  });
  const triggerRef = useMergedRefs(targetRef, safeZoneHandle.targetRef);
  const menuPopoverRef = useMergedRefs(containerRef, safeZoneHandle.containerRef);
  const [open, setOpen] = useMenuOpenState({
    hoverDelay,
    isSubmenu,
    setContextTarget,
    closeOnScroll,
    menuPopoverRef,
    triggerRef,
    open: props.open,
    defaultOpen: props.defaultOpen,
    onOpenChange: props.onOpenChange,
    openOnContext
  });
  const [checkedValues, onCheckedValueChange] = useMenuSelectableState({
    checkedValues: props.checkedValues,
    defaultCheckedValues,
    onCheckedValueChange: props.onCheckedValueChange
  });
  return {
    inline: inline2,
    hoverDelay,
    triggerId,
    isSubmenu,
    openOnHover,
    contextTarget,
    setContextTarget,
    hasCheckmarks,
    hasIcons,
    closeOnScroll,
    menuTrigger,
    menuPopover,
    mountNode,
    triggerRef,
    menuPopoverRef,
    components: {},
    openOnContext,
    open,
    setOpen,
    checkedValues,
    onCheckedValueChange,
    persistOnItemClick,
    safeZone: safeZoneHandle.elementToRender
  };
};
var useMenuSelectableState = (props) => {
  const [checkedValues, setCheckedValues] = useControllableState({
    state: props.checkedValues,
    defaultState: props.defaultCheckedValues,
    initialState: {}
  });
  const onCheckedValueChange = useEventCallback((e, { name, checkedItems }) => {
    var _props_onCheckedValueChange;
    (_props_onCheckedValueChange = props.onCheckedValueChange) === null || _props_onCheckedValueChange === void 0 ? void 0 : _props_onCheckedValueChange.call(props, e, {
      name,
      checkedItems
    });
    setCheckedValues((currentValue) => ({
      ...currentValue,
      [name]: checkedItems
    }));
  });
  return [
    checkedValues,
    onCheckedValueChange
  ];
};
var useMenuOpenState = (state) => {
  "use no memo";
  const { targetDocument } = useFluent();
  const parentSetOpen = useMenuContext_unstable((context) => context.setOpen);
  const onOpenChange = useEventCallback((e, data) => {
    var _state_onOpenChange;
    return (_state_onOpenChange = state.onOpenChange) === null || _state_onOpenChange === void 0 ? void 0 : _state_onOpenChange.call(state, e, data);
  });
  const enteringTriggerRef = React195.useRef(false);
  const [open, setOpenState] = useControllableState({
    state: state.open,
    defaultState: state.defaultOpen,
    initialState: false
  });
  const trySetOpen = useEventCallback((e, data) => {
    const event = e instanceof CustomEvent && e.type === MENU_ENTER_EVENT ? e.detail.nativeEvent : e;
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(event, {
      ...data
    });
    if (data.open && e.type === "contextmenu") {
      state.setContextTarget(e);
    }
    if (!data.open) {
      state.setContextTarget(void 0);
    }
    if (data.bubble) {
      parentSetOpen(e, {
        ...data
      });
    }
    setOpenState(data.open);
  });
  const [setOpenTimeout, clearOpenTimeout] = useTimeout();
  const setOpen = useEventCallback((e, data) => {
    clearOpenTimeout();
    if (!(e instanceof Event) && e.persist) {
      e.persist();
    }
    const shouldUseDelay = !data.ignoreHoverDelay && (e.type === "mouseleave" || e.type === "mouseover" || e.type === "mousemove" || e.type === MENU_ENTER_EVENT);
    if (shouldUseDelay) {
      var _state_triggerRef_current;
      if ((_state_triggerRef_current = state.triggerRef.current) === null || _state_triggerRef_current === void 0 ? void 0 : _state_triggerRef_current.contains(e.target)) {
        enteringTriggerRef.current = e.type === "mouseover" || e.type === "mousemove";
      }
      setOpenTimeout(() => trySetOpen(e, data), state.hoverDelay);
    } else {
      trySetOpen(e, data);
    }
  });
  useOnClickOutside({
    contains: elementContains,
    disabled: !open,
    element: targetDocument,
    refs: [
      state.menuPopoverRef,
      !state.openOnContext && state.triggerRef
    ].filter(Boolean),
    callback: (event) => setOpen(event, {
      open: false,
      type: "clickOutside",
      event
    })
  });
  const closeOnScroll = state.openOnContext || state.closeOnScroll;
  useOnScrollOutside({
    contains: elementContains,
    element: targetDocument,
    callback: (event) => setOpen(event, {
      open: false,
      type: "scrollOutside",
      event
    }),
    refs: [
      state.menuPopoverRef,
      !state.openOnContext && state.triggerRef
    ].filter(Boolean),
    disabled: !open || !closeOnScroll
  });
  useOnMenuMouseEnter({
    element: targetDocument,
    callback: (event) => {
      if (!enteringTriggerRef.current) {
        setOpen(event, {
          open: false,
          type: "menuMouseEnter",
          event
        });
      }
    },
    disabled: !open,
    refs: [
      state.menuPopoverRef
    ]
  });
  const { findFirstFocusable } = useFocusFinders();
  const focusFirst = React195.useCallback(() => {
    const firstFocusable = findFirstFocusable(state.menuPopoverRef.current);
    firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
  }, [
    findFirstFocusable,
    state.menuPopoverRef
  ]);
  const firstMount = useFirstMount();
  React195.useEffect(() => {
    if (open) {
      focusFirst();
    } else {
      if (!firstMount) {
        if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body)) {
          var _state_triggerRef_current;
          (_state_triggerRef_current = state.triggerRef.current) === null || _state_triggerRef_current === void 0 ? void 0 : _state_triggerRef_current.focus();
        }
      }
    }
  }, [
    state.triggerRef,
    state.isSubmenu,
    open,
    focusFirst,
    targetDocument,
    state.menuPopoverRef
  ]);
  return [
    open,
    setOpen
  ];
};

// node_modules/@fluentui/react-menu/lib/components/Menu/useMenuContextValues.js
function useMenuContextValues_unstable(state) {
  const { checkedValues, hasCheckmarks, hasIcons, inline: inline2, isSubmenu, menuPopoverRef, mountNode, onCheckedValueChange, open, openOnContext, openOnHover, persistOnItemClick, safeZone, setOpen, triggerId, triggerRef } = state;
  const menu = {
    checkedValues,
    hasCheckmarks,
    hasIcons,
    inline: inline2,
    isSubmenu,
    menuPopoverRef,
    mountNode,
    onCheckedValueChange,
    open,
    openOnContext,
    openOnHover,
    persistOnItemClick,
    safeZone,
    setOpen,
    triggerId,
    triggerRef
  };
  return {
    menu
  };
}

// node_modules/@fluentui/react-menu/lib/components/Menu/renderMenu.js
var React196 = __toESM(require_react());
var renderMenu_unstable = (state, contextValues) => {
  return React196.createElement(MenuProvider, {
    value: contextValues.menu
  }, state.menuTrigger, state.open && state.menuPopover);
};

// node_modules/@fluentui/react-menu/lib/components/Menu/Menu.js
var Menu = (props) => {
  const state = useMenu_unstable(props);
  const contextValues = useMenuContextValues_unstable(state);
  return renderMenu_unstable(state, contextValues);
};
Menu.displayName = "Menu";

// node_modules/@fluentui/react-menu/lib/components/MenuDivider/MenuDivider.js
var React199 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuDivider/useMenuDivider.js
var React198 = __toESM(require_react());
var useMenuDivider_unstable = (props, ref) => {
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      role: "presentation",
      "aria-hidden": true,
      ...props,
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-menu/lib/components/MenuDivider/useMenuDividerStyles.styles.js
var menuDividerClassNames = {
  root: "fui-MenuDivider"
};
var useStyles21 = __styles2({
  root: {
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f8dz51a",
    a9b677: "f14z66ap",
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f1facbz3"
  }
}, {
  d: [[".f8dz51a{margin:4px -5px 4px -5px;}", {
    p: -1
  }], ".f14z66ap{width:auto;}", [".f1facbz3{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStroke2);}", {
    p: -1
  }]]
});
var useMenuDividerStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles21();
  state.root.className = mergeClasses(menuDividerClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuDivider/renderMenuDivider.js
var renderMenuDivider_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-menu/lib/components/MenuDivider/MenuDivider.js
var MenuDivider = React199.forwardRef((props, ref) => {
  const state = useMenuDivider_unstable(props, ref);
  useMenuDividerStyles_unstable(state);
  useCustomStyleHook("useMenuDividerStyles_unstable")(state);
  return renderMenuDivider_unstable(state);
});
MenuDivider.displayName = "MenuDivider";

// node_modules/@fluentui/react-menu/lib/components/MenuGroup/MenuGroup.js
var React202 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuGroup/useMenuGroup.js
var React200 = __toESM(require_react());
function useMenuGroup_unstable(props, ref) {
  const headerId = useId2("menu-group");
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      "aria-labelledby": headerId,
      role: "group",
      ...props
    }), {
      elementType: "div"
    }),
    headerId
  };
}

// node_modules/@fluentui/react-menu/lib/components/MenuGroup/renderMenuGroup.js
var renderMenuGroup_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(MenuGroupContextProvider, {
    value: contextValues.menuGroup,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuGroup/useMenuGroupContextValues.js
var React201 = __toESM(require_react());
function useMenuGroupContextValues_unstable(state) {
  const { headerId } = state;
  const menuGroup = React201.useMemo(() => ({
    headerId
  }), [
    headerId
  ]);
  return {
    menuGroup
  };
}

// node_modules/@fluentui/react-menu/lib/components/MenuGroup/useMenuGroupStyles.styles.js
var menuGroupClassNames = {
  root: "fui-MenuGroup"
};
var useMenuGroupStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(menuGroupClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuGroup/MenuGroup.js
var MenuGroup = React202.forwardRef((props, ref) => {
  const state = useMenuGroup_unstable(props, ref);
  const contextValues = useMenuGroupContextValues_unstable(state);
  useMenuGroupStyles_unstable(state);
  useCustomStyleHook("useMenuGroupStyles_unstable")(state);
  return renderMenuGroup_unstable(state, contextValues);
});
MenuGroup.displayName = "MenuGroup";

// node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/MenuGroupHeader.js
var React204 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/useMenuGroupHeader.js
var React203 = __toESM(require_react());
function useMenuGroupHeader_unstable(props, ref) {
  const { headerId: id } = useMenuGroupContext_unstable();
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      id,
      ...props
    }), {
      elementType: "div"
    })
  };
}

// node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/useMenuGroupHeaderStyles.styles.js
var menuGroupHeaderClassNames = {
  root: "fui-MenuGroupHeader"
};
var useStyles22 = __styles2({
  root: {
    Be2twd7: "fy9rknc",
    sj55zd: "f11d4kpn",
    uwmqm3: ["f177v4lu", "f19lj068"],
    z189sj: ["f19lj068", "f177v4lu"],
    Bhrd7zp: "fl43uef",
    Bqenvij: "f1d2rq10",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59"
  }
}, {
  d: [".fy9rknc{font-size:var(--fontSizeBase200);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f177v4lu{padding-left:8px;}", ".f19lj068{padding-right:8px;}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f1d2rq10{height:32px;}", ".f22iagw{display:flex;}", ".f122n59{align-items:center;}"]
});
var useMenuGroupHeaderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles22();
  state.root.className = mergeClasses(menuGroupHeaderClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/renderMenuGroupHeader.js
var renderMenuGroupHeader_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/MenuGroupHeader.js
var MenuGroupHeader = React204.forwardRef((props, ref) => {
  const state = useMenuGroupHeader_unstable(props, ref);
  useMenuGroupHeaderStyles_unstable(state);
  useCustomStyleHook("useMenuGroupHeaderStyles_unstable")(state);
  return renderMenuGroupHeader_unstable(state);
});
MenuGroupHeader.displayName = "MenuGroupHeader";

// node_modules/@fluentui/react-menu/lib/components/MenuItem/MenuItem.js
var React208 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItem/useMenuItem.js
var React207 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItem/useCharacterSearch.js
var React205 = __toESM(require_react());
var useCharacterSearch = (state, ref) => {
  "use no memo";
  const setFocusByFirstCharacter = useMenuListContext_unstable((context) => context.setFocusByFirstCharacter);
  const { onKeyDown: originalOnKeyDown } = state.root;
  state.root.onKeyDown = (e) => {
    var _e_key;
    originalOnKeyDown === null || originalOnKeyDown === void 0 ? void 0 : originalOnKeyDown(e);
    if (((_e_key = e.key) === null || _e_key === void 0 ? void 0 : _e_key.length) > 1) {
      return;
    }
    if (ref.current) {
      setFocusByFirstCharacter === null || setFocusByFirstCharacter === void 0 ? void 0 : setFocusByFirstCharacter(e, ref.current);
    }
  };
  return state;
};

// node_modules/@fluentui/react-menu/lib/contexts/menuSplitGroupContext.js
var React206 = __toESM(require_react());
var MenuSplitGroupContext = React206.createContext(void 0);
var menuSplitGroupContextDefaultValue = {
  setMultiline: () => null
};
var MenuSplitGroupContextProvider = MenuSplitGroupContext.Provider;
var useMenuSplitGroupContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React206.useContext(MenuSplitGroupContext)) !== null && _React_useContext !== void 0 ? _React_useContext : menuSplitGroupContextDefaultValue;
};
var useIsInMenuSplitGroup = () => {
  const context = useMenuSplitGroupContext_unstable();
  return context !== menuSplitGroupContextDefaultValue;
};

// node_modules/@fluentui/react-menu/lib/components/MenuItem/useMenuItem.js
var ChevronRightIcon = bundleIcon_default(ChevronRightFilled, ChevronRightRegular);
var ChevronLeftIcon = bundleIcon_default(ChevronLeftFilled, ChevronLeftRegular);
var useMenuItem_unstable = (props, ref) => {
  const isSubmenuTrigger = useMenuTriggerContext_unstable();
  const persistOnClickContext = useMenuContext_unstable((context) => context.persistOnItemClick);
  const { as = "div", disabled = false, hasSubmenu = isSubmenuTrigger, persistOnClick = persistOnClickContext, content: _content, ...rest } = props;
  const { hasIcons, hasCheckmarks } = useIconAndCheckmarkAlignment({
    hasSubmenu
  });
  const setOpen = useMenuContext_unstable((context) => context.setOpen);
  useNotifySplitItemMultiline({
    multiline: !!props.subText,
    hasSubmenu
  });
  const { dir } = useFluent();
  const innerRef = React207.useRef(null);
  const dismissedWithKeyboardRef = React207.useRef(false);
  const state = {
    hasSubmenu,
    disabled,
    persistOnClick,
    components: {
      root: "div",
      icon: "span",
      checkmark: "span",
      submenuIndicator: "span",
      content: "span",
      secondaryContent: "span",
      subText: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps(as, useARIAButtonProps(as, {
      role: "menuitem",
      ...rest,
      disabled: false,
      disabledFocusable: disabled,
      ref: useMergedRefs(ref, innerRef),
      onKeyDown: useEventCallback((event) => {
        var _props_onKeyDown;
        (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, event);
        if (!event.isDefaultPrevented() && (event.key === Space || event.key === Enter)) {
          dismissedWithKeyboardRef.current = true;
        }
      }),
      onMouseMove: useEventCallback((event) => {
        var _props_onMouseMove;
        if (event.currentTarget.ownerDocument.activeElement !== event.currentTarget) {
          var _innerRef_current;
          (_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.focus();
        }
        (_props_onMouseMove = props.onMouseMove) === null || _props_onMouseMove === void 0 ? void 0 : _props_onMouseMove.call(props, event);
      }),
      onClick: useEventCallback((event) => {
        var _props_onClick;
        if (!hasSubmenu && !persistOnClick) {
          setOpen(event, {
            open: false,
            keyboard: dismissedWithKeyboardRef.current,
            bubble: true,
            type: "menuItemClick",
            event
          });
          dismissedWithKeyboardRef.current = false;
        }
        (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, event);
      })
    })), {
      elementType: "div"
    }),
    icon: slot_exports.optional(props.icon, {
      renderByDefault: hasIcons,
      elementType: "span"
    }),
    checkmark: slot_exports.optional(props.checkmark, {
      renderByDefault: hasCheckmarks,
      elementType: "span"
    }),
    submenuIndicator: slot_exports.optional(props.submenuIndicator, {
      renderByDefault: hasSubmenu,
      defaultProps: {
        children: dir === "ltr" ? React207.createElement(ChevronRightIcon, null) : React207.createElement(ChevronLeftIcon, null)
      },
      elementType: "span"
    }),
    content: slot_exports.optional(props.content, {
      renderByDefault: !!props.children,
      defaultProps: {
        children: props.children
      },
      elementType: "span"
    }),
    secondaryContent: slot_exports.optional(props.secondaryContent, {
      elementType: "span"
    }),
    subText: slot_exports.optional(props.subText, {
      elementType: "span"
    })
  };
  useCharacterSearch(state, innerRef);
  return state;
};
var useNotifySplitItemMultiline = (options) => {
  const { hasSubmenu, multiline } = options;
  const isSplitItemTrigger = useIsInMenuSplitGroup() && hasSubmenu;
  const { setMultiline } = useMenuSplitGroupContext_unstable();
  useIsomorphicLayoutEffect(() => {
    if (!isSplitItemTrigger) {
      setMultiline(multiline);
    }
  }, [
    setMultiline,
    multiline,
    isSplitItemTrigger
  ]);
};
var useIconAndCheckmarkAlignment = (options) => {
  const { hasSubmenu } = options;
  const hasIcons = useMenuListContext_unstable((context) => context.hasIcons);
  const hasCheckmarks = useMenuListContext_unstable((context) => context.hasCheckmarks);
  const isSplitItemTrigger = useIsInMenuSplitGroup() && hasSubmenu;
  return {
    hasIcons: hasIcons && !isSplitItemTrigger,
    hasCheckmarks: hasCheckmarks && !isSplitItemTrigger
  };
};

// node_modules/@fluentui/react-menu/lib/components/MenuItem/renderMenuItem.js
var renderMenuItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.checkmark && jsx(state.checkmark, {}),
      state.icon && jsx(state.icon, {}),
      state.content && jsxs(state.content, {
        children: [
          state.content.children,
          state.subText && jsx(state.subText, {})
        ]
      }),
      state.secondaryContent && jsx(state.secondaryContent, {}),
      state.submenuIndicator && jsx(state.submenuIndicator, {})
    ]
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuItem/MenuItem.js
var MenuItem = React208.forwardRef((props, ref) => {
  const state = useMenuItem_unstable(props, ref);
  useMenuItemStyles_unstable(state);
  useCustomStyleHook("useMenuItemStyles_unstable")(state);
  return renderMenuItem_unstable(state);
});
MenuItem.displayName = "MenuItem";

// node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/MenuItemCheckbox.js
var React210 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/useMenuItemCheckbox.js
var React209 = __toESM(require_react());
var useMenuItemCheckbox_unstable = (props, ref) => {
  const toggleCheckbox = useMenuListContext_unstable((context) => context.toggleCheckbox);
  const { name, value } = props;
  const checked = useMenuListContext_unstable((context) => {
    var _context_checkedValues;
    const checkedItems = ((_context_checkedValues = context.checkedValues) === null || _context_checkedValues === void 0 ? void 0 : _context_checkedValues[name]) || [];
    return checkedItems.indexOf(value) !== -1;
  });
  const state = {
    ...useMenuItem_unstable({
      role: "menuitemcheckbox",
      persistOnClick: true,
      ...props,
      "aria-checked": checked,
      checkmark: slot_exports.optional(props.checkmark, {
        defaultProps: {
          children: React209.createElement(Checkmark16Filled, null)
        },
        renderByDefault: true,
        elementType: "span"
      }),
      onClick: (e) => {
        var _props_onClick;
        toggleCheckbox === null || toggleCheckbox === void 0 ? void 0 : toggleCheckbox(e, name, value, checked);
        (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, e);
      }
    }, ref),
    name,
    value,
    checked
  };
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/renderMenuItemCheckbox.js
var renderMenuItemCheckbox_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.checkmark && jsx(state.checkmark, {}),
      state.icon && jsx(state.icon, {}),
      state.content && jsxs(state.content, {
        children: [
          state.content.children,
          state.subText && jsx(state.subText, {})
        ]
      }),
      state.secondaryContent && jsx(state.secondaryContent, {})
    ]
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/useMenuItemCheckboxStyles.styles.js
var menuItemCheckboxClassNames = {
  root: "fui-MenuItemCheckbox",
  icon: "fui-MenuItemCheckbox__icon",
  checkmark: "fui-MenuItemCheckbox__checkmark",
  content: "fui-MenuItemCheckbox__content",
  secondaryContent: "fui-MenuItemCheckbox__secondaryContent",
  subText: "fui-MenuItemCheckbox__subText"
};
var useMenuItemCheckboxStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(menuItemCheckboxClassNames.root, state.root.className);
  if (state.content) {
    state.content.className = mergeClasses(menuItemCheckboxClassNames.content, state.content.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(menuItemCheckboxClassNames.secondaryContent, state.secondaryContent.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(menuItemCheckboxClassNames.icon, state.icon.className);
  }
  if (state.checkmark) {
    state.checkmark.className = mergeClasses(menuItemCheckboxClassNames.checkmark, state.checkmark.className);
  }
  if (state.subText) {
    state.subText.className = mergeClasses(menuItemCheckboxClassNames.subText, state.subText.className);
  }
  useMenuItemStyles_unstable(state);
  useCheckmarkStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/MenuItemCheckbox.js
var MenuItemCheckbox = React210.forwardRef((props, ref) => {
  const state = useMenuItemCheckbox_unstable(props, ref);
  useMenuItemCheckboxStyles_unstable(state);
  useCustomStyleHook("useMenuItemCheckboxStyles_unstable")(state);
  return renderMenuItemCheckbox_unstable(state);
});
MenuItemCheckbox.displayName = "MenuItemCheckbox";

// node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/MenuItemRadio.js
var React212 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/useMenuItemRadio.js
var React211 = __toESM(require_react());
var useMenuItemRadio_unstable = (props, ref) => {
  const { name, value } = props;
  const checked = useMenuListContext_unstable((context) => {
    var _context_checkedValues;
    const checkedItems = ((_context_checkedValues = context.checkedValues) === null || _context_checkedValues === void 0 ? void 0 : _context_checkedValues[name]) || [];
    return checkedItems.indexOf(value) !== -1;
  });
  const selectRadio = useMenuListContext_unstable((context) => context.selectRadio);
  return {
    ...useMenuItem_unstable({
      ...props,
      role: "menuitemradio",
      "aria-checked": checked,
      checkmark: slot_exports.optional(props.checkmark, {
        defaultProps: {
          children: React211.createElement(Checkmark16Filled, null)
        },
        renderByDefault: true,
        elementType: "span"
      }),
      onClick: (e) => {
        var _props_onClick;
        selectRadio === null || selectRadio === void 0 ? void 0 : selectRadio(e, name, value, checked);
        (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, e);
      }
    }, ref),
    checked,
    name,
    value
  };
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/renderMenuItemRadio.js
var renderMenuItemRadio_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.checkmark && jsx(state.checkmark, {}),
      state.icon && jsx(state.icon, {}),
      state.content && jsxs(state.content, {
        children: [
          state.content.children,
          state.subText && jsx(state.subText, {})
        ]
      }),
      state.secondaryContent && jsx(state.secondaryContent, {})
    ]
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/useMenuItemRadioStyles.styles.js
var menuItemRadioClassNames = {
  root: "fui-MenuItemRadio",
  icon: "fui-MenuItemRadio__icon",
  checkmark: "fui-MenuItemRadio__checkmark",
  content: "fui-MenuItemRadio__content",
  secondaryContent: "fui-MenuItemRadio__secondaryContent",
  subText: "fui-MenuItemRadio__subText"
};
var useMenuItemRadioStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(menuItemRadioClassNames.root, state.root.className);
  if (state.content) {
    state.content.className = mergeClasses(menuItemRadioClassNames.content, state.content.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(menuItemRadioClassNames.secondaryContent, state.secondaryContent.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(menuItemRadioClassNames.icon, state.icon.className);
  }
  if (state.checkmark) {
    state.checkmark.className = mergeClasses(menuItemRadioClassNames.checkmark, state.checkmark.className);
  }
  if (state.subText) {
    state.subText.className = mergeClasses(menuItemRadioClassNames.subText, state.subText.className);
  }
  useMenuItemStyles_unstable(state);
  useCheckmarkStyles_unstable(state);
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/MenuItemRadio.js
var MenuItemRadio = React212.forwardRef((props, ref) => {
  const state = useMenuItemRadio_unstable(props, ref);
  useMenuItemRadioStyles_unstable(state);
  useCustomStyleHook("useMenuItemRadioStyles_unstable")(state);
  return renderMenuItemRadio_unstable(state);
});
MenuItemRadio.displayName = "MenuItemRadio";

// node_modules/@fluentui/react-menu/lib/components/MenuList/MenuList.js
var React214 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuList/useMenuList.js
var React213 = __toESM(require_react());
var useMenuList_unstable = (props, ref) => {
  const { findAllFocusable } = useFocusFinders();
  const { targetDocument } = useFluent();
  const menuContext = useMenuContextSelectors();
  const hasMenuContext = useHasParentContext(MenuContext);
  const focusAttributes = useArrowNavigationGroup({
    circular: true
  });
  if (usingPropsAndMenuContext(props, menuContext, hasMenuContext)) {
    console.warn("You are using both MenuList and Menu props, we recommend you to use Menu props when available");
  }
  const innerRef = React213.useRef(null);
  React213.useEffect(() => {
    const element = innerRef.current;
    if (hasMenuContext && targetDocument && element) {
      const onTabsterMoveFocus = (e) => {
        const nextElement = e.detail.next;
        if (nextElement && element.contains(targetDocument.activeElement) && !element.contains(nextElement)) {
          e.preventDefault();
        }
      };
      targetDocument.addEventListener(TabsterMoveFocusEventName, onTabsterMoveFocus);
      return () => {
        targetDocument.removeEventListener(TabsterMoveFocusEventName, onTabsterMoveFocus);
      };
    }
  }, [
    innerRef,
    targetDocument,
    hasMenuContext
  ]);
  const setFocusByFirstCharacter = React213.useCallback((e, itemEl) => {
    const acceptedRoles = [
      "menuitem",
      "menuitemcheckbox",
      "menuitemradio"
    ];
    if (!innerRef.current) {
      return;
    }
    const menuItems = findAllFocusable(innerRef.current, (el) => el.hasAttribute("role") && acceptedRoles.indexOf(el.getAttribute("role")) !== -1);
    let startIndex = menuItems.indexOf(itemEl) + 1;
    if (startIndex === menuItems.length) {
      startIndex = 0;
    }
    const firstChars = menuItems.map((menuItem) => {
      var _menuItem_textContent;
      return (_menuItem_textContent = menuItem.textContent) === null || _menuItem_textContent === void 0 ? void 0 : _menuItem_textContent.charAt(0).toLowerCase();
    });
    const char = e.key.toLowerCase();
    const getIndexFirstChars = (start, firstChar) => {
      for (let i = start; i < firstChars.length; i++) {
        if (char === firstChars[i]) {
          return i;
        }
      }
      return -1;
    };
    let index = getIndexFirstChars(startIndex, char);
    if (index === -1) {
      index = getIndexFirstChars(0, char);
    }
    if (index > -1) {
      menuItems[index].focus();
    }
  }, [
    findAllFocusable
  ]);
  var _props_checkedValues;
  const [checkedValues, setCheckedValues] = useControllableState({
    state: (_props_checkedValues = props.checkedValues) !== null && _props_checkedValues !== void 0 ? _props_checkedValues : hasMenuContext ? menuContext.checkedValues : void 0,
    defaultState: props.defaultCheckedValues,
    initialState: {}
  });
  var _props_onCheckedValueChange;
  const handleCheckedValueChange = (_props_onCheckedValueChange = props.onCheckedValueChange) !== null && _props_onCheckedValueChange !== void 0 ? _props_onCheckedValueChange : hasMenuContext ? menuContext.onCheckedValueChange : void 0;
  const toggleCheckbox = useEventCallback((e, name, value, checked) => {
    const checkedItems = (checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name]) || [];
    const newCheckedItems = [
      ...checkedItems
    ];
    if (checked) {
      newCheckedItems.splice(newCheckedItems.indexOf(value), 1);
    } else {
      newCheckedItems.push(value);
    }
    handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {
      name,
      checkedItems: newCheckedItems
    });
    setCheckedValues((s) => ({
      ...s,
      [name]: newCheckedItems
    }));
  });
  const selectRadio = useEventCallback((e, name, value) => {
    const newCheckedItems = [
      value
    ];
    setCheckedValues((s) => ({
      ...s,
      [name]: newCheckedItems
    }));
    handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {
      name,
      checkedItems: newCheckedItems
    });
  });
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, innerRef),
      role: "menu",
      "aria-labelledby": menuContext.triggerId,
      ...focusAttributes,
      ...props
    }), {
      elementType: "div"
    }),
    hasIcons: menuContext.hasIcons || false,
    hasCheckmarks: menuContext.hasCheckmarks || false,
    checkedValues,
    hasMenuContext,
    setFocusByFirstCharacter,
    selectRadio,
    toggleCheckbox
  };
};
var useMenuContextSelectors = () => {
  const checkedValues = useMenuContext_unstable((context) => context.checkedValues);
  const onCheckedValueChange = useMenuContext_unstable((context) => context.onCheckedValueChange);
  const triggerId = useMenuContext_unstable((context) => context.triggerId);
  const hasIcons = useMenuContext_unstable((context) => context.hasIcons);
  const hasCheckmarks = useMenuContext_unstable((context) => context.hasCheckmarks);
  return {
    checkedValues,
    onCheckedValueChange,
    triggerId,
    hasIcons,
    hasCheckmarks
  };
};
var usingPropsAndMenuContext = (props, contextValue, hasMenuContext) => {
  let isUsingPropsAndContext = false;
  for (const val in contextValue) {
    if (props[val]) {
      isUsingPropsAndContext = true;
    }
  }
  return hasMenuContext && isUsingPropsAndContext;
};

// node_modules/@fluentui/react-menu/lib/components/MenuList/renderMenuList.js
var renderMenuList_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(MenuListProvider, {
    value: contextValues.menuList,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuList/useMenuListContextValues.js
function useMenuListContextValues_unstable(state) {
  const { checkedValues, hasCheckmarks, hasIcons, selectRadio, setFocusByFirstCharacter, toggleCheckbox } = state;
  const menuList = {
    checkedValues,
    hasCheckmarks,
    hasIcons,
    selectRadio,
    setFocusByFirstCharacter,
    toggleCheckbox
  };
  return {
    menuList
  };
}

// node_modules/@fluentui/react-menu/lib/components/MenuList/useMenuListStyles.styles.js
var menuListClassNames = {
  root: "fui-MenuList"
};
var useStyles23 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1t6b6ee"
  },
  hasMenuContext: {
    Bqenvij: "f1l02sjl"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", [".f1t6b6ee{gap:2px;}", {
    p: -1
  }], ".f1l02sjl{height:100%;}"]
});
var useMenuListStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles23();
  state.root.className = mergeClasses(menuListClassNames.root, styles.root, state.hasMenuContext && styles.hasMenuContext, state.root.className);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuList/MenuList.js
var MenuList = React214.forwardRef((props, ref) => {
  const state = useMenuList_unstable(props, ref);
  const contextValues = useMenuListContextValues_unstable(state);
  useMenuListStyles_unstable(state);
  useCustomStyleHook("useMenuListStyles_unstable")(state);
  return renderMenuList_unstable(state, contextValues);
});
MenuList.displayName = "MenuList";

// node_modules/@fluentui/react-menu/lib/components/MenuPopover/MenuPopover.js
var React216 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuPopover/useMenuPopover.js
var React215 = __toESM(require_react());
var useMenuPopover_unstable = (props, ref) => {
  "use no memo";
  const safeZone = useMenuContext_unstable((context) => context.safeZone);
  const popoverRef = useMenuContext_unstable((context) => context.menuPopoverRef);
  const setOpen = useMenuContext_unstable((context) => context.setOpen);
  const open = useMenuContext_unstable((context) => context.open);
  const openOnHover = useMenuContext_unstable((context) => context.openOnHover);
  const triggerRef = useMenuContext_unstable((context) => context.triggerRef);
  const isSubmenu = useIsSubmenu();
  const canDispatchCustomEventRef = React215.useRef(true);
  const restoreFocusSourceAttributes = useRestoreFocusSource();
  const [setThrottleTimeout, clearThrottleTimeout] = useTimeout();
  const { dir } = useFluent();
  const CloseArrowKey = dir === "ltr" ? ArrowLeft : ArrowRight;
  const mouseOverListenerCallbackRef = React215.useCallback((node) => {
    if (node) {
      node.addEventListener("mouseover", (e) => {
        if (canDispatchCustomEventRef.current) {
          canDispatchCustomEventRef.current = false;
          dispatchMenuEnterEvent(popoverRef.current, e);
          setThrottleTimeout(() => {
            canDispatchCustomEventRef.current = true;
          }, 250);
        }
      });
    }
  }, [
    popoverRef,
    setThrottleTimeout
  ]);
  React215.useEffect(() => {
    return () => clearThrottleTimeout();
  }, [
    clearThrottleTimeout
  ]);
  var _useMenuContext_unstable;
  const inline2 = (_useMenuContext_unstable = useMenuContext_unstable((context) => context.inline)) !== null && _useMenuContext_unstable !== void 0 ? _useMenuContext_unstable : false;
  const mountNode = useMenuContext_unstable((context) => context.mountNode);
  const rootProps = slot_exports.always(getIntrinsicElementProps("div", {
    role: "presentation",
    ...restoreFocusSourceAttributes,
    ...props,
    // FIXME:
    // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
    // but since it would be a breaking change to fix it, we are casting ref to it's proper type
    ref: useMergedRefs(ref, popoverRef, mouseOverListenerCallbackRef)
  }), {
    elementType: "div"
  });
  const { onMouseEnter: onMouseEnterOriginal, onKeyDown: onKeyDownOriginal } = rootProps;
  rootProps.onMouseEnter = useEventCallback((event) => {
    if (openOnHover || isSubmenu) {
      setOpen(event, {
        open: true,
        keyboard: false,
        type: "menuPopoverMouseEnter",
        event
      });
    }
    onMouseEnterOriginal === null || onMouseEnterOriginal === void 0 ? void 0 : onMouseEnterOriginal(event);
  });
  rootProps.onKeyDown = useEventCallback((event) => {
    const key = event.key;
    if (key === Escape || isSubmenu && key === CloseArrowKey) {
      var _popoverRef_current;
      if (open && ((_popoverRef_current = popoverRef.current) === null || _popoverRef_current === void 0 ? void 0 : _popoverRef_current.contains(event.target)) && !event.isDefaultPrevented()) {
        setOpen(event, {
          open: false,
          keyboard: true,
          type: "menuPopoverKeyDown",
          event
        });
        event.preventDefault();
      }
    }
    if (key === Tab) {
      setOpen(event, {
        open: false,
        keyboard: true,
        type: "menuPopoverKeyDown",
        event
      });
      if (!isSubmenu) {
        var _triggerRef_current;
        (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
      }
    }
    onKeyDownOriginal === null || onKeyDownOriginal === void 0 ? void 0 : onKeyDownOriginal(event);
  });
  return {
    inline: inline2,
    mountNode,
    safeZone,
    components: {
      root: "div"
    },
    root: rootProps
  };
};

// node_modules/@fluentui/react-menu/lib/components/MenuPopover/useMenuPopoverStyles.styles.js
var menuPopoverClassNames = {
  root: "fui-MenuPopover"
};
var useStyles24 = __styles2({
  root: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    De3pzq: "fxugw4r",
    sj55zd: "f19n0e5",
    B7ck84d: "f1ewtqcl",
    Bf4jedk: "fl8fusi",
    B2u0y6b: "f1kaai3v",
    B68tc82: "f1p9o1ba",
    a9b677: "f1ahpp82",
    E5pizo: "f1hg901r",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fd3pd8h",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f9ggezi",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    B93otf3: "f18k4bn6",
    vin17d: "fo1kyvf",
    Ezkn3b: "fetxo7e",
    nyiy2g: "f8x1vz1",
    swvrvq: "f8g0anz",
    Bkovbt3: "fezwn9i",
    hgjdhn: "fz5efge",
    fsy9dk: "f1ydixl4",
    B3ogreh: "f8dgqj5",
    jv49x5: "fnyfnr8",
    Bk7o48c: "fgw77r4",
    Bv12yb3: "f1noc5he",
    z0t1cu: "fi19xcv",
    Bks05zx: "f1mxk9aa",
    Bvtglag: "ffzg62k"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1ewtqcl{box-sizing:border-box;}", ".fl8fusi{min-width:138px;}", ".f1kaai3v{max-width:300px;}", ".f1p9o1ba{overflow-x:hidden;}", ".f1ahpp82{width:max-content;}", ".f1hg901r{box-shadow:var(--shadow16);}", [".fd3pd8h{padding:4px;}", {
    p: -1
  }], [".f9ggezi{border:1px solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f18k4bn6{animation-composition:accumulate;}", ".fo1kyvf{animation-duration:var(--durationSlower);}", ".fetxo7e{animation-timing-function:var(--curveDecelerateMid);}", ".f8x1vz1{--fui-positioning-slide-distance-x:0px;}", ".f8g0anz{--fui-positioning-slide-distance-y:10px;}", ".fezwn9i[data-popper-placement^=right]{--fui-positioning-slide-distance-x:-10px;}", ".fz5efge[data-popper-placement^=right]{--fui-positioning-slide-distance-y:0px;}", ".f1ydixl4[data-popper-placement^=bottom]{--fui-positioning-slide-distance-x:0px;}", ".f8dgqj5[data-popper-placement^=bottom]{--fui-positioning-slide-distance-y:-10px;}", ".fnyfnr8[data-popper-placement^=left]{--fui-positioning-slide-distance-x:10px;}", ".fgw77r4[data-popper-placement^=left]{--fui-positioning-slide-distance-y:0px;}", ".f1noc5he{animation-name:f1m0q9mo,f79suad;}"],
  k: ["@keyframes f1m0q9mo{from{opacity:-1;}to{opacity:0;}}", "@keyframes f79suad{from{transform:translate(var(--fui-positioning-slide-distance-x), var(--fui-positioning-slide-distance-y));}}"],
  m: [["@media (prefers-reduced-motion){.fi19xcv[data-popper-placement]{animation-duration:1ms;}}", {
    m: "(prefers-reduced-motion)"
  }], ["@media (prefers-reduced-motion){.f1mxk9aa[data-popper-placement]{animation-name:f1m0q9mo;}}", {
    m: "(prefers-reduced-motion)"
  }]],
  t: ["@supports not (animation-composition: accumulate){.ffzg62k[data-popper-placement]{animation-name:f1m0q9mo;}}"]
});
var useMenuPopoverStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles24();
  state.root.className = mergeClasses(menuPopoverClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuPopover/renderMenuPopover.js
var renderMenuPopover_unstable = (state) => {
  assertSlots(state);
  if (state.inline) {
    return jsxs(import_react.Fragment, {
      children: [
        jsx(state.root, {}),
        state.safeZone
      ]
    });
  }
  return jsxs(Portal, {
    mountNode: state.mountNode,
    children: [
      jsx(state.root, {}),
      state.safeZone
    ]
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuPopover/MenuPopover.js
var MenuPopover = React216.forwardRef((props, ref) => {
  const state = useMenuPopover_unstable(props, ref);
  useMenuPopoverStyles_unstable(state);
  useCustomStyleHook("useMenuPopoverStyles_unstable")(state);
  return renderMenuPopover_unstable(state);
});
MenuPopover.displayName = "MenuPopover";

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/MenuSplitGroup.js
var React219 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/useMenuSplitGroup.js
var React217 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/useMenuSplitGroupStyles.styles.js
var menuSplitGroupMultilineAttr = "data-multiline";
var menuSplitGroupClassNames = {
  root: "fui-MenuSplitGroup"
};
var useStyles25 = __styles2({
  root: {
    Bhlrgs3: "f1v24km9",
    mc9l5x: "f22iagw",
    rue6gn: 0,
    oe75ve: 0,
    Bbblmiw: 0,
    Bn2ps6a: "fa49so4",
    Bu15iap: ["fsdyxoe", "fuk6rhi"],
    B71tm0z: ["fn8z6db", "f1be8c1t"],
    Gjs4sj: ["f1vtn0lh", "f8hq2kl"],
    foni4y: "f7j48hl",
    Ie9k5m: "f13du8c1",
    f30fub: "fe64lw1",
    Jberyy: "f92oj5h"
  }
}, {
  d: [".f1v24km9[data-multiline]>.fui-MenuItem:nth-of-type(2){align-self:center;}", ".f22iagw{display:flex;}", [".fa49so4>.fui-MenuItem:nth-of-type(1){flex:1;}", {
    p: -1
  }], ".fsdyxoe>.fui-MenuItem:nth-of-type(2){border-top-left-radius:0;}", ".fuk6rhi>.fui-MenuItem:nth-of-type(2){border-top-right-radius:0;}", ".fn8z6db>.fui-MenuItem:nth-of-type(2){border-bottom-left-radius:0;}", ".f1be8c1t>.fui-MenuItem:nth-of-type(2){border-bottom-right-radius:0;}", ".f1vtn0lh>.fui-MenuItem:nth-of-type(2){padding-left:0;}", ".f8hq2kl>.fui-MenuItem:nth-of-type(2){padding-right:0;}", '.f7j48hl>.fui-MenuItem:nth-of-type(2)::before{content:"";}', ".f13du8c1>.fui-MenuItem:nth-of-type(2)::before{width:var(--strokeWidthThin);}", ".fe64lw1>.fui-MenuItem:nth-of-type(2)::before{height:20px;}", ".f92oj5h>.fui-MenuItem:nth-of-type(2)::before{background-color:var(--colorNeutralStroke1);}"]
});
var useMenuSplitGroupStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles25();
  state.root.className = mergeClasses(menuSplitGroupClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/useMenuSplitGroup.js
var useMenuSplitGroup_unstable = (props, ref) => {
  const innerRef = React217.useRef(void 0);
  const { dir, targetDocument } = useFluent();
  const nextArrowKey = getRTLSafeKey(ArrowRight, dir);
  const prevArrowKey = getRTLSafeKey(ArrowLeft, dir);
  const { findNextFocusable, findPrevFocusable } = useFocusFinders();
  const { multilineRef, setMultiline } = useHandleMultilineMenuItem();
  const onKeyDown = React217.useCallback((e) => {
    var _innerRef_current;
    const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
    if (!activeElement) {
      return;
    }
    if (!((_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.contains(activeElement))) {
      return;
    }
    if (e.key === nextArrowKey) {
      const next = findNextFocusable(activeElement, {
        container: innerRef.current
      });
      next === null || next === void 0 ? void 0 : next.focus();
    }
    if (e.key === prevArrowKey) {
      const prev = findPrevFocusable(activeElement, {
        container: innerRef.current
      });
      prev === null || prev === void 0 ? void 0 : prev.focus();
    }
  }, [
    findNextFocusable,
    findPrevFocusable,
    targetDocument,
    nextArrowKey,
    prevArrowKey
  ]);
  return {
    components: {
      root: "div"
    },
    setMultiline,
    root: slot_exports.always(getIntrinsicElementProps("div", {
      role: "group",
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, innerRef, multilineRef),
      onKeyDown,
      ...props
    }), {
      elementType: "div"
    })
  };
};
var useHandleMultilineMenuItem = () => {
  const [handle] = React217.useState(() => {
    let isMultiline = false;
    let multilineNode = null;
    function applyAttr() {
      multilineNode === null || multilineNode === void 0 ? void 0 : multilineNode.toggleAttribute(menuSplitGroupMultilineAttr, isMultiline);
    }
    return {
      multilineRef: (node) => {
        if (node) {
          multilineNode = node;
          applyAttr();
        } else {
          multilineNode = null;
        }
      },
      setMultiline: (value) => {
        isMultiline = value;
        applyAttr();
      }
    };
  });
  return handle;
};

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/renderMenuSplitGroup.js
var renderMenuSplitGroup_unstable = (state, contexts) => {
  assertSlots(state);
  var _contexts_menuSplitGroup;
  return jsx(MenuSplitGroupContextProvider, {
    value: (_contexts_menuSplitGroup = contexts === null || contexts === void 0 ? void 0 : contexts.menuSplitGroup) !== null && _contexts_menuSplitGroup !== void 0 ? _contexts_menuSplitGroup : menuSplitGroupContextDefaultValue,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/useMenuSplitGroupContextValues.js
var React218 = __toESM(require_react());
var useMenuSplitGroupContextValues = (state) => {
  "use no memo";
  return React218.useMemo(() => {
    return {
      menuSplitGroup: {
        setMultiline: state.setMultiline
      }
    };
  }, [
    state.setMultiline
  ]);
};

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/MenuSplitGroup.js
var MenuSplitGroup = React219.forwardRef((props, ref) => {
  const state = useMenuSplitGroup_unstable(props, ref);
  useMenuSplitGroupStyles_unstable(state);
  useCustomStyleHook("useMenuSplitGroupStyles_unstable")(state);
  return renderMenuSplitGroup_unstable(state, useMenuSplitGroupContextValues(state));
});
MenuSplitGroup.displayName = "MenuSplitGroup";

// node_modules/@fluentui/react-menu/lib/components/MenuTrigger/MenuTrigger.js
var React222 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuTrigger/useMenuTrigger.js
var React220 = __toESM(require_react());
function noop3() {
}
var useMenuTrigger_unstable = (props) => {
  const { children: children2, disableButtonEnhancement = false } = props;
  const triggerRef = useMenuContext_unstable((context) => context.triggerRef);
  const menuPopoverRef = useMenuContext_unstable((context) => context.menuPopoverRef);
  const setOpen = useMenuContext_unstable((context) => context.setOpen);
  const open = useMenuContext_unstable((context) => context.open);
  const triggerId = useMenuContext_unstable((context) => context.triggerId);
  const openOnHover = useMenuContext_unstable((context) => context.openOnHover);
  const openOnContext = useMenuContext_unstable((context) => context.openOnContext);
  const isSubmenu = useIsSubmenu();
  const { findFirstFocusable } = useFocusFinders();
  const focusFirst = React220.useCallback(() => {
    const firstFocusable = findFirstFocusable(menuPopoverRef.current);
    firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
  }, [
    findFirstFocusable,
    menuPopoverRef
  ]);
  const openedWithKeyboardRef = React220.useRef(false);
  const openedViaSafeZoneRef = React220.useRef(false);
  const hasMouseMovedRef = React220.useRef(false);
  const { dir } = useFluent();
  const OpenArrowKey = dir === "ltr" ? ArrowRight : ArrowLeft;
  const child = getTriggerChild(children2);
  const safeZoneHandlerRef = useOnMenuSafeZoneTimeout(useEventCallback(() => {
    if (isSubmenu) {
      openedViaSafeZoneRef.current = true;
    }
  }));
  const onContextMenu = (event) => {
    if (isTargetDisabled(event) || event.isDefaultPrevented()) {
      return;
    }
    if (openOnContext) {
      event.preventDefault();
      setOpen(event, {
        open: true,
        keyboard: false,
        type: "menuTriggerContextMenu",
        event
      });
    }
  };
  const onClick = (event) => {
    if (isTargetDisabled(event)) {
      return;
    }
    if (!openOnContext) {
      setOpen(event, {
        open: !open,
        keyboard: openedWithKeyboardRef.current,
        type: "menuTriggerClick",
        event
      });
      openedWithKeyboardRef.current = false;
    }
  };
  const onKeyDown = (event) => {
    if (isTargetDisabled(event) || event.isDefaultPrevented()) {
      return;
    }
    const key = event.key;
    if (!openOnContext && (isSubmenu && key === OpenArrowKey || !isSubmenu && key === ArrowDown)) {
      setOpen(event, {
        open: true,
        keyboard: true,
        type: "menuTriggerKeyDown",
        event
      });
    }
    if (key === Escape && !isSubmenu) {
      setOpen(event, {
        open: false,
        keyboard: true,
        type: "menuTriggerKeyDown",
        event
      });
    }
    if (open && key === OpenArrowKey && isSubmenu) {
      focusFirst();
    }
  };
  const onMouseOver = (event) => {
    if (isTargetDisabled(event)) {
      return;
    }
    if (openOnHover) {
      if (hasMouseMovedRef.current) {
        setOpen(event, {
          open: true,
          keyboard: false,
          type: "menuTriggerMouseEnter",
          event
        });
      } else if (openedViaSafeZoneRef.current) {
        setOpen(event, {
          open: true,
          keyboard: false,
          ignoreHoverDelay: true,
          type: "menuTriggerMouseEnter",
          event
        });
        openedViaSafeZoneRef.current = false;
      }
    }
  };
  const onMouseMove = (event) => {
    if (isTargetDisabled(event)) {
      return;
    }
    if (openOnHover && !hasMouseMovedRef.current) {
      setOpen(event, {
        open: true,
        keyboard: false,
        type: "menuTriggerMouseMove",
        event
      });
      hasMouseMovedRef.current = true;
    }
  };
  const onMouseLeave = (event) => {
    if (isTargetDisabled(event)) {
      return;
    }
    if (openOnHover) {
      setOpen(event, {
        open: false,
        keyboard: false,
        type: "menuTriggerMouseLeave",
        event
      });
    }
  };
  var _child_props_onMouseEnter;
  const contextMenuProps = {
    id: triggerId,
    ...child === null || child === void 0 ? void 0 : child.props,
    ref: useMergedRefs(triggerRef, getReactElementRef(child), safeZoneHandlerRef),
    onMouseEnter: useEventCallback((_child_props_onMouseEnter = child === null || child === void 0 ? void 0 : child.props.onMouseEnter) !== null && _child_props_onMouseEnter !== void 0 ? _child_props_onMouseEnter : noop3),
    onMouseLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseLeave, onMouseLeave)),
    onContextMenu: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onContextMenu, onContextMenu)),
    onMouseMove: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseMove, onMouseMove)),
    onMouseOver: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseOver, onMouseOver))
  };
  const triggerChildProps = {
    "aria-haspopup": "menu",
    "aria-expanded": !open && !isSubmenu ? void 0 : open,
    ...contextMenuProps,
    onClick: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onClick, onClick)),
    onKeyDown: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onKeyDown, onKeyDown))
  };
  const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", triggerChildProps);
  return {
    isSubmenu,
    children: applyTriggerPropsToChildren(children2, openOnContext ? contextMenuProps : disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)
  };
};
var isTargetDisabled = (event) => {
  const isDisabled = (el) => el.hasAttribute("disabled") || el.hasAttribute("aria-disabled") && el.getAttribute("aria-disabled") === "true";
  if (isHTMLElement(event.target) && isDisabled(event.target)) {
    return true;
  }
  return isHTMLElement(event.currentTarget) && isDisabled(event.currentTarget);
};

// node_modules/@fluentui/react-menu/lib/components/MenuTrigger/renderMenuTrigger.js
var React221 = __toESM(require_react());
var renderMenuTrigger_unstable = (state) => {
  return React221.createElement(MenuTriggerContextProvider, {
    value: state.isSubmenu
  }, state.children);
};

// node_modules/@fluentui/react-menu/lib/components/MenuTrigger/MenuTrigger.js
var MenuTrigger = (props) => {
  const state = useMenuTrigger_unstable(props);
  return renderMenuTrigger_unstable(state);
};
MenuTrigger.displayName = "MenuTrigger";
MenuTrigger.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-menu/lib/components/MenuItemLink/MenuItemLink.js
var React224 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItemLink/useMenuItemLink.js
var React223 = __toESM(require_react());
var useMenuItemLink_unstable = (props, ref) => {
  const baseState = useMenuItem_unstable(props, null);
  const _props = {
    ...props,
    ...baseState.root,
    ref,
    tabIndex: props.tabIndex
  };
  return {
    ...baseState,
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...baseState.components,
      root: "a"
    },
    root: slot_exports.always(getIntrinsicElementProps("a", {
      role: "menuitem",
      ..._props
    }), {
      elementType: "a"
    })
  };
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemLink/renderMenuItemLink.js
var renderMenuItemLink_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.checkmark && jsx(state.checkmark, {}),
      state.icon && jsx(state.icon, {}),
      state.content && jsx(state.content, {}),
      state.secondaryContent && jsx(state.secondaryContent, {})
    ]
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemLink/useMenuItemLinkStyles.styles.js
var menuItemLinkClassNames = {
  root: "fui-MenuItemLink",
  icon: "fui-MenuItemLink__icon",
  checkmark: "fui-MenuItemLink__checkmark",
  content: "fui-MenuItemLink__content",
  secondaryContent: "fui-MenuItemLink__secondaryContent"
};
var useStyles26 = __styles2({
  resetLink: {
    w71qe1: "f1iuv45f",
    Bkioxbp: "f9pkogg",
    I8pafv: "foe20s3",
    dvvfom: "f1kn6jj"
  }
}, {
  d: [".f1iuv45f{text-decoration-line:none;}", ".f9pkogg{text-decoration-thickness:initial;}", ".foe20s3{text-decoration-style:initial;}", ".f1kn6jj{text-decoration-color:initial;}"]
});
var useMenuItemLinkStyles_unstable = (state) => {
  "use no memo";
  useMenuItemStyles_unstable(state);
  const styles = useStyles26();
  state.root.className = mergeClasses(menuItemLinkClassNames.root, styles.resetLink, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(menuItemLinkClassNames.icon, state.icon.className);
  }
  if (state.content) {
    state.content.className = mergeClasses(menuItemLinkClassNames.content, state.content.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(menuItemLinkClassNames.secondaryContent, state.secondaryContent.className);
  }
  if (state.checkmark) {
    state.checkmark.className = mergeClasses(menuItemLinkClassNames.checkmark, state.checkmark.className);
  }
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemLink/MenuItemLink.js
var MenuItemLink = React224.forwardRef((props, ref) => {
  const state = useMenuItemLink_unstable(props, ref);
  useMenuItemLinkStyles_unstable(state);
  useCustomStyleHook("useMenuItemLinkStyles_unstable")(state);
  return renderMenuItemLink_unstable(state);
});
MenuItemLink.displayName = "MenuItemLink";

// node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/MenuItemSwitch.js
var React226 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/useMenuItemSwitch.js
var React225 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/useMenuItemSwitchStyles.styles.js
var menuItemSwitchClassNames = {
  root: "fui-MenuItemSwitch",
  icon: "fui-MenuItemSwitch__icon",
  content: "fui-MenuItemSwitch__content",
  secondaryContent: "fui-MenuItemSwitch__secondaryContent",
  switchIndicator: "fui-MenuItemSwitch__switchIndicator",
  subText: "fui-MenuItemSwitch__subText"
};
var circleFilledClassName = "fui-MenuItemSwitch__switchIndicator__circleFilled";
var spaceBetweenThumbAndTrack = 2;
var trackHeight = 20;
var thumbSize = trackHeight - spaceBetweenThumbAndTrack;
var useSwitchIndicatorBaseClassName = __resetStyles("r1x31n8g", "rsmcm5v", {
  r: [".r1x31n8g{border-radius:var(--borderRadiusCircular);border:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);line-height:0;box-sizing:border-box;fill:currentColor;flex-shrink:0;font-size:18px;height:20px;transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:background,border,color;width:40px;margin-right:var(--spacingHorizontalXS);color:var(--colorNeutralStrokeAccessible);}", ".r1x31n8g:hover{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".r1x31n8g:hover:active{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".r1x31n8g .fui-MenuItemSwitch__switchIndicator__circleFilled{transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:transform;}", ".rsmcm5v{border-radius:var(--borderRadiusCircular);border:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);line-height:0;box-sizing:border-box;fill:currentColor;flex-shrink:0;font-size:18px;height:20px;transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:background,border,color;width:40px;margin-left:var(--spacingHorizontalXS);color:var(--colorNeutralStrokeAccessible);}", ".rsmcm5v:hover{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".rsmcm5v:hover:active{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".rsmcm5v .fui-MenuItemSwitch__switchIndicator__circleFilled{transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:transform;}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.r1x31n8g{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1x31n8g .fui-MenuItemSwitch__switchIndicator__circleFilled{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.rsmcm5v{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.rsmcm5v .fui-MenuItemSwitch__switchIndicator__circleFilled{transition-duration:0.01ms;}}"]
});
var useSwitchIndicatorStyles = __styles2({
  checked: {
    G4r02d: ["fdca5i2", "fk0rr1z"],
    De3pzq: "ftywsgz",
    sj55zd: "fqpbvvt",
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"],
    Bi91k9c: "fz46y8r",
    Jwef8y: "f1kjrvvj",
    Bgoe8wy: "fpa59ij",
    Bwzppfd: ["f1rhln42", "f1l1ogpg"],
    oetu4i: "fz67qlh",
    gg5e9n: ["f1l1ogpg", "f1rhln42"],
    B2d53fq: "frlnr8d",
    iro3zm: "fle2s0s",
    b661bw: "f1j8ziw4",
    Bk6r4ia: ["f1xzu9i0", "f1jlpvxk"],
    B9zn80p: "f1i1ccxp",
    Bpld233: ["f1jlpvxk", "f1xzu9i0"]
  }
}, {
  d: [".fdca5i2 .fui-MenuItemSwitch__switchIndicator__circleFilled{transform:translateX(20px);}", ".fk0rr1z .fui-MenuItemSwitch__switchIndicator__circleFilled{transform:translateX(-20px);}", ".ftywsgz{background-color:var(--colorCompoundBrandBackground);}", ".fqpbvvt{color:var(--colorNeutralForegroundInverted);}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}"],
  h: [".fz46y8r:hover{color:var(--colorNeutralForegroundInverted);}", ".f1kjrvvj:hover{background-color:var(--colorCompoundBrandBackgroundHover);}", ".fpa59ij:hover{border-top-color:var(--colorTransparentStrokeInteractive);}", ".f1rhln42:hover{border-right-color:var(--colorTransparentStrokeInteractive);}", ".f1l1ogpg:hover{border-left-color:var(--colorTransparentStrokeInteractive);}", ".fz67qlh:hover{border-bottom-color:var(--colorTransparentStrokeInteractive);}", ".frlnr8d:hover:active{color:var(--colorNeutralForegroundInverted);}", ".fle2s0s:hover:active{background-color:var(--colorCompoundBrandBackgroundPressed);}", ".f1j8ziw4:hover:active{border-top-color:var(--colorTransparentStrokeInteractive);}", ".f1xzu9i0:hover:active{border-right-color:var(--colorTransparentStrokeInteractive);}", ".f1jlpvxk:hover:active{border-left-color:var(--colorTransparentStrokeInteractive);}", ".f1i1ccxp:hover:active{border-bottom-color:var(--colorTransparentStrokeInteractive);}"]
});
var useMultilineStyles2 = __styles2({
  "switch": {
    qb2dma: "f7nlbp4"
  }
}, {
  d: [".f7nlbp4{align-self:center;}"]
});
var useMenuItemSwitchStyles_unstable = (state) => {
  "use no memo";
  const {
    checked,
    subText
  } = state;
  const multiline = !!subText;
  const switchIndicatorStyles = useSwitchIndicatorStyles();
  const switchIndicatorBaseStyles = useSwitchIndicatorBaseClassName();
  const multilineStyles = useMultilineStyles2();
  state.root.className = mergeClasses(menuItemSwitchClassNames.root, state.root.className);
  if (state.content) {
    state.content.className = mergeClasses(menuItemSwitchClassNames.content, state.content.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(menuItemSwitchClassNames.secondaryContent, state.secondaryContent.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(menuItemSwitchClassNames.icon, state.icon.className);
  }
  if (state.subText) {
    state.subText.className = mergeClasses(menuItemSwitchClassNames.subText, state.subText.className);
  }
  if (state.switchIndicator) {
    state.switchIndicator.className = mergeClasses(menuItemSwitchClassNames.switchIndicator, switchIndicatorBaseStyles, checked && switchIndicatorStyles.checked, state.switchIndicator.className, multiline && multilineStyles.switch);
  }
  useMenuItemStyles_unstable({
    ...state,
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...state.components,
      checkmark: "span",
      submenuIndicator: "span"
    },
    checkmark: void 0,
    submenuIndicator: void 0,
    hasSubmenu: false,
    persistOnClick: true
  });
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/useMenuItemSwitch.js
var useMenuItemSwitch_unstable = (props, ref) => {
  const baseState = useMenuItemCheckbox_unstable(props, ref);
  return {
    ...baseState,
    switchIndicator: slot_exports.optional(props.switchIndicator, {
      renderByDefault: true,
      elementType: "span",
      defaultProps: {
        children: React225.createElement(CircleFilled, {
          className: circleFilledClassName
        })
      }
    }),
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...baseState.components,
      switchIndicator: "span"
    }
  };
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/renderMenuItemSwitch.js
var renderMenuItemSwitch_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      state.content && jsxs(state.content, {
        children: [
          state.content.children,
          state.subText && jsx(state.subText, {})
        ]
      }),
      state.secondaryContent && jsx(state.secondaryContent, {}),
      state.switchIndicator && jsx(state.switchIndicator, {})
    ]
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/MenuItemSwitch.js
var MenuItemSwitch = React226.forwardRef((props, ref) => {
  const state = useMenuItemSwitch_unstable(props, ref);
  useMenuItemSwitchStyles_unstable(state);
  useCustomStyleHook("useMenuItemSwitchStyles_unstable")(state);
  return renderMenuItemSwitch_unstable(state);
});
MenuItemSwitch.displayName = "MenuItemSwitch";

// node_modules/@fluentui/react-persona/lib/components/Persona/Persona.js
var React228 = __toESM(require_react());

// node_modules/@fluentui/react-persona/lib/components/Persona/renderPersona.js
var renderPersona_unstable = (state) => {
  const { presenceOnly, textPosition } = state;
  assertSlots(state);
  const coin = presenceOnly ? state.presence && jsx(state.presence, {}) : state.avatar && jsx(state.avatar, {});
  return jsxs(state.root, {
    children: [
      (textPosition === "after" || textPosition === "below") && coin,
      state.primaryText && jsx(state.primaryText, {}),
      state.secondaryText && jsx(state.secondaryText, {}),
      state.tertiaryText && jsx(state.tertiaryText, {}),
      state.quaternaryText && jsx(state.quaternaryText, {}),
      textPosition === "before" && coin
    ]
  });
};

// node_modules/@fluentui/react-persona/lib/components/Persona/usePersona.js
var React227 = __toESM(require_react());
var usePersona_unstable = (props, ref) => {
  const { name, presenceOnly = false, size: size3 = "medium", textAlignment = "start", textPosition = "after" } = props;
  const primaryText = slot_exports.optional(props.primaryText, {
    renderByDefault: true,
    defaultProps: {
      children: name
    },
    elementType: "span"
  });
  const secondaryText = slot_exports.optional(props.secondaryText, {
    elementType: "span"
  });
  const tertiaryText = slot_exports.optional(props.tertiaryText, {
    elementType: "span"
  });
  const quaternaryText = slot_exports.optional(props.quaternaryText, {
    elementType: "span"
  });
  const numTextLines = [
    primaryText,
    secondaryText,
    tertiaryText,
    quaternaryText
  ].filter(Boolean).length;
  return {
    numTextLines,
    presenceOnly,
    size: size3,
    textAlignment,
    textPosition,
    components: {
      root: "div",
      avatar: Avatar,
      presence: PresenceBadge,
      primaryText: "span",
      secondaryText: "span",
      tertiaryText: "span",
      quaternaryText: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps(
      "div",
      {
        ...props,
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref
      },
      /* excludedPropNames */
      [
        "name"
      ]
    ), {
      elementType: "div"
    }),
    avatar: !presenceOnly ? slot_exports.optional(props.avatar, {
      renderByDefault: true,
      defaultProps: {
        name,
        badge: props.presence,
        size: avatarSizes[size3]
      },
      elementType: Avatar
    }) : void 0,
    presence: presenceOnly ? slot_exports.optional(props.presence, {
      defaultProps: {
        size: presenceSizes[size3]
      },
      elementType: PresenceBadge
    }) : void 0,
    primaryText,
    secondaryText,
    tertiaryText,
    quaternaryText
  };
};
var presenceSizes = {
  "extra-small": "tiny",
  small: "extra-small",
  medium: "small",
  large: "medium",
  "extra-large": "large",
  huge: "large"
};
var avatarSizes = {
  "extra-small": 20,
  small: 28,
  medium: 32,
  large: 36,
  "extra-large": 40,
  huge: 56
};

// node_modules/@fluentui/react-persona/lib/components/Persona/usePersonaStyles.styles.js
var personaClassNames = {
  root: "fui-Persona",
  avatar: "fui-Persona__avatar",
  presence: "fui-Persona__presence",
  primaryText: "fui-Persona__primaryText",
  secondaryText: "fui-Persona__secondaryText",
  tertiaryText: "fui-Persona__tertiaryText",
  quaternaryText: "fui-Persona__quaternaryText"
};
var useRootClassName5 = __resetStyles("rlroi9i", null, [".rlroi9i{display:inline-grid;grid-auto-rows:max-content;grid-auto-flow:column;justify-items:start;grid-template-columns:max-content [middle] auto;}"]);
var useStyles27 = __styles2({
  beforeAfterCenter: {
    wkccdc: "f1iantul"
  },
  after: {},
  before: {
    B7hvi0a: "f1tll2w5",
    Budl1dq: "ffvkwdr"
  },
  below: {
    Bxotwcr: "f1nkeedh",
    B7hvi0a: "f1oiokrs",
    Budl1dq: "f1emgwh2"
  },
  media: {
    Ijaq50: "f1hek2iy"
  },
  mediaBeforeAfterCenter: {
    Ijaq50: "fa4dipu"
  },
  start: {
    qb2dma: "f9h729m"
  },
  center: {
    qb2dma: "f7nlbp4"
  },
  afterAlignToPrimary: {
    qb2dma: "f7nlbp4",
    Ijaq50: "f1rnkkuc",
    Bw0ie65: "f1warjpf"
  },
  beforeAlignToPrimary: {
    qb2dma: "f7nlbp4",
    Ijaq50: "f1rnkkuc",
    Br312pm: "fwu52yu"
  },
  secondLineSpacing: {
    B6of3ja: "f1ryq6si"
  },
  primary: {
    Ijaq50: "f1q3ipgb"
  },
  secondary: {
    Ijaq50: "f3drtdk"
  },
  tertiary: {
    Ijaq50: "fa1o6s1"
  },
  quaternary: {
    Ijaq50: "f1tuwaia"
  }
}, {
  d: [".f1iantul{grid-template-rows:1fr [primary] max-content [secondary] max-content [tertiary] max-content [quaternary] max-content 1fr;}", ".f1tll2w5{justify-items:end;}", ".ffvkwdr{grid-template-columns:auto [middle] max-content;}", ".f1nkeedh{grid-auto-flow:unset;}", ".f1oiokrs{justify-items:center;}", ".f1emgwh2{grid-template-columns:unset;}", ".f1hek2iy{grid-row-start:span 5;}", ".fa4dipu{grid-row-start:span 6;}", ".f9h729m{align-self:start;}", ".f7nlbp4{align-self:center;}", ".f1rnkkuc{grid-row-start:unset;}", ".f1warjpf{grid-column-end:middle;}", ".fwu52yu{grid-column-start:middle;}", ".f1ryq6si{margin-top:-2px;}", ".f1q3ipgb{grid-row-start:primary;}", ".f3drtdk{grid-row-start:secondary;}", ".fa1o6s1{grid-row-start:tertiary;}", ".f1tuwaia{grid-row-start:quaternary;}"]
});
var useAvatarSpacingStyles = __styles2({
  "extra-small": {
    Bs1gm4r: "f1e48tse"
  },
  small: {
    Bs1gm4r: "f18q9vkd"
  },
  medium: {
    Bs1gm4r: "f18q9vkd"
  },
  large: {
    Bs1gm4r: "fx34bi6"
  },
  "extra-large": {
    Bs1gm4r: "fx34bi6"
  },
  huge: {
    Bs1gm4r: "f1o96qtm"
  },
  after: {
    t21cq0: ["f103ycu4", "f1tao51"]
  },
  below: {
    jrapky: "fbo7acy"
  },
  before: {
    Frg6f3: ["f1tao51", "f103ycu4"]
  }
}, {
  d: [".f1e48tse{--fui-Persona__avatar--spacing:var(--spacingHorizontalSNudge);}", ".f18q9vkd{--fui-Persona__avatar--spacing:var(--spacingHorizontalS);}", ".fx34bi6{--fui-Persona__avatar--spacing:var(--spacingHorizontalMNudge);}", ".f1o96qtm{--fui-Persona__avatar--spacing:var(--spacingHorizontalM);}", ".f103ycu4{margin-right:var(--fui-Persona__avatar--spacing);}", ".f1tao51{margin-left:var(--fui-Persona__avatar--spacing);}", ".fbo7acy{margin-bottom:var(--fui-Persona__avatar--spacing);}"]
});
var usePresenceSpacingStyles = __styles2({
  small: {
    Bs1gm4r: "f1e48tse"
  }
}, {
  d: [".f1e48tse{--fui-Persona__avatar--spacing:var(--spacingHorizontalSNudge);}"]
});
var usePersonaStyles_unstable = (state) => {
  "use no memo";
  const {
    presenceOnly,
    size: size3,
    textAlignment,
    textPosition
  } = state;
  const alignToPrimary = presenceOnly && textAlignment === "start" && size3 !== "extra-large" && size3 !== "huge";
  const alignBeforeAfterCenter = textPosition !== "below" && textAlignment === "center";
  const {
    primaryTextClassName,
    optionalTextClassName
  } = useTextClassNames(state, alignToPrimary);
  const rootClassName = useRootClassName5();
  const styles = useStyles27();
  const avatarSpacingStyles = useAvatarSpacingStyles();
  const presenceSpacingStyles = {
    ...avatarSpacingStyles,
    ...usePresenceSpacingStyles()
  };
  state.root.className = mergeClasses(personaClassNames.root, rootClassName, alignBeforeAfterCenter && styles.beforeAfterCenter, styles[textPosition], state.root.className);
  if (state.avatar) {
    state.avatar.className = mergeClasses(personaClassNames.avatar, textPosition !== "below" && styles.media, alignBeforeAfterCenter && styles.mediaBeforeAfterCenter, styles[textAlignment], avatarSpacingStyles[size3], avatarSpacingStyles[textPosition], state.avatar.className);
  }
  if (state.presence) {
    state.presence.className = mergeClasses(personaClassNames.presence, textPosition !== "below" && styles.media, alignBeforeAfterCenter && styles.mediaBeforeAfterCenter, styles[textAlignment], presenceSpacingStyles[size3], presenceSpacingStyles[textPosition], textPosition === "after" && alignToPrimary && styles.afterAlignToPrimary, textPosition === "before" && alignToPrimary && styles.beforeAlignToPrimary, state.presence.className);
  }
  if (state.primaryText) {
    state.primaryText.className = mergeClasses(personaClassNames.primaryText, alignBeforeAfterCenter && styles.primary, primaryTextClassName, state.primaryText.className);
  }
  if (state.secondaryText) {
    state.secondaryText.className = mergeClasses(personaClassNames.secondaryText, alignBeforeAfterCenter && styles.secondary, optionalTextClassName, styles.secondLineSpacing, state.secondaryText.className);
  }
  if (state.tertiaryText) {
    state.tertiaryText.className = mergeClasses(personaClassNames.tertiaryText, alignBeforeAfterCenter && styles.tertiary, optionalTextClassName, state.tertiaryText.className);
  }
  if (state.quaternaryText) {
    state.quaternaryText.className = mergeClasses(personaClassNames.quaternaryText, alignBeforeAfterCenter && styles.quaternary, optionalTextClassName, state.quaternaryText.className);
  }
  return state;
};
var usePrimaryTextBaseClassName = __resetStyles("rvj41k9", null, [".rvj41k9{display:block;color:var(--colorNeutralForeground1);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);}"]);
var useOptionalTextBaseClassName = __resetStyles("rp1pf9e", null, [".rp1pf9e{display:block;color:var(--colorNeutralForeground2);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
var useTextStyles = __styles2({
  beforeAlignToPrimary: {
    Bw0ie65: "f1warjpf"
  },
  afterAlignToPrimary: {
    Br312pm: "fwu52yu"
  },
  body1: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  caption1: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  subtitle2: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  }
}, {
  d: [".f1warjpf{grid-column-end:middle;}", ".fwu52yu{grid-column-start:middle;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}"]
});
var useTextClassNames = (state, alignToPrimary) => {
  const {
    presenceOnly,
    size: size3,
    textPosition
  } = state;
  const primaryTextBaseClassName = usePrimaryTextBaseClassName();
  const optionalTextBaseClassName = useOptionalTextBaseClassName();
  const textStyles = useTextStyles();
  let primaryTextSize;
  let alignToPrimaryClassName;
  if (presenceOnly) {
    if (size3 === "extra-small") {
      primaryTextSize = state.numTextLines <= 1 && textStyles.caption1;
    } else if (size3 === "extra-large" || size3 === "huge") {
      primaryTextSize = textStyles.subtitle2;
    }
    if (alignToPrimary) {
      if (textPosition === "before") {
        alignToPrimaryClassName = textStyles.beforeAlignToPrimary;
      } else if (textPosition === "after") {
        alignToPrimaryClassName = textStyles.afterAlignToPrimary;
      }
    }
  } else {
    if (size3 === "huge") {
      primaryTextSize = textStyles.subtitle2;
    } else if (size3 === "extra-large") {
      primaryTextSize = textStyles.subtitle2;
    }
  }
  return {
    primaryTextClassName: mergeClasses(primaryTextBaseClassName, primaryTextSize, alignToPrimaryClassName),
    optionalTextClassName: mergeClasses(optionalTextBaseClassName, !presenceOnly && size3 === "huge" && textStyles.body1, alignToPrimaryClassName)
  };
};

// node_modules/@fluentui/react-persona/lib/components/Persona/Persona.js
var Persona = React228.forwardRef((props, ref) => {
  const state = usePersona_unstable(props, ref);
  usePersonaStyles_unstable(state);
  useCustomStyleHook("usePersonaStyles_unstable")(state);
  return renderPersona_unstable(state);
});
Persona.displayName = "Persona";

// node_modules/@fluentui/react-radio/lib/components/RadioGroup/RadioGroup.js
var React232 = __toESM(require_react());

// node_modules/@fluentui/react-radio/lib/contexts/RadioGroupContext.js
var React229 = __toESM(require_react());
var RadioGroupContext = React229.createContext(void 0);
var radioGroupContextDefaultValue = {};
var RadioGroupProvider = RadioGroupContext.Provider;
var useRadioGroupContextValue_unstable = () => React229.useContext(RadioGroupContext) || radioGroupContextDefaultValue;
var useRadioGroupContext_unstable = (selector) => selector(useRadioGroupContextValue_unstable());

// node_modules/@fluentui/react-radio/lib/components/RadioGroup/renderRadioGroup.js
var renderRadioGroup_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(RadioGroupContext.Provider, {
    value: contextValues.radioGroup,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-radio/lib/components/RadioGroup/useRadioGroup.js
var React230 = __toESM(require_react());
var useRadioGroup_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props);
  const generatedName = useId2("radiogroup-");
  const { name = generatedName, value, defaultValue, disabled, layout = "vertical", onChange, required } = props;
  return {
    layout,
    name,
    value,
    defaultValue,
    disabled,
    required,
    components: {
      root: "div"
    },
    root: {
      ref,
      role: "radiogroup",
      ...slot_exports.always(getIntrinsicElementProps(
        "div",
        props,
        /*excludedPropNames:*/
        [
          "onChange",
          "name"
        ]
      ), {
        elementType: "div"
      }),
      onChange: useEventCallback((ev) => {
        if (onChange && isHTMLElement(ev.target, {
          constructorName: "HTMLInputElement"
        }) && ev.target.type === "radio") {
          onChange(ev, {
            value: ev.target.value
          });
        }
      })
    }
  };
};

// node_modules/@fluentui/react-radio/lib/components/RadioGroup/useRadioGroupStyles.styles.js
var radioGroupClassNames = {
  root: "fui-RadioGroup"
};
var useStyles28 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f6jr5hl"
  },
  vertical: {
    Beiy3e4: "f1vx9l62"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f6jr5hl{align-items:flex-start;}", ".f1vx9l62{flex-direction:column;}"]
});
var useRadioGroupStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles28();
  state.root.className = mergeClasses(radioGroupClassNames.root, styles.root, state.layout === "vertical" && styles.vertical, state.root.className);
  return state;
};

// node_modules/@fluentui/react-radio/lib/contexts/useRadioGroupContextValues.js
var React231 = __toESM(require_react());
var useRadioGroupContextValues = (state) => {
  const { name, value, defaultValue, disabled, layout, required } = state;
  const ariaDescribedBy = state.root["aria-describedby"];
  const radioGroup = React231.useMemo(() => ({
    name,
    value,
    defaultValue,
    disabled,
    layout,
    required,
    "aria-describedby": ariaDescribedBy
  }), [
    name,
    value,
    defaultValue,
    disabled,
    layout,
    required,
    ariaDescribedBy
  ]);
  return {
    radioGroup
  };
};

// node_modules/@fluentui/react-radio/lib/components/RadioGroup/RadioGroup.js
var RadioGroup = React232.forwardRef((props, ref) => {
  const state = useRadioGroup_unstable(props, ref);
  const contextValues = useRadioGroupContextValues(state);
  useRadioGroupStyles_unstable(state);
  useCustomStyleHook("useRadioGroupStyles_unstable")(state);
  return renderRadioGroup_unstable(state, contextValues);
});
RadioGroup.displayName = "RadioGroup";

// node_modules/@fluentui/react-radio/lib/components/Radio/Radio.js
var React234 = __toESM(require_react());

// node_modules/@fluentui/react-radio/lib/components/Radio/renderRadio.js
var renderRadio_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      jsx(state.indicator, {}),
      state.label && jsx(state.label, {})
    ]
  });
};

// node_modules/@fluentui/react-radio/lib/components/Radio/useRadio.js
var React233 = __toESM(require_react());
var useRadio_unstable = (props, ref) => {
  const group = useRadioGroupContextValue_unstable();
  const { name = group.name, checked = group.value !== void 0 ? group.value === props.value : void 0, defaultChecked = group.defaultValue !== void 0 ? group.defaultValue === props.value : void 0, labelPosition = group.layout === "horizontal-stacked" ? "below" : "after", disabled = group.disabled, required = group.required, "aria-describedby": ariaDescribedBy = group["aria-describedby"], onChange } = props;
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "checked",
      "defaultChecked",
      "onChange"
    ]
  });
  const root = slot_exports.always(props.root, {
    defaultProps: {
      ref: useFocusWithin(),
      ...nativeProps.root
    },
    elementType: "span"
  });
  const input = slot_exports.always(props.input, {
    defaultProps: {
      ref,
      type: "radio",
      id: useId2("radio-", nativeProps.primary.id),
      name,
      checked,
      defaultChecked,
      disabled,
      required,
      "aria-describedby": ariaDescribedBy,
      ...nativeProps.primary
    },
    elementType: "input"
  });
  input.onChange = mergeCallbacks(input.onChange, (ev) => onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
    value: ev.currentTarget.value
  }));
  const label = slot_exports.optional(props.label, {
    defaultProps: {
      htmlFor: input.id,
      disabled: input.disabled
    },
    elementType: Label
  });
  const indicator = slot_exports.always(props.indicator, {
    defaultProps: {
      "aria-hidden": true
    },
    elementType: "div"
  });
  return {
    labelPosition,
    components: {
      root: "span",
      input: "input",
      label: Label,
      indicator: "div"
    },
    root,
    input,
    label,
    indicator
  };
};

// node_modules/@fluentui/react-radio/lib/components/Radio/useRadioStyles.styles.js
var radioClassNames = {
  root: "fui-Radio",
  indicator: "fui-Radio__indicator",
  input: "fui-Radio__input",
  label: "fui-Radio__label"
};
var useRootBaseClassName3 = __resetStyles("r1siqwd8", "rmnplyc", {
  r: [".r1siqwd8{display:inline-flex;position:relative;}", ".r1siqwd8:focus{outline-style:none;}", ".r1siqwd8:focus-visible{outline-style:none;}", ".r1siqwd8[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r1siqwd8[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".rmnplyc{display:inline-flex;position:relative;}", ".rmnplyc:focus{outline-style:none;}", ".rmnplyc:focus-visible{outline-style:none;}", ".rmnplyc[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.rmnplyc[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.r1siqwd8[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.rmnplyc[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useRootStyles9 = __styles2({
  vertical: {
    Beiy3e4: "f1vx9l62",
    Bt984gj: "f122n59"
  }
}, {
  d: [".f1vx9l62{flex-direction:column;}", ".f122n59{align-items:center;}"]
});
var useInputBaseClassName2 = __resetStyles("rg1upok", "rzwdzb4", {
  r: [".rg1upok{position:absolute;left:0;top:0;width:calc(16px + 2 * var(--spacingHorizontalS));height:100%;box-sizing:border-box;margin:0;opacity:0;}", ".rg1upok:enabled{cursor:pointer;}", ".rg1upok:enabled~.fui-Radio__label{cursor:pointer;}", ".rg1upok:enabled:not(:checked)~.fui-Radio__label{color:var(--colorNeutralForeground3);}", ".rg1upok:enabled:not(:checked)~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessible);}", ".rg1upok:enabled:not(:checked):hover~.fui-Radio__label{color:var(--colorNeutralForeground2);}", ".rg1upok:enabled:not(:checked):hover~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessibleHover);}", ".rg1upok:enabled:not(:checked):hover:active~.fui-Radio__label{color:var(--colorNeutralForeground1);}", ".rg1upok:enabled:not(:checked):hover:active~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".rg1upok:enabled:checked~.fui-Radio__label{color:var(--colorNeutralForeground1);}", ".rg1upok:enabled:checked~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStroke);color:var(--colorCompoundBrandForeground1);}", ".rg1upok:enabled:checked:hover~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokeHover);color:var(--colorCompoundBrandForeground1Hover);}", ".rg1upok:enabled:checked:hover:active~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokePressed);color:var(--colorCompoundBrandForeground1Pressed);}", ".rg1upok:disabled~.fui-Radio__label{color:var(--colorNeutralForegroundDisabled);cursor:default;}", ".rg1upok:disabled~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeDisabled);color:var(--colorNeutralForegroundDisabled);}", ".rzwdzb4{position:absolute;right:0;top:0;width:calc(16px + 2 * var(--spacingHorizontalS));height:100%;box-sizing:border-box;margin:0;opacity:0;}", ".rzwdzb4:enabled{cursor:pointer;}", ".rzwdzb4:enabled~.fui-Radio__label{cursor:pointer;}", ".rzwdzb4:enabled:not(:checked)~.fui-Radio__label{color:var(--colorNeutralForeground3);}", ".rzwdzb4:enabled:not(:checked)~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessible);}", ".rzwdzb4:enabled:not(:checked):hover~.fui-Radio__label{color:var(--colorNeutralForeground2);}", ".rzwdzb4:enabled:not(:checked):hover~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessibleHover);}", ".rzwdzb4:enabled:not(:checked):hover:active~.fui-Radio__label{color:var(--colorNeutralForeground1);}", ".rzwdzb4:enabled:not(:checked):hover:active~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".rzwdzb4:enabled:checked~.fui-Radio__label{color:var(--colorNeutralForeground1);}", ".rzwdzb4:enabled:checked~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStroke);color:var(--colorCompoundBrandForeground1);}", ".rzwdzb4:enabled:checked:hover~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokeHover);color:var(--colorCompoundBrandForeground1Hover);}", ".rzwdzb4:enabled:checked:hover:active~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokePressed);color:var(--colorCompoundBrandForeground1Pressed);}", ".rzwdzb4:disabled~.fui-Radio__label{color:var(--colorNeutralForegroundDisabled);cursor:default;}", ".rzwdzb4:disabled~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeDisabled);color:var(--colorNeutralForegroundDisabled);}"],
  s: ["@media (forced-colors: active){.rg1upok:enabled:not(:checked)~.fui-Radio__indicator{border-color:ButtonBorder;}}", "@media (forced-colors: active){.rg1upok:enabled:checked~.fui-Radio__indicator{border-color:Highlight;color:Highlight;}.rg1upok:enabled:checked~.fui-Radio__indicator::after{background-color:Highlight;}}", "@media (forced-colors: active){.rg1upok:disabled~.fui-Radio__label{color:GrayText;}}", "@media (forced-colors: active){.rg1upok:disabled~.fui-Radio__indicator{border-color:GrayText;color:GrayText;}.rg1upok:disabled~.fui-Radio__indicator::after{background-color:GrayText;}}", "@media (forced-colors: active){.rzwdzb4:enabled:not(:checked)~.fui-Radio__indicator{border-color:ButtonBorder;}}", "@media (forced-colors: active){.rzwdzb4:enabled:checked~.fui-Radio__indicator{border-color:Highlight;color:Highlight;}.rzwdzb4:enabled:checked~.fui-Radio__indicator::after{background-color:Highlight;}}", "@media (forced-colors: active){.rzwdzb4:disabled~.fui-Radio__label{color:GrayText;}}", "@media (forced-colors: active){.rzwdzb4:disabled~.fui-Radio__indicator{border-color:GrayText;color:GrayText;}.rzwdzb4:disabled~.fui-Radio__indicator::after{background-color:GrayText;}}"]
});
var useInputStyles3 = __styles2({
  below: {
    a9b677: "fly5x3f",
    Bqenvij: "f1je6zif"
  },
  defaultIndicator: {
    Blbys7f: "f9ma1gx"
  },
  customIndicator: {
    Bj53wkj: "f12zxao0"
  }
}, {
  d: [".fly5x3f{width:100%;}", ".f1je6zif{height:calc(16px + 2 * var(--spacingVerticalS));}", '.f9ma1gx:checked~.fui-Radio__indicator::after{content:"";}', ".f12zxao0:not(:checked)~.fui-Radio__indicator>*{opacity:0;}"]
});
var useIndicatorBaseClassName2 = __resetStyles("rwtekvw", null, [".rwtekvw{position:relative;width:16px;height:16px;font-size:12px;box-sizing:border-box;flex-shrink:0;display:flex;align-items:center;justify-content:center;overflow:hidden;border:var(--strokeWidthThin) solid;border-radius:var(--borderRadiusCircular);margin:var(--spacingVerticalS) var(--spacingHorizontalS);fill:currentColor;pointer-events:none;}", ".rwtekvw::after{position:absolute;width:16px;height:16px;border-radius:var(--borderRadiusCircular);transform:scale(0.625);background-color:currentColor;}"]);
var useLabelStyles3 = __styles2({
  base: {
    qb2dma: "f7nlbp4",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1f5q0n8"
  },
  after: {
    uwmqm3: ["fruq291", "f7x41pl"],
    B6of3ja: "fjzwpt6",
    jrapky: "fh6j2fo"
  },
  below: {
    z8tnut: "f1ywm7hm",
    fsow6f: "f17mccla"
  }
}, {
  d: [".f7nlbp4{align-self:center;}", [".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fjzwpt6{margin-top:calc((16px - var(--lineHeightBase300)) / 2);}", ".fh6j2fo{margin-bottom:calc((16px - var(--lineHeightBase300)) / 2);}", ".f1ywm7hm{padding-top:var(--spacingVerticalXS);}", ".f17mccla{text-align:center;}"]
});
var useRadioStyles_unstable = (state) => {
  "use no memo";
  const {
    labelPosition
  } = state;
  const rootBaseClassName = useRootBaseClassName3();
  const rootStyles = useRootStyles9();
  state.root.className = mergeClasses(radioClassNames.root, rootBaseClassName, labelPosition === "below" && rootStyles.vertical, state.root.className);
  const inputBaseClassName = useInputBaseClassName2();
  const inputStyles = useInputStyles3();
  state.input.className = mergeClasses(radioClassNames.input, inputBaseClassName, labelPosition === "below" && inputStyles.below, state.indicator.children ? inputStyles.customIndicator : inputStyles.defaultIndicator, state.input.className);
  const indicatorBaseClassName = useIndicatorBaseClassName2();
  state.indicator.className = mergeClasses(radioClassNames.indicator, indicatorBaseClassName, state.indicator.className);
  const labelStyles = useLabelStyles3();
  if (state.label) {
    state.label.className = mergeClasses(radioClassNames.label, labelStyles.base, labelStyles[labelPosition], state.label.className);
  }
  return state;
};

// node_modules/@fluentui/react-radio/lib/components/Radio/Radio.js
var Radio = React234.forwardRef((props, ref) => {
  const state = useRadio_unstable(props, ref);
  useRadioStyles_unstable(state);
  useCustomStyleHook("useRadioStyles_unstable")(state);
  return renderRadio_unstable(state);
});
Radio.displayName = "Radio";

// node_modules/@fluentui/react-select/lib/components/Select/Select.js
var React236 = __toESM(require_react());

// node_modules/@fluentui/react-select/lib/components/Select/useSelect.js
var React235 = __toESM(require_react());
var useSelect_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true,
    supportsSize: true
  });
  const overrides = useOverrides();
  var _overrides_inputDefaultAppearance;
  const { defaultValue, value, select, icon, root, appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", onChange, size: size3 = "medium" } = props;
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "select",
    excludedPropNames: [
      "appearance",
      "defaultValue",
      "onChange",
      "size",
      "value"
    ]
  });
  const state = {
    size: size3,
    appearance,
    components: {
      root: "span",
      select: "select",
      icon: "span"
    },
    select: slot_exports.always(select, {
      defaultProps: {
        defaultValue,
        value,
        ref,
        ...nativeProps.primary
      },
      elementType: "select"
    }),
    icon: slot_exports.optional(icon, {
      renderByDefault: true,
      defaultProps: {
        children: React235.createElement(ChevronDownRegular, null)
      },
      elementType: "span"
    }),
    root: slot_exports.always(root, {
      defaultProps: nativeProps.root,
      elementType: "span"
    })
  };
  state.select.onChange = useEventCallback((event) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(event, {
      value: event.target.value
    });
  });
  return state;
};

// node_modules/@fluentui/react-select/lib/components/Select/renderSelect.js
var renderSelect_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.select, {
        children: state.select.children
      }),
      state.icon && jsx(state.icon, {})
    ]
  });
};

// node_modules/@fluentui/react-select/lib/components/Select/useSelectStyles.styles.js
var selectClassNames = {
  root: "fui-Select",
  select: "fui-Select__select",
  icon: "fui-Select__icon"
};
var iconSizes2 = {
  small: "16px",
  medium: "20px",
  large: "24px"
};
var paddingRight = {
  small: `calc(${tokens.spacingHorizontalSNudge}
    + ${iconSizes2.small}
    + ${tokens.spacingHorizontalXXS}
    + ${tokens.spacingHorizontalXXS})`,
  medium: `calc(${tokens.spacingHorizontalMNudge}
    + ${iconSizes2.medium}
    + ${tokens.spacingHorizontalXXS}
    + ${tokens.spacingHorizontalXXS})`,
  large: `calc(${tokens.spacingHorizontalM}
    + ${iconSizes2.large}
    + ${tokens.spacingHorizontalSNudge}
    + ${tokens.spacingHorizontalSNudge})`
};
var paddingLeft = {
  small: `calc(${tokens.spacingHorizontalSNudge} + ${tokens.spacingHorizontalXXS})`,
  medium: `calc(${tokens.spacingHorizontalMNudge} + ${tokens.spacingHorizontalXXS})`,
  large: `calc(${tokens.spacingHorizontalM} + ${tokens.spacingHorizontalSNudge})`
};
var useRootStyles10 = __styles2({
  base: {
    Bt984gj: "f122n59",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "f22iagw",
    Eh141a: "flvyvdh",
    Bahqtrf: "fk6fouc",
    qhf8xq: "f10pi13n",
    h62rwi: "f7ll8cq",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "fe5s0lv",
    li1rpt: "f1gw3sf2",
    Bsft5z2: "f13zj6fq",
    Dlnsje: "fhwjr99",
    E3zdtr: "f1mdlcz9",
    By385i5: "fo72kxq",
    Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
    B1piin3: ["f15yvnhg", "f1n6gb5g"],
    b1kco5: "f1yk9hq",
    Ba2ppi3: "fhwpy7i",
    F2fol1: "f14ee0xe",
    lck23g: "f1xhbsuh",
    df92cz: "fv8e3ye",
    I188md: "ftb5wc6",
    umuwi5: "fjw5xc1",
    Blcqepd: "f1xdyd5c",
    nplu4u: "fatpbeo",
    Bioka5o: "fb7uyps",
    H713fs: "f1cmft4k",
    B9ooomg: "f1x58t8o"
  }
}, {
  d: [".f122n59{align-items:center;}", ".f1ewtqcl{box-sizing:border-box;}", ".f22iagw{display:flex;}", ".flvyvdh{flex-wrap:nowrap;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f10pi13n{position:relative;}", ".f7ll8cq::after{background-image:linear-gradient(\n        0deg,\n        var(--colorCompoundBrandStroke) 0%,\n        var(--colorCompoundBrandStroke) 50%,\n        transparent 50%,\n        transparent 100%\n      );}", [".fe5s0lv::after{border-radius:0 0 var(--borderRadiusMedium) var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1gw3sf2::after{box-sizing:border-box;}", '.f13zj6fq::after{content:"";}', ".fhwjr99::after{height:var(--borderRadiusMedium);}", ".f1mdlcz9::after{position:absolute;}", ".fo72kxq::after{bottom:0;}", ".f1n6gb5g::after{left:0;}", ".f15yvnhg::after{right:0;}", ".f1yk9hq::after{transform:scaleX(0);}", ".fhwpy7i::after{transition-property:transform;}", ".f14ee0xe::after{transition-duration:var(--durationUltraFast);}", ".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.fv8e3ye::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.ftb5wc6::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1cmft4k:focus-within::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1x58t8o:focus-within::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }]],
  w: [".fjw5xc1:focus-within::after{transform:scaleX(1);}", ".f1xdyd5c:focus-within::after{transition-property:transform;}", ".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}", ".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}"]
});
var useSelectStyles = __styles2({
  base: {
    Bowrso0: "fqrijq1",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "faev5xe",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    E5pizo: "f1couhl3",
    B7ck84d: "f1ewtqcl",
    sj55zd: "f19n0e5",
    Bceei9c: "f1k6fduh",
    Bh6795r: "fqerorx",
    B2u0y6b: "f6dzj5z",
    Byoj8tv: "f1qch9an",
    z8tnut: "f1g0x7ka",
    B3aqqti: "fatbyko",
    Brovlpu: "f1grzc83",
    Bxa1mx5: "f19shzzi"
  },
  disabled: {
    De3pzq: "f1c21dwh",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr",
    Bjwas2f: "fg455y9",
    Bn1d65q: ["f1rvyvqg", "f14g86mu"],
    Bxeuatn: "f1cwzwz",
    n51gp8: ["f14g86mu", "f1rvyvqg"]
  },
  disabledUnderline: {
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fziff3p", "f1mxt3zg"]
  },
  small: {
    Bqenvij: "frvgh55",
    uwmqm3: ["f1xile11", "fqznh8f"],
    z189sj: ["fiqd4sw", "f11fkzut"],
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  medium: {
    Bqenvij: "f1d2rq10",
    uwmqm3: ["f1e60jzv", "f135dnwl"],
    z189sj: ["f154vowv", "flqamny"],
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  large: {
    Bqenvij: "fbhnoac",
    uwmqm3: ["fnphzt9", "flt1dlf"],
    z189sj: ["f1xi5ia2", "f1xi1l47"],
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k"
  },
  outline: {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: "f1c1zstj",
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fm9niy"
  },
  outlineInteractive: {
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "flmw63s",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    B6oc9vd: "fvs00aa",
    ak43y8: ["f1assf6x", "f4ruux4"],
    wmxk5l: "fqhmt4z",
    B50zh58: ["f4ruux4", "f1assf6x"]
  },
  underline: {
    De3pzq: "f1c21dwh",
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "fd91s9p",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779",
    C8i20h: "fb77jct"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r"
  },
  "filled-darker": {
    De3pzq: "f16xq7d1"
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  },
  invalidUnderline: {
    hhx65j: "f1fgmyf4"
  }
}, {
  d: [".fqrijq1{-webkit-appearance:none;-moz-appearance:none;appearance:none;}", [".faev5xe{border:1px solid transparent;}", {
    p: -2
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1couhl3{box-shadow:none;}", ".f1ewtqcl{box-sizing:border-box;}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1k6fduh{cursor:pointer;}", ".fqerorx{flex-grow:1;}", ".f6dzj5z{max-width:100%;}", ".f1qch9an{padding-bottom:0;}", ".f1g0x7ka{padding-top:0;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".fgig46g{border-top-color:var(--colorTransparentStrokeDisabled);}", ".f1mxt3zg{border-right-color:var(--colorTransparentStrokeDisabled);}", ".fziff3p{border-left-color:var(--colorTransparentStrokeDisabled);}", ".frvgh55{height:24px;}", ".f1xile11{padding-left:calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", ".fqznh8f{padding-right:calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", ".fiqd4sw{padding-right:calc(var(--spacingHorizontalSNudge)\n    + 16px\n    + var(--spacingHorizontalXXS)\n    + var(--spacingHorizontalXXS));}", ".f11fkzut{padding-left:calc(var(--spacingHorizontalSNudge)\n    + 16px\n    + var(--spacingHorizontalXXS)\n    + var(--spacingHorizontalXXS));}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1d2rq10{height:32px;}", ".f1e60jzv{padding-left:calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", ".f135dnwl{padding-right:calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", ".f154vowv{padding-right:calc(var(--spacingHorizontalMNudge)\n    + 20px\n    + var(--spacingHorizontalXXS)\n    + var(--spacingHorizontalXXS));}", ".flqamny{padding-left:calc(var(--spacingHorizontalMNudge)\n    + 20px\n    + var(--spacingHorizontalXXS)\n    + var(--spacingHorizontalXXS));}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fbhnoac{height:40px;}", ".fnphzt9{padding-left:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", ".flt1dlf{padding-right:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", ".f1xi5ia2{padding-right:calc(var(--spacingHorizontalM)\n    + 24px\n    + var(--spacingHorizontalSNudge)\n    + var(--spacingHorizontalSNudge));}", ".f1xi1l47{padding-left:calc(var(--spacingHorizontalM)\n    + 24px\n    + var(--spacingHorizontalSNudge)\n    + var(--spacingHorizontalSNudge));}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".fm9niy{border:1px solid var(--colorNeutralStroke1);}", {
    p: -2
  }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", [".fd91s9p{border-bottom:1px solid var(--colorNeutralStrokeAccessible);}", {
    p: -1
  }], [".fokr779{border-radius:0;}", {
    p: -1
  }], ".fb77jct option{background-color:var(--colorNeutralBackground1);}", ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}"],
  f: [".fatbyko:focus{outline-width:2px;}", ".f1grzc83:focus{outline-style:solid;}", ".f19shzzi:focus{outline-color:transparent;}"],
  m: [["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".flmw63s:hover{border-bottom-color:var(--colorNeutralStrokeAccessible);}"],
  a: [".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".fqhmt4z:active{border-bottom-color:var(--colorNeutralStrokeAccessible);}"]
});
var useIconStyles6 = __styles2({
  icon: {
    B7ck84d: "f1ewtqcl",
    sj55zd: "fxkbij4",
    mc9l5x: "ftgm304",
    qhf8xq: "f1euv43f",
    Bkecrkj: "f1aehjj5",
    Bo70h7d: "fvc9v3g"
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    Bbusuzp: "f1dcs8yz"
  },
  small: {
    Be2twd7: "f4ybsrx",
    Bqenvij: "fd461yt",
    j35jbq: ["f13lnp83", "f1i5nn0v"],
    a9b677: "fjw5fx7"
  },
  medium: {
    Be2twd7: "fe5j1ua",
    Bqenvij: "fjamq6b",
    j35jbq: ["fnyteob", "f1enpzzf"],
    a9b677: "f64fuq3"
  },
  large: {
    Be2twd7: "f1rt2boy",
    Bqenvij: "frvgh55",
    j35jbq: ["f8b87gs", "fedtrts"],
    a9b677: "fq4mcun"
  }
}, {
  d: [".f1ewtqcl{box-sizing:border-box;}", ".fxkbij4{color:var(--colorNeutralStrokeAccessible);}", ".ftgm304{display:block;}", ".f1euv43f{position:absolute;}", ".f1aehjj5{pointer-events:none;}", ".fvc9v3g svg{display:block;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f4ybsrx{font-size:16px;}", ".fd461yt{height:16px;}", ".f13lnp83{right:var(--spacingHorizontalSNudge);}", ".f1i5nn0v{left:var(--spacingHorizontalSNudge);}", ".fjw5fx7{width:16px;}", ".fe5j1ua{font-size:20px;}", ".fjamq6b{height:20px;}", ".fnyteob{right:var(--spacingHorizontalMNudge);}", ".f1enpzzf{left:var(--spacingHorizontalMNudge);}", ".f64fuq3{width:20px;}", ".f1rt2boy{font-size:24px;}", ".frvgh55{height:24px;}", ".f8b87gs{right:var(--spacingHorizontalM);}", ".fedtrts{left:var(--spacingHorizontalM);}", ".fq4mcun{width:24px;}"],
  m: [["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useSelectStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3,
    appearance
  } = state;
  const disabled = state.select.disabled;
  const invalid = `${state.select["aria-invalid"]}` === "true";
  const iconStyles = useIconStyles6();
  const rootStyles = useRootStyles10();
  const selectStyles = useSelectStyles();
  state.root.className = mergeClasses(selectClassNames.root, rootStyles.base, state.root.className);
  state.select.className = mergeClasses(selectClassNames.select, selectStyles.base, selectStyles[size3], selectStyles[appearance], !disabled && appearance === "outline" && selectStyles.outlineInteractive, !disabled && invalid && appearance !== "underline" && selectStyles.invalid, !disabled && invalid && appearance === "underline" && selectStyles.invalidUnderline, disabled && selectStyles.disabled, disabled && appearance === "underline" && selectStyles.disabledUnderline, state.select.className);
  if (state.icon) {
    state.icon.className = mergeClasses(selectClassNames.icon, iconStyles.icon, disabled && iconStyles.disabled, iconStyles[size3], state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-select/lib/components/Select/Select.js
var Select2 = React236.forwardRef((props, ref) => {
  const state = useSelect_unstable(props, ref);
  useSelectStyles_unstable(state);
  useCustomStyleHook("useSelectStyles_unstable")(state);
  return renderSelect_unstable(state);
});
Select2.displayName = "Select";

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/Skeleton.js
var React240 = __toESM(require_react());

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/useSkeleton.js
var React238 = __toESM(require_react());

// node_modules/@fluentui/react-skeleton/lib/contexts/SkeletonContext.js
var React237 = __toESM(require_react());
var SkeletonContext = React237.createContext(void 0);
var skeletonContextDefaultValue = {};
var SkeletonContextProvider = SkeletonContext.Provider;
var useSkeletonContext = () => {
  var _React_useContext;
  return (_React_useContext = React237.useContext(SkeletonContext)) !== null && _React_useContext !== void 0 ? _React_useContext : skeletonContextDefaultValue;
};

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/useSkeleton.js
var useSkeleton_unstable = (props, ref) => {
  const { animation: contextAnimation, appearance: contextAppearance } = useSkeletonContext();
  const { animation = contextAnimation !== null && contextAnimation !== void 0 ? contextAnimation : "wave", appearance = contextAppearance !== null && contextAppearance !== void 0 ? contextAppearance : "opaque" } = props;
  const root = slot_exports.always(getIntrinsicElementProps("div", {
    // FIXME:
    // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
    // but since it would be a breaking change to fix it, we are casting ref to it's proper type
    ref,
    role: "progressbar",
    "aria-busy": true,
    ...props
  }), {
    elementType: "div"
  });
  return {
    animation,
    appearance,
    components: {
      root: "div"
    },
    root
  };
};

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/renderSkeleton.js
var renderSkeleton_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(SkeletonContextProvider, {
    value: contextValues.skeletonGroup,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/useSkeletonStyles.styles.js
var skeletonClassNames = {
  root: "fui-Skeleton"
};
var useStyles29 = __styles2({
  blockStyling: {
    mc9l5x: "ftgm304"
  }
}, {
  d: [".ftgm304{display:block;}"]
});
var useSkeletonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles29();
  state.root.className = mergeClasses(skeletonClassNames.root, state.root.as === "span" && styles.blockStyling, state.root.className);
  return state;
};

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/useSkeletonContextValues.js
var React239 = __toESM(require_react());
var useSkeletonContextValues = (state) => {
  const { animation, appearance } = state;
  const skeletonGroup = React239.useMemo(() => ({
    animation,
    appearance
  }), [
    animation,
    appearance
  ]);
  return {
    skeletonGroup
  };
};

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/Skeleton.js
var Skeleton = React240.forwardRef((props, ref) => {
  const state = useSkeleton_unstable(props, ref);
  const contextValues = useSkeletonContextValues(state);
  useSkeletonStyles_unstable(state);
  useCustomStyleHook("useSkeletonStyles_unstable")(state);
  return renderSkeleton_unstable(state, contextValues);
});
Skeleton.displayName = "Skeleton";

// node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/SkeletonItem.js
var React242 = __toESM(require_react());

// node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/useSkeletonItem.js
var React241 = __toESM(require_react());
var useSkeletonItem_unstable = (props, ref) => {
  const { animation: contextAnimation, appearance: contextAppearance } = useSkeletonContext();
  const { animation = contextAnimation !== null && contextAnimation !== void 0 ? contextAnimation : "wave", appearance = contextAppearance !== null && contextAppearance !== void 0 ? contextAppearance : "opaque", size: size3 = 16, shape = "rectangle" } = props;
  const root = slot_exports.always(getIntrinsicElementProps("div", {
    // FIXME:
    // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
    // but since it would be a breaking change to fix it, we are casting ref to it's proper type
    ref,
    ...props
  }), {
    elementType: "div"
  });
  return {
    appearance,
    animation,
    size: size3,
    shape,
    components: {
      root: "div"
    },
    root
  };
};

// node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/renderSkeletonItem.js
var renderSkeletonItem_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/useSkeletonItemStyles.styles.js
var skeletonItemClassNames = {
  root: "fui-SkeletonItem"
};
var useStyles30 = __styles2({
  root: {
    qhf8xq: "f10pi13n",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    Bsft5z2: "f13zj6fq",
    ap17g6: "f2gz7yw",
    E3zdtr: "f1mdlcz9",
    By385i5: 0,
    Eqx8gd: 0,
    B1piin3: 0,
    bn5sak: 0,
    B58onuk: "f1nt53hs",
    s9ouvv: "f18xs7ez",
    xr36ep: "ffm3629",
    Bitv4sc: "f1f9zsvm",
    Jx5sug: "f1ub80pn",
    Hzyzrh: "f1e7twep"
  },
  wave: {
    De3pzq: "f1gjxg63",
    Br128sd: ["f3fo419", "f6m9r4"],
    h62rwi: ["ftnv2js", "f12jzhyt"],
    b1kco5: ["fig1c6l", "f1rv5y9h"],
    oi31me: "f103n15n"
  },
  pulse: {
    Br128sd: "f171zwvm",
    xr36ep: "fs3pcyf",
    Bjyk6c5: "f1yu5riq"
  },
  translucent: {
    De3pzq: "f162mh4z",
    h62rwi: ["flvf4r0", "f1uek97b"]
  },
  translucentPulse: {
    De3pzq: "flu3bqm",
    Bjyk6c5: "fxucc0w"
  },
  blockStyling: {
    mc9l5x: "ftgm304"
  }
}, {
  d: [".f10pi13n{position:relative;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], '.f13zj6fq::after{content:"";}', ".f2gz7yw::after{display:block;}", ".f1mdlcz9::after{position:absolute;}", [".f1nt53hs::after{inset:0;}", {
    p: -1
  }], ".f18xs7ez::after{animation-iteration-count:infinite;}", ".ffm3629::after{animation-duration:3s;}", ".f1f9zsvm::after{animation-timing-function:ease-in-out;}", ".f1gjxg63{background-color:var(--colorNeutralStencil1);}", ".f3fo419::after{animation-name:f1efwx7q;}", ".f6m9r4::after{animation-name:f1kkgpz1;}", ".ftnv2js::after{background-image:linear-gradient(\n        to right,\n        var(--colorNeutralStencil1) 0%,\n        var(--colorNeutralStencil2) 50%,\n        var(--colorNeutralStencil1) 100%);}", ".f12jzhyt::after{background-image:linear-gradient(\n        to left,\n        var(--colorNeutralStencil1) 0%,\n        var(--colorNeutralStencil2) 50%,\n        var(--colorNeutralStencil1) 100%);}", ".fig1c6l::after{transform:translate(-100%);}", ".f1rv5y9h::after{transform:translate(100%);}", ".f171zwvm::after{animation-name:f12o7gg6;}", ".fs3pcyf::after{animation-duration:1s;}", ".f1yu5riq::after{background-color:var(--colorNeutralStencil1);}", ".f162mh4z{background-color:var(--colorNeutralStencil1Alpha);}", ".flvf4r0::after{background-image:linear-gradient(\n      to right,\n      transparent 0%,\n      var(--colorNeutralStencil1Alpha) 50%,\n      transparent 100%);}", ".f1uek97b::after{background-image:linear-gradient(\n      to left,\n      transparent 0%,\n      var(--colorNeutralStencil1Alpha) 50%,\n      transparent 100%);}", ".flu3bqm{background-color:none;}", ".fxucc0w::after{background-color:var(--colorNeutralStencil1Alpha);}", ".ftgm304{display:block;}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.f1ub80pn::after{animation-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1e7twep::after{animation-iteration-count:1;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (forced-colors: active){.f103n15n::after{background-color:WindowText;}}", {
    m: "screen and (forced-colors: active)"
  }]],
  k: ["@keyframes f1efwx7q{to{transform:translate(100%);}}", "@keyframes f1kkgpz1{to{transform:translate(-100%);}}", "@keyframes f12o7gg6{0%{opacity:1;}50%{opacity:0.4;}100%{opacity:1;}}"]
});
var useRectangleStyles = __styles2({
  "8": {
    Bqenvij: "f1x82gua"
  },
  "12": {
    Bqenvij: "fvblgha"
  },
  "16": {
    Bqenvij: "fd461yt"
  },
  "20": {
    Bqenvij: "fjamq6b"
  },
  "24": {
    Bqenvij: "frvgh55"
  },
  "28": {
    Bqenvij: "fxldao9"
  },
  "32": {
    Bqenvij: "f1d2rq10"
  },
  "36": {
    Bqenvij: "f8ljn23"
  },
  "40": {
    Bqenvij: "fbhnoac"
  },
  "48": {
    Bqenvij: "ff2sm71"
  },
  "56": {
    Bqenvij: "fzki0ko"
  },
  "64": {
    Bqenvij: "f16k9i2m"
  },
  "72": {
    Bqenvij: "f1shusfg"
  },
  "96": {
    Bqenvij: "fypu0ge"
  },
  "120": {
    Bqenvij: "fjr5b71"
  },
  "128": {
    Bqenvij: "fele2au"
  },
  root: {
    a9b677: "fly5x3f",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ff3glw6"
  }
}, {
  d: [".f1x82gua{height:8px;}", ".fvblgha{height:12px;}", ".fd461yt{height:16px;}", ".fjamq6b{height:20px;}", ".frvgh55{height:24px;}", ".fxldao9{height:28px;}", ".f1d2rq10{height:32px;}", ".f8ljn23{height:36px;}", ".fbhnoac{height:40px;}", ".ff2sm71{height:48px;}", ".fzki0ko{height:56px;}", ".f16k9i2m{height:64px;}", ".f1shusfg{height:72px;}", ".fypu0ge{height:96px;}", ".fjr5b71{height:120px;}", ".fele2au{height:128px;}", ".fly5x3f{width:100%;}", [".ff3glw6{border-radius:4px;}", {
    p: -1
  }]]
});
var useSizeStyles2 = __styles2({
  "8": {
    a9b677: "f1o3cbw4",
    Bqenvij: "f1x82gua"
  },
  "12": {
    a9b677: "frx94fk",
    Bqenvij: "fvblgha"
  },
  "16": {
    a9b677: "fjw5fx7",
    Bqenvij: "fd461yt"
  },
  "20": {
    a9b677: "f64fuq3",
    Bqenvij: "fjamq6b"
  },
  "24": {
    a9b677: "fq4mcun",
    Bqenvij: "frvgh55"
  },
  "28": {
    a9b677: "f1w9dchk",
    Bqenvij: "fxldao9"
  },
  "32": {
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10"
  },
  "36": {
    a9b677: "fpdz1er",
    Bqenvij: "f8ljn23"
  },
  "40": {
    a9b677: "feqmc2u",
    Bqenvij: "fbhnoac"
  },
  "48": {
    a9b677: "f124akge",
    Bqenvij: "ff2sm71"
  },
  "56": {
    a9b677: "f1u66zr1",
    Bqenvij: "fzki0ko"
  },
  "64": {
    a9b677: "fa9ln6p",
    Bqenvij: "f16k9i2m"
  },
  "72": {
    a9b677: "fhcae8x",
    Bqenvij: "f1shusfg"
  },
  "96": {
    a9b677: "f1kyr2gn",
    Bqenvij: "fypu0ge"
  },
  "120": {
    a9b677: "fwfqyga",
    Bqenvij: "fjr5b71"
  },
  "128": {
    a9b677: "f1iksgmy",
    Bqenvij: "fele2au"
  }
}, {
  d: [".f1o3cbw4{width:8px;}", ".f1x82gua{height:8px;}", ".frx94fk{width:12px;}", ".fvblgha{height:12px;}", ".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}", ".fpdz1er{width:36px;}", ".f8ljn23{height:36px;}", ".feqmc2u{width:40px;}", ".fbhnoac{height:40px;}", ".f124akge{width:48px;}", ".ff2sm71{height:48px;}", ".f1u66zr1{width:56px;}", ".fzki0ko{height:56px;}", ".fa9ln6p{width:64px;}", ".f16k9i2m{height:64px;}", ".fhcae8x{width:72px;}", ".f1shusfg{height:72px;}", ".f1kyr2gn{width:96px;}", ".fypu0ge{height:96px;}", ".fwfqyga{width:120px;}", ".fjr5b71{height:120px;}", ".f1iksgmy{width:128px;}", ".fele2au{height:128px;}"]
});
var useCircleSizeStyles = __styles2({
  root: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f5q2cvs"
  }
}, {
  d: [[".f5q2cvs{border-radius:50%;}", {
    p: -1
  }]]
});
var useSkeletonItemStyles_unstable = (state) => {
  "use no memo";
  const {
    animation,
    appearance,
    size: size3,
    shape
  } = state;
  const rootStyles = useStyles30();
  const rectStyles = useRectangleStyles();
  const sizeStyles = useSizeStyles2();
  const circleStyles = useCircleSizeStyles();
  state.root.className = mergeClasses(skeletonItemClassNames.root, rootStyles.root, state.root.as === "span" && rootStyles.blockStyling, animation === "wave" && rootStyles.wave, animation === "pulse" && rootStyles.pulse, appearance === "translucent" && rootStyles.translucent, animation === "pulse" && appearance === "translucent" && rootStyles.translucentPulse, shape === "rectangle" && rectStyles.root, shape === "rectangle" && rectStyles[size3], shape === "square" && sizeStyles[size3], shape === "circle" && circleStyles.root, shape === "circle" && sizeStyles[size3], state.root.className);
  return state;
};

// node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/SkeletonItem.js
var SkeletonItem = React242.forwardRef((props, ref) => {
  const state = useSkeletonItem_unstable(props, ref);
  useSkeletonItemStyles_unstable(state);
  useCustomStyleHook("useSkeletonItemStyles_unstable")(state);
  return renderSkeletonItem_unstable(state);
});
SkeletonItem.displayName = "SkeletonItem";

// node_modules/@fluentui/react-slider/lib/components/Slider/Slider.js
var React245 = __toESM(require_react());

// node_modules/@fluentui/react-slider/lib/components/Slider/useSlider.js
var React244 = __toESM(require_react());

// node_modules/@fluentui/react-slider/lib/components/Slider/useSliderState.js
var React243 = __toESM(require_react());

// node_modules/@fluentui/react-slider/lib/components/Slider/useSliderStyles.styles.js
var sliderClassNames = {
  root: "fui-Slider",
  rail: "fui-Slider__rail",
  thumb: "fui-Slider__thumb",
  input: "fui-Slider__input"
};
var sliderCSSVars = {
  sliderDirectionVar: `--fui-Slider--direction`,
  sliderInnerThumbRadiusVar: `--fui-Slider__inner-thumb--radius`,
  sliderProgressVar: `--fui-Slider--progress`,
  sliderProgressColorVar: `--fui-Slider__progress--color`,
  sliderRailSizeVar: `--fui-Slider__rail--size`,
  sliderRailColorVar: `--fui-Slider__rail--color`,
  sliderStepsPercentVar: `--fui-Slider--steps-percent`,
  sliderThumbColorVar: `--fui-Slider__thumb--color`,
  sliderThumbSizeVar: `--fui-Slider__thumb--size`
};
var {
  sliderDirectionVar,
  sliderInnerThumbRadiusVar,
  sliderProgressVar,
  sliderProgressColorVar,
  sliderRailSizeVar,
  sliderRailColorVar,
  sliderStepsPercentVar,
  sliderThumbColorVar,
  sliderThumbSizeVar
} = sliderCSSVars;
var useRootStyles11 = __styles2({
  root: {
    qhf8xq: "f10pi13n",
    mc9l5x: "fwk3njj",
    lpbzjs: "f1sdsnyy",
    Bt984gj: "f122n59",
    B7hvi0a: "f1oiokrs"
  },
  small: {
    Bi64ftq: "f1agqo6f",
    Bslxy2k: "f1mmvox9",
    Ba19x4e: "f1i7ztpd",
    sshi5w: "f1pha7fy"
  },
  medium: {
    Bi64ftq: "f1a78h9h",
    Bslxy2k: "fh1udnr",
    Ba19x4e: "fuok0yf",
    sshi5w: "f1nxs5xn"
  },
  horizontal: {
    Bf4jedk: "fyvtabn",
    wkccdc: "fgfd48t",
    Budl1dq: "f4t5rw1"
  },
  vertical: {
    sshi5w: "f1pzv1zu",
    wkccdc: "fktlcaf",
    Budl1dq: "fiadc6h"
  },
  enabled: {
    B7wi8oa: "f4l8x3l",
    B250r6j: "f671q34",
    Bpmy4es: "fvfzmw5",
    Buw9y6v: "faw1t00",
    Bq939m0: "fxdgx5",
    gjzr1t: "fii04fa",
    tg7hqu: "f36hzz8",
    ypdvl1: "f1volkfw",
    Bw5jdd4: "f1xddb6",
    Bdjie01: "fcdikl",
    Bvh9j6m: "fhpzgm6",
    Bvsvvpo: "f1q6pm3h"
  },
  disabled: {
    Bpmy4es: "foojseg",
    B7wi8oa: "f1lgdqhv",
    B250r6j: "f1veetlj",
    ypdvl1: "fu12m3e",
    Bw5jdd4: "fi9guym",
    Bdjie01: "fcdjl4u"
  },
  focusIndicatorHorizontal: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    Bssx7fj: "f1b1k54r",
    uh7if5: ["f4ne723", "fqqcjud"],
    clntm0: "fh7aioi",
    Dlk2r6: ["fqqcjud", "f4ne723"],
    Bm3wd5j: "f1k55ka9",
    Bbrhkcr: ["fgclinu", "f16pcs8n"],
    f1oku: "fycbxed",
    aywvf2: ["f16pcs8n", "fgclinu"],
    B2j2mmj: "ffht0p2",
    wigs8: "f1p0ul1q",
    pbfy6t: "f1c901ms",
    B0v4ure: "f1alokd7",
    Byrf0fs: 0,
    Bsiemmq: 0,
    Bwckmig: 0,
    skfxo0: 0,
    Iidy0u: 0,
    B98u21t: 0,
    Bvwlmkc: 0,
    jo1ztg: 0,
    Ba1iezr: 0,
    Blmvk6g: 0,
    B24cy0v: 0,
    Bil7v7r: 0,
    Br3gin4: 0,
    nr063g: 0,
    ghq09: 0,
    Bbgo44z: 0,
    Bseh09z: "fmj8fco",
    az1dzo: 0,
    Ba3ybja: 0,
    B6352mv: 0,
    vppk2z: 0,
    Biaj6j7: "f1iwowo3",
    B2pnrqr: "f1pffoy2",
    B29w5g4: ["f1dfga45", "f63jj3o"],
    Bhhzhcn: "fs6b7xr",
    Bec0n69: ["f63jj3o", "f1dfga45"]
  },
  focusIndicatorVertical: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    Bssx7fj: "f1b1k54r",
    uh7if5: ["f4ne723", "fqqcjud"],
    clntm0: "fh7aioi",
    Dlk2r6: ["fqqcjud", "f4ne723"],
    Bm3wd5j: "f1k55ka9",
    Bbrhkcr: ["fgclinu", "f16pcs8n"],
    f1oku: "fycbxed",
    aywvf2: ["f16pcs8n", "fgclinu"],
    B2j2mmj: "ffht0p2",
    wigs8: "f1p0ul1q",
    pbfy6t: "f1c901ms",
    B0v4ure: "f1alokd7",
    Byrf0fs: 0,
    Bsiemmq: 0,
    Bwckmig: 0,
    skfxo0: 0,
    Iidy0u: 0,
    B98u21t: 0,
    Bvwlmkc: 0,
    jo1ztg: 0,
    Ba1iezr: 0,
    Blmvk6g: 0,
    B24cy0v: 0,
    Bil7v7r: 0,
    Br3gin4: 0,
    nr063g: 0,
    ghq09: 0,
    Bbgo44z: 0,
    Bseh09z: "fmj8fco",
    az1dzo: 0,
    Ba3ybja: 0,
    B6352mv: 0,
    vppk2z: 0,
    Biaj6j7: "f1iwowo3",
    B2pnrqr: "f1pffoy2",
    B29w5g4: ["fm5xmfm", "femsgmt"],
    Bhhzhcn: "fs6b7xr",
    Bec0n69: ["femsgmt", "fm5xmfm"]
  }
}, {
  d: [".f10pi13n{position:relative;}", ".fwk3njj{display:inline-grid;}", ".f1sdsnyy{touch-action:none;}", ".f122n59{align-items:center;}", ".f1oiokrs{justify-items:center;}", ".f1agqo6f{--fui-Slider__thumb--size:16px;}", ".f1mmvox9{--fui-Slider__inner-thumb--radius:5px;}", ".f1i7ztpd{--fui-Slider__rail--size:2px;}", ".f1pha7fy{min-height:24px;}", ".f1a78h9h{--fui-Slider__thumb--size:20px;}", ".fh1udnr{--fui-Slider__inner-thumb--radius:6px;}", ".fuok0yf{--fui-Slider__rail--size:4px;}", ".f1nxs5xn{min-height:32px;}", ".fyvtabn{min-width:120px;}", ".fgfd48t{grid-template-rows:1fr var(--fui-Slider__thumb--size) 1fr;}", ".f4t5rw1{grid-template-columns:1fr calc(100% - var(--fui-Slider__thumb--size)) 1fr;}", ".f1pzv1zu{min-height:120px;}", ".fktlcaf{grid-template-rows:1fr calc(100% - var(--fui-Slider__thumb--size)) 1fr;}", ".fiadc6h{grid-template-columns:1fr var(--fui-Slider__thumb--size) 1fr;}", ".f4l8x3l{--fui-Slider__rail--color:var(--colorNeutralStrokeAccessible);}", ".f671q34{--fui-Slider__progress--color:var(--colorCompoundBrandBackground);}", ".fvfzmw5{--fui-Slider__thumb--color:var(--colorCompoundBrandBackground);}", ".foojseg{--fui-Slider__thumb--color:var(--colorNeutralForegroundDisabled);}", ".f1lgdqhv{--fui-Slider__rail--color:var(--colorNeutralBackgroundDisabled);}", ".f1veetlj{--fui-Slider__progress--color:var(--colorNeutralForegroundDisabled);}", ".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}", ".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}", ".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}", ".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}", '.ffht0p2[data-fui-focus-within]:focus-within::after{content:"";}', ".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}", ".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}", ".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}", [".fmj8fco[data-fui-focus-within]:focus-within::after{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1iwowo3[data-fui-focus-within]:focus-within::after{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1pffoy2[data-fui-focus-within]:focus-within::after{top:calc(0px - 2px - -2px);}", ".f1dfga45[data-fui-focus-within]:focus-within::after{right:calc(0px - 2px - -4px);}", ".f63jj3o[data-fui-focus-within]:focus-within::after{left:calc(0px - 2px - -4px);}", ".fs6b7xr[data-fui-focus-within]:focus-within::after{bottom:calc(0px - 2px - -2px);}", [".fmj8fco[data-fui-focus-within]:focus-within::after{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1iwowo3[data-fui-focus-within]:focus-within::after{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fm5xmfm[data-fui-focus-within]:focus-within::after{right:calc(0px - 2px - 4px);}", ".femsgmt[data-fui-focus-within]:focus-within::after{left:calc(0px - 2px - 4px);}"],
  h: [".faw1t00:hover{--fui-Slider__thumb--color:var(--colorCompoundBrandBackgroundHover);}", ".fxdgx5:hover{--fui-Slider__progress--color:var(--colorCompoundBrandBackgroundHover);}"],
  a: [".fii04fa:active{--fui-Slider__thumb--color:var(--colorCompoundBrandBackgroundPressed);}", ".f36hzz8:active{--fui-Slider__progress--color:var(--colorCompoundBrandBackgroundPressed);}"],
  m: [["@media (forced-colors: active){.f1volkfw{--fui-Slider__rail--color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1xddb6{--fui-Slider__thumb--color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fcdikl{--fui-Slider__progress--color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fhpzgm6:hover{--fui-Slider__thumb--color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1q6pm3h:hover{--fui-Slider__progress--color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fu12m3e{--fui-Slider__rail--color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fi9guym{--fui-Slider__thumb--color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fcdjl4u{--fui-Slider__progress--color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1k55ka9[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f16pcs8n[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}.fgclinu[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fycbxed[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"]
});
var useRailStyles = __styles2({
  rail: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1kijzfu",
    Bkecrkj: "f1aehjj5",
    Ijaq50: "faunodf",
    nk6f5a: "f88nxoq",
    Br312pm: "fd46tj4",
    Bw0ie65: "f1e2fz10",
    qhf8xq: "f10pi13n",
    Bvjb7m6: "fdgv6k0",
    Bcmaq0h: "fizngqt",
    Bpd4iqm: "fpvhumw",
    oeaueh: "f1yog68k",
    Bw0xxkn: "f13sgyd8",
    Ftih45: "fzhtfnv",
    Brfgrao: "f1j7ml58",
    Bbn5juq: "fx36ao7",
    Brdvuy1: "fux3rle"
  },
  horizontal: {
    a9b677: "fly5x3f",
    Bqenvij: "f1cy86ho",
    Fbdkly: ["f1heqfse", "fkh49vu"],
    mdwyqc: ["fkh49vu", "f1heqfse"],
    Baz25je: "f16tdq4e"
  },
  vertical: {
    a9b677: "fqxfnkd",
    Bqenvij: "f1l02sjl",
    Ccq8qp: "f1rik0od",
    Bciustq: "f14xwovp",
    lawp4y: "fdehrcx"
  }
}, {
  d: [[".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", {
    p: -1
  }], ".f1aehjj5{pointer-events:none;}", ".faunodf{grid-row-start:2;}", ".f88nxoq{grid-row-end:2;}", ".fd46tj4{grid-column-start:2;}", ".f1e2fz10{grid-column-end:2;}", ".f10pi13n{position:relative;}", ".fdgv6k0{forced-color-adjust:none;}", ".fizngqt{background-image:linear-gradient(\n      var(--fui-Slider--direction),\n      var(--fui-Slider__progress--color) 0%,\n      var(--fui-Slider__progress--color) var(--fui-Slider--progress),\n      var(--fui-Slider__rail--color) var(--fui-Slider--progress)\n    );}", ".fpvhumw{outline-width:1px;}", ".f1yog68k{outline-style:solid;}", ".f13sgyd8{outline-color:var(--colorTransparentStroke);}", ".fzhtfnv::before{content:'';}", ".f1j7ml58::before{position:absolute;}", ".fx36ao7::before{background-image:repeating-linear-gradient(\n        var(--fui-Slider--direction),\n        #0000 0%,\n        #0000 calc(var(--fui-Slider--steps-percent) - 1px),\n        var(--colorNeutralBackground1) calc(var(--fui-Slider--steps-percent) - 1px),\n        var(--colorNeutralBackground1) var(--fui-Slider--steps-percent)\n      );}", ".fly5x3f{width:100%;}", ".f1cy86ho{height:var(--fui-Slider__rail--size);}", ".f1heqfse::before{left:-1px;}", ".fkh49vu::before{right:-1px;}", ".f16tdq4e::before{height:var(--fui-Slider__rail--size);}", ".fqxfnkd{width:var(--fui-Slider__rail--size);}", ".f1l02sjl{height:100%;}", ".f1rik0od::before{width:var(--fui-Slider__rail--size);}", ".f14xwovp::before{top:-1px;}", ".fdehrcx::before{bottom:-1px;}"],
  m: [["@media (forced-colors: active){.fux3rle::before{background-image:repeating-linear-gradient(\n          var(--fui-Slider--direction),\n          #0000 0%,\n          #0000 calc(var(--fui-Slider--steps-percent) - 1px),\n          HighlightText calc(var(--fui-Slider--steps-percent) - 1px),\n          HighlightText var(--fui-Slider--steps-percent)\n        );}}", {
    m: "(forced-colors: active)"
  }]]
});
var useThumbStyles = __styles2({
  thumb: {
    B2lzsem: "ftx3jue",
    Ijaq50: "faunodf",
    nk6f5a: "f88nxoq",
    Br312pm: "fd46tj4",
    Bw0ie65: "f1e2fz10",
    qhf8xq: "f1euv43f",
    a9b677: "f174ca62",
    Bqenvij: "f1yfdkfd",
    Bkecrkj: "f1aehjj5",
    oeaueh: "f1s6fcnf",
    Bvjb7m6: "fdgv6k0",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    E5pizo: "fof7hq0",
    De3pzq: "foksa45",
    Brfgrao: "f1j7ml58",
    Bciustq: "f14u7mkt",
    Fbdkly: ["f5zrw40", "f1ks5ppg"],
    lawp4y: "fto0uou",
    mdwyqc: ["f1ks5ppg", "f5zrw40"],
    r59vdv: 0,
    Budzafs: 0,
    ck0cow: 0,
    n07z76: 0,
    Gng75u: "fielpny",
    Bcvre1j: "fyl8oag",
    Ftih45: "fzhtfnv",
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f1fsco4d"
  },
  disabled: {
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f1pv9hn4"
  },
  horizontal: {
    Bz10aip: ["f13gfj74", "f1nfknbn"],
    oyh7mz: ["foa2ioz", "fjmilum"]
  },
  vertical: {
    Bz10aip: "f5cv5a3",
    B5kzvoi: "f1k2fpdo"
  }
}, {
  d: [".ftx3jue{--fui-Slider__thumb--position:clamp(var(--fui-Slider__inner-thumb--radius), var(--fui-Slider--progress), calc(100% - var(--fui-Slider__inner-thumb--radius)));}", ".faunodf{grid-row-start:2;}", ".f88nxoq{grid-row-end:2;}", ".fd46tj4{grid-column-start:2;}", ".f1e2fz10{grid-column-end:2;}", ".f1euv43f{position:absolute;}", ".f174ca62{width:var(--fui-Slider__thumb--size);}", ".f1yfdkfd{height:var(--fui-Slider__thumb--size);}", ".f1aehjj5{pointer-events:none;}", ".f1s6fcnf{outline-style:none;}", ".fdgv6k0{forced-color-adjust:none;}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".fof7hq0{box-shadow:0 0 0 calc(var(--fui-Slider__thumb--size) * .2) var(--colorNeutralBackground1) inset;}", ".foksa45{background-color:var(--fui-Slider__thumb--color);}", ".f1j7ml58::before{position:absolute;}", ".f14u7mkt::before{top:0px;}", ".f5zrw40::before{left:0px;}", ".f1ks5ppg::before{right:0px;}", ".fto0uou::before{bottom:0px;}", [".fielpny::before{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".fyl8oag::before{box-sizing:border-box;}", ".fzhtfnv::before{content:'';}", [".f1fsco4d::before{border:calc(var(--fui-Slider__thumb--size) * .05) solid var(--colorNeutralStroke1);}", {
    p: -2
  }], [".f1pv9hn4::before{border:calc(var(--fui-Slider__thumb--size) * .05) solid var(--colorNeutralForegroundDisabled);}", {
    p: -2
  }], ".f13gfj74{transform:translateX(-50%);}", ".f1nfknbn{transform:translateX(50%);}", ".foa2ioz{left:var(--fui-Slider__thumb--position);}", ".fjmilum{right:var(--fui-Slider__thumb--position);}", ".f5cv5a3{transform:translateY(50%);}", ".f1k2fpdo{bottom:var(--fui-Slider__thumb--position);}"]
});
var useInputStyles4 = __styles2({
  input: {
    Bceei9c: "f1k6fduh",
    abs64n: "fk73vx1",
    Ijaq50: "f16hsg94",
    nk6f5a: "f1nzqi2z",
    Br312pm: "fwpfdsa",
    Bw0ie65: "fuur7zz",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao"
  },
  disabled: {
    Bceei9c: "f158kwzp"
  },
  horizontal: {
    Bqenvij: "f1yfdkfd",
    a9b677: "fly5x3f"
  },
  vertical: {
    Bqenvij: "f1l02sjl",
    a9b677: "f174ca62",
    fsx8h0: "f1mm7lwf",
    B0wtrmc: ["fdkxjay", "f6bzpni"],
    B5laz1p: "f1ry0dy"
  }
}, {
  d: [".f1k6fduh{cursor:pointer;}", ".fk73vx1{opacity:0;}", ".f16hsg94{grid-row-start:1;}", ".f1nzqi2z{grid-row-end:-1;}", ".fwpfdsa{grid-column-start:1;}", ".fuur7zz{grid-column-end:-1;}", [".f1mk8lai{padding:0;}", {
    p: -1
  }], [".f1s184ao{margin:0;}", {
    p: -1
  }], ".f158kwzp{cursor:default;}", ".f1yfdkfd{height:var(--fui-Slider__thumb--size);}", ".fly5x3f{width:100%;}", ".f1l02sjl{height:100%;}", ".f174ca62{width:var(--fui-Slider__thumb--size);}"],
  t: ["@supports (writing-mode: sideways-lr){.f1mm7lwf{writing-mode:vertical-lr;}}", "@supports (writing-mode: sideways-lr){.f6bzpni{direction:ltr;}.fdkxjay{direction:rtl;}}", "@supports not (writing-mode: sideways-lr){.f1ry0dy{-webkit-appearance:slider-vertical;}}"]
});
var useSliderStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles11();
  const railStyles = useRailStyles();
  const thumbStyles = useThumbStyles();
  const inputStyles = useInputStyles4();
  const isVertical = state.vertical;
  state.root.className = mergeClasses(sliderClassNames.root, rootStyles.root, isVertical ? rootStyles.focusIndicatorVertical : rootStyles.focusIndicatorHorizontal, rootStyles[state.size], isVertical ? rootStyles.vertical : rootStyles.horizontal, state.disabled ? rootStyles.disabled : rootStyles.enabled, state.root.className);
  state.rail.className = mergeClasses(sliderClassNames.rail, railStyles.rail, isVertical ? railStyles.vertical : railStyles.horizontal, state.rail.className);
  state.thumb.className = mergeClasses(sliderClassNames.thumb, thumbStyles.thumb, isVertical ? thumbStyles.vertical : thumbStyles.horizontal, state.disabled && thumbStyles.disabled, state.thumb.className);
  state.input.className = mergeClasses(sliderClassNames.input, inputStyles.input, isVertical ? inputStyles.vertical : inputStyles.horizontal, state.disabled && inputStyles.disabled, state.input.className);
  return state;
};

// node_modules/@fluentui/react-slider/lib/components/Slider/useSliderState.js
var { sliderStepsPercentVar: sliderStepsPercentVar2, sliderProgressVar: sliderProgressVar2, sliderDirectionVar: sliderDirectionVar2 } = sliderCSSVars;
var getPercent = (value, min2, max2) => {
  return max2 === min2 ? 0 : (value - min2) / (max2 - min2) * 100;
};
var useSliderState_unstable = (state, props) => {
  "use no memo";
  const { min: min2 = 0, max: max2 = 100, step } = props;
  const { dir } = useFluent();
  const [currentValue, setCurrentValue] = useControllableState({
    state: props.value,
    defaultState: props.defaultValue,
    initialState: 0
  });
  const clampedValue = clamp(currentValue, min2, max2);
  const valuePercent = getPercent(clampedValue, min2, max2);
  const inputOnChange = state.input.onChange;
  const propsOnChange = props.onChange;
  const onChange = useEventCallback((ev) => {
    const newValue = Number(ev.target.value);
    setCurrentValue(clamp(newValue, min2, max2));
    if (inputOnChange && inputOnChange !== propsOnChange) {
      inputOnChange(ev);
    } else if (propsOnChange) {
      propsOnChange(ev, {
        value: newValue
      });
    }
  });
  const stepPercent = step && step > 0 ? `${step * 100 / (max2 - min2)}%` : void 0;
  const rootVariables = {
    [sliderDirectionVar2]: state.vertical ? "0deg" : dir === "ltr" ? "90deg" : "270deg",
    [sliderProgressVar2]: `${valuePercent}%`,
    // Set the sliderStepsPercentVar only if defined - fixes SSR errors in React 18
    ...stepPercent !== void 0 && {
      [sliderStepsPercentVar2]: stepPercent
    }
  };
  state.root.style = {
    ...rootVariables,
    ...state.root.style
  };
  state.input.value = clampedValue;
  state.input.onChange = onChange;
  return state;
};

// node_modules/@fluentui/react-slider/lib/components/Slider/useSlider.js
var useSlider_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true
  });
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "onChange",
      "size"
    ]
  });
  const {
    disabled,
    vertical,
    size: size3 = "medium",
    // Slots
    root,
    input,
    rail,
    thumb
  } = props;
  const state = {
    disabled,
    size: size3,
    vertical,
    components: {
      input: "input",
      rail: "div",
      root: "div",
      thumb: "div"
    },
    root: slot_exports.always(root, {
      defaultProps: nativeProps.root,
      elementType: "div"
    }),
    input: slot_exports.always(input, {
      defaultProps: {
        id: useId2("slider-", props.id),
        ref,
        ...nativeProps.primary,
        type: "range",
        orient: vertical ? "vertical" : void 0
      },
      elementType: "input"
    }),
    rail: slot_exports.always(rail, {
      elementType: "div"
    }),
    thumb: slot_exports.always(thumb, {
      elementType: "div"
    })
  };
  state.root.ref = useMergedRefs(state.root.ref, useFocusWithin());
  useSliderState_unstable(state, props);
  return state;
};

// node_modules/@fluentui/react-slider/lib/components/Slider/renderSlider.js
var renderSlider_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      jsx(state.rail, {}),
      jsx(state.thumb, {})
    ]
  });
};

// node_modules/@fluentui/react-slider/lib/components/Slider/Slider.js
var Slider = React245.forwardRef((props, ref) => {
  const state = useSlider_unstable(props, ref);
  useSliderStyles_unstable(state);
  useCustomStyleHook("useSliderStyles_unstable")(state);
  return renderSlider_unstable(state);
});
Slider.displayName = "Slider";

// node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/SpinButton.js
var React247 = __toESM(require_react());

// node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/useSpinButton.js
var React246 = __toESM(require_react());

// node_modules/@fluentui/react-spinbutton/lib/utils/clamp.js
var clamp3 = (value, min2, max2) => {
  let nextValue = value;
  if (min2 !== void 0) {
    if (max2 !== void 0 && min2 > max2) {
      const error = new Error();
      if (true) {
        console.error([
          `"min" value "${min2}" is greater than "max" value "${max2}".`,
          '"min" must be less than or equal to "max".',
          `Returning value "${value}".`,
          error.stack
        ].join());
      }
      return value;
    }
    nextValue = Math.max(min2, nextValue);
  }
  if (max2 !== void 0) {
    nextValue = Math.min(max2, nextValue);
  }
  return nextValue;
};

// node_modules/@fluentui/react-spinbutton/lib/utils/getBound.js
var getBound = (value, min2, max2) => {
  if (min2 !== void 0 && value === min2) {
    if (max2 === min2) {
      return "both";
    }
    return "min";
  } else if (max2 !== void 0 && value === max2) {
    return "max";
  }
  return "none";
};

// node_modules/@fluentui/react-spinbutton/lib/utils/precision.js
function calculatePrecision(value) {
  const groups = /[1-9]([0]+$)|\.([0-9]*)/.exec(String(value));
  if (!groups) {
    return 0;
  }
  if (groups[1]) {
    return -groups[1].length;
  }
  if (groups[2]) {
    return groups[2].length;
  }
  return 0;
}
function precisionRound(value, precision, base = 10) {
  const exp = Math.pow(base, precision);
  return Math.round(value * exp) / exp;
}

// node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/useSpinButton.js
var DEFAULT_SPIN_DELAY_MS = 150;
var MIN_SPIN_DELAY_MS = 80;
var MAX_SPIN_TIME_MS = 1e3;
var lerp = (start, end, percent) => start + (end - start) * percent;
var useSpinButton_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true
  });
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "defaultValue",
      "max",
      "min",
      "onChange",
      "size",
      "value"
    ]
  });
  const overrides = useOverrides();
  var _overrides_inputDefaultAppearance;
  const { value, displayValue, defaultValue, min: min2, max: max2, step = 1, stepPage = 1, precision: precisionFromProps, onChange, size: size3 = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", root, input, incrementButton, decrementButton } = props;
  const precision = React246.useMemo(() => {
    return precisionFromProps !== null && precisionFromProps !== void 0 ? precisionFromProps : Math.max(calculatePrecision(step), 0);
  }, [
    precisionFromProps,
    step
  ]);
  const [currentValue, setCurrentValue] = useControllableState({
    state: value,
    defaultState: defaultValue,
    initialState: 0
  });
  const inputRef = React246.useRef(null);
  const isControlled = value !== void 0;
  const [textValue, setTextValue] = React246.useState(void 0);
  const [keyboardSpinState, setKeyboardSpinState] = React246.useState("rest");
  const internalState = React246.useRef({
    value: currentValue,
    spinState: "rest",
    spinTime: 0,
    spinDelay: DEFAULT_SPIN_DELAY_MS,
    atBound: currentValue !== null ? getBound(precisionRound(currentValue, precision), min2, max2) : "none"
  });
  const [setStepTimeout, clearStepTimeout] = useTimeout();
  const stepValue = (e, direction, startFrom) => {
    let startValue = internalState.current.value;
    if (startFrom) {
      const num = parseFloat(startFrom);
      if (!isNaN(num)) {
        startValue = num;
      }
    }
    const val = startValue;
    const dir = direction === "up" || direction === "upPage" ? 1 : -1;
    const stepSize = direction === "upPage" || direction === "downPage" ? stepPage : step;
    if (val === null) {
      const stepStart = min2 === void 0 ? 0 : min2;
      const nullStep = clamp3(stepStart + stepSize * dir, min2, max2);
      commit(e, nullStep);
      return;
    }
    let newValue = val + stepSize * dir;
    if (!Number.isNaN(newValue)) {
      newValue = clamp3(newValue, min2, max2);
    }
    commit(e, newValue);
    if (internalState.current.spinState !== "rest") {
      setStepTimeout(() => {
        internalState.current.spinTime += internalState.current.spinDelay;
        internalState.current.spinDelay = lerp(DEFAULT_SPIN_DELAY_MS, MIN_SPIN_DELAY_MS, internalState.current.spinTime / MAX_SPIN_TIME_MS);
        stepValue(e, direction);
      }, internalState.current.spinDelay);
    }
  };
  const handleInputChange = (e) => {
    if (!internalState.current.previousTextValue) {
      internalState.current.previousTextValue = textValue !== null && textValue !== void 0 ? textValue : String(currentValue);
    }
    const newValue = e.target.value;
    setTextValue(newValue);
    if (inputRef.current) {
      inputRef.current.ariaValueNow = newValue;
    }
  };
  const handleIncrementMouseDown = (e) => {
    commit(e, currentValue, textValue);
    internalState.current.spinState = "up";
    stepValue(e, "up");
  };
  const handleDecrementMouseDown = (e) => {
    commit(e, currentValue, textValue);
    internalState.current.spinState = "down";
    stepValue(e, "down");
  };
  const handleStepMouseUpOrLeave = (e) => {
    clearStepTimeout();
    internalState.current.spinState = "rest";
    internalState.current.spinDelay = DEFAULT_SPIN_DELAY_MS;
    internalState.current.spinTime = 0;
  };
  const handleBlur = (e) => {
    commit(e, currentValue, textValue);
    internalState.current.previousTextValue = void 0;
  };
  const handleKeyDown = (e) => {
    let nextKeyboardSpinState = "rest";
    if (e.key === ArrowUp) {
      stepValue(e, "up", textValue);
      nextKeyboardSpinState = "up";
    } else if (e.key === ArrowDown) {
      stepValue(e, "down", textValue);
      nextKeyboardSpinState = "down";
    } else if (e.key === PageUp) {
      e.preventDefault();
      stepValue(e, "upPage", textValue);
      nextKeyboardSpinState = "up";
    } else if (e.key === PageDown) {
      e.preventDefault();
      stepValue(e, "downPage", textValue);
      nextKeyboardSpinState = "down";
    } else if (!e.shiftKey && e.key === Home && min2 !== void 0) {
      commit(e, min2);
      nextKeyboardSpinState = "down";
    } else if (!e.shiftKey && e.key === End && max2 !== void 0) {
      commit(e, max2);
      nextKeyboardSpinState = "up";
    } else if (e.key === Enter) {
      commit(e, currentValue, textValue);
      internalState.current.previousTextValue = void 0;
    } else if (e.key === Escape) {
      if (internalState.current.previousTextValue) {
        setTextValue(void 0);
        internalState.current.previousTextValue = void 0;
      }
    }
    if (keyboardSpinState !== nextKeyboardSpinState) {
      setKeyboardSpinState(nextKeyboardSpinState);
    }
  };
  const handleKeyUp = (e) => {
    if (keyboardSpinState !== "rest") {
      setKeyboardSpinState("rest");
      internalState.current.spinState = "rest";
    }
  };
  const commit = (e, newValue, newDisplayValue) => {
    const valueChanged = newValue !== void 0 && currentValue !== newValue;
    const displayValueChanged = newDisplayValue !== void 0 && internalState.current.previousTextValue !== void 0 && internalState.current.previousTextValue !== newDisplayValue;
    let roundedValue;
    if (valueChanged) {
      roundedValue = precisionRound(newValue, precision);
      setCurrentValue(roundedValue);
      internalState.current.value = roundedValue;
    } else if (displayValueChanged && !isControlled) {
      const nextValue = parseFloat(newDisplayValue);
      if (!isNaN(nextValue)) {
        setCurrentValue(precisionRound(nextValue, precision));
        internalState.current.value = precisionRound(nextValue, precision);
      }
    }
    if (valueChanged || displayValueChanged) {
      onChange === null || onChange === void 0 ? void 0 : onChange(e, {
        value: roundedValue,
        displayValue: newDisplayValue
      });
    }
    setTextValue(void 0);
  };
  let valueToDisplay;
  if (textValue !== void 0) {
    valueToDisplay = textValue;
  } else if (value === null || currentValue === null) {
    valueToDisplay = displayValue !== null && displayValue !== void 0 ? displayValue : "";
    internalState.current.value = null;
    internalState.current.atBound = "none";
  } else {
    const roundedValue = precisionRound(currentValue, precision);
    internalState.current.value = roundedValue;
    internalState.current.atBound = getBound(roundedValue, min2, max2);
    if (isControlled) {
      valueToDisplay = displayValue !== null && displayValue !== void 0 ? displayValue : String(roundedValue);
    } else {
      valueToDisplay = String(roundedValue);
    }
  }
  const state = {
    size: size3,
    appearance,
    spinState: keyboardSpinState,
    atBound: internalState.current.atBound,
    components: {
      root: "span",
      input: "input",
      incrementButton: "button",
      decrementButton: "button"
    },
    root: slot_exports.always(root, {
      defaultProps: nativeProps.root,
      elementType: "span"
    }),
    input: slot_exports.always(input, {
      defaultProps: {
        autoComplete: "off",
        role: "spinbutton",
        appearance,
        type: "text",
        ...nativeProps.primary
      },
      elementType: "input"
    }),
    incrementButton: slot_exports.always(incrementButton, {
      defaultProps: {
        tabIndex: -1,
        children: React246.createElement(ChevronUp16Regular, null),
        disabled: nativeProps.primary.disabled || internalState.current.atBound === "max" || internalState.current.atBound === "both",
        "aria-label": "Increment value",
        type: "button"
      },
      elementType: "button"
    }),
    decrementButton: slot_exports.always(decrementButton, {
      defaultProps: {
        tabIndex: -1,
        children: React246.createElement(ChevronDown16Regular, null),
        disabled: nativeProps.primary.disabled || internalState.current.atBound === "min" || internalState.current.atBound === "both",
        "aria-label": "Decrement value",
        type: "button"
      },
      elementType: "button"
    })
  };
  state.input.value = valueToDisplay;
  state.input.ref = useMergedRefs(inputRef, ref);
  state.input["aria-valuemin"] = min2;
  state.input["aria-valuemax"] = max2;
  var _internalState_current_value;
  state.input["aria-valuenow"] = (_internalState_current_value = internalState.current.value) !== null && _internalState_current_value !== void 0 ? _internalState_current_value : void 0;
  var _state_input_ariavaluetext;
  state.input["aria-valuetext"] = (_state_input_ariavaluetext = state.input["aria-valuetext"]) !== null && _state_input_ariavaluetext !== void 0 ? _state_input_ariavaluetext : value !== void 0 && displayValue || void 0;
  state.input.onChange = mergeCallbacks(state.input.onChange, handleInputChange);
  state.input.onInput = mergeCallbacks(state.input.onInput, handleInputChange);
  state.input.onBlur = mergeCallbacks(state.input.onBlur, handleBlur);
  state.input.onKeyDown = mergeCallbacks(state.input.onKeyDown, handleKeyDown);
  state.input.onKeyUp = mergeCallbacks(state.input.onKeyUp, handleKeyUp);
  state.incrementButton.onMouseDown = mergeCallbacks(handleIncrementMouseDown, state.incrementButton.onMouseDown);
  state.incrementButton.onMouseUp = mergeCallbacks(state.incrementButton.onMouseUp, handleStepMouseUpOrLeave);
  state.incrementButton.onMouseLeave = mergeCallbacks(state.incrementButton.onMouseLeave, handleStepMouseUpOrLeave);
  state.decrementButton.onMouseDown = mergeCallbacks(handleDecrementMouseDown, state.decrementButton.onMouseDown);
  state.decrementButton.onMouseUp = mergeCallbacks(state.decrementButton.onMouseUp, handleStepMouseUpOrLeave);
  state.decrementButton.onMouseLeave = mergeCallbacks(state.decrementButton.onMouseLeave, handleStepMouseUpOrLeave);
  return state;
};

// node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/renderSpinButton.js
var renderSpinButton_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      jsx(state.incrementButton, {}),
      jsx(state.decrementButton, {})
    ]
  });
};

// node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/useSpinButtonStyles.styles.js
var spinButtonClassNames = {
  root: "fui-SpinButton",
  input: "fui-SpinButton__input",
  incrementButton: "fui-SpinButton__incrementButton",
  decrementButton: "fui-SpinButton__decrementButton"
};
var spinButtonExtraClassNames = {
  buttonActive: "fui-SpinButton__button_active"
};
var useRootClassName6 = __resetStyles("r109xulx", "r1h2jnch", {
  r: [".r109xulx{display:inline-grid;grid-template-columns:1fr 24px;grid-template-rows:1fr 1fr;column-gap:var(--spacingHorizontalXS);row-gap:0;position:relative;isolation:isolate;vertical-align:middle;background-color:var(--colorNeutralBackground1);min-height:32px;padding:0 0 0 var(--spacingHorizontalMNudge);border-radius:var(--borderRadiusMedium);}", '.r109xulx::before{content:"";box-sizing:border-box;position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;z-index:10;border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);border-radius:var(--borderRadiusMedium);}', '.r109xulx::after{box-sizing:border-box;content:"";position:absolute;right:0;bottom:0;left:0;z-index:20;height:max(2px, var(--borderRadiusMedium));border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".r109xulx:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".r109xulx:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".r109xulx:focus-within{outline:2px solid transparent;}", ".r1h2jnch{display:inline-grid;grid-template-columns:1fr 24px;grid-template-rows:1fr 1fr;column-gap:var(--spacingHorizontalXS);row-gap:0;position:relative;isolation:isolate;vertical-align:middle;background-color:var(--colorNeutralBackground1);min-height:32px;padding:0 var(--spacingHorizontalMNudge) 0 0;border-radius:var(--borderRadiusMedium);}", '.r1h2jnch::before{content:"";box-sizing:border-box;position:absolute;top:0;left:0;bottom:0;right:0;pointer-events:none;z-index:10;border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);border-radius:var(--borderRadiusMedium);}', '.r1h2jnch::after{box-sizing:border-box;content:"";position:absolute;left:0;bottom:0;right:0;z-index:20;height:max(2px, var(--borderRadiusMedium));border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".r1h2jnch:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".r1h2jnch:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".r1h2jnch:focus-within{outline:2px solid transparent;}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.r109xulx::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r109xulx:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1h2jnch::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1h2jnch:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}"]
});
var useRootStyles12 = __styles2({
  small: {
    sshi5w: "f1pha7fy",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    uwmqm3: ["f1f5gg8d", "f1vdfbxk"]
  },
  medium: {},
  outline: {},
  outlineInteractive: {
    Bo3r8zu: "f1w2y1rc",
    Hpvxnh: ["f1gofhvl", "f18htlvq"],
    Bx11ytk: "ffcnd28",
    B1rg0w0: ["f18htlvq", "f1gofhvl"],
    Bsg1tlv: "f6lmxco",
    Brjw370: ["fcoc0mf", "f15r4wkl"],
    xcfy85: "f1ipdth8",
    Bcc6kan: ["f15r4wkl", "fcoc0mf"]
  },
  underline: {
    B0qfbqy: "f1o236ok",
    B4f6apu: ["faeg28l", "f64aojp"],
    y0oebl: "fdw6hkg",
    uvfttm: ["f64aojp", "faeg28l"],
    r59vdv: 0,
    Budzafs: 0,
    ck0cow: 0,
    n07z76: 0,
    Gng75u: "f1xyh2jw"
  },
  underlineInteractive: {
    Bx11ytk: "ffcnd28",
    xcfy85: "f1ipdth8",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "fkp7w9h"
  },
  filled: {
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f1kc0wz4"
  },
  "filled-darker": {
    De3pzq: "f16xq7d1"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r"
  },
  filledInteractive: {
    B05mzqr: "f1xqt08",
    tb9y6h: ["fzt5lgo", "f8tv3r9"],
    jcehpj: "fyhrops",
    B23o0hn: ["f8tv3r9", "fzt5lgo"]
  },
  invalid: {
    emecyz: "fl48pg9",
    lz0pba: ["f1a168p3", "f1pvdymy"],
    Bo1k74p: "f11knvgl",
    Ba322q7: ["f1pvdymy", "f1a168p3"]
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    Bq4z7u6: "f1a0lfh7",
    Bk5zm6e: ["f1p2ejm6", "fmzytvz"],
    Bqjgrrk: "fas2e61",
    Bm6vgfq: ["fmzytvz", "f1p2ejm6"],
    Cffpyd: "flb8es4",
    hxi8he: ["f1lclws", "frjp63v"],
    Bcuq369: "f1yv9wnt",
    Imo2if: ["frjp63v", "f1lclws"]
  }
}, {
  d: [".f1pha7fy{min-height:24px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1o236ok::before{border-top-width:0;}", ".faeg28l::before{border-right-width:0;}", ".f64aojp::before{border-left-width:0;}", ".fdw6hkg::before{border-bottom-width:1px;}", [".f1xyh2jw::before{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], [".fkp7w9h::after{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], [".f1kc0wz4::before{border:1px solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".fl48pg9:not(:focus-within)::before,.fl48pg9:hover:not(:focus-within)::before{border-top-color:var(--colorPaletteRedBorder2);}", ".f1a168p3:not(:focus-within)::before,.f1a168p3:hover:not(:focus-within)::before{border-right-color:var(--colorPaletteRedBorder2);}", ".f1pvdymy:not(:focus-within)::before,.f1pvdymy:hover:not(:focus-within)::before{border-left-color:var(--colorPaletteRedBorder2);}", ".f11knvgl:not(:focus-within)::before,.f11knvgl:hover:not(:focus-within)::before{border-bottom-color:var(--colorPaletteRedBorder2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1a0lfh7::before{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1p2ejm6::before{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fmzytvz::before{border-left-color:var(--colorNeutralStrokeDisabled);}", ".fas2e61::before{border-bottom-color:var(--colorNeutralStrokeDisabled);}"],
  h: [".f1w2y1rc:hover::before{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1gofhvl:hover::before{border-right-color:var(--colorNeutralStroke1Hover);}", ".f18htlvq:hover::before{border-left-color:var(--colorNeutralStroke1Hover);}", ".ffcnd28:hover::before{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}", ".f1xqt08:hover::before,.f1xqt08:focus-within::before{border-top-color:var(--colorTransparentStrokeInteractive);}", ".fzt5lgo:hover::before,.fzt5lgo:focus-within::before{border-right-color:var(--colorTransparentStrokeInteractive);}", ".f8tv3r9:hover::before,.f8tv3r9:focus-within::before{border-left-color:var(--colorTransparentStrokeInteractive);}", ".fyhrops:hover::before,.fyhrops:focus-within::before{border-bottom-color:var(--colorTransparentStrokeInteractive);}"],
  a: [".f6lmxco:active::before,.f6lmxco:focus-within::before{border-top-color:var(--colorNeutralStroke1Pressed);}", ".fcoc0mf:active::before,.fcoc0mf:focus-within::before{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f15r4wkl:active::before,.f15r4wkl:focus-within::before{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1ipdth8:active::before,.f1ipdth8:focus-within::before{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
  m: [["@media (forced-colors: active){.flb8es4::before{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1lclws::before{border-right-color:GrayText;}.frjp63v::before{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1yv9wnt::before{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useInputClassName2 = __resetStyles("r1ljrqje", null, [".r1ljrqje{grid-column-start:1;grid-column-end:2;grid-row-start:1;grid-row-end:3;outline-style:none;border:0;padding:0;color:var(--colorNeutralForeground1);background-color:transparent;font-family:inherit;font-size:inherit;font-weight:inherit;line-height:inherit;width:100%;}", ".r1ljrqje::-webkit-input-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r1ljrqje::-moz-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r1ljrqje::placeholder{color:var(--colorNeutralForeground4);opacity:1;}"]);
var useInputStyles5 = __styles2({
  disabled: {
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    yvdlaj: "fahhnxm"
  }
}, {
  d: [".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"]
});
var useBaseButtonClassName = __resetStyles("r1g4chgs", null, [".r1g4chgs{display:inline-flex;width:24px;align-items:center;justify-content:center;border:0;position:absolute;outline-style:none;height:16px;background-color:transparent;color:var(--colorNeutralForeground3);grid-column-start:2;border-radius:0;padding:0 5px 0 5px;}", ".r1g4chgs:active{outline-style:none;}", ".r1g4chgs:enabled:hover{cursor:pointer;color:var(--colorNeutralForeground3Hover);background-color:var(--colorSubtleBackgroundHover);}", ".r1g4chgs:enabled:active{color:var(--colorNeutralForeground3Pressed);background-color:var(--colorSubtleBackgroundPressed);}", ".r1g4chgs:enabled.fui-SpinButton__button_active{color:var(--colorNeutralForeground3Pressed);background-color:var(--colorSubtleBackgroundPressed);}", ".r1g4chgs:disabled{cursor:not-allowed;color:var(--colorNeutralForegroundDisabled);}"]);
var useButtonStyles = __styles2({
  increment: {
    Ijaq50: "f16hsg94",
    B7oj6ja: ["f1jar5jt", "fyu767a"],
    z8tnut: "f10ra9hq",
    Byoj8tv: "f1brlhvm"
  },
  decrement: {
    Ijaq50: "faunodf",
    Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
    z8tnut: "f1sl3k7w",
    Byoj8tv: "f1y2xyjm"
  },
  incrementButtonSmall: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f4lv8q1", "fm3uwd2"],
    Bqenvij: "fvblgha"
  },
  decrementButtonSmall: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1q86st8", "frkrfqj"],
    Bqenvij: "fvblgha"
  },
  outline: {},
  underline: {
    De3pzq: "f3rmtva",
    sj55zd: "f11d4kpn",
    r4wkhp: "f1no7wuu",
    B95qlz1: "f1bifk9c",
    p743kt: "fp1zg4s",
    B7xitij: "fo6hitd",
    B6siaa6: "f1wiab75",
    Ba9qmo4: "fj9zm5z",
    Dyrjrp: "f1cqwcg4"
  },
  "filled-darker": {
    De3pzq: "f3rmtva",
    sj55zd: "f11d4kpn",
    r4wkhp: "f1no7wuu",
    B95qlz1: "fwwxidx",
    p743kt: "fp1zg4s",
    B7xitij: "f14i52sd",
    B6siaa6: "f1wiab75",
    Ba9qmo4: "fwry2ka",
    Dyrjrp: "f1cqwcg4"
  },
  "filled-lighter": {
    De3pzq: "f3rmtva",
    sj55zd: "f11d4kpn",
    r4wkhp: "f1no7wuu",
    B95qlz1: "f1yywxnv",
    drw0cw: "fzaa11h",
    idzz8t: "f4fpmm9",
    Dyrjrp: "f1cqwcg4"
  }
}, {
  d: [".f16hsg94{grid-row-start:1;}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".f10ra9hq{padding-top:4px;}", ".f1brlhvm{padding-bottom:1px;}", ".faunodf{grid-row-start:2;}", ".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1sl3k7w{padding-top:1px;}", ".f1y2xyjm{padding-bottom:4px;}", [".f4lv8q1{padding:3px 6px 0px 4px;}", {
    p: -1
  }], [".fm3uwd2{padding:3px 4px 0px 6px;}", {
    p: -1
  }], ".fvblgha{height:12px;}", [".f1q86st8{padding:0px 6px 3px 4px;}", {
    p: -1
  }], [".frkrfqj{padding:0px 4px 3px 6px;}", {
    p: -1
  }], ".f3rmtva{background-color:transparent;}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f1no7wuu:enabled:hover{color:var(--colorNeutralForeground3Hover);}", ".f1bifk9c:enabled:hover{background-color:var(--colorSubtleBackgroundHover);}", ".fp1zg4s:enabled:active{color:var(--colorNeutralForeground3Pressed);}", ".fo6hitd:enabled:active{background-color:var(--colorSubtleBackgroundPressed);}", ".f1wiab75:enabled.fui-SpinButton__button_active{color:var(--colorNeutralForeground3Pressed);}", ".fj9zm5z:enabled.fui-SpinButton__button_active{background-color:var(--colorSubtleBackgroundPressed);}", ".f1cqwcg4:disabled{color:var(--colorNeutralForegroundDisabled);}", ".fwwxidx:enabled:hover{background-color:var(--colorNeutralBackground3Hover);}", ".f14i52sd:enabled:active{background-color:var(--colorNeutralBackground3Pressed);}", ".fwry2ka:enabled.fui-SpinButton__button_active{background-color:var(--colorNeutralBackground3Pressed);}", ".f1yywxnv:enabled:hover{background-color:var(--colorNeutralBackground1Hover);}", ".fzaa11h:enabled:active,.fzaa11h:enabled.fui-SpinButton__button_active{color:var(--colorNeutralForeground3Pressed);}", ".f4fpmm9:enabled:active,.f4fpmm9:enabled.fui-SpinButton__button_active{background-color:var(--colorNeutralBackground1Pressed);}"]
});
var useSpinButtonStyles_unstable = (state) => {
  "use no memo";
  const {
    appearance,
    spinState,
    size: size3
  } = state;
  const disabled = state.input.disabled;
  const invalid = `${state.input["aria-invalid"]}` === "true";
  const filled = appearance.startsWith("filled");
  const rootStyles = useRootStyles12();
  const buttonStyles = useButtonStyles();
  const inputStyles = useInputStyles5();
  state.root.className = mergeClasses(spinButtonClassNames.root, useRootClassName6(), rootStyles[size3], rootStyles[appearance], filled && rootStyles.filled, !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && appearance === "underline" && rootStyles.underlineInteractive, !disabled && filled && rootStyles.filledInteractive, !disabled && invalid && rootStyles.invalid, disabled && rootStyles.disabled, state.root.className);
  state.incrementButton.className = mergeClasses(spinButtonClassNames.incrementButton, spinState === "up" && `${spinButtonExtraClassNames.buttonActive}`, useBaseButtonClassName(), buttonStyles.increment, buttonStyles[appearance], size3 === "small" && buttonStyles.incrementButtonSmall, state.incrementButton.className);
  state.decrementButton.className = mergeClasses(spinButtonClassNames.decrementButton, spinState === "down" && `${spinButtonExtraClassNames.buttonActive}`, useBaseButtonClassName(), buttonStyles.decrement, buttonStyles[appearance], size3 === "small" && buttonStyles.decrementButtonSmall, state.decrementButton.className);
  state.input.className = mergeClasses(spinButtonClassNames.input, useInputClassName2(), disabled && inputStyles.disabled, state.input.className);
  return state;
};

// node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/SpinButton.js
var SpinButton = React247.forwardRef((props, ref) => {
  const state = useSpinButton_unstable(props, ref);
  useSpinButtonStyles_unstable(state);
  useCustomStyleHook("useSpinButtonStyles_unstable")(state);
  return renderSpinButton_unstable(state);
});
SpinButton.displayName = "SpinButton";

// node_modules/@fluentui/react-spinner/lib/components/Spinner/Spinner.js
var React250 = __toESM(require_react());

// node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinner.js
var React249 = __toESM(require_react());

// node_modules/@fluentui/react-spinner/lib/contexts/SpinnerContext.js
var React248 = __toESM(require_react());
var SpinnerContext = React248.createContext(void 0);
var SpinnerContextDefaultValue = {};
var SpinnerContextProvider = SpinnerContext.Provider;
var useSpinnerContext = () => {
  var _React_useContext;
  return (_React_useContext = React248.useContext(SpinnerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : SpinnerContextDefaultValue;
};

// node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinner.js
var useSpinner_unstable = (props, ref) => {
  const { size: contextSize } = useSpinnerContext();
  const { appearance = "primary", labelPosition = "after", size: size3 = contextSize !== null && contextSize !== void 0 ? contextSize : "medium", delay = 0 } = props;
  const baseId = useId2("spinner");
  const { role = "progressbar", ...rest } = props;
  const nativeRoot = slot_exports.always(getIntrinsicElementProps("div", {
    // FIXME:
    // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
    // but since it would be a breaking change to fix it, we are casting ref to it's proper type
    ref,
    role,
    ...rest
  }, [
    "size"
  ]), {
    elementType: "div"
  });
  const [isShownAfterDelay, setIsShownAfterDelay] = React249.useState(false);
  const [setDelayTimeout, clearDelayTimeout] = useTimeout();
  React249.useEffect(() => {
    if (delay <= 0) {
      return;
    }
    setDelayTimeout(() => {
      setIsShownAfterDelay(true);
    }, delay);
    return () => {
      clearDelayTimeout();
    };
  }, [
    setDelayTimeout,
    clearDelayTimeout,
    delay
  ]);
  const labelShorthand = slot_exports.optional(props.label, {
    defaultProps: {
      id: baseId
    },
    renderByDefault: false,
    elementType: Label
  });
  const spinnerShortHand = slot_exports.optional(props.spinner, {
    renderByDefault: true,
    elementType: "span"
  });
  if (labelShorthand && nativeRoot && !nativeRoot["aria-labelledby"]) {
    nativeRoot["aria-labelledby"] = labelShorthand.id;
  }
  const state = {
    appearance,
    delay,
    labelPosition,
    size: size3,
    shouldRenderSpinner: !delay || isShownAfterDelay,
    components: {
      root: "div",
      spinner: "span",
      spinnerTail: "span",
      label: Label
    },
    root: nativeRoot,
    spinner: spinnerShortHand,
    spinnerTail: slot_exports.always(props.spinnerTail, {
      elementType: "span"
    }),
    label: labelShorthand
  };
  return state;
};

// node_modules/@fluentui/react-spinner/lib/components/Spinner/renderSpinner.js
var renderSpinner_unstable = (state) => {
  assertSlots(state);
  const { labelPosition, shouldRenderSpinner } = state;
  return jsxs(state.root, {
    children: [
      state.label && shouldRenderSpinner && (labelPosition === "above" || labelPosition === "before") && jsx(state.label, {}),
      state.spinner && shouldRenderSpinner && jsx(state.spinner, {
        children: state.spinnerTail && jsx(state.spinnerTail, {})
      }),
      state.label && shouldRenderSpinner && (labelPosition === "below" || labelPosition === "after") && jsx(state.label, {})
    ]
  });
};

// node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinnerStyles.styles.js
var spinnerClassNames = {
  root: "fui-Spinner",
  spinner: "fui-Spinner__spinner",
  spinnerTail: "fui-Spinner__spinnerTail",
  label: "fui-Spinner__label"
};
var useRootBaseClassName4 = __resetStyles("rpp59a7", null, [".rpp59a7{display:flex;align-items:center;justify-content:center;line-height:0;gap:8px;overflow:hidden;min-width:min-content;}"]);
var useRootStyles13 = __styles2({
  vertical: {
    Beiy3e4: "f1vx9l62"
  }
}, {
  d: [".f1vx9l62{flex-direction:column;}"]
});
var useSpinnerBaseClassName = __resetStyles("rvgcg50", "r15nd2jo", {
  r: [".rvgcg50{position:relative;flex-shrink:0;-webkit-mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);background-color:var(--colorBrandStroke2Contrast);color:var(--colorBrandStroke1);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:linear;animation-name:rb7n1on;}", "@keyframes rb7n1on{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}", ".r15nd2jo{position:relative;flex-shrink:0;-webkit-mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);background-color:var(--colorBrandStroke2Contrast);color:var(--colorBrandStroke1);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:linear;animation-name:r1gx3jof;}", "@keyframes r1gx3jof{0%{transform:rotate(0deg);}100%{transform:rotate(-360deg);}}"],
  s: ["@media screen and (forced-colors: active){.rvgcg50{background-color:HighlightText;color:Highlight;forced-color-adjust:none;}}", "@media screen and (prefers-reduced-motion: reduce){.rvgcg50{animation-duration:1.8s;}}", "@media screen and (forced-colors: active){.r15nd2jo{background-color:HighlightText;color:Highlight;forced-color-adjust:none;}}", "@media screen and (prefers-reduced-motion: reduce){.r15nd2jo{animation-duration:1.8s;}}"]
});
var useSpinnerTailBaseClassName = __resetStyles("rxov3xa", "r1o544mv", {
  r: [".rxov3xa{position:absolute;display:block;width:100%;height:100%;-webkit-mask-image:conic-gradient(transparent 105deg, white 105deg);mask-image:conic-gradient(transparent 105deg, white 105deg);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:var(--curveEasyEase);animation-name:r15mim6k;}", '.rxov3xa::before,.rxov3xa::after{content:"";position:absolute;display:block;width:100%;height:100%;animation:inherit;background-image:conic-gradient(currentcolor 135deg, transparent 135deg);}', "@keyframes r15mim6k{0%{transform:rotate(-135deg);}50%{transform:rotate(0deg);}100%{transform:rotate(225deg);}}", ".rxov3xa::before{animation-name:r18vhmn8;}", "@keyframes r18vhmn8{0%{transform:rotate(0deg);}50%{transform:rotate(105deg);}100%{transform:rotate(0deg);}}", ".rxov3xa::after{animation-name:rkgrvoi;}", "@keyframes rkgrvoi{0%{transform:rotate(0deg);}50%{transform:rotate(225deg);}100%{transform:rotate(0deg);}}", ".r1o544mv{position:absolute;display:block;width:100%;height:100%;-webkit-mask-image:conic-gradient(transparent 105deg, white 105deg);mask-image:conic-gradient(transparent 105deg, white 105deg);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:var(--curveEasyEase);animation-name:r109gmi5;}", '.r1o544mv::before,.r1o544mv::after{content:"";position:absolute;display:block;width:100%;height:100%;animation:inherit;background-image:conic-gradient(currentcolor 135deg, transparent 135deg);}', "@keyframes r109gmi5{0%{transform:rotate(135deg);}50%{transform:rotate(0deg);}100%{transform:rotate(-225deg);}}", ".r1o544mv::before{animation-name:r17whflh;}", "@keyframes r17whflh{0%{transform:rotate(0deg);}50%{transform:rotate(-105deg);}100%{transform:rotate(0deg);}}", ".r1o544mv::after{animation-name:re4odhl;}", "@keyframes re4odhl{0%{transform:rotate(0deg);}50%{transform:rotate(-225deg);}100%{transform:rotate(0deg);}}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.rxov3xa{animation-iteration-count:0;background-image:conic-gradient(transparent 120deg, currentcolor 360deg);}.rxov3xa::before,.rxov3xa::after{content:none;}}", "@media screen and (prefers-reduced-motion: reduce){.r1o544mv{animation-iteration-count:0;background-image:conic-gradient(transparent 120deg, currentcolor 360deg);}.r1o544mv::before,.r1o544mv::after{content:none;}}"]
});
var useSpinnerStyles = __styles2({
  inverted: {
    De3pzq: "fr407j0",
    sj55zd: "f1f7voed"
  },
  rtlTail: {
    btxmck: "f179dep3",
    gb5jj2: "fbz9ihp",
    Br2kee7: "f1wkkxo7"
  },
  "extra-tiny": {
    Bqenvij: "fd461yt",
    a9b677: "fjw5fx7",
    qmp6fs: "f1v3ph3m"
  },
  tiny: {
    Bqenvij: "fjamq6b",
    a9b677: "f64fuq3",
    qmp6fs: "f1v3ph3m"
  },
  "extra-small": {
    Bqenvij: "frvgh55",
    a9b677: "fq4mcun",
    qmp6fs: "f1v3ph3m"
  },
  small: {
    Bqenvij: "fxldao9",
    a9b677: "f1w9dchk",
    qmp6fs: "f1v3ph3m"
  },
  medium: {
    Bqenvij: "f1d2rq10",
    a9b677: "f1szoe96",
    qmp6fs: "fb52u90"
  },
  large: {
    Bqenvij: "f8ljn23",
    a9b677: "fpdz1er",
    qmp6fs: "fb52u90"
  },
  "extra-large": {
    Bqenvij: "fbhnoac",
    a9b677: "feqmc2u",
    qmp6fs: "fb52u90"
  },
  huge: {
    Bqenvij: "f1ft4266",
    a9b677: "fksc0bp",
    qmp6fs: "fa3u9ii"
  }
}, {
  d: [".fr407j0{background-color:var(--colorNeutralStrokeAlpha2);}", ".f1f7voed{color:var(--colorNeutralStrokeOnBrand2);}", ".f179dep3{-webkit-mask-image:conic-gradient(white 255deg, transparent 255deg);mask-image:conic-gradient(white 255deg, transparent 255deg);}", ".fbz9ihp::before,.fbz9ihp::after{background-image:conic-gradient(transparent 225deg, currentcolor 225deg);}", ".fd461yt{height:16px;}", ".fjw5fx7{width:16px;}", ".f1v3ph3m{--fui-Spinner--strokeWidth:var(--strokeWidthThick);}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".frvgh55{height:24px;}", ".fq4mcun{width:24px;}", ".fxldao9{height:28px;}", ".f1w9dchk{width:28px;}", ".f1d2rq10{height:32px;}", ".f1szoe96{width:32px;}", ".fb52u90{--fui-Spinner--strokeWidth:var(--strokeWidthThicker);}", ".f8ljn23{height:36px;}", ".fpdz1er{width:36px;}", ".fbhnoac{height:40px;}", ".feqmc2u{width:40px;}", ".f1ft4266{height:44px;}", ".fksc0bp{width:44px;}", ".fa3u9ii{--fui-Spinner--strokeWidth:var(--strokeWidthThickest);}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.f1wkkxo7{background-image:conic-gradient(currentcolor 0deg, transparent 240deg);}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }]]
});
var useLabelStyles4 = __styles2({
  inverted: {
    sj55zd: "fonrgv7"
  },
  "extra-tiny": {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  tiny: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  "extra-small": {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  small: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  large: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  "extra-large": {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  huge: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f1pp30po",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f106mvju"
  }
}, {
  d: [".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f106mvju{line-height:var(--lineHeightBase500);}"]
});
var useSpinnerStyles_unstable = (state) => {
  "use no memo";
  const {
    labelPosition,
    size: size3,
    appearance
  } = state;
  const {
    dir
  } = useFluent();
  const rootBaseClassName = useRootBaseClassName4();
  const rootStyles = useRootStyles13();
  const spinnerBaseClassName = useSpinnerBaseClassName();
  const spinnerStyles = useSpinnerStyles();
  const spinnerTailBaseClassName = useSpinnerTailBaseClassName();
  const labelStyles = useLabelStyles4();
  state.root.className = mergeClasses(spinnerClassNames.root, rootBaseClassName, (labelPosition === "above" || labelPosition === "below") && rootStyles.vertical, state.root.className);
  if (state.spinner) {
    state.spinner.className = mergeClasses(spinnerClassNames.spinner, spinnerBaseClassName, spinnerStyles[size3], appearance === "inverted" && spinnerStyles.inverted, state.spinner.className);
  }
  if (state.spinnerTail) {
    state.spinnerTail.className = mergeClasses(spinnerClassNames.spinnerTail, spinnerTailBaseClassName, dir === "rtl" && spinnerStyles.rtlTail, state.spinnerTail.className);
  }
  if (state.label) {
    state.label.className = mergeClasses(spinnerClassNames.label, labelStyles[size3], appearance === "inverted" && labelStyles.inverted, state.label.className);
  }
  return state;
};

// node_modules/@fluentui/react-spinner/lib/components/Spinner/Spinner.js
var Spinner = React250.forwardRef((props, ref) => {
  const state = useSpinner_unstable(props, ref);
  useSpinnerStyles_unstable(state);
  useCustomStyleHook("useSpinnerStyles_unstable")(state);
  return renderSpinner_unstable(state);
});
Spinner.displayName = "Spinner";

// node_modules/@fluentui/react-switch/lib/components/Switch/Switch.js
var React252 = __toESM(require_react());

// node_modules/@fluentui/react-switch/lib/components/Switch/useSwitch.js
var React251 = __toESM(require_react());
var useSwitch_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true
  });
  const { checked, defaultChecked, disabled, labelPosition = "after", onChange, required } = props;
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "checked",
      "defaultChecked",
      "onChange"
    ]
  });
  const id = useId2("switch-", nativeProps.primary.id);
  const root = slot_exports.always(props.root, {
    defaultProps: {
      ref: useFocusWithin(),
      ...nativeProps.root
    },
    elementType: "div"
  });
  const indicator = slot_exports.always(props.indicator, {
    defaultProps: {
      "aria-hidden": true,
      children: React251.createElement(CircleFilled, null)
    },
    elementType: "div"
  });
  const input = slot_exports.always(props.input, {
    defaultProps: {
      checked,
      defaultChecked,
      id,
      ref,
      role: "switch",
      type: "checkbox",
      ...nativeProps.primary
    },
    elementType: "input"
  });
  input.onChange = mergeCallbacks(input.onChange, (ev) => onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
    checked: ev.currentTarget.checked
  }));
  const label = slot_exports.optional(props.label, {
    defaultProps: {
      disabled,
      htmlFor: id,
      required,
      size: "medium"
    },
    elementType: Label
  });
  return {
    labelPosition,
    components: {
      root: "div",
      indicator: "div",
      input: "input",
      label: Label
    },
    root,
    indicator,
    input,
    label
  };
};

// node_modules/@fluentui/react-switch/lib/components/Switch/renderSwitch.js
var renderSwitch_unstable = (state) => {
  assertSlots(state);
  const { labelPosition } = state;
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      labelPosition !== "after" && state.label && jsx(state.label, {}),
      jsx(state.indicator, {}),
      labelPosition === "after" && state.label && jsx(state.label, {})
    ]
  });
};

// node_modules/@fluentui/react-switch/lib/components/Switch/useSwitchStyles.styles.js
var switchClassNames = {
  root: "fui-Switch",
  indicator: "fui-Switch__indicator",
  input: "fui-Switch__input",
  label: "fui-Switch__label"
};
var switchClassName = switchClassNames.root;
var spaceBetweenThumbAndTrack2 = 2;
var trackHeight2 = 20;
var thumbSize2 = trackHeight2 - spaceBetweenThumbAndTrack2;
var useRootBaseClassName5 = __resetStyles("r2i81i2", "rofhmb8", {
  r: [".r2i81i2{align-items:flex-start;box-sizing:border-box;display:inline-flex;position:relative;}", ".r2i81i2:focus{outline-style:none;}", ".r2i81i2:focus-visible{outline-style:none;}", ".r2i81i2[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r2i81i2[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".rofhmb8{align-items:flex-start;box-sizing:border-box;display:inline-flex;position:relative;}", ".rofhmb8:focus{outline-style:none;}", ".rofhmb8:focus-visible{outline-style:none;}", ".rofhmb8[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.rofhmb8[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.r2i81i2[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.rofhmb8[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useRootStyles14 = __styles2({
  vertical: {
    Beiy3e4: "f1vx9l62"
  }
}, {
  d: [".f1vx9l62{flex-direction:column;}"]
});
var useIndicatorBaseClassName3 = __resetStyles("r1c3hft5", null, {
  r: [".r1c3hft5{border-radius:var(--borderRadiusCircular);border:1px solid;line-height:0;box-sizing:border-box;fill:currentColor;flex-shrink:0;font-size:18px;height:20px;margin:var(--spacingVerticalS) var(--spacingHorizontalS);pointer-events:none;transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:background,border,color;width:40px;}", ".r1c3hft5>*{transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:transform;}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.r1c3hft5{transition-duration:0.01ms;}}", "@media (forced-colors: active){.r1c3hft5{color:CanvasText;}.r1c3hft5>i{forced-color-adjust:none;}}", "@media screen and (prefers-reduced-motion: reduce){.r1c3hft5>*{transition-duration:0.01ms;}}"]
});
var useIndicatorStyles2 = __styles2({
  labelAbove: {
    B6of3ja: "f1hu3pq6"
  }
}, {
  d: [".f1hu3pq6{margin-top:0;}"]
});
var useInputBaseClassName3 = __resetStyles("rsji9ng", "r15xih98", {
  r: [".rsji9ng{box-sizing:border-box;cursor:pointer;height:100%;margin:0;opacity:0;position:absolute;width:calc(40px + 2 * var(--spacingHorizontalS));}", ".rsji9ng:checked~.fui-Switch__indicator>*{transform:translateX(20px);}", ".rsji9ng:disabled{cursor:default;}", ".rsji9ng:disabled~.fui-Switch__indicator{color:var(--colorNeutralForegroundDisabled);}", ".rsji9ng:disabled~.fui-Switch__label{cursor:default;color:var(--colorNeutralForegroundDisabled);}", ".rsji9ng:enabled:not(:checked)~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessible);border-color:var(--colorNeutralStrokeAccessible);}", ".rsji9ng:enabled:not(:checked)~.fui-Switch__label{color:var(--colorNeutralForeground1);}", ".rsji9ng:enabled:not(:checked):hover~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".rsji9ng:enabled:not(:checked):hover:active~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".rsji9ng:enabled:checked~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackground);color:var(--colorNeutralForegroundInverted);border-color:var(--colorTransparentStroke);}", ".rsji9ng:enabled:checked:hover~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundHover);border-color:var(--colorTransparentStrokeInteractive);}", ".rsji9ng:enabled:checked:hover:active~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundPressed);border-color:var(--colorTransparentStrokeInteractive);}", ".rsji9ng:disabled:not(:checked)~.fui-Switch__indicator{border-color:var(--colorNeutralStrokeDisabled);}", ".rsji9ng:disabled:checked~.fui-Switch__indicator{background-color:var(--colorNeutralBackgroundDisabled);border-color:var(--colorTransparentStrokeDisabled);}", ".r15xih98{box-sizing:border-box;cursor:pointer;height:100%;margin:0;opacity:0;position:absolute;width:calc(40px + 2 * var(--spacingHorizontalS));}", ".r15xih98:checked~.fui-Switch__indicator>*{transform:translateX(-20px);}", ".r15xih98:disabled{cursor:default;}", ".r15xih98:disabled~.fui-Switch__indicator{color:var(--colorNeutralForegroundDisabled);}", ".r15xih98:disabled~.fui-Switch__label{cursor:default;color:var(--colorNeutralForegroundDisabled);}", ".r15xih98:enabled:not(:checked)~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessible);border-color:var(--colorNeutralStrokeAccessible);}", ".r15xih98:enabled:not(:checked)~.fui-Switch__label{color:var(--colorNeutralForeground1);}", ".r15xih98:enabled:not(:checked):hover~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".r15xih98:enabled:not(:checked):hover:active~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".r15xih98:enabled:checked~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackground);color:var(--colorNeutralForegroundInverted);border-color:var(--colorTransparentStroke);}", ".r15xih98:enabled:checked:hover~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundHover);border-color:var(--colorTransparentStrokeInteractive);}", ".r15xih98:enabled:checked:hover:active~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundPressed);border-color:var(--colorTransparentStrokeInteractive);}", ".r15xih98:disabled:not(:checked)~.fui-Switch__indicator{border-color:var(--colorNeutralStrokeDisabled);}", ".r15xih98:disabled:checked~.fui-Switch__indicator{background-color:var(--colorNeutralBackgroundDisabled);border-color:var(--colorTransparentStrokeDisabled);}"],
  s: ["@media (forced-colors: active){.rsji9ng:disabled~.fui-Switch__indicator{color:GrayText;border-color:GrayText;}.rsji9ng:disabled~.fui-Switch__label{color:GrayText;}.rsji9ng:hover{color:CanvasText;}.rsji9ng:hover:active{color:CanvasText;}.rsji9ng:enabled:checked:hover~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.rsji9ng:enabled:checked:hover:active~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.rsji9ng:enabled:checked~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}}", "@media (forced-colors: active){.r15xih98:disabled~.fui-Switch__indicator{color:GrayText;border-color:GrayText;}.r15xih98:disabled~.fui-Switch__label{color:GrayText;}.r15xih98:hover{color:CanvasText;}.r15xih98:hover:active{color:CanvasText;}.r15xih98:enabled:checked:hover~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.r15xih98:enabled:checked:hover:active~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.r15xih98:enabled:checked~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}}"]
});
var useInputStyles6 = __styles2({
  before: {
    j35jbq: ["f1e31b4d", "f1vgc2s3"],
    Bhzewxz: "f15twtuk"
  },
  after: {
    oyh7mz: ["f1vgc2s3", "f1e31b4d"],
    Bhzewxz: "f15twtuk"
  },
  above: {
    B5kzvoi: "f1yab3r1",
    Bqenvij: "f1aar7gd",
    a9b677: "fly5x3f"
  }
}, {
  d: [".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f15twtuk{top:0;}", ".f1yab3r1{bottom:0;}", ".f1aar7gd{height:calc(20px + var(--spacingVerticalS));}", ".fly5x3f{width:100%;}"]
});
var useLabelStyles5 = __styles2({
  base: {
    Bceei9c: "f1k6fduh",
    jrapky: "f49ad5g",
    B6of3ja: "f1xlvstr",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1f5q0n8"
  },
  above: {
    z8tnut: "f1ywm7hm",
    Byoj8tv: "f14wxoun",
    a9b677: "fly5x3f"
  },
  after: {
    uwmqm3: ["fruq291", "f7x41pl"]
  },
  before: {
    z189sj: ["f7x41pl", "fruq291"]
  }
}, {
  d: [".f1k6fduh{cursor:pointer;}", ".f49ad5g{margin-bottom:calc((20px - var(--lineHeightBase300)) / 2);}", ".f1xlvstr{margin-top:calc((20px - var(--lineHeightBase300)) / 2);}", [".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], ".f1ywm7hm{padding-top:var(--spacingVerticalXS);}", ".f14wxoun{padding-bottom:var(--spacingVerticalXS);}", ".fly5x3f{width:100%;}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}"]
});
var useSwitchStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName5();
  const rootStyles = useRootStyles14();
  const indicatorBaseClassName = useIndicatorBaseClassName3();
  const indicatorStyles = useIndicatorStyles2();
  const inputBaseClassName = useInputBaseClassName3();
  const inputStyles = useInputStyles6();
  const labelStyles = useLabelStyles5();
  const {
    label,
    labelPosition
  } = state;
  state.root.className = mergeClasses(switchClassNames.root, rootBaseClassName, labelPosition === "above" && rootStyles.vertical, state.root.className);
  state.indicator.className = mergeClasses(switchClassNames.indicator, indicatorBaseClassName, label && labelPosition === "above" && indicatorStyles.labelAbove, state.indicator.className);
  state.input.className = mergeClasses(switchClassNames.input, inputBaseClassName, label && inputStyles[labelPosition], state.input.className);
  if (state.label) {
    state.label.className = mergeClasses(switchClassNames.label, labelStyles.base, labelStyles[labelPosition], state.label.className);
  }
  return state;
};

// node_modules/@fluentui/react-switch/lib/components/Switch/Switch.js
var Switch = React252.forwardRef((props, ref) => {
  const state = useSwitch_unstable(props, ref);
  useSwitchStyles_unstable(state);
  useCustomStyleHook("useSwitchStyles_unstable")(state);
  return renderSwitch_unstable(state);
});
Switch.displayName = "Switch";

// node_modules/@fluentui/react-tabs/lib/components/Tab/Tab.js
var React255 = __toESM(require_react());

// node_modules/@fluentui/react-tabs/lib/components/Tab/useTab.js
var React253 = __toESM(require_react());

// node_modules/@fluentui/react-tabs/lib/components/TabList/TabListContext.js
var tabListContextDefaultValue = {
  appearance: "transparent",
  reserveSelectedTabSpace: true,
  selectTabOnFocus: false,
  disabled: false,
  selectedValue: void 0,
  onRegister: () => {
  },
  onUnregister: () => {
  },
  onSelect: () => {
  },
  getRegisteredTabs: () => {
    return {
      registeredTabs: {}
    };
  },
  size: "medium",
  vertical: false
};
var TabListContext = createContext13(void 0);
var TabListProvider = TabListContext.Provider;
var useTabListContext_unstable = (selector) => useContextSelector(TabListContext, (ctx = tabListContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-tabs/lib/components/Tab/useTab.js
var useTab_unstable = (props, ref) => {
  const { content, disabled: tabDisabled = false, icon, onClick, onFocus, value } = props;
  const appearance = useTabListContext_unstable((ctx) => ctx.appearance);
  const reserveSelectedTabSpace = useTabListContext_unstable((ctx) => ctx.reserveSelectedTabSpace);
  const selectTabOnFocus = useTabListContext_unstable((ctx) => ctx.selectTabOnFocus);
  const listDisabled = useTabListContext_unstable((ctx) => ctx.disabled);
  const selected = useTabListContext_unstable((ctx) => ctx.selectedValue === value);
  const onRegister = useTabListContext_unstable((ctx) => ctx.onRegister);
  const onUnregister = useTabListContext_unstable((ctx) => ctx.onUnregister);
  const onSelect = useTabListContext_unstable((ctx) => ctx.onSelect);
  const size3 = useTabListContext_unstable((ctx) => ctx.size);
  const vertical = useTabListContext_unstable((ctx) => !!ctx.vertical);
  const disabled = listDisabled || tabDisabled;
  const innerRef = React253.useRef(null);
  const onSelectCallback = (event) => onSelect(event, {
    value
  });
  const onTabClick = useEventCallback(mergeCallbacks(onClick, onSelectCallback));
  const onTabFocus = useEventCallback(mergeCallbacks(onFocus, onSelectCallback));
  const focusProps = useTabsterAttributes({
    focusable: {
      isDefault: selected
    }
  });
  React253.useEffect(() => {
    onRegister({
      value,
      ref: innerRef
    });
    return () => {
      onUnregister({
        value,
        ref: innerRef
      });
    };
  }, [
    onRegister,
    onUnregister,
    innerRef,
    value
  ]);
  const iconSlot = slot_exports.optional(icon, {
    elementType: "span"
  });
  const contentSlot = slot_exports.always(content, {
    defaultProps: {
      children: props.children
    },
    elementType: "span"
  });
  const contentReservedSpace = content && typeof content === "object" ? omit(content, [
    "ref"
  ]) : content;
  const iconOnly = Boolean((iconSlot === null || iconSlot === void 0 ? void 0 : iconSlot.children) && !contentSlot.children);
  return {
    components: {
      root: "button",
      icon: "span",
      content: "span",
      contentReservedSpace: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLButtonElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, innerRef),
      role: "tab",
      type: "button",
      // aria-selected undefined indicates it is not selectable
      // according to https://www.w3.org/TR/wai-aria-1.1/#aria-selected
      "aria-selected": disabled ? void 0 : `${selected}`,
      ...focusProps,
      ...props,
      disabled,
      onClick: onTabClick,
      onFocus: selectTabOnFocus ? onTabFocus : onFocus
    }), {
      elementType: "button"
    }),
    icon: iconSlot,
    iconOnly,
    content: contentSlot,
    contentReservedSpace: slot_exports.optional(contentReservedSpace, {
      renderByDefault: !selected && !iconOnly && reserveSelectedTabSpace,
      defaultProps: {
        children: props.children
      },
      elementType: "span"
    }),
    appearance,
    disabled,
    selected,
    size: size3,
    value,
    vertical
  };
};

// node_modules/@fluentui/react-tabs/lib/components/Tab/renderTab.js
var renderTab_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      !state.iconOnly && jsx(state.content, {}),
      state.contentReservedSpace && jsx(state.contentReservedSpace, {})
    ]
  });
};

// node_modules/@fluentui/react-tabs/lib/components/Tab/useTabAnimatedIndicator.styles.js
var React254 = __toESM(require_react());
var tabIndicatorCssVars_unstable = {
  offsetVar: "--fui-Tab__indicator--offset",
  scaleVar: "--fui-Tab__indicator--scale"
};
var useActiveIndicatorStyles = __styles2({
  base: {
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1gl81tg"
  },
  animated: {
    Ba2ppi3: "fhwpy7i",
    F2fol1: "f6zz20j",
    B1dyfl9: "f1ai4sc1",
    B0vmy72: "f9qxlq5",
    u9bimw: "f1aql376"
  },
  horizontal: {
    sjv3b2: ["fug4aj8", "f1i5xzg7"],
    b1kco5: "f1q7ujh"
  },
  vertical: {
    sjv3b2: "f1hqboyk",
    b1kco5: "f1dxupa6"
  }
}, {
  d: [[".f1gl81tg{overflow:visible;}", {
    p: -1
  }], ".fhwpy7i::after{transition-property:transform;}", ".f6zz20j::after{transition-duration:var(--durationSlow);}", ".f1ai4sc1::after{transition-timing-function:var(--curveDecelerateMax);}", ".fug4aj8::after{transform-origin:left;}", ".f1i5xzg7::after{transform-origin:right;}", ".f1q7ujh::after{transform:translateX(var(--fui-Tab__indicator--offset)) scaleX(var(--fui-Tab__indicator--scale));}", ".f1hqboyk::after{transform-origin:top;}", ".f1dxupa6::after{transform:translateY(var(--fui-Tab__indicator--offset)) scaleY(var(--fui-Tab__indicator--scale));}"],
  m: [["@media (prefers-reduced-motion: reduce){.f9qxlq5::after{transition-property:none;}}", {
    m: "(prefers-reduced-motion: reduce)"
  }], ["@media (prefers-reduced-motion: reduce){.f1aql376::after{transition-duration:0.01ms;}}", {
    m: "(prefers-reduced-motion: reduce)"
  }]]
});
var calculateTabRect = (element) => {
  if (element) {
    var _element_parentElement;
    const parentRect = ((_element_parentElement = element.parentElement) === null || _element_parentElement === void 0 ? void 0 : _element_parentElement.getBoundingClientRect()) || {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    const tabRect = element.getBoundingClientRect();
    return {
      x: tabRect.x - parentRect.x,
      y: tabRect.y - parentRect.y,
      width: tabRect.width,
      height: tabRect.height
    };
  }
  return void 0;
};
var getRegisteredTabRect = (registeredTabs, value) => {
  var _registeredTabs_JSON_stringify;
  const element = isValueDefined(value) ? (_registeredTabs_JSON_stringify = registeredTabs[JSON.stringify(value)]) === null || _registeredTabs_JSON_stringify === void 0 ? void 0 : _registeredTabs_JSON_stringify.ref.current : void 0;
  return element ? calculateTabRect(element) : void 0;
};
var isValueDefined = (value) => value != null;
var useTabAnimatedIndicatorStyles_unstable = (state) => {
  const {
    disabled,
    selected,
    vertical
  } = state;
  const activeIndicatorStyles = useActiveIndicatorStyles();
  const [lastAnimatedFrom, setLastAnimatedFrom] = React254.useState();
  const [animationValues, setAnimationValues] = React254.useState({
    offset: 0,
    scale: 1
  });
  const getRegisteredTabs = useTabListContext_unstable((ctx) => ctx.getRegisteredTabs);
  const [requestAnimationFrame2] = useAnimationFrame();
  if (selected) {
    const {
      previousSelectedValue,
      selectedValue,
      registeredTabs
    } = getRegisteredTabs();
    if (isValueDefined(previousSelectedValue) && lastAnimatedFrom !== previousSelectedValue) {
      const previousSelectedTabRect = getRegisteredTabRect(registeredTabs, previousSelectedValue);
      const selectedTabRect = getRegisteredTabRect(registeredTabs, selectedValue);
      if (selectedTabRect && previousSelectedTabRect) {
        const offset4 = vertical ? previousSelectedTabRect.y - selectedTabRect.y : previousSelectedTabRect.x - selectedTabRect.x;
        const scale = vertical ? previousSelectedTabRect.height / selectedTabRect.height : previousSelectedTabRect.width / selectedTabRect.width;
        setAnimationValues({
          offset: offset4,
          scale
        });
        setLastAnimatedFrom(previousSelectedValue);
        requestAnimationFrame2(() => setAnimationValues({
          offset: 0,
          scale: 1
        }));
      }
    }
  } else if (isValueDefined(lastAnimatedFrom)) {
    setLastAnimatedFrom(void 0);
  }
  if (disabled) {
    return state;
  }
  const animating = animationValues.offset === 0 && animationValues.scale === 1;
  state.root.className = mergeClasses(state.root.className, selected && activeIndicatorStyles.base, selected && animating && activeIndicatorStyles.animated, selected && (vertical ? activeIndicatorStyles.vertical : activeIndicatorStyles.horizontal));
  const rootCssVars = {
    [tabIndicatorCssVars_unstable.offsetVar]: `${animationValues.offset}px`,
    [tabIndicatorCssVars_unstable.scaleVar]: `${animationValues.scale}`
  };
  state.root.style = {
    ...rootCssVars,
    ...state.root.style
  };
  return state;
};

// node_modules/@fluentui/react-tabs/lib/components/Tab/useTabStyles.styles.js
var tabClassNames = {
  root: "fui-Tab",
  icon: "fui-Tab__icon",
  content: "fui-Tab__content"
};
var tabReservedSpaceClassNames = {
  content: "fui-Tab__content--reserved-space"
};
var useRootStyles15 = __styles2({
  root: {
    Bt984gj: "f122n59",
    mc9l5x: "f13qh94s",
    Bnnss6s: "fi64zpg",
    Bxotwcr: "f1u07yai",
    Budl1dq: "frn2hmy",
    wkccdc: "f1olsevy",
    oeaueh: "f1s6fcnf",
    qhf8xq: "f10pi13n"
  },
  button: {
    Bt984gj: "f122n59",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bceei9c: "f1k6fduh",
    mc9l5x: "f13qh94s",
    Bnnss6s: "fi64zpg",
    Bxotwcr: "f1u07yai",
    Budl1dq: "frn2hmy",
    wkccdc: "f1olsevy",
    Bahqtrf: "fk6fouc",
    Bg96gwp: "f1i3iumi",
    oeaueh: "f1s6fcnf",
    qhf8xq: "f10pi13n",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    B9bfxx9: "f1cxpek8"
  },
  horizontal: {
    Brf1p80: "f4d9j23"
  },
  vertical: {
    Brf1p80: "f1s9ku6b"
  },
  smallHorizontal: {
    i8kkvl: "f14mj54c",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1wmopi4"
  },
  smallVertical: {
    i8kkvl: "f14mj54c",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f12or63q"
  },
  mediumHorizontal: {
    i8kkvl: "f1rjii52",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1w08f2p"
  },
  mediumVertical: {
    i8kkvl: "f1rjii52",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fymxs25"
  },
  largeHorizontal: {
    i8kkvl: "f1rjii52",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1ssfvub"
  },
  largeVertical: {
    i8kkvl: "f1rjii52",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fwkd1rq"
  },
  transparent: {
    De3pzq: "f1c21dwh",
    B95qlz1: "f9rvdkv",
    B7xitij: "f1051ucx",
    Bptxc3x: "fmmjozx",
    Bwqhzpy: "fqhzt5g",
    iyk698: "f7l5cgy",
    cl4aha: "fpkze5g",
    B0q3jbp: "f1iywnoi",
    Be9ayug: "f9n45c4"
  },
  subtle: {
    De3pzq: "fhovq9v",
    B95qlz1: "f1bifk9c",
    B7xitij: "fo6hitd",
    Bptxc3x: "fmmjozx",
    Bwqhzpy: "fqhzt5g",
    iyk698: "f7l5cgy",
    cl4aha: "fpkze5g",
    B0q3jbp: "f1iywnoi",
    Be9ayug: "f9n45c4"
  },
  disabledCursor: {
    Bceei9c: "fdrzuqr"
  },
  disabled: {
    De3pzq: "f1c21dwh",
    Bptxc3x: "fato7r6",
    cl4aha: "fao1bnu"
  },
  selected: {
    Bptxc3x: "f1cadz5z",
    Bwqhzpy: "fwhdxxj",
    iyk698: "fintccb",
    cl4aha: "ffplhdr",
    B0q3jbp: "fjo17wb",
    Be9ayug: "f148789c"
  }
}, {
  d: [".f122n59{align-items:center;}", ".f13qh94s{display:grid;}", ".fi64zpg{flex-shrink:0;}", ".f1u07yai{grid-auto-flow:column;}", ".frn2hmy{grid-template-columns:auto;}", ".f1olsevy{grid-template-rows:auto;}", ".f1s6fcnf{outline-style:none;}", ".f10pi13n{position:relative;}", [".f3bhgqh{border:none;}", {
    p: -2
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1k6fduh{cursor:pointer;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], ".f1cxpek8{text-transform:none;}", ".f4d9j23{justify-content:center;}", ".f1s9ku6b{justify-content:start;}", ".f14mj54c{column-gap:var(--spacingHorizontalXXS);}", [".f1wmopi4{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalSNudge);}", {
    p: -1
  }], [".f12or63q{padding:var(--spacingVerticalXXS) var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", [".f1w08f2p{padding:var(--spacingVerticalM) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".fymxs25{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".f1ssfvub{padding:var(--spacingVerticalL) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".fwkd1rq{padding:var(--spacingVerticalS) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f9rvdkv:enabled:hover{background-color:var(--colorTransparentBackgroundHover);}", ".f1051ucx:enabled:active{background-color:var(--colorTransparentBackgroundPressed);}", ".fmmjozx .fui-Tab__icon{color:var(--colorNeutralForeground2);}", ".fqhzt5g:enabled:hover .fui-Tab__icon{color:var(--colorNeutralForeground2Hover);}", ".f7l5cgy:enabled:active .fui-Tab__icon{color:var(--colorNeutralForeground2Pressed);}", ".fpkze5g .fui-Tab__content{color:var(--colorNeutralForeground2);}", ".f1iywnoi:enabled:hover .fui-Tab__content{color:var(--colorNeutralForeground2Hover);}", ".f9n45c4:enabled:active .fui-Tab__content{color:var(--colorNeutralForeground2Pressed);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".f1bifk9c:enabled:hover{background-color:var(--colorSubtleBackgroundHover);}", ".fo6hitd:enabled:active{background-color:var(--colorSubtleBackgroundPressed);}", ".fdrzuqr{cursor:not-allowed;}", ".fato7r6 .fui-Tab__icon{color:var(--colorNeutralForegroundDisabled);}", ".fao1bnu .fui-Tab__content{color:var(--colorNeutralForegroundDisabled);}", ".f1cadz5z .fui-Tab__icon{color:var(--colorCompoundBrandForeground1);}", ".fwhdxxj:enabled:hover .fui-Tab__icon{color:var(--colorCompoundBrandForeground1Hover);}", ".fintccb:enabled:active .fui-Tab__icon{color:var(--colorCompoundBrandForeground1Pressed);}", ".ffplhdr .fui-Tab__content{color:var(--colorNeutralForeground1);}", ".fjo17wb:enabled:hover .fui-Tab__content{color:var(--colorNeutralForeground1Hover);}", ".f148789c:enabled:active .fui-Tab__content{color:var(--colorNeutralForeground1Pressed);}"]
});
var useCircularAppearanceStyles = __styles2({
  base: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fp7rvkm",
    Bptxc3x: "ftorr8m",
    cl4aha: "f16lqpmv"
  },
  small: {
    Dbcxam: 0,
    rjzwhg: 0,
    Bblux5w: "fzklhed"
  },
  medium: {
    Dbcxam: 0,
    rjzwhg: 0,
    Bblux5w: "f1j721cc"
  },
  large: {
    Dbcxam: 0,
    rjzwhg: 0,
    Bblux5w: "frx9knr"
  },
  subtle: {
    De3pzq: "fhovq9v",
    sj55zd: "fkfq4zb",
    B95qlz1: "f1bifk9c",
    Eo63ln: 0,
    r9osk6: 0,
    Itrz8y: 0,
    zeg6vx: 0,
    l65xgk: 0,
    Bw4olcx: 0,
    Folb0i: 0,
    I2h8y4: 0,
    Bgxgoyi: 0,
    Bvlkotb: 0,
    Fwyncl: 0,
    Byh5edv: 0,
    Becqvjq: 0,
    uumbiq: 0,
    B73q3dg: 0,
    Bblwbaf: 0,
    B0ezav: "ft57sj0",
    r4wkhp: "f1fcoy83",
    B7xitij: "fo6hitd",
    d3wsvi: 0,
    Hdqn7s: 0,
    zu5y1p: 0,
    owqphb: 0,
    g9c53k: 0,
    Btmu08z: 0,
    Bthxvy6: 0,
    gluvuq: 0,
    tb88gp: 0,
    wns6jk: 0,
    kdfdk4: 0,
    Bbw008l: 0,
    Bayi1ib: 0,
    B1kkfu3: 0,
    J1oqyp: 0,
    kem6az: 0,
    goa3yj: "fhn220o",
    p743kt: "f15qf7sh",
    uu68id: 0,
    Bxeuatn: 0,
    felo30: 0,
    Bc736ss: 0,
    Bhz882k: 0,
    n51gp8: 0,
    Eshu5l: 0,
    Bk6ri7n: 0,
    v49c4f: 0,
    Bn1d65q: 0,
    c4eypz: 0,
    v3aym: 0,
    hft9gk: 0,
    Bjwas2f: 0,
    Bk5ld8o: 0,
    gwxt9v: 0,
    B6k8go: "f130w16x"
  },
  subtleSelected: {
    De3pzq: "f16xkysk",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f1c2pc3t",
    sj55zd: "faj9fo0",
    B95qlz1: "fsm7zmf",
    Eo63ln: 0,
    r9osk6: 0,
    Itrz8y: 0,
    zeg6vx: 0,
    l65xgk: 0,
    Bw4olcx: 0,
    Folb0i: 0,
    I2h8y4: 0,
    Bgxgoyi: 0,
    Bvlkotb: 0,
    Fwyncl: 0,
    Byh5edv: 0,
    Becqvjq: 0,
    uumbiq: 0,
    B73q3dg: 0,
    Bblwbaf: 0,
    B0ezav: "f1wo0sfq",
    r4wkhp: "f1afuynh",
    B7xitij: "f94ddyl",
    d3wsvi: 0,
    Hdqn7s: 0,
    zu5y1p: 0,
    owqphb: 0,
    g9c53k: 0,
    Btmu08z: 0,
    Bthxvy6: 0,
    gluvuq: 0,
    tb88gp: 0,
    wns6jk: 0,
    kdfdk4: 0,
    Bbw008l: 0,
    Bayi1ib: 0,
    B1kkfu3: 0,
    J1oqyp: 0,
    kem6az: 0,
    goa3yj: "fmle6oo",
    p743kt: "f1d3itm4",
    uu68id: 0,
    Bxeuatn: 0,
    felo30: 0,
    Bc736ss: 0,
    Bhz882k: 0,
    n51gp8: 0,
    Eshu5l: 0,
    Bk6ri7n: 0,
    v49c4f: 0,
    Bn1d65q: 0,
    c4eypz: 0,
    v3aym: 0,
    hft9gk: 0,
    Bjwas2f: 0,
    Bk5ld8o: 0,
    gwxt9v: 0,
    B6k8go: "f19qjb1h"
  },
  subtleDisabled: {
    De3pzq: "fhovq9v",
    sj55zd: "f1s2aq7o"
  },
  subtleDisabledSelected: {
    De3pzq: "f1bg9a2p",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fegtqic",
    sj55zd: "f1s2aq7o"
  },
  filled: {
    De3pzq: "f16xq7d1",
    sj55zd: "fkfq4zb",
    B95qlz1: "fwwxidx",
    r4wkhp: "f1fcoy83",
    B7xitij: "f14i52sd",
    p743kt: "f15qf7sh",
    Bw5j0gk: "f159yq2d",
    Baikq8m: "ful0ncq",
    B2ndh17: "f2rulcp",
    w0x64w: "f19p5z4e",
    Bdzpij4: "fo1bcu3"
  },
  filledSelected: {
    De3pzq: "ffp7eso",
    sj55zd: "f1phragk",
    B95qlz1: "f1lm9dni",
    r4wkhp: "f1mn5ei1",
    B7xitij: "f1g6ncd0",
    p743kt: "fl71aob",
    bml8oc: "f13s88zn",
    qew46a: "f16zjd40",
    B84x17g: "f1mr3uue",
    Jetwu1: "f196ywdt"
  },
  filledDisabled: {
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o"
  },
  filledDisabledSelected: {
    De3pzq: "f1bg9a2p",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fegtqic",
    sj55zd: "f1s2aq7o"
  }
}, {
  d: [[".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".fp7rvkm{border:solid var(--strokeWidthThin) var(--colorTransparentStroke);}", {
    p: -2
  }], ".ftorr8m .fui-Tab__icon{color:inherit;}", ".f16lqpmv .fui-Tab__content{color:inherit;}", [".fzklhed{padding-block:calc(var(--spacingVerticalXXS) - var(--strokeWidthThin));}", {
    p: -1
  }], [".f1j721cc{padding-block:calc(var(--spacingVerticalSNudge) - var(--strokeWidthThin));}", {
    p: -1
  }], [".frx9knr{padding-block:calc(var(--spacingVerticalS) - var(--strokeWidthThin));}", {
    p: -1
  }], ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f1bifk9c:enabled:hover{background-color:var(--colorSubtleBackgroundHover);}", [".ft57sj0:enabled:hover{border:solid var(--strokeWidthThin) var(--colorNeutralStroke1Hover);}", {
    p: -2
  }], ".f1fcoy83:enabled:hover{color:var(--colorNeutralForeground2Hover);}", ".fo6hitd:enabled:active{background-color:var(--colorSubtleBackgroundPressed);}", [".fhn220o:enabled:active{border:solid var(--strokeWidthThin) var(--colorNeutralStroke1Pressed);}", {
    p: -2
  }], ".f15qf7sh:enabled:active{color:var(--colorNeutralForeground2Pressed);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", [".f1c2pc3t{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStroke);}", {
    p: -2
  }], ".faj9fo0{color:var(--colorBrandForeground2);}", ".fsm7zmf:enabled:hover{background-color:var(--colorBrandBackground2Hover);}", [".f1wo0sfq:enabled:hover{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStrokeHover);}", {
    p: -2
  }], ".f1afuynh:enabled:hover{color:var(--colorBrandForeground2Hover);}", ".f94ddyl:enabled:active{background-color:var(--colorBrandBackground2Pressed);}", [".fmle6oo:enabled:active{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStrokePressed);}", {
    p: -2
  }], ".f1d3itm4:enabled:active{color:var(--colorBrandForeground2Pressed);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", [".fegtqic{border:solid var(--strokeWidthThin) var(--colorNeutralStrokeDisabled);}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fwwxidx:enabled:hover{background-color:var(--colorNeutralBackground3Hover);}", ".f14i52sd:enabled:active{background-color:var(--colorNeutralBackground3Pressed);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".f1lm9dni:enabled:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1mn5ei1:enabled:hover{color:var(--colorNeutralForegroundOnBrand);}", ".f1g6ncd0:enabled:active{background-color:var(--colorBrandBackgroundPressed);}", ".fl71aob:enabled:active{color:var(--colorNeutralForegroundOnBrand);}", [".fegtqic{border:solid var(--strokeWidthThin) var(--colorNeutralStrokeDisabled);}", {
    p: -2
  }]],
  m: [["@media (forced-colors: active){.f130w16x{border:solid var(--strokeWidthThin) Canvas;}}", {
    p: -2,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f19qjb1h{border:solid var(--strokeWidthThin) Highlight;}}", {
    p: -2,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f159yq2d:enabled:hover{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.ful0ncq:enabled:hover{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f2rulcp:enabled:hover .fui-Tab__content{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f19p5z4e:enabled:hover .fui-Icon-filled{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fo1bcu3:enabled:hover .fui-Icon-regular{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f13s88zn:enabled{background-color:ButtonText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f16zjd40:enabled .fui-Tab__content{color:ButtonFace;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1mr3uue:enabled .fui-Tab__content{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f196ywdt:enabled .fui-Tab__icon{color:ButtonFace;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useFocusStyles2 = __styles2({
  base: {
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Bn4voq9: "f1p7hgxw",
    Bfpq7zp: "f1way5bb",
    g9k6zt: "f9znhxp",
    j6ew2k: ["fqa318h", "fqa318h"],
    Bhxq17a: "f1vjpng2"
  },
  circular: {
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Bn4voq9: "f1p7hgxw",
    Bfpq7zp: "f1way5bb",
    g9k6zt: "f9znhxp",
    j6ew2k: ["fzgyhws", "fqxug60"],
    Bhxq17a: "f1vjpng2"
  }
}, {
  d: [".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", ".f1p7hgxw[data-fui-focus-visible]{outline-width:var(--strokeWidthThick);}", ".f1way5bb[data-fui-focus-visible]{outline-color:transparent;}", ".f9znhxp[data-fui-focus-visible]{outline-style:solid;}", ".fqa318h[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2);}", ".f1vjpng2[data-fui-focus-visible]{z-index:1;}", ".fzgyhws[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),0 0 0 var(--strokeWidthThin) var(--colorNeutralStrokeOnBrand) inset;}", ".fqxug60[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),0 0 0 var(--strokeWidthThin) var(--colorNeutralStrokeOnBrand) inset;}"]
});
var usePendingIndicatorStyles = __styles2({
  base: {
    az7l2e: "fhw179n",
    vqofr: 0,
    Bv4n3vi: 0,
    Bgqb9hq: 0,
    B0uxbk8: 0,
    Bf3jju6: "fg9j5n4",
    amg5m6: "f1kmhr4c",
    zkfqfm: "fl1ydde",
    Bkydozb: "f1y7maxz",
    Bka2azo: 0,
    vzq8l0: 0,
    csmgbd: 0,
    Br4ovkg: 0,
    aelrif: "fceyvr4",
    y36c18: "f16cxu0",
    B1ctymy: "f1nwgacf",
    Bgvrrv0: "f15ovonk",
    ddr6p5: "fvje46l"
  },
  disabled: {
    az7l2e: "f1ut20fw",
    Bkydozb: "fhrzcfn",
    Bgvrrv0: "f1v15rkt",
    ddr6p5: "f3nwrnk"
  },
  smallHorizontal: {
    lawp4y: "fchca7p",
    Baz25je: "f1r53b5e",
    Fbdkly: ["f1s6rxz5", "fo35v8s"],
    mdwyqc: ["fo35v8s", "f1s6rxz5"]
  },
  smallVertical: {
    lawp4y: "fze4zud",
    Fbdkly: ["f1fzr1x6", "f1f351id"],
    Bciustq: "fdp32p8",
    Ccq8qp: "f1aij3q"
  },
  mediumHorizontal: {
    lawp4y: "fchca7p",
    Baz25je: "f1s2r9ax",
    Fbdkly: ["f1o0nnkk", "fxb7rol"],
    mdwyqc: ["fxb7rol", "f1o0nnkk"]
  },
  mediumVertical: {
    lawp4y: "f17jracn",
    Fbdkly: ["f1fzr1x6", "f1f351id"],
    Bciustq: "f117lcb2",
    Ccq8qp: "f1aij3q"
  },
  largeHorizontal: {
    lawp4y: "fchca7p",
    Baz25je: "f1s2r9ax",
    Fbdkly: ["f1o0nnkk", "fxb7rol"],
    mdwyqc: ["fxb7rol", "f1o0nnkk"]
  },
  largeVertical: {
    lawp4y: "fel9d3z",
    Fbdkly: ["f1fzr1x6", "f1f351id"],
    Bciustq: "f6vqlre",
    Ccq8qp: "f1aij3q"
  }
}, {
  h: [".fhw179n:hover::before{background-color:var(--colorNeutralStroke1Hover);}", [".fg9j5n4:hover::before{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], '.f1kmhr4c:hover::before{content:"";}', ".fl1ydde:hover::before{position:absolute;}", ".f1ut20fw:hover::before{background-color:var(--colorTransparentStroke);}"],
  a: [".f1y7maxz:active::before{background-color:var(--colorNeutralStroke1Pressed);}", [".fceyvr4:active::before{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], '.f16cxu0:active::before{content:"";}', ".f1nwgacf:active::before{position:absolute;}", ".fhrzcfn:active::before{background-color:var(--colorTransparentStroke);}"],
  m: [["@media (forced-colors: active){.f15ovonk:hover::before{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fvje46l:active::before{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1v15rkt:hover::before{background-color:transparent;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3nwrnk:active::before{background-color:transparent;}}", {
    m: "(forced-colors: active)"
  }]],
  d: [".fchca7p::before{bottom:0;}", ".f1r53b5e::before{height:var(--strokeWidthThick);}", ".f1s6rxz5::before{left:var(--spacingHorizontalSNudge);}", ".fo35v8s::before{right:var(--spacingHorizontalSNudge);}", ".fze4zud::before{bottom:var(--spacingVerticalXS);}", ".f1fzr1x6::before{left:0;}", ".f1f351id::before{right:0;}", ".fdp32p8::before{top:var(--spacingVerticalXS);}", ".f1aij3q::before{width:var(--strokeWidthThicker);}", ".f1s2r9ax::before{height:var(--strokeWidthThicker);}", ".f1o0nnkk::before{left:var(--spacingHorizontalM);}", ".fxb7rol::before{right:var(--spacingHorizontalM);}", ".f17jracn::before{bottom:var(--spacingVerticalS);}", ".f117lcb2::before{top:var(--spacingVerticalS);}", ".fel9d3z::before{bottom:var(--spacingVerticalMNudge);}", ".f6vqlre::before{top:var(--spacingVerticalMNudge);}"]
});
var useActiveIndicatorStyles2 = __styles2({
  base: {
    Bjyk6c5: "f1rp0jgh",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "f3b9emi",
    Bsft5z2: "f13zj6fq",
    E3zdtr: "f1mdlcz9"
  },
  selected: {
    Bjyk6c5: "f1ksivud",
    Bej4dhw: "f1476jrx",
    B7wqxwa: "f18q216b",
    f7digc: "fy7ktjt",
    Bvuzv5k: "f1033yux",
    k4sdgo: "fkh9b8o"
  },
  disabled: {
    Bjyk6c5: "f13lkzet"
  },
  smallHorizontal: {
    By385i5: "fo72kxq",
    Dlnsje: "f9bb2ob",
    Eqx8gd: ["f1q70ajw", "f18rbzdx"],
    B1piin3: ["f18rbzdx", "f1q70ajw"]
  },
  smallVertical: {
    By385i5: "fqbue9b",
    Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
    bn5sak: "fk1klkt",
    a2br6o: "f1o25lip"
  },
  mediumHorizontal: {
    By385i5: "fo72kxq",
    Dlnsje: "f1vx7lu8",
    Eqx8gd: ["fna7m5n", "f1oxpfwv"],
    B1piin3: ["f1oxpfwv", "fna7m5n"]
  },
  mediumVertical: {
    By385i5: "fipylg0",
    Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
    bn5sak: "fqchiol",
    a2br6o: "f1o25lip"
  },
  largeHorizontal: {
    By385i5: "fo72kxq",
    Dlnsje: "f1vx7lu8",
    Eqx8gd: ["fna7m5n", "f1oxpfwv"],
    B1piin3: ["f1oxpfwv", "fna7m5n"]
  },
  largeVertical: {
    By385i5: "f1w7dm5g",
    Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
    bn5sak: "f1p6em4m",
    a2br6o: "f1o25lip"
  }
}, {
  d: [".f1rp0jgh::after{background-color:var(--colorTransparentStroke);}", [".f3b9emi::after{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1ksivud::after{background-color:var(--colorCompoundBrandStroke);}", ".f1476jrx:enabled:hover::after{background-color:var(--colorCompoundBrandStrokeHover);}", ".f18q216b:enabled:active::after{background-color:var(--colorCompoundBrandStrokePressed);}", ".f13lkzet::after{background-color:var(--colorNeutralForegroundDisabled);}", ".fo72kxq::after{bottom:0;}", ".f9bb2ob::after{height:var(--strokeWidthThick);}", ".f1q70ajw::after{left:var(--spacingHorizontalSNudge);}", ".f18rbzdx::after{right:var(--spacingHorizontalSNudge);}", ".fqbue9b::after{bottom:var(--spacingVerticalXS);}", ".f1n6gb5g::after{left:0;}", ".f15yvnhg::after{right:0;}", ".fk1klkt::after{top:var(--spacingVerticalXS);}", ".f1o25lip::after{width:var(--strokeWidthThicker);}", ".f1vx7lu8::after{height:var(--strokeWidthThicker);}", ".fna7m5n::after{left:var(--spacingHorizontalM);}", ".f1oxpfwv::after{right:var(--spacingHorizontalM);}", ".fipylg0::after{bottom:var(--spacingVerticalS);}", ".fqchiol::after{top:var(--spacingVerticalS);}", ".f1w7dm5g::after{bottom:var(--spacingVerticalMNudge);}", ".f1p6em4m::after{top:var(--spacingVerticalMNudge);}"],
  m: [["@media (forced-colors: active){.fy7ktjt::after{background-color:ButtonText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1033yux:enabled:hover::after{background-color:ButtonText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fkh9b8o:enabled:active::after{background-color:ButtonText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useIconStyles7 = __styles2({
  base: {
    Br312pm: "fwpfdsa",
    Ijaq50: "f16hsg94",
    Bt984gj: "f122n59",
    mc9l5x: "ftuwxu6",
    Brf1p80: "f4d9j23",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    D0sxk3: "f16u1re",
    t6yez3: "f8bsbmo"
  },
  small: {
    Be2twd7: "fe5j1ua",
    Bqenvij: "fjamq6b",
    a9b677: "f64fuq3"
  },
  medium: {
    Be2twd7: "fe5j1ua",
    Bqenvij: "fjamq6b",
    a9b677: "f64fuq3"
  },
  large: {
    Be2twd7: "f1rt2boy",
    Bqenvij: "frvgh55",
    a9b677: "fq4mcun"
  },
  selected: {
    D0sxk3: "fxoiby5",
    t6yez3: "f15q0o9g"
  }
}, {
  d: [".fwpfdsa{grid-column-start:1;}", ".f16hsg94{grid-row-start:1;}", ".f122n59{align-items:center;}", ".ftuwxu6{display:inline-flex;}", ".f4d9j23{justify-content:center;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], ".f16u1re .fui-Icon-filled{display:none;}", ".f8bsbmo .fui-Icon-regular{display:inline;}", ".fe5j1ua{font-size:20px;}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".f1rt2boy{font-size:24px;}", ".frvgh55{height:24px;}", ".fq4mcun{width:24px;}", ".fxoiby5 .fui-Icon-filled{display:inline;}", ".f15q0o9g .fui-Icon-regular{display:none;}"]
});
var useContentStyles3 = __styles2({
  base: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1bwptpd"
  },
  selected: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1i3iumi"
  },
  large: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k"
  },
  largeSelected: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  noIconBefore: {
    Br312pm: "fwpfdsa",
    Ijaq50: "f16hsg94"
  },
  iconBefore: {
    Br312pm: "fd46tj4",
    Ijaq50: "f16hsg94"
  },
  placeholder: {
    Bcdw1i0: "fd7fpy0"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], [".f1bwptpd{padding:var(--spacingVerticalNone) var(--spacingHorizontalXXS);}", {
    p: -1
  }], ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fwpfdsa{grid-column-start:1;}", ".f16hsg94{grid-row-start:1;}", ".fd46tj4{grid-column-start:2;}", ".fd7fpy0{visibility:hidden;}"]
});
var useTabStyles_unstable = (state) => {
  "use no memo";
  useTabIndicatorStyles_unstable(state);
  useTabButtonStyles_unstable(state, state.root);
  useTabContentStyles_unstable(state);
  return state;
};
var useTabIndicatorStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles15();
  const pendingIndicatorStyles = usePendingIndicatorStyles();
  const activeIndicatorStyles = useActiveIndicatorStyles2();
  const {
    appearance,
    disabled,
    selected,
    size: size3,
    vertical
  } = state;
  const classes = [tabClassNames.root, rootStyles.root];
  if (appearance !== "subtle-circular" && appearance !== "filled-circular") {
    classes.push(
      // pending indicator (before pseudo element)
      pendingIndicatorStyles.base,
      size3 === "small" && (vertical ? pendingIndicatorStyles.smallVertical : pendingIndicatorStyles.smallHorizontal),
      size3 === "medium" && (vertical ? pendingIndicatorStyles.mediumVertical : pendingIndicatorStyles.mediumHorizontal),
      size3 === "large" && (vertical ? pendingIndicatorStyles.largeVertical : pendingIndicatorStyles.largeHorizontal),
      disabled && pendingIndicatorStyles.disabled,
      // active indicator (after pseudo element)
      selected && activeIndicatorStyles.base,
      selected && !disabled && activeIndicatorStyles.selected,
      selected && size3 === "small" && (vertical ? activeIndicatorStyles.smallVertical : activeIndicatorStyles.smallHorizontal),
      selected && size3 === "medium" && (vertical ? activeIndicatorStyles.mediumVertical : activeIndicatorStyles.mediumHorizontal),
      selected && size3 === "large" && (vertical ? activeIndicatorStyles.largeVertical : activeIndicatorStyles.largeHorizontal),
      selected && disabled && activeIndicatorStyles.disabled
    );
  }
  state.root.className = mergeClasses(...classes, state.root.className);
  useTabAnimatedIndicatorStyles_unstable(state);
  return state;
};
var useTabButtonStyles_unstable = (state, slot) => {
  "use no memo";
  const rootStyles = useRootStyles15();
  const focusStyles = useFocusStyles2();
  const circularStyles = useCircularAppearanceStyles();
  const {
    appearance,
    disabled,
    selected,
    size: size3,
    vertical
  } = state;
  const isSubtleCircular = appearance === "subtle-circular";
  const isFilledCircular = appearance === "filled-circular";
  const isCircular = isSubtleCircular || isFilledCircular;
  const circularAppearance = [
    circularStyles.base,
    focusStyles.circular,
    // sizes
    size3 === "small" && circularStyles.small,
    size3 === "medium" && circularStyles.medium,
    size3 === "large" && circularStyles.large,
    // subtle-circular appearance
    isSubtleCircular && circularStyles.subtle,
    selected && isSubtleCircular && circularStyles.subtleSelected,
    disabled && isSubtleCircular && circularStyles.subtleDisabled,
    selected && disabled && isSubtleCircular && circularStyles.subtleDisabledSelected,
    // filled-circular appearance
    isFilledCircular && circularStyles.filled,
    selected && isFilledCircular && circularStyles.filledSelected,
    disabled && isFilledCircular && circularStyles.filledDisabled,
    selected && disabled && isFilledCircular && circularStyles.filledDisabledSelected
  ];
  const regularAppearance = [focusStyles.base, !disabled && appearance === "subtle" && rootStyles.subtle, !disabled && appearance === "transparent" && rootStyles.transparent, !disabled && selected && rootStyles.selected, disabled && rootStyles.disabled];
  slot.className = mergeClasses(
    rootStyles.button,
    // orientation
    vertical ? rootStyles.vertical : rootStyles.horizontal,
    // size
    size3 === "small" && (vertical ? rootStyles.smallVertical : rootStyles.smallHorizontal),
    size3 === "medium" && (vertical ? rootStyles.mediumVertical : rootStyles.mediumHorizontal),
    size3 === "large" && (vertical ? rootStyles.largeVertical : rootStyles.largeHorizontal),
    ...isCircular ? circularAppearance : regularAppearance,
    disabled && rootStyles.disabledCursor,
    slot.className
  );
  return state;
};
var useTabContentStyles_unstable = (state) => {
  "use no memo";
  const iconStyles = useIconStyles7();
  const contentStyles = useContentStyles3();
  const {
    selected,
    size: size3
  } = state;
  if (state.icon) {
    state.icon.className = mergeClasses(tabClassNames.icon, iconStyles.base, iconStyles[size3], selected && iconStyles.selected, state.icon.className);
  }
  if (state.contentReservedSpace) {
    state.contentReservedSpace.className = mergeClasses(tabReservedSpaceClassNames.content, contentStyles.base, size3 === "large" ? contentStyles.largeSelected : contentStyles.selected, state.icon ? contentStyles.iconBefore : contentStyles.noIconBefore, contentStyles.placeholder, state.content.className);
    state.contentReservedSpaceClassName = state.contentReservedSpace.className;
  }
  state.content.className = mergeClasses(tabClassNames.content, contentStyles.base, size3 === "large" && contentStyles.large, selected && (size3 === "large" ? contentStyles.largeSelected : contentStyles.selected), state.icon ? contentStyles.iconBefore : contentStyles.noIconBefore, state.content.className);
  return state;
};

// node_modules/@fluentui/react-tabs/lib/components/Tab/Tab.js
var Tab2 = React255.forwardRef((props, ref) => {
  const state = useTab_unstable(props, ref);
  useTabStyles_unstable(state);
  useCustomStyleHook("useTabStyles_unstable")(state);
  return renderTab_unstable(state);
});
Tab2.displayName = "Tab";

// node_modules/@fluentui/react-tabs/lib/components/TabList/TabList.js
var React257 = __toESM(require_react());

// node_modules/@fluentui/react-tabs/lib/components/TabList/useTabList.js
var React256 = __toESM(require_react());
var useTabList_unstable = (props, ref) => {
  const { appearance = "transparent", reserveSelectedTabSpace = true, disabled = false, onTabSelect, selectTabOnFocus = false, size: size3 = "medium", vertical = false } = props;
  const innerRef = React256.useRef(null);
  const focusAttributes = useArrowNavigationGroup({
    circular: true,
    axis: vertical ? "vertical" : "horizontal",
    memorizeCurrent: false,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_hasDefault: true
  });
  const [selectedValue, setSelectedValue] = useControllableState({
    state: props.selectedValue,
    defaultState: props.defaultSelectedValue,
    initialState: void 0
  });
  const currentSelectedValue = React256.useRef(void 0);
  const previousSelectedValue = React256.useRef(void 0);
  React256.useEffect(() => {
    previousSelectedValue.current = currentSelectedValue.current;
    currentSelectedValue.current = selectedValue;
  }, [
    selectedValue
  ]);
  const onSelect = useEventCallback((event, data) => {
    setSelectedValue(data.value);
    onTabSelect === null || onTabSelect === void 0 ? void 0 : onTabSelect(event, data);
  });
  const registeredTabs = React256.useRef({});
  const onRegister = useEventCallback((data) => {
    const key = JSON.stringify(data.value);
    if (!key && true) {
      console.error([
        `[@fluentui/react-tabs] The value "${data.value}" cannot be serialized to JSON string.`,
        "Tab component requires serializable values.",
        "Please provide a primitive value (string, number, boolean),",
        `or a plain object/array that doesn't contain functions, symbols, or circular references.`
      ].join(" "));
    }
    registeredTabs.current[key] = data;
  });
  const onUnregister = useEventCallback((data) => {
    delete registeredTabs.current[JSON.stringify(data.value)];
  });
  const getRegisteredTabs = React256.useCallback(() => {
    return {
      selectedValue: currentSelectedValue.current,
      previousSelectedValue: previousSelectedValue.current,
      registeredTabs: registeredTabs.current
    };
  }, []);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, innerRef),
      role: "tablist",
      "aria-orientation": vertical ? "vertical" : "horizontal",
      ...focusAttributes,
      ...props
    }), {
      elementType: "div"
    }),
    appearance,
    reserveSelectedTabSpace,
    disabled,
    selectTabOnFocus,
    selectedValue,
    size: size3,
    vertical,
    onRegister,
    onUnregister,
    onSelect,
    getRegisteredTabs
  };
};

// node_modules/@fluentui/react-tabs/lib/components/TabList/renderTabList.js
var renderTabList_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(TabListProvider, {
      value: contextValues.tabList,
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-tabs/lib/components/TabList/useTabListStyles.styles.js
var tabListClassNames = {
  root: "fui-TabList"
};
var useStyles31 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    Bnnss6s: "fi64zpg",
    Eh141a: "flvyvdh",
    qhf8xq: "f10pi13n"
  },
  horizontal: {
    Bt984gj: "f1q9h2pe",
    Beiy3e4: "f1063pyq"
  },
  vertical: {
    Bt984gj: "f1q9h2pe",
    Beiy3e4: "f1vx9l62"
  },
  roundedSmall: {
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1eyhf9v"
  },
  rounded: {
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "faqewft"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".fi64zpg{flex-shrink:0;}", ".flvyvdh{flex-wrap:nowrap;}", ".f10pi13n{position:relative;}", ".f1q9h2pe{align-items:stretch;}", ".f1vx9l62{flex-direction:column;}", [".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", {
    p: -1
  }], [".faqewft{gap:var(--spacingHorizontalS);}", {
    p: -1
  }]]
});
var useTabListStyles_unstable = (state) => {
  "use no memo";
  const {
    appearance,
    vertical,
    size: size3
  } = state;
  const styles = useStyles31();
  const isRounded = appearance === "subtle-circular" || appearance === "filled-circular";
  state.root.className = mergeClasses(tabListClassNames.root, styles.root, vertical ? styles.vertical : styles.horizontal, isRounded && (size3 === "small" ? styles.roundedSmall : styles.rounded), state.root.className);
  return state;
};

// node_modules/@fluentui/react-tabs/lib/components/TabList/useTabListContextValues.js
function useTabListContextValues_unstable(state) {
  const { appearance, reserveSelectedTabSpace, disabled, selectTabOnFocus, selectedValue: selectedKey, onRegister, onUnregister, onSelect, getRegisteredTabs, size: size3, vertical } = state;
  const tabList = {
    appearance,
    reserveSelectedTabSpace,
    disabled,
    selectTabOnFocus,
    selectedValue: selectedKey,
    onSelect,
    onRegister,
    onUnregister,
    getRegisteredTabs,
    size: size3,
    vertical
  };
  return {
    tabList
  };
}

// node_modules/@fluentui/react-tabs/lib/components/TabList/TabList.js
var TabList = React257.forwardRef((props, ref) => {
  const state = useTabList_unstable(props, ref);
  const contextValues = useTabListContextValues_unstable(state);
  useTabListStyles_unstable(state);
  useCustomStyleHook("useTabListStyles_unstable")(state);
  return renderTabList_unstable(state, contextValues);
});
TabList.displayName = "TabList";

// node_modules/@fluentui/react-text/lib/components/Text/Text.js
var React259 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/Text/useText.js
var React258 = __toESM(require_react());
var useText_unstable = (props, ref) => {
  const { wrap, truncate, block, italic, underline, strikethrough, size: size3, font, weight, align } = props;
  const state = {
    align: align !== null && align !== void 0 ? align : "start",
    block: block !== null && block !== void 0 ? block : false,
    font: font !== null && font !== void 0 ? font : "base",
    italic: italic !== null && italic !== void 0 ? italic : false,
    size: size3 !== null && size3 !== void 0 ? size3 : 300,
    strikethrough: strikethrough !== null && strikethrough !== void 0 ? strikethrough : false,
    truncate: truncate !== null && truncate !== void 0 ? truncate : false,
    underline: underline !== null && underline !== void 0 ? underline : false,
    weight: weight !== null && weight !== void 0 ? weight : "regular",
    wrap: wrap !== null && wrap !== void 0 ? wrap : true,
    components: {
      root: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("span", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLHeadingElement & HTMLPreElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "span"
    })
  };
  return state;
};

// node_modules/@fluentui/react-text/lib/components/Text/renderText.js
var renderText_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-text/lib/components/Text/useTextStyles.styles.js
var textClassNames = {
  root: "fui-Text"
};
var useStyles32 = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bg96gwp: "f1i3iumi",
    Bhrd7zp: "figsok6",
    fsow6f: "fpgzoln",
    mc9l5x: "f1w7gpdv",
    Huce71: "f6juhto",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1gl81tg",
    ygn44y: "f2jf649"
  },
  nowrap: {
    Huce71: "fz5stix",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp"
  },
  truncate: {
    ygn44y: "f1cmbuwj"
  },
  block: {
    mc9l5x: "ftgm304"
  },
  italic: {
    B80ckks: "f1j4dglz"
  },
  underline: {
    w71qe1: "f13mvf36"
  },
  strikethrough: {
    w71qe1: "fv5q2k7"
  },
  strikethroughUnderline: {
    w71qe1: "f1drk4o6"
  },
  base100: {
    Be2twd7: "f13mqy1h",
    Bg96gwp: "fcpl73t"
  },
  base200: {
    Be2twd7: "fy9rknc",
    Bg96gwp: "fwrc4pm"
  },
  base400: {
    Be2twd7: "fod5ikn",
    Bg96gwp: "faaz57k"
  },
  base500: {
    Be2twd7: "f1pp30po",
    Bg96gwp: "f106mvju"
  },
  base600: {
    Be2twd7: "f1x0m3f5",
    Bg96gwp: "fb86gi6"
  },
  hero700: {
    Be2twd7: "fojgt09",
    Bg96gwp: "fcen8rp"
  },
  hero800: {
    Be2twd7: "fccw675",
    Bg96gwp: "f1ebx5kk"
  },
  hero900: {
    Be2twd7: "f15afnhw",
    Bg96gwp: "fr3w3wp"
  },
  hero1000: {
    Be2twd7: "fpyltcb",
    Bg96gwp: "f1ivgwrt"
  },
  monospace: {
    Bahqtrf: "f1fedwem"
  },
  numeric: {
    Bahqtrf: "f1uq0ln5"
  },
  weightMedium: {
    Bhrd7zp: "fdj6btp"
  },
  weightSemibold: {
    Bhrd7zp: "fl43uef"
  },
  weightBold: {
    Bhrd7zp: "flh3ekv"
  },
  alignCenter: {
    fsow6f: "f17mccla"
  },
  alignEnd: {
    fsow6f: "f12ymhq5"
  },
  alignJustify: {
    fsow6f: "f1j59e10"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fpgzoln{text-align:start;}", ".f1w7gpdv{display:inline;}", ".f6juhto{white-space:normal;}", [".f1gl81tg{overflow:visible;}", {
    p: -1
  }], ".f2jf649{text-overflow:clip;}", ".fz5stix{white-space:nowrap;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], ".f1cmbuwj{text-overflow:ellipsis;}", ".ftgm304{display:block;}", ".f1j4dglz{font-style:italic;}", ".f13mvf36{text-decoration-line:underline;}", ".fv5q2k7{text-decoration-line:line-through;}", ".f1drk4o6{text-decoration-line:line-through underline;}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fcpl73t{line-height:var(--lineHeightBase100);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f106mvju{line-height:var(--lineHeightBase500);}", ".f1x0m3f5{font-size:var(--fontSizeBase600);}", ".fb86gi6{line-height:var(--lineHeightBase600);}", ".fojgt09{font-size:var(--fontSizeHero700);}", ".fcen8rp{line-height:var(--lineHeightHero700);}", ".fccw675{font-size:var(--fontSizeHero800);}", ".f1ebx5kk{line-height:var(--lineHeightHero800);}", ".f15afnhw{font-size:var(--fontSizeHero900);}", ".fr3w3wp{line-height:var(--lineHeightHero900);}", ".fpyltcb{font-size:var(--fontSizeHero1000);}", ".f1ivgwrt{line-height:var(--lineHeightHero1000);}", ".f1fedwem{font-family:var(--fontFamilyMonospace);}", ".f1uq0ln5{font-family:var(--fontFamilyNumeric);}", ".fdj6btp{font-weight:var(--fontWeightMedium);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".flh3ekv{font-weight:var(--fontWeightBold);}", ".f17mccla{text-align:center;}", ".f12ymhq5{text-align:end;}", ".f1j59e10{text-align:justify;}"]
});
var useTextStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles32();
  state.root.className = mergeClasses(textClassNames.root, styles.root, state.wrap === false && styles.nowrap, state.truncate && styles.truncate, state.block && styles.block, state.italic && styles.italic, state.underline && styles.underline, state.strikethrough && styles.strikethrough, state.underline && state.strikethrough && styles.strikethroughUnderline, state.size === 100 && styles.base100, state.size === 200 && styles.base200, state.size === 400 && styles.base400, state.size === 500 && styles.base500, state.size === 600 && styles.base600, state.size === 700 && styles.hero700, state.size === 800 && styles.hero800, state.size === 900 && styles.hero900, state.size === 1e3 && styles.hero1000, state.font === "monospace" && styles.monospace, state.font === "numeric" && styles.numeric, state.weight === "medium" && styles.weightMedium, state.weight === "semibold" && styles.weightSemibold, state.weight === "bold" && styles.weightBold, state.align === "center" && styles.alignCenter, state.align === "end" && styles.alignEnd, state.align === "justify" && styles.alignJustify, state.root.className);
  return state;
};

// node_modules/@fluentui/react-text/lib/components/Text/Text.js
var Text = React259.forwardRef((props, ref) => {
  const state = useText_unstable(props, ref);
  useTextStyles_unstable(state);
  useCustomStyleHook("useTextStyles_unstable")(state);
  return renderText_unstable(state);
});
Text.displayName = "Text";

// node_modules/@fluentui/react-text/lib/components/presets/Body1/Body1.js
var React261 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/createPreset.js
var React260 = __toESM(require_react());
function createPreset(options) {
  const { useStyles: useStyles109, className, displayName } = options;
  const Wrapper = React260.forwardRef((props, ref) => {
    "use no memo";
    const styles = useStyles109();
    const state = useText_unstable(props, ref);
    useTextStyles_unstable(state);
    state.root.className = mergeClasses(className, state.root.className, styles.root, props.className);
    return renderText_unstable(state);
  });
  Wrapper.displayName = displayName;
  return Wrapper;
}

// node_modules/@fluentui/react-text/lib/components/presets/Body1/useBody1Styles.styles.js
var body1ClassNames = {
  root: "fui-Body1"
};
var useBody1Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Body1/Body1.js
var Body1 = createPreset({
  useStyles: useBody1Styles,
  className: body1ClassNames.root,
  displayName: "Body1"
});

// node_modules/@fluentui/react-text/lib/components/presets/Body1Strong/Body1Strong.js
var React262 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Body1Strong/useBody1StrongStyles.styles.js
var body1StrongClassNames = {
  root: "fui-Body1Strong"
};
var useBody1StrongStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Body1Strong/Body1Strong.js
var Body1Strong = createPreset({
  useStyles: useBody1StrongStyles,
  className: body1StrongClassNames.root,
  displayName: "Body1Strong"
});

// node_modules/@fluentui/react-text/lib/components/presets/Body1Stronger/Body1Stronger.js
var React263 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Body1Stronger/useBody1StrongerStyles.styles.js
var body1StrongerClassNames = {
  root: "fui-Body1Stronger"
};
var useBody1StrongerStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "flh3ekv",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".flh3ekv{font-weight:var(--fontWeightBold);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Body1Stronger/Body1Stronger.js
var Body1Stronger = createPreset({
  useStyles: useBody1StrongerStyles,
  className: body1StrongerClassNames.root,
  displayName: "Body1Stronger"
});

// node_modules/@fluentui/react-text/lib/components/presets/Body2/Body2.js
var React264 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Body2/useBody2Styles.styles.js
var body2ClassNames = {
  root: "fui-Body2"
};
var useBody2Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".faaz57k{line-height:var(--lineHeightBase400);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Body2/Body2.js
var Body2 = createPreset({
  useStyles: useBody2Styles,
  className: body2ClassNames.root,
  displayName: "Body2"
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption1/Caption1.js
var React265 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Caption1/useCaption1Styles.styles.js
var caption1ClassNames = {
  root: "fui-Caption1"
};
var useCaption1Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption1/Caption1.js
var Caption1 = createPreset({
  useStyles: useCaption1Styles,
  className: caption1ClassNames.root,
  displayName: "Caption1"
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption1Strong/Caption1Strong.js
var React266 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Caption1Strong/useCaption1StrongStyles.styles.js
var caption1StrongClassNames = {
  root: "fui-Caption1Strong"
};
var useCaption1StrongStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fwrc4pm"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption1Strong/Caption1Strong.js
var Caption1Strong = createPreset({
  useStyles: useCaption1StrongStyles,
  className: caption1StrongClassNames.root,
  displayName: "Caption1Strong"
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption1Stronger/Caption1Stronger.js
var React267 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Caption1Stronger/useCaption1Stronger.styles.js
var caption1StrongerClassNames = {
  root: "fui-Caption1Stronger"
};
var useCaption1StrongerStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "flh3ekv",
    Bg96gwp: "fwrc4pm"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".flh3ekv{font-weight:var(--fontWeightBold);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption1Stronger/Caption1Stronger.js
var Caption1Stronger = createPreset({
  useStyles: useCaption1StrongerStyles,
  className: caption1StrongerClassNames.root,
  displayName: "Caption1Stronger"
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption2/Caption2.js
var React268 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Caption2/useCaption2Styles.styles.js
var caption2ClassNames = {
  root: "fui-Caption2"
};
var useCaption2Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f13mqy1h",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fcpl73t"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fcpl73t{line-height:var(--lineHeightBase100);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption2/Caption2.js
var Caption2 = createPreset({
  useStyles: useCaption2Styles,
  className: caption2ClassNames.root,
  displayName: "Caption2"
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption2Strong/Caption2Strong.js
var React269 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Caption2Strong/useCaption2StrongStyles.styles.js
var caption2StrongClassNames = {
  root: "fui-Caption2Strong"
};
var useCaption2StrongStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f13mqy1h",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fcpl73t"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fcpl73t{line-height:var(--lineHeightBase100);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption2Strong/Caption2Strong.js
var Caption2Strong = createPreset({
  useStyles: useCaption2StrongStyles,
  className: caption2StrongClassNames.root,
  displayName: "Caption2Strong"
});

// node_modules/@fluentui/react-text/lib/components/presets/Display/Display.js
var React270 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Display/useDisplayStyles.styles.js
var displayClassNames = {
  root: "fui-Display"
};
var useDisplayStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fpyltcb",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1ivgwrt"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fpyltcb{font-size:var(--fontSizeHero1000);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f1ivgwrt{line-height:var(--lineHeightHero1000);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Display/Display.js
var Display = createPreset({
  useStyles: useDisplayStyles,
  className: displayClassNames.root,
  displayName: "Display"
});

// node_modules/@fluentui/react-text/lib/components/presets/LargeTitle/LargeTitle.js
var React271 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/LargeTitle/useLargeTitleStyles.styles.js
var largeTitleClassNames = {
  root: "fui-LargeTitle"
};
var useLargeTitleStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f15afnhw",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fr3w3wp"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f15afnhw{font-size:var(--fontSizeHero900);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fr3w3wp{line-height:var(--lineHeightHero900);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/LargeTitle/LargeTitle.js
var LargeTitle = createPreset({
  useStyles: useLargeTitleStyles,
  className: largeTitleClassNames.root,
  displayName: "LargeTitle"
});

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle1/Subtitle1.js
var React272 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle1/useSubtitle1Styles.styles.js
var subtitle1ClassNames = {
  root: "fui-Subtitle1"
};
var useSubtitle1Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f1pp30po",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f106mvju"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f106mvju{line-height:var(--lineHeightBase500);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle1/Subtitle1.js
var Subtitle1 = createPreset({
  useStyles: useSubtitle1Styles,
  className: subtitle1ClassNames.root,
  displayName: "Subtitle1"
});

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle2/Subtitle2.js
var React273 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle2/useSubtitle2Styles.styles.js
var subtitle2ClassNames = {
  root: "fui-Subtitle2"
};
var useSubtitle2Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle2/Subtitle2.js
var Subtitle2 = createPreset({
  useStyles: useSubtitle2Styles,
  className: subtitle2ClassNames.root,
  displayName: "Subtitle2"
});

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle2Stronger/Subtitle2Stronger.js
var React274 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle2Stronger/useSubtitle2Stronger.styles.js
var subtitle2StrongerClassNames = {
  root: "fui-Subtitle2Stronger"
};
var useSubtitle2StrongerStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "flh3ekv",
    Bg96gwp: "faaz57k"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".flh3ekv{font-weight:var(--fontWeightBold);}", ".faaz57k{line-height:var(--lineHeightBase400);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle2Stronger/Subtitle2Stronger.js
var Subtitle2Stronger = createPreset({
  useStyles: useSubtitle2StrongerStyles,
  className: subtitle2StrongerClassNames.root,
  displayName: "Subtitle2Stronger"
});

// node_modules/@fluentui/react-text/lib/components/presets/Title1/Title1.js
var React275 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Title1/useTitle1Styles.styles.js
var title1ClassNames = {
  root: "fui-Title1"
};
var useTitle1Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fccw675",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1ebx5kk"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fccw675{font-size:var(--fontSizeHero800);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f1ebx5kk{line-height:var(--lineHeightHero800);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Title1/Title1.js
var Title1 = createPreset({
  useStyles: useTitle1Styles,
  className: title1ClassNames.root,
  displayName: "Title1"
});

// node_modules/@fluentui/react-text/lib/components/presets/Title2/Title2.js
var React276 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Title2/useTitle2Styles.styles.js
var title2ClassNames = {
  root: "fui-Title2"
};
var useTitle2Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fojgt09",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fcen8rp"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fojgt09{font-size:var(--fontSizeHero700);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fcen8rp{line-height:var(--lineHeightHero700);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Title2/Title2.js
var Title2 = createPreset({
  useStyles: useTitle2Styles,
  className: title2ClassNames.root,
  displayName: "Title2"
});

// node_modules/@fluentui/react-text/lib/components/presets/Title3/Title3.js
var React277 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Title3/useTitle3Styles.styles.js
var title3ClassNames = {
  root: "fui-Title3"
};
var useTitle3Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f1x0m3f5",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fb86gi6"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1x0m3f5{font-size:var(--fontSizeBase600);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fb86gi6{line-height:var(--lineHeightBase600);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Title3/Title3.js
var Title3 = createPreset({
  useStyles: useTitle3Styles,
  className: title3ClassNames.root,
  displayName: "Title3"
});

// node_modules/@fluentui/react-textarea/lib/components/Textarea/Textarea.js
var React279 = __toESM(require_react());

// node_modules/@fluentui/react-textarea/lib/components/Textarea/renderTextarea.js
var renderTextarea_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(state.textarea, {})
  });
};

// node_modules/@fluentui/react-textarea/lib/components/Textarea/useTextarea.js
var React278 = __toESM(require_react());
var useTextarea_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true,
    supportsSize: true
  });
  const overrides = useOverrides();
  var _overrides_inputDefaultAppearance;
  const { size: size3 = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", resize = "none", onChange } = props;
  if (appearance === "filled-darker-shadow" || appearance === "filled-lighter-shadow") {
    console.error("The 'filled-darker-shadow' and 'filled-lighter-shadow' appearances are deprecated and will be removed in the future.");
  }
  const [value, setValue] = useControllableState({
    state: props.value,
    defaultState: props.defaultValue,
    initialState: void 0
  });
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "textarea",
    excludedPropNames: [
      "onChange",
      "value",
      "defaultValue"
    ]
  });
  const state = {
    size: size3,
    appearance,
    resize,
    components: {
      root: "span",
      textarea: "textarea"
    },
    textarea: slot_exports.always(props.textarea, {
      defaultProps: {
        ref,
        ...nativeProps.primary
      },
      elementType: "textarea"
    }),
    root: slot_exports.always(props.root, {
      defaultProps: nativeProps.root,
      elementType: "span"
    })
  };
  state.textarea.value = value;
  state.textarea.onChange = useEventCallback((ev) => {
    const newValue = ev.target.value;
    onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
      value: newValue
    });
    setValue(newValue);
  });
  return state;
};

// node_modules/@fluentui/react-textarea/lib/components/Textarea/useTextareaStyles.styles.js
var textareaClassNames = {
  root: "fui-Textarea",
  textarea: "fui-Textarea__textarea"
};
var useRootStyles16 = __styles2({
  base: {
    mc9l5x: "ftuwxu6",
    B7ck84d: "f1ewtqcl",
    qhf8xq: "f10pi13n",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1yiegib",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    ha4doy: "f12kltsn"
  },
  disabled: {
    De3pzq: "f1c21dwh",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "ff3nzm7",
    Bjwas2f: "fg455y9",
    Bn1d65q: ["f1rvyvqg", "f14g86mu"],
    Bxeuatn: "f1cwzwz",
    n51gp8: ["f14g86mu", "f1rvyvqg"]
  },
  interactive: {
    li1rpt: "f1gw3sf2",
    Bsft5z2: "f13zj6fq",
    E3zdtr: "f1mdlcz9",
    Eqx8gd: ["f1a7op3", "f1cjjd47"],
    By385i5: "f1gboi2j",
    B1piin3: ["f1cjjd47", "f1a7op3"],
    Dlnsje: "ffyw7fx",
    d9w3h3: ["f1kp91vd", "f1ibwz09"],
    B3778ie: ["f1ibwz09", "f1kp91vd"],
    B1q35kw: 0,
    Bw17bha: 0,
    Bcgy8vk: 0,
    Bjuhk93: "f1mnjydx",
    Gjdm7m: "fj2g8qd",
    b1kco5: "f1yk9hq",
    Ba2ppi3: "fhwpy7i",
    F2fol1: "f14ee0xe",
    lck23g: "f1xhbsuh",
    df92cz: "fv8e3ye",
    I188md: "ftb5wc6",
    umuwi5: "fjw5xc1",
    Blcqepd: "f1xdyd5c",
    nplu4u: "fatpbeo",
    Bioka5o: "fb7uyps",
    H713fs: "f1cmft4k",
    B9ooomg: "f1x58t8o",
    Bercvud: "f1ibeo51",
    Bbr2w1p: "f1vnc8sk",
    Bduesf4: "f3e99gv",
    Bpq79vn: "fhljsf7"
  },
  filled: {
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w",
    q7v0qe: "ftmjh5b",
    kmh5ft: ["f17blpuu", "fsrcdbj"],
    nagaa4: "f1tpwn32",
    B1yhkcb: ["fsrcdbj", "f17blpuu"]
  },
  "filled-darker": {
    De3pzq: "f16xq7d1"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r"
  },
  "filled-darker-shadow": {
    De3pzq: "f16xq7d1",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f1gmd7mu",
    E5pizo: "fyed02w"
  },
  "filled-lighter-shadow": {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f1gmd7mu",
    E5pizo: "fyed02w"
  },
  outline: {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: "f1c1zstj",
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fhz96rm"
  },
  outlineInteractive: {
    kzujx5: 0,
    oetu4i: "f1l4zc64",
    gvrnp0: 0,
    xv9156: 0,
    jek2p4: 0,
    gg5e9n: 0,
    Beu9t3s: 0,
    dt87k2: 0,
    Bt1vbvt: 0,
    Bwzppfd: 0,
    Bop6t4b: 0,
    B2zwrfe: 0,
    Bwp2tzp: 0,
    Bgoe8wy: 0,
    Bf40cpq: 0,
    ckks6v: 0,
    Baalond: "f9mts5e",
    v2iqwr: 0,
    wmxk5l: "f1z0osm6",
    Bj33j0h: 0,
    Bs0cc2w: 0,
    qwjtx1: 0,
    B50zh58: 0,
    f7epvg: 0,
    e1hlit: 0,
    B7mkhst: 0,
    ak43y8: 0,
    Bbcopvn: 0,
    Bvecx4l: 0,
    lwioe0: 0,
    B6oc9vd: 0,
    e2sjt0: 0,
    uqwnxt: 0,
    asj8p9: "f1acnei2",
    Br8fjdy: 0,
    zoxjo1: "f1so894s",
    Bt3ojkv: 0,
    B7pmvfx: 0,
    Bfht2n1: 0,
    an54nd: 0,
    t1ykpo: 0,
    Belqbek: 0,
    bbt1vd: 0,
    Brahy3i: 0,
    r7b1zc: 0,
    rexu52: 0,
    ovtnii: 0,
    Bvq3b66: 0,
    Bawrxx6: 0,
    Bbs6y8j: 0,
    B2qpgjt: "f19ezbcq"
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".f1ewtqcl{box-sizing:border-box;}", ".f10pi13n{position:relative;}", [".f1yiegib{padding:0 0 var(--strokeWidthThick) 0;}", {
    p: -1
  }], [".f1s184ao{margin:0;}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f12kltsn{vertical-align:top;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".ff3nzm7{border:var(--strokeWidthThin) solid var(--colorNeutralStrokeDisabled);}", {
    p: -2
  }], ".f1gw3sf2::after{box-sizing:border-box;}", '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1a7op3::after{left:-1px;}", ".f1cjjd47::after{right:-1px;}", ".f1gboi2j::after{bottom:-1px;}", ".ffyw7fx::after{height:max(var(--strokeWidthThick), var(--borderRadiusMedium));}", ".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}", [".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", {
    p: -1
  }], ".fj2g8qd::after{clip-path:inset(calc(100% - var(--strokeWidthThick)) 0 0 0);}", ".f1yk9hq::after{transform:scaleX(0);}", ".fhwpy7i::after{transition-property:transform;}", ".f14ee0xe::after{transition-duration:var(--durationUltraFast);}", ".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}", [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".f1gmd7mu{border:var(--strokeWidthThin) solid var(--colorTransparentStrokeInteractive);}", {
    p: -2
  }], ".fyed02w{box-shadow:var(--shadow2);}", [".f1gmd7mu{border:var(--strokeWidthThin) solid var(--colorTransparentStrokeInteractive);}", {
    p: -2
  }], [".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", {
    p: -2
  }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}"],
  m: [["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.fv8e3ye::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.ftb5wc6::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1cmft4k:focus-within::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1x58t8o:focus-within::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }]],
  w: [".fjw5xc1:focus-within::after{transform:scaleX(1);}", ".f1xdyd5c:focus-within::after{transition-property:transform;}", ".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}", ".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}", ".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".f1vnc8sk:focus-within{outline-width:var(--strokeWidthThick);}", ".f3e99gv:focus-within{outline-style:solid;}", ".fhljsf7:focus-within{outline-color:transparent;}", [".f19ezbcq:focus-within{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Pressed);}", {
    p: -2
  }], ".f1so894s:focus-within{border-bottom-color:var(--colorCompoundBrandStroke);}"],
  h: [".ftmjh5b:hover,.ftmjh5b:focus-within{border-top-color:var(--colorTransparentStrokeInteractive);}", ".f17blpuu:hover,.f17blpuu:focus-within{border-right-color:var(--colorTransparentStrokeInteractive);}", ".fsrcdbj:hover,.fsrcdbj:focus-within{border-left-color:var(--colorTransparentStrokeInteractive);}", ".f1tpwn32:hover,.f1tpwn32:focus-within{border-bottom-color:var(--colorTransparentStrokeInteractive);}", [".f9mts5e:hover{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Hover);}", {
    p: -2
  }], ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"],
  a: [[".f1acnei2:active{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Pressed);}", {
    p: -2
  }], ".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"]
});
var useTextareaStyles = __styles2({
  base: {
    icvyot: "f1ern45e",
    vrafjx: ["f1n71otn", "f1deefiw"],
    oivjwe: "f1h8hb77",
    wvpqe5: ["f1deefiw", "f1n71otn"],
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    De3pzq: "f3rmtva",
    B7ck84d: "f1ewtqcl",
    sj55zd: "f19n0e5",
    Bh6795r: "fqerorx",
    Bahqtrf: "fk6fouc",
    Bqenvij: "f1l02sjl",
    yvdlaj: "fwyc1cq",
    B3o7kgh: "f13ta7ih",
    oeaueh: "f1s6fcnf"
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr",
    yvdlaj: "fahhnxm"
  },
  small: {
    sshi5w: "f1w5jphr",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1pnffij",
    Bxyxcbc: "f192z54u",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  medium: {
    sshi5w: "fvmd9f",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1ww82xo",
    Bxyxcbc: "f1if7ixc",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  large: {
    sshi5w: "f1kfson",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f15hvtkj",
    Bxyxcbc: "f3kip1f",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k"
  }
}, {
  d: [".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1h8hb77{border-bottom-style:none;}", [".f1s184ao{margin:0;}", {
    p: -1
  }], ".f3rmtva{background-color:transparent;}", ".f1ewtqcl{box-sizing:border-box;}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fqerorx{flex-grow:1;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1l02sjl{height:100%;}", ".fwyc1cq::-webkit-input-placeholder{color:var(--colorNeutralForeground4);}", ".fwyc1cq::-moz-placeholder{color:var(--colorNeutralForeground4);}", ".f13ta7ih::-webkit-input-placeholder{opacity:1;}", ".f13ta7ih::-moz-placeholder{opacity:1;}", ".f1s6fcnf{outline-style:none;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".f1w5jphr{min-height:40px;}", [".f1pnffij{padding:var(--spacingVerticalXS) calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], ".f192z54u{max-height:200px;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fvmd9f{min-height:52px;}", [".f1ww82xo{padding:var(--spacingVerticalSNudge) calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], ".f1if7ixc{max-height:260px;}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1kfson{min-height:64px;}", [".f15hvtkj{padding:var(--spacingVerticalS) calc(var(--spacingHorizontalM) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], ".f3kip1f{max-height:320px;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}"]
});
var useTextareaResizeStyles = __styles2({
  none: {
    B3rzk8w: "f1o1s39h"
  },
  both: {
    B3rzk8w: "f1pxm0xe"
  },
  horizontal: {
    B3rzk8w: "fq6nmtn"
  },
  vertical: {
    B3rzk8w: "f1f5ktr4"
  }
}, {
  d: [".f1o1s39h{resize:none;}", ".f1pxm0xe{resize:both;}", ".fq6nmtn{resize:horizontal;}", ".f1f5ktr4{resize:vertical;}"]
});
var useTextareaStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3,
    appearance,
    resize
  } = state;
  const disabled = state.textarea.disabled;
  const invalid = `${state.textarea["aria-invalid"]}` === "true";
  const filled = appearance.startsWith("filled");
  const rootStyles = useRootStyles16();
  state.root.className = mergeClasses(textareaClassNames.root, rootStyles.base, disabled && rootStyles.disabled, !disabled && filled && rootStyles.filled, !disabled && rootStyles[appearance], !disabled && rootStyles.interactive, !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && invalid && rootStyles.invalid, state.root.className);
  const textareaStyles = useTextareaStyles();
  const textareaResizeStyles = useTextareaResizeStyles();
  state.textarea.className = mergeClasses(textareaClassNames.textarea, textareaStyles.base, textareaStyles[size3], textareaResizeStyles[resize], disabled && textareaStyles.disabled, state.textarea.className);
  return state;
};

// node_modules/@fluentui/react-textarea/lib/components/Textarea/Textarea.js
var Textarea = React279.forwardRef((props, ref) => {
  const state = useTextarea_unstable(props, ref);
  useTextareaStyles_unstable(state);
  useCustomStyleHook("useTextareaStyles_unstable")(state);
  return renderTextarea_unstable(state);
});
Textarea.displayName = "Textarea";

// node_modules/@fluentui/react-dialog/lib/components/Dialog/Dialog.js
var React287 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialog.js
var React284 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.js
var React280 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.styles.js
var useHTMLNoScrollStyles = __resetStyles("r6pzz3z", null, [".r6pzz3z{overflow-y:hidden;overflow-y:clip;scrollbar-gutter:stable;}"]);
var useBodyNoScrollStyles = __resetStyles("r144vlu9", null, [".r144vlu9{overflow-y:hidden;}"]);

// node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.js
function useDisableBodyScroll() {
  const htmlNoScrollStyles = useHTMLNoScrollStyles();
  const bodyNoScrollStyles = useBodyNoScrollStyles();
  const { targetDocument } = useFluent();
  const disableBodyScroll = React280.useCallback(() => {
    var _targetDocument_defaultView;
    if (!targetDocument) {
      return;
    }
    var _targetDocument_defaultView_innerHeight;
    const isHorizontalScrollbarVisible = (
      // When the window is a fractional height, `innerHeight` always rounds down but `clientHeight` rounds either up or down depending on the value.
      // To properly compare the body clientHeight to the window innerHeight, manually round down the fractional value to match innerHeight's calculation.
      Math.floor(targetDocument.body.getBoundingClientRect().height) > ((_targetDocument_defaultView_innerHeight = (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.innerHeight) !== null && _targetDocument_defaultView_innerHeight !== void 0 ? _targetDocument_defaultView_innerHeight : 0)
    );
    if (!isHorizontalScrollbarVisible) {
      return;
    }
    targetDocument.documentElement.classList.add(htmlNoScrollStyles);
    targetDocument.body.classList.add(bodyNoScrollStyles);
    return;
  }, [
    targetDocument,
    htmlNoScrollStyles,
    bodyNoScrollStyles
  ]);
  const enableBodyScroll = React280.useCallback(() => {
    if (!targetDocument) {
      return;
    }
    targetDocument.documentElement.classList.remove(htmlNoScrollStyles);
    targetDocument.body.classList.remove(bodyNoScrollStyles);
  }, [
    targetDocument,
    htmlNoScrollStyles,
    bodyNoScrollStyles
  ]);
  return {
    disableBodyScroll,
    enableBodyScroll
  };
}

// node_modules/@fluentui/react-dialog/lib/utils/useFocusFirstElement.js
var React281 = __toESM(require_react());
function useFocusFirstElement(open, modalType) {
  const { findFirstFocusable } = useFocusFinders();
  const { targetDocument } = useFluent();
  const dialogRef = React281.useRef(null);
  React281.useEffect(() => {
    if (!open) {
      return;
    }
    const element = dialogRef.current && findFirstFocusable(dialogRef.current);
    if (element) {
      element.focus();
    } else {
      var _dialogRef_current;
      (_dialogRef_current = dialogRef.current) === null || _dialogRef_current === void 0 ? void 0 : _dialogRef_current.focus();
      if (true) {
        console.warn(`@fluentui/react-dialog [useFocusFirstElement]:
A Dialog should have at least one focusable element inside DialogSurface.
Please add at least a close button either on \`DialogTitle\` action slot or inside \`DialogActions\``);
      }
    }
  }, [
    findFirstFocusable,
    open,
    modalType,
    targetDocument
  ]);
  return dialogRef;
}

// node_modules/@fluentui/react-dialog/lib/contexts/dialogContext.js
var React282 = __toESM(require_react());
var defaultContextValue = {
  open: false,
  inertTrapFocus: false,
  modalType: "modal",
  isNestedDialog: false,
  dialogRef: {
    current: null
  },
  requestOpenChange() {
  }
};
var DialogContext = createContext13(void 0);
var DialogProvider = DialogContext.Provider;
var useDialogContext_unstable = (selector) => useContextSelector(DialogContext, (ctx = defaultContextValue) => selector(ctx));

// node_modules/@fluentui/react-dialog/lib/contexts/dialogSurfaceContext.js
var React283 = __toESM(require_react());
var defaultContextValue2 = false;
var DialogSurfaceContext = React283.createContext(void 0);
var DialogSurfaceProvider = DialogSurfaceContext.Provider;
var useDialogSurfaceContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React283.useContext(DialogSurfaceContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultContextValue2;
};

// node_modules/@fluentui/react-dialog/lib/components/DialogSurfaceMotion.js
var DialogSurfaceMotion = createPresenceComponentVariant(Scale, {
  fromScale: 0.85,
  easing: motionTokens.curveDecelerateMid,
  duration: motionTokens.durationGentle,
  exitEasing: motionTokens.curveAccelerateMin,
  exitDuration: motionTokens.durationGentle
});

// node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialog.js
var useDialog_unstable = (props) => {
  const { children: children2, modalType = "modal", onOpenChange, inertTrapFocus = false } = props;
  const [trigger, content] = childrenToTriggerAndContent(children2);
  const [open, setOpen] = useControllableState({
    state: props.open,
    defaultState: props.defaultOpen,
    initialState: false
  });
  const requestOpenChange = useEventCallback((data) => {
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(data.event, data);
    if (!data.event.isDefaultPrevented()) {
      setOpen(data.open);
    }
  });
  const focusRef = useFocusFirstElement(open, modalType);
  const { modalAttributes, triggerAttributes } = useModalAttributes({
    trapFocus: modalType !== "non-modal",
    legacyTrapFocus: !inertTrapFocus
  });
  const isNestedDialog = useHasParentContext(DialogContext);
  return {
    components: {
      surfaceMotion: DialogSurfaceMotion
    },
    inertTrapFocus,
    open,
    modalType,
    content,
    trigger,
    requestOpenChange,
    dialogTitleId: useId2("dialog-title-"),
    isNestedDialog,
    dialogRef: focusRef,
    modalAttributes,
    triggerAttributes,
    surfaceMotion: presenceMotionSlot(props.surfaceMotion, {
      elementType: DialogSurfaceMotion,
      defaultProps: {
        appear: true,
        visible: open,
        unmountOnExit: true
      }
    })
  };
};
function childrenToTriggerAndContent(children2) {
  const childrenArray = React284.Children.toArray(children2);
  if (true) {
    if (childrenArray.length !== 1 && childrenArray.length !== 2) {
      console.warn(`@fluentui/react-dialog [useDialog]:
Dialog must contain at least one child <DialogSurface/>,
and at most two children <DialogTrigger/> <DialogSurface/> (in this order).`);
    }
  }
  switch (childrenArray.length) {
    case 2:
      return childrenArray;
    case 1:
      return [
        void 0,
        childrenArray[0]
      ];
    default:
      return [
        void 0,
        void 0
      ];
  }
}

// node_modules/@fluentui/react-dialog/lib/components/Dialog/renderDialog.js
var React286 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/MotionRefForwarder.js
var React285 = __toESM(require_react());
var MotionRefForwarderContext = React285.createContext(void 0);
function useMotionForwardedRef() {
  return React285.useContext(MotionRefForwarderContext);
}
var MotionRefForwarder = React285.forwardRef((props, ref) => {
  return React285.createElement(MotionRefForwarderContext.Provider, {
    value: ref
  }, props.children);
});

// node_modules/@fluentui/react-dialog/lib/components/Dialog/renderDialog.js
var renderDialog_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(DialogProvider, {
    value: contextValues.dialog,
    children: jsxs(DialogSurfaceProvider, {
      value: contextValues.dialogSurface,
      children: [
        state.trigger,
        state.content && jsx(state.surfaceMotion, {
          children: jsx(MotionRefForwarder, {
            children: state.content
          })
        })
      ]
    })
  });
};

// node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialogContextValues.js
function useDialogContextValues_unstable(state) {
  const { modalType, open, dialogRef, dialogTitleId, isNestedDialog, inertTrapFocus, requestOpenChange, modalAttributes, triggerAttributes } = state;
  const dialog = {
    open,
    modalType,
    dialogRef,
    dialogTitleId,
    isNestedDialog,
    inertTrapFocus,
    modalAttributes,
    triggerAttributes,
    requestOpenChange
  };
  const dialogSurface = false;
  return {
    dialog,
    dialogSurface
  };
}

// node_modules/@fluentui/react-dialog/lib/components/Dialog/Dialog.js
var Dialog = React287.memo((props) => {
  const state = useDialog_unstable(props);
  const contextValues = useDialogContextValues_unstable(state);
  return renderDialog_unstable(state, contextValues);
});
Dialog.displayName = "Dialog";

// node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/DialogTrigger.js
var React289 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/useDialogTrigger.js
var React288 = __toESM(require_react());
var useDialogTrigger_unstable = (props) => {
  const isInsideSurfaceDialog = useDialogSurfaceContext_unstable();
  const { children: children2, disableButtonEnhancement = false, action = isInsideSurfaceDialog ? "close" : "open" } = props;
  const child = getTriggerChild(children2);
  const requestOpenChange = useDialogContext_unstable((ctx) => ctx.requestOpenChange);
  const { triggerAttributes } = useModalAttributes();
  const handleClick = useEventCallback((event) => {
    var _child_props_onClick, _child_props;
    child === null || child === void 0 ? void 0 : (_child_props_onClick = (_child_props = child.props).onClick) === null || _child_props_onClick === void 0 ? void 0 : _child_props_onClick.call(_child_props, event);
    if (!event.isDefaultPrevented()) {
      requestOpenChange({
        event,
        type: "triggerClick",
        open: action === "open"
      });
    }
  });
  const triggerChildProps = {
    ...child === null || child === void 0 ? void 0 : child.props,
    ref: getReactElementRef(child),
    onClick: handleClick,
    ...triggerAttributes
  };
  const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", {
    ...triggerChildProps,
    type: "button"
  });
  return {
    children: applyTriggerPropsToChildren(children2, disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)
  };
};

// node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/renderDialogTrigger.js
var renderDialogTrigger_unstable = (state) => state.children;

// node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/DialogTrigger.js
var DialogTrigger = (props) => {
  const state = useDialogTrigger_unstable(props);
  return renderDialogTrigger_unstable(state);
};
DialogTrigger.displayName = "DialogTrigger";
DialogTrigger.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-dialog/lib/components/DialogActions/DialogActions.js
var React291 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogActions/useDialogActions.js
var React290 = __toESM(require_react());
var useDialogActions_unstable = (props, ref) => {
  const { position = "end", fluid = false } = props;
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    position,
    fluid
  };
};

// node_modules/@fluentui/react-dialog/lib/components/DialogActions/renderDialogActions.js
var renderDialogActions_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-dialog/lib/components/DialogActions/useDialogActionsStyles.styles.js
var dialogActionsClassNames = {
  root: "fui-DialogActions"
};
var useResetStyles = __resetStyles("rhfpeu0", null, {
  r: [".rhfpeu0{gap:8px;height:fit-content;box-sizing:border-box;display:flex;grid-row-start:3;grid-row-end:3;}"],
  s: ["@media screen and (max-width: 480px){.rhfpeu0{flex-direction:column;justify-self:stretch;}}"]
});
var useStyles33 = __styles2({
  gridPositionEnd: {
    Bdqf98w: "f1a7i8kp",
    Br312pm: "fd46tj4",
    Bw0ie65: "fsyjsko",
    B6n781s: "f1f41i0t",
    Bv5d0be: "f1jaqex3",
    v4ugfu: "f2ao6jk"
  },
  gridPositionStart: {
    Bdqf98w: "fsxvdwy",
    Br312pm: "fwpfdsa",
    Bw0ie65: "f1e2fz10",
    Bojbm9c: "f11ihkml",
    Bv5d0be: "fce5bvx",
    v4ugfu: "f2ao6jk"
  },
  fluidStart: {
    Bw0ie65: "fsyjsko"
  },
  fluidEnd: {
    Br312pm: "fwpfdsa"
  }
}, {
  d: [".f1a7i8kp{justify-self:end;}", ".fd46tj4{grid-column-start:2;}", ".fsyjsko{grid-column-end:4;}", ".fsxvdwy{justify-self:start;}", ".fwpfdsa{grid-column-start:1;}", ".f1e2fz10{grid-column-end:2;}"],
  m: [["@media screen and (max-width: 480px){.f1f41i0t{grid-column-start:1;}}", {
    m: "screen and (max-width: 480px)"
  }], ["@media screen and (max-width: 480px){.f1jaqex3{grid-row-start:4;}}", {
    m: "screen and (max-width: 480px)"
  }], ["@media screen and (max-width: 480px){.f2ao6jk{grid-row-end:auto;}}", {
    m: "screen and (max-width: 480px)"
  }], ["@media screen and (max-width: 480px){.f11ihkml{grid-column-end:4;}}", {
    m: "screen and (max-width: 480px)"
  }], ["@media screen and (max-width: 480px){.fce5bvx{grid-row-start:3;}}", {
    m: "screen and (max-width: 480px)"
  }]]
});
var useDialogActionsStyles_unstable = (state) => {
  "use no memo";
  const resetStyles = useResetStyles();
  const styles = useStyles33();
  state.root.className = mergeClasses(dialogActionsClassNames.root, resetStyles, state.position === "start" && styles.gridPositionStart, state.position === "end" && styles.gridPositionEnd, state.fluid && state.position === "start" && styles.fluidStart, state.fluid && state.position === "end" && styles.fluidEnd, state.root.className);
  return state;
};

// node_modules/@fluentui/react-dialog/lib/components/DialogActions/DialogActions.js
var DialogActions = React291.forwardRef((props, ref) => {
  const state = useDialogActions_unstable(props, ref);
  useDialogActionsStyles_unstable(state);
  useCustomStyleHook("useDialogActionsStyles_unstable")(state);
  return renderDialogActions_unstable(state);
});
DialogActions.displayName = "DialogActions";

// node_modules/@fluentui/react-dialog/lib/components/DialogBody/DialogBody.js
var React293 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogBody/useDialogBody.js
var React292 = __toESM(require_react());
var useDialogBody_unstable = (props, ref) => {
  var _props_as;
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : "div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-dialog/lib/components/DialogBody/renderDialogBody.js
var renderDialogBody_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-dialog/lib/components/DialogBody/useDialogBodyStyles.styles.js
var dialogBodyClassNames = {
  root: "fui-DialogBody"
};
var useResetStyles2 = __resetStyles("rhwx3p8", null, {
  r: [".rhwx3p8{overflow:unset;gap:8px;display:grid;max-height:calc(100vh - 2 * 24px);max-height:calc(100dvh - 2 * 24px);box-sizing:border-box;grid-template-rows:auto 1fr;grid-template-columns:1fr 1fr auto;}"],
  s: ["@media screen and (max-width: 480px){.rhwx3p8{max-width:100vw;grid-template-rows:auto 1fr auto;}}", "@media screen and (max-height: 359px){.rhwx3p8{max-height:unset;}}"]
});
var useDialogBodyStyles_unstable = (state) => {
  "use no memo";
  const resetStyles = useResetStyles2();
  state.root.className = mergeClasses(dialogBodyClassNames.root, resetStyles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-dialog/lib/components/DialogBody/DialogBody.js
var DialogBody = React293.forwardRef((props, ref) => {
  const state = useDialogBody_unstable(props, ref);
  useDialogBodyStyles_unstable(state);
  useCustomStyleHook("useDialogBodyStyles_unstable")(state);
  return renderDialogBody_unstable(state);
});
DialogBody.displayName = "DialogBody";

// node_modules/@fluentui/react-dialog/lib/components/DialogTitle/DialogTitle.js
var React295 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitle.js
var React294 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitleStyles.styles.js
var dialogTitleClassNames = {
  root: "fui-DialogTitle",
  action: "fui-DialogTitle__action"
};
var useRootResetStyles = __resetStyles("rxjm636", null, [".rxjm636{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase500);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase500);margin:0;grid-row-start:1;grid-row-end:1;grid-column-start:1;grid-column-end:3;}"]);
var useStyles34 = __styles2({
  rootWithoutAction: {
    Bw0ie65: "fsyjsko"
  }
}, {
  d: [".fsyjsko{grid-column-end:4;}"]
});
var useActionResetStyles = __resetStyles("r13kcrze", null, [".r13kcrze{grid-row-start:1;grid-row-end:1;grid-column-start:3;justify-self:end;align-self:start;}"]);
var useDialogTitleInternalStyles = __resetStyles("r2avt6e", "roj2bbc", {
  r: [".r2avt6e{overflow:visible;padding:0;border-style:none;position:relative;box-sizing:content-box;background-color:inherit;color:inherit;font-family:inherit;font-size:inherit;cursor:pointer;line-height:0;-webkit-appearance:button;text-align:unset;}", ".r2avt6e:focus{outline-style:none;}", ".r2avt6e:focus-visible{outline-style:none;}", ".r2avt6e[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r2avt6e[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".roj2bbc{overflow:visible;padding:0;border-style:none;position:relative;box-sizing:content-box;background-color:inherit;color:inherit;font-family:inherit;font-size:inherit;cursor:pointer;line-height:0;-webkit-appearance:button;text-align:unset;}", ".roj2bbc:focus{outline-style:none;}", ".roj2bbc:focus-visible{outline-style:none;}", ".roj2bbc[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.roj2bbc[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.r2avt6e[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.roj2bbc[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useDialogTitleStyles_unstable = (state) => {
  "use no memo";
  const rootResetStyles = useRootResetStyles();
  const actionResetStyles = useActionResetStyles();
  const styles = useStyles34();
  state.root.className = mergeClasses(dialogTitleClassNames.root, rootResetStyles, !state.action && styles.rootWithoutAction, state.root.className);
  if (state.action) {
    state.action.className = mergeClasses(dialogTitleClassNames.action, actionResetStyles, state.action.className);
  }
  return state;
};

// node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitle.js
var useDialogTitle_unstable = (props, ref) => {
  const { action } = props;
  const modalType = useDialogContext_unstable((ctx) => ctx.modalType);
  const internalStyles = useDialogTitleInternalStyles();
  return {
    components: {
      root: "h2",
      action: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("h2", {
      ref,
      id: useDialogContext_unstable((ctx) => ctx.dialogTitleId),
      ...props
    }), {
      elementType: "h2"
    }),
    action: slot_exports.optional(action, {
      renderByDefault: modalType === "non-modal",
      defaultProps: {
        children: React294.createElement(DialogTrigger, {
          disableButtonEnhancement: true,
          action: "close"
        }, React294.createElement("button", {
          type: "button",
          className: internalStyles,
          // TODO: find a better way to add internal labels
          "aria-label": "close"
        }, React294.createElement(Dismiss20Regular, null)))
      },
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-dialog/lib/components/DialogTitle/renderDialogTitle.js
var renderDialogTitle_unstable = (state) => {
  assertSlots(state);
  return jsxs(import_react.Fragment, {
    children: [
      jsx(state.root, {
        children: state.root.children
      }),
      state.action && jsx(state.action, {})
    ]
  });
};

// node_modules/@fluentui/react-dialog/lib/components/DialogTitle/DialogTitle.js
var DialogTitle = React295.forwardRef((props, ref) => {
  const state = useDialogTitle_unstable(props, ref);
  useDialogTitleStyles_unstable(state);
  useCustomStyleHook("useDialogTitleStyles_unstable")(state);
  return renderDialogTitle_unstable(state);
});
DialogTitle.displayName = "DialogTitle";

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/DialogSurface.js
var React297 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurface.js
var React296 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogBackdropMotion.js
var DialogBackdropMotion = FadeRelaxed;

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurface.js
var useDialogSurface_unstable = (props, ref) => {
  const contextRef = useMotionForwardedRef();
  const modalType = useDialogContext_unstable((ctx) => ctx.modalType);
  const isNestedDialog = useDialogContext_unstable((ctx) => ctx.isNestedDialog);
  const modalAttributes = useDialogContext_unstable((ctx) => ctx.modalAttributes);
  const dialogRef = useDialogContext_unstable((ctx) => ctx.dialogRef);
  const requestOpenChange = useDialogContext_unstable((ctx) => ctx.requestOpenChange);
  const dialogTitleID = useDialogContext_unstable((ctx) => ctx.dialogTitleId);
  const open = useDialogContext_unstable((ctx) => ctx.open);
  const handledBackdropClick = useEventCallback((event) => {
    if (isResolvedShorthand(props.backdrop)) {
      var _props_backdrop_onClick, _props_backdrop;
      (_props_backdrop_onClick = (_props_backdrop = props.backdrop).onClick) === null || _props_backdrop_onClick === void 0 ? void 0 : _props_backdrop_onClick.call(_props_backdrop, event);
    }
    if (modalType === "modal" && !event.isDefaultPrevented()) {
      requestOpenChange({
        event,
        open: false,
        type: "backdropClick"
      });
    }
  });
  const handleKeyDown = useEventCallback((event) => {
    var _props_onKeyDown;
    (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, event);
    if (event.key === Escape && !event.isDefaultPrevented()) {
      requestOpenChange({
        event,
        open: false,
        type: "escapeKeyDown"
      });
      event.preventDefault();
    }
  });
  const backdrop = slot_exports.optional(props.backdrop, {
    renderByDefault: modalType !== "non-modal",
    defaultProps: {
      "aria-hidden": "true"
    },
    elementType: "div"
  });
  if (backdrop) {
    backdrop.onClick = handledBackdropClick;
  }
  const { disableBodyScroll, enableBodyScroll } = useDisableBodyScroll();
  useIsomorphicLayoutEffect(() => {
    if (isNestedDialog || modalType === "non-modal") {
      return;
    }
    disableBodyScroll();
    return () => {
      enableBodyScroll();
    };
  }, [
    enableBodyScroll,
    isNestedDialog,
    disableBodyScroll,
    modalType
  ]);
  return {
    components: {
      backdrop: "div",
      root: "div",
      backdropMotion: DialogBackdropMotion
    },
    open,
    backdrop,
    isNestedDialog,
    mountNode: props.mountNode,
    root: slot_exports.always(getIntrinsicElementProps("div", {
      tabIndex: -1,
      "aria-modal": modalType !== "non-modal",
      role: modalType === "alert" ? "alertdialog" : "dialog",
      "aria-labelledby": props["aria-label"] ? void 0 : dialogTitleID,
      ...props,
      ...modalAttributes,
      onKeyDown: handleKeyDown,
      // FIXME:
      // `DialogSurfaceElement` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, contextRef, dialogRef)
    }), {
      elementType: "div"
    }),
    backdropMotion: presenceMotionSlot(props.backdropMotion, {
      elementType: DialogBackdropMotion,
      defaultProps: {
        appear: true,
        visible: open
      }
    }),
    // Deprecated properties
    transitionStatus: void 0
  };
};

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/renderDialogSurface.js
var renderDialogSurface_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(Portal, {
    mountNode: state.mountNode,
    children: [
      state.backdrop && // TODO: state.backdropMotion is non nullable, but assertSlots asserts it as nullable
      // FIXME: this should be resolved by properly splitting props and state slots declaration
      state.backdropMotion && jsx(state.backdropMotion, {
        children: jsx(state.backdrop, {})
      }),
      jsx(DialogSurfaceProvider, {
        value: contextValues.dialogSurface,
        children: jsx(state.root, {})
      })
    ]
  });
};

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurfaceStyles.styles.js
var dialogSurfaceClassNames = {
  root: "fui-DialogSurface",
  backdrop: "fui-DialogSurface__backdrop"
};
var useRootBaseStyle = __resetStyles("r1u3t6p6", "r5coedp", {
  r: [".r1u3t6p6{inset:0;padding:24px;margin:auto;border-style:none;overflow:unset;border:1px solid var(--colorTransparentStroke);border-radius:var(--borderRadiusXLarge);display:block;-webkit-user-select:unset;-moz-user-select:unset;user-select:unset;visibility:unset;position:fixed;height:fit-content;max-width:600px;max-height:100vh;max-height:100dvh;box-sizing:border-box;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);box-shadow:var(--shadow64);}", ".r1u3t6p6:focus{outline-style:none;}", ".r1u3t6p6:focus-visible{outline-style:none;}", ".r1u3t6p6[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r1u3t6p6[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".r5coedp{inset:0;padding:24px;margin:auto;border-style:none;overflow:unset;border:1px solid var(--colorTransparentStroke);border-radius:var(--borderRadiusXLarge);display:block;-webkit-user-select:unset;-moz-user-select:unset;user-select:unset;visibility:unset;position:fixed;height:fit-content;max-width:600px;max-height:100vh;max-height:100dvh;box-sizing:border-box;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);box-shadow:var(--shadow64);}", ".r5coedp:focus{outline-style:none;}", ".r5coedp:focus-visible{outline-style:none;}", ".r5coedp[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.r5coedp[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.r1u3t6p6[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media screen and (max-width: 480px){.r1u3t6p6{max-width:100vw;}}", "@media screen and (max-height: 359px){.r1u3t6p6{overflow-y:auto;padding-right:calc(24px - 4px);border-right-width:4px;border-top-width:4px;border-bottom-width:4px;}}", "@media (forced-colors: active){.r5coedp[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}", "@media screen and (max-width: 480px){.r5coedp{max-width:100vw;}}", "@media screen and (max-height: 359px){.r5coedp{overflow-y:auto;padding-left:calc(24px - 4px);border-left-width:4px;border-top-width:4px;border-bottom-width:4px;}}"]
});
var useBackdropBaseStyle = __resetStyles("r1e18s3l", null, [".r1e18s3l{inset:0px;background-color:var(--colorBackgroundOverlay);position:fixed;}"]);
var useStyles35 = __styles2({
  nestedDialogBackdrop: {
    De3pzq: "f1c21dwh"
  }
}, {
  d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}"]
});
var useDialogSurfaceStyles_unstable = (state) => {
  "use no memo";
  const {
    isNestedDialog,
    root,
    backdrop
  } = state;
  const rootBaseStyle = useRootBaseStyle();
  const backdropBaseStyle = useBackdropBaseStyle();
  const styles = useStyles35();
  root.className = mergeClasses(dialogSurfaceClassNames.root, rootBaseStyle, root.className);
  if (backdrop) {
    backdrop.className = mergeClasses(dialogSurfaceClassNames.backdrop, backdropBaseStyle, isNestedDialog && styles.nestedDialogBackdrop, backdrop.className);
  }
  return state;
};

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurfaceContextValues.js
function useDialogSurfaceContextValues_unstable(state) {
  const dialogSurface = true;
  return {
    dialogSurface
  };
}

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/DialogSurface.js
var DialogSurface = React297.forwardRef((props, ref) => {
  const state = useDialogSurface_unstable(props, ref);
  const contextValues = useDialogSurfaceContextValues_unstable(state);
  useDialogSurfaceStyles_unstable(state);
  useCustomStyleHook("useDialogSurfaceStyles_unstable")(state);
  return renderDialogSurface_unstable(state, contextValues);
});
DialogSurface.displayName = "DialogSurface";

// node_modules/@fluentui/react-dialog/lib/components/DialogContent/DialogContent.js
var React299 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogContent/useDialogContent.js
var React298 = __toESM(require_react());
var useDialogContent_unstable = (props, ref) => {
  var _props_as;
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : "div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-dialog/lib/components/DialogContent/renderDialogContent.js
var renderDialogContent_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-dialog/lib/components/DialogContent/useDialogContentStyles.styles.js
var dialogContentClassNames = {
  root: "fui-DialogContent"
};
var useStyles36 = __resetStyles("r1v5zwsm", null, {
  r: [".r1v5zwsm{padding:var(--strokeWidthThick);margin:calc(var(--strokeWidthThick) * -1);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);overflow-y:auto;min-height:32px;box-sizing:border-box;grid-row-start:2;grid-row-end:2;grid-column-start:1;grid-column-end:4;}"],
  s: ["@media screen and (max-height: 359px){.r1v5zwsm{overflow-y:unset;}}"]
});
var useDialogContentStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles36();
  state.root.className = mergeClasses(dialogContentClassNames.root, styles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-dialog/lib/components/DialogContent/DialogContent.js
var DialogContent = React299.forwardRef((props, ref) => {
  const state = useDialogContent_unstable(props, ref);
  useDialogContentStyles_unstable(state);
  useCustomStyleHook("useDialogContentStyles_unstable")(state);
  return renderDialogContent_unstable(state);
});
DialogContent.displayName = "DialogContent";

// node_modules/@fluentui/react-progress/lib/components/ProgressBar/ProgressBar.js
var React301 = __toESM(require_react());

// node_modules/@fluentui/react-progress/lib/components/ProgressBar/useProgressBar.js
var React300 = __toESM(require_react());

// node_modules/@fluentui/react-progress/lib/utils/clampMax.js
var clampMax = (max2) => {
  const internalMax = max2 <= 0 ? 1 : max2;
  if (true) {
    if (max2 <= 0) {
      console.error(`The prop 'max' must be greater than 0. Received max: ${max2}`);
    }
  }
  return internalMax;
};

// node_modules/@fluentui/react-progress/lib/utils/clampValue.js
var clampValue = (value, max2) => {
  if (value === void 0) {
    return value;
  }
  const internalValue = value < 0 ? 0 : value > max2 ? max2 : value;
  if (true) {
    if (value < 0) {
      console.error(`The prop 'value' must be greater than or equal to zero. Received value: ${value}`);
    }
    if (value > max2) {
      console.error(`The prop 'value' must be less than or equal to 'max'. Received value: ${value}, max: ${max2}`);
    }
  }
  return internalValue;
};

// node_modules/@fluentui/react-progress/lib/components/ProgressBar/useProgressBar.js
var useProgressBar_unstable = (props, ref) => {
  const field = useFieldContext_unstable();
  const fieldState = field === null || field === void 0 ? void 0 : field.validationState;
  const { color: color2 = fieldState === "error" || fieldState === "warning" || fieldState === "success" ? fieldState : "brand", shape = "rounded", thickness = "medium" } = props;
  var _props_max;
  const max2 = clampMax((_props_max = props.max) !== null && _props_max !== void 0 ? _props_max : 1);
  const value = clampValue(props.value, max2);
  const root = slot_exports.always(getIntrinsicElementProps("div", {
    // FIXME:
    // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
    // but since it would be a breaking change to fix it, we are casting ref to it's proper type
    ref,
    role: "progressbar",
    "aria-valuemin": value !== void 0 ? 0 : void 0,
    "aria-valuemax": value !== void 0 ? max2 : void 0,
    "aria-valuenow": value,
    "aria-labelledby": field === null || field === void 0 ? void 0 : field.labelId,
    ...props
  }), {
    elementType: "div"
  });
  if (field && (field.validationMessageId || field.hintId)) {
    root["aria-describedby"] = [
      field === null || field === void 0 ? void 0 : field.validationMessageId,
      field === null || field === void 0 ? void 0 : field.hintId,
      root["aria-describedby"]
    ].filter(Boolean).join(" ");
  }
  const bar = slot_exports.always(props.bar, {
    elementType: "div"
  });
  const state = {
    color: color2,
    max: max2,
    shape,
    thickness,
    value,
    components: {
      root: "div",
      bar: "div"
    },
    root,
    bar
  };
  return state;
};

// node_modules/@fluentui/react-progress/lib/components/ProgressBar/renderProgressBar.js
var renderProgressBar_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: state.bar && jsx(state.bar, {})
  });
};

// node_modules/@fluentui/react-progress/lib/components/ProgressBar/useProgressBarStyles.styles.js
var progressBarClassNames = {
  root: "fui-ProgressBar",
  bar: "fui-ProgressBar__bar"
};
var ZERO_THRESHOLD = 0.01;
var useRootStyles17 = __styles2({
  root: {
    mc9l5x: "ftgm304",
    De3pzq: "f18f03hv",
    a9b677: "fly5x3f",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    Bpep1pd: "fu42dvn"
  },
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw"
  },
  medium: {
    Bqenvij: "f4t8t6x"
  },
  large: {
    Bqenvij: "f6ywr7j"
  }
}, {
  d: [".ftgm304{display:block;}", ".f18f03hv{background-color:var(--colorNeutralBackground6);}", ".fly5x3f{width:100%;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], ".f4t8t6x{height:2px;}", ".f6ywr7j{height:4px;}"],
  m: [["@media screen and (forced-colors: active){.fu42dvn{background-color:CanvasText;}}", {
    m: "screen and (forced-colors: active)"
  }]]
});
var useBarStyles = __styles2({
  base: {
    Bpep1pd: "f1neahkh",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f12b9xdw",
    Bqenvij: "f1l02sjl"
  },
  nonZeroDeterminate: {
    Bmy1vo4: "fjt6zfz",
    B3o57yi: "f1wofebd",
    Bkqvd7p: "fv71qf3"
  },
  indeterminate: {
    B2u0y6b: "fa0wk36",
    qhf8xq: "f10pi13n",
    Bcmaq0h: ["fpo0yib", "f1u5hf6c"],
    Bv12yb3: ["fwd2bol", "f14gig94"],
    vin17d: "f1a27w2r",
    Ezkn3b: "f452v7t",
    w3vfg9: "f1cpbl36",
    B3ks32h: "f2xo07b",
    B3vm3ge: "f1f2ih6z",
    Gqtpxc: "f7h4d4t",
    vr3tzx: "f32r5lb"
  },
  brand: {
    De3pzq: "ftywsgz"
  },
  error: {
    De3pzq: "fdl5y0r"
  },
  warning: {
    De3pzq: "f1s438gw"
  },
  success: {
    De3pzq: "flxk52p"
  }
}, {
  m: [["@media screen and (forced-colors: active){.f1neahkh{background-color:Highlight;}}", {
    m: "screen and (forced-colors: active)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f2xo07b{max-width:100%;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1f2ih6z{animation-iteration-count:infinite;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f7h4d4t{animation-duration:3s;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f32r5lb{animation-name:ftc26vs;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }]],
  d: [[".f12b9xdw{border-radius:inherit;}", {
    p: -1
  }], ".f1l02sjl{height:100%;}", ".fjt6zfz{transition-property:width;}", ".f1wofebd{transition-duration:0.3s;}", ".fv71qf3{transition-timing-function:ease;}", ".fa0wk36{max-width:33%;}", ".f10pi13n{position:relative;}", ".fpo0yib{background-image:linear-gradient(\n      to right,\n      var(--colorNeutralBackground6) 0%,\n      var(--colorTransparentBackground) 50%,\n      var(--colorNeutralBackground6) 100%\n    );}", ".f1u5hf6c{background-image:linear-gradient(\n      to left,\n      var(--colorNeutralBackground6) 0%,\n      var(--colorTransparentBackground) 50%,\n      var(--colorNeutralBackground6) 100%\n    );}", ".fwd2bol{animation-name:f1keuaan;}", ".f14gig94{animation-name:f10x8f8u;}", ".f1a27w2r{animation-duration:3s;}", ".f452v7t{animation-timing-function:linear;}", ".f1cpbl36{animation-iteration-count:infinite;}", ".ftywsgz{background-color:var(--colorCompoundBrandBackground);}", ".fdl5y0r{background-color:var(--colorPaletteRedBackground3);}", ".f1s438gw{background-color:var(--colorPaletteDarkOrangeBackground3);}", ".flxk52p{background-color:var(--colorPaletteGreenBackground3);}"],
  k: ["@keyframes f1keuaan{0%{left:-33%;}100%{left:100%;}}", "@keyframes f10x8f8u{0%{right:-33%;}100%{right:100%;}}", "@keyframes ftc26vs{0%{opacity:.2;}50%{opacity:1;}100%{opacity:.2;}}"]
});
var useProgressBarStyles_unstable = (state) => {
  "use no memo";
  const {
    color: color2,
    max: max2,
    shape,
    thickness,
    value
  } = state;
  const rootStyles = useRootStyles17();
  const barStyles = useBarStyles();
  state.root.className = mergeClasses(progressBarClassNames.root, rootStyles.root, rootStyles[shape], rootStyles[thickness], state.root.className);
  if (state.bar) {
    state.bar.className = mergeClasses(progressBarClassNames.bar, barStyles.base, barStyles.brand, value === void 0 && barStyles.indeterminate, value !== void 0 && value > ZERO_THRESHOLD && barStyles.nonZeroDeterminate, color2 && value !== void 0 && barStyles[color2], state.bar.className);
  }
  if (state.bar && value !== void 0) {
    state.bar.style = {
      width: Math.min(100, Math.max(0, value / max2 * 100)) + "%",
      ...state.bar.style
    };
  }
  return state;
};

// node_modules/@fluentui/react-progress/lib/components/ProgressBar/ProgressBar.js
var ProgressBar = React301.forwardRef((props, ref) => {
  const state = useProgressBar_unstable(props, ref);
  useProgressBarStyles_unstable(state);
  useCustomStyleHook("useProgressBarStyles_unstable")(state);
  return renderProgressBar_unstable(state);
});
ProgressBar.displayName = "ProgressBar";

// node_modules/@fluentui/react-overflow/lib/components/Overflow.js
var React303 = __toESM(require_react());

// node_modules/@fluentui/react-overflow/lib/overflowContext.js
var OverflowContext = createContext13(void 0);
var overflowContextDefaultValue = {
  itemVisibility: {},
  groupVisibility: {},
  hasOverflow: false,
  registerItem: () => () => null,
  updateOverflow: () => null,
  registerOverflowMenu: () => () => null,
  registerDivider: () => () => null
};
var useOverflowContext = (selector) => useContextSelector(OverflowContext, (ctx = overflowContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-overflow/lib/useOverflowContainer.js
var React302 = __toESM(require_react());

// node_modules/@fluentui/priority-overflow/lib/consts.js
var DATA_OVERFLOWING = "data-overflowing";
var DATA_OVERFLOW_GROUP = "data-overflow-group";

// node_modules/@fluentui/priority-overflow/lib/createResizeObserver.js
function observeResize(elementToObserve, callback) {
  var _elementToObserve_ownerDocument_defaultView;
  const GlobalResizeObserver = (_elementToObserve_ownerDocument_defaultView = elementToObserve.ownerDocument.defaultView) === null || _elementToObserve_ownerDocument_defaultView === void 0 ? void 0 : _elementToObserve_ownerDocument_defaultView.ResizeObserver;
  if (!GlobalResizeObserver) {
    if (true) {
      console.error("@fluentui/priority-overflow", "ResizeObserver does not exist on container window");
    }
    return () => null;
  }
  let resizeObserver = new GlobalResizeObserver(callback);
  resizeObserver.observe(elementToObserve);
  return () => {
    resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
    resizeObserver = void 0;
  };
}

// node_modules/@fluentui/priority-overflow/lib/debounce.js
function debounce2(fn) {
  let pending;
  if (false) {
    return fn;
  }
  return () => {
    if (!pending) {
      pending = true;
      queueMicrotask(() => {
        pending = false;
        fn();
      });
    }
  };
}

// node_modules/@fluentui/priority-overflow/lib/priorityQueue.js
function createPriorityQueue2(compare) {
  const arr = [];
  let size3 = 0;
  const left2 = (i) => {
    return 2 * i + 1;
  };
  const right2 = (i) => {
    return 2 * i + 2;
  };
  const parent2 = (i) => {
    return Math.floor((i - 1) / 2);
  };
  const swap = (a, b) => {
    const tmp = arr[a];
    arr[a] = arr[b];
    arr[b] = tmp;
  };
  const heapify = (i) => {
    let smallest = i;
    const l = left2(i);
    const r = right2(i);
    if (l < size3 && compare(arr[l], arr[smallest]) < 0) {
      smallest = l;
    }
    if (r < size3 && compare(arr[r], arr[smallest]) < 0) {
      smallest = r;
    }
    if (smallest !== i) {
      swap(smallest, i);
      heapify(smallest);
    }
  };
  const dequeue = () => {
    if (size3 === 0) {
      throw new Error("Priority queue empty");
    }
    const res = arr[0];
    arr[0] = arr[--size3];
    heapify(0);
    return res;
  };
  const peek = () => {
    if (size3 === 0) {
      return null;
    }
    return arr[0];
  };
  const enqueue = (item) => {
    arr[size3++] = item;
    let i = size3 - 1;
    let p = parent2(i);
    while (i > 0 && compare(arr[p], arr[i]) > 0) {
      swap(p, i);
      i = p;
      p = parent2(i);
    }
  };
  const contains = (item) => {
    const index = arr.indexOf(item);
    return index >= 0 && index < size3;
  };
  const remove = (item) => {
    const i = arr.indexOf(item);
    if (i === -1 || i >= size3) {
      return;
    }
    arr[i] = arr[--size3];
    heapify(i);
  };
  const clear = () => {
    size3 = 0;
  };
  const all = () => {
    return arr.slice(0, size3);
  };
  return {
    all,
    clear,
    contains,
    dequeue,
    enqueue,
    peek,
    remove,
    size: () => size3
  };
}

// node_modules/@fluentui/priority-overflow/lib/overflowManager.js
function createOverflowManager() {
  const sizeCache = /* @__PURE__ */ new Map();
  let container;
  let overflowMenu;
  let observing = false;
  let forceDispatch = true;
  const options = {
    padding: 10,
    overflowAxis: "horizontal",
    overflowDirection: "end",
    minimumVisible: 0,
    onUpdateItemVisibility: () => void 0,
    onUpdateOverflow: () => void 0
  };
  const overflowItems = {};
  const overflowDividers = {};
  let disposeResizeObserver = () => null;
  const getNextItem = (queueToDequeue, queueToEnqueue) => {
    const nextItem = queueToDequeue.dequeue();
    queueToEnqueue.enqueue(nextItem);
    return overflowItems[nextItem];
  };
  const groupManager = createGroupManager();
  function compareItems(lt, rt) {
    if (!lt || !rt) {
      return 0;
    }
    const lte = overflowItems[lt];
    const rte = overflowItems[rt];
    if (!lte || !rte) {
      return lte ? 1 : -1;
    }
    if (lte.priority !== rte.priority) {
      return lte.priority > rte.priority ? 1 : -1;
    }
    const positionStatusBit = options.overflowDirection === "end" ? Node.DOCUMENT_POSITION_FOLLOWING : Node.DOCUMENT_POSITION_PRECEDING;
    return lte.element.compareDocumentPosition(rte.element) & positionStatusBit ? 1 : -1;
  }
  function getElementAxisSize(horizontal, vertical, el) {
    if (!sizeCache.has(el)) {
      sizeCache.set(el, options.overflowAxis === "horizontal" ? el[horizontal] : el[vertical]);
    }
    return sizeCache.get(el);
  }
  const getOffsetSize = getElementAxisSize.bind(null, "offsetWidth", "offsetHeight");
  const getClientSize = getElementAxisSize.bind(null, "clientWidth", "clientHeight");
  const invisibleItemQueue = createPriorityQueue2((a, b) => -1 * compareItems(a, b));
  const visibleItemQueue = createPriorityQueue2(compareItems);
  function occupiedSize() {
    const totalItemSize = visibleItemQueue.all().map((id) => overflowItems[id].element).map(getOffsetSize).reduce((prev, current) => prev + current, 0);
    const totalDividerSize = Object.entries(groupManager.groupVisibility()).reduce((acc, [id, state]) => acc + (state !== "hidden" && overflowDividers[id] ? getOffsetSize(overflowDividers[id].element) : 0), 0);
    const overflowMenuSize = invisibleItemQueue.size() > 0 && overflowMenu ? getOffsetSize(overflowMenu) : 0;
    return totalItemSize + totalDividerSize + overflowMenuSize;
  }
  const showItem = () => {
    const item = getNextItem(invisibleItemQueue, visibleItemQueue);
    options.onUpdateItemVisibility({
      item,
      visible: true
    });
    if (item.groupId) {
      groupManager.showItem(item.id, item.groupId);
      if (groupManager.isSingleItemVisible(item.id, item.groupId)) {
        var _overflowDividers_item_groupId;
        (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.removeAttribute(DATA_OVERFLOWING);
      }
    }
  };
  const hideItem = () => {
    const item = getNextItem(visibleItemQueue, invisibleItemQueue);
    options.onUpdateItemVisibility({
      item,
      visible: false
    });
    if (item.groupId) {
      if (groupManager.isSingleItemVisible(item.id, item.groupId)) {
        var _overflowDividers_item_groupId;
        (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.setAttribute(DATA_OVERFLOWING, "");
      }
      groupManager.hideItem(item.id, item.groupId);
    }
  };
  const dispatchOverflowUpdate = () => {
    const visibleItemIds = visibleItemQueue.all();
    const invisibleItemIds = invisibleItemQueue.all();
    const visibleItems = visibleItemIds.map((itemId) => overflowItems[itemId]);
    const invisibleItems = invisibleItemIds.map((itemId) => overflowItems[itemId]);
    options.onUpdateOverflow({
      visibleItems,
      invisibleItems,
      groupVisibility: groupManager.groupVisibility()
    });
  };
  const processOverflowItems = () => {
    if (!container) {
      return false;
    }
    sizeCache.clear();
    const availableSize = getClientSize(container) - options.padding;
    const visibleTop = visibleItemQueue.peek();
    const invisibleTop = invisibleItemQueue.peek();
    while (compareItems(invisibleItemQueue.peek(), visibleItemQueue.peek()) > 0) {
      hideItem();
    }
    for (let i = 0; i < 2; i++) {
      while (occupiedSize() < availableSize && invisibleItemQueue.size() > 0 || invisibleItemQueue.size() === 1) {
        showItem();
      }
      while (occupiedSize() > availableSize && visibleItemQueue.size() > options.minimumVisible) {
        hideItem();
      }
    }
    return visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop;
  };
  const forceUpdate = () => {
    if (processOverflowItems() || forceDispatch) {
      forceDispatch = false;
      dispatchOverflowUpdate();
    }
  };
  const update = debounce2(forceUpdate);
  const observe = (observedContainer, userOptions) => {
    Object.assign(options, userOptions);
    observing = true;
    Object.values(overflowItems).forEach((item) => visibleItemQueue.enqueue(item.id));
    container = observedContainer;
    disposeResizeObserver = observeResize(container, (entries) => {
      if (!entries[0] || !container) {
        return;
      }
      update();
    });
  };
  const addItem = (item) => {
    if (overflowItems[item.id]) {
      return;
    }
    overflowItems[item.id] = item;
    if (observing) {
      forceDispatch = true;
      visibleItemQueue.enqueue(item.id);
    }
    if (item.groupId) {
      groupManager.addItem(item.id, item.groupId);
      item.element.setAttribute(DATA_OVERFLOW_GROUP, item.groupId);
    }
    update();
  };
  const addOverflowMenu = (el) => {
    overflowMenu = el;
  };
  const addDivider = (divider) => {
    if (!divider.groupId || overflowDividers[divider.groupId]) {
      return;
    }
    divider.element.setAttribute(DATA_OVERFLOW_GROUP, divider.groupId);
    overflowDividers[divider.groupId] = divider;
  };
  const removeOverflowMenu = () => {
    overflowMenu = void 0;
  };
  const removeDivider = (groupId) => {
    if (!overflowDividers[groupId]) {
      return;
    }
    const divider = overflowDividers[groupId];
    if (divider.groupId) {
      delete overflowDividers[groupId];
      divider.element.removeAttribute(DATA_OVERFLOW_GROUP);
    }
  };
  const removeItem = (itemId) => {
    if (!overflowItems[itemId]) {
      return;
    }
    if (observing) {
      forceDispatch = true;
    }
    const item = overflowItems[itemId];
    visibleItemQueue.remove(itemId);
    invisibleItemQueue.remove(itemId);
    if (item.groupId) {
      groupManager.removeItem(item.id, item.groupId);
      item.element.removeAttribute(DATA_OVERFLOW_GROUP);
    }
    sizeCache.delete(item.element);
    delete overflowItems[itemId];
    update();
  };
  const disconnect = () => {
    disposeResizeObserver();
    container = void 0;
    observing = false;
    forceDispatch = true;
    Object.keys(overflowItems).forEach((itemId) => removeItem(itemId));
    Object.keys(overflowDividers).forEach((dividerId) => removeDivider(dividerId));
    removeOverflowMenu();
    sizeCache.clear();
  };
  return {
    addItem,
    disconnect,
    forceUpdate,
    observe,
    removeItem,
    update,
    addOverflowMenu,
    removeOverflowMenu,
    addDivider,
    removeDivider
  };
}
var createGroupManager = () => {
  const groupVisibility = {};
  const groups = {};
  function updateGroupVisibility(groupId) {
    const group = groups[groupId];
    if (group.invisibleItemIds.size && group.visibleItemIds.size) {
      groupVisibility[groupId] = "overflow";
    } else if (group.visibleItemIds.size === 0) {
      groupVisibility[groupId] = "hidden";
    } else {
      groupVisibility[groupId] = "visible";
    }
  }
  function isGroupVisible(groupId) {
    return groupVisibility[groupId] === "visible" || groupVisibility[groupId] === "overflow";
  }
  return {
    groupVisibility: () => groupVisibility,
    isSingleItemVisible(itemId, groupId) {
      return isGroupVisible(groupId) && groups[groupId].visibleItemIds.has(itemId) && groups[groupId].visibleItemIds.size === 1;
    },
    addItem(itemId, groupId) {
      var _groups, _groupId;
      var _;
      (_ = (_groups = groups)[_groupId = groupId]) !== null && _ !== void 0 ? _ : _groups[_groupId] = {
        visibleItemIds: /* @__PURE__ */ new Set(),
        invisibleItemIds: /* @__PURE__ */ new Set()
      };
      groups[groupId].visibleItemIds.add(itemId);
      updateGroupVisibility(groupId);
    },
    removeItem(itemId, groupId) {
      groups[groupId].invisibleItemIds.delete(itemId);
      groups[groupId].visibleItemIds.delete(itemId);
      updateGroupVisibility(groupId);
    },
    showItem(itemId, groupId) {
      groups[groupId].invisibleItemIds.delete(itemId);
      groups[groupId].visibleItemIds.add(itemId);
      updateGroupVisibility(groupId);
    },
    hideItem(itemId, groupId) {
      groups[groupId].invisibleItemIds.add(itemId);
      groups[groupId].visibleItemIds.delete(itemId);
      updateGroupVisibility(groupId);
    }
  };
};

// node_modules/@fluentui/react-overflow/lib/constants.js
var DATA_OVERFLOWING2 = "data-overflowing";
var DATA_OVERFLOW_ITEM = "data-overflow-item";
var DATA_OVERFLOW_MENU = "data-overflow-menu";
var DATA_OVERFLOW_DIVIDER = "data-overflow-divider";

// node_modules/@fluentui/react-overflow/lib/useOverflowContainer.js
var noop4 = () => null;
var useOverflowContainer = (update, options) => {
  "use no memo";
  const { overflowAxis = "horizontal", overflowDirection = "end", padding = 10, minimumVisible = 0, onUpdateItemVisibility = noop4 } = options;
  const onUpdateOverflow = useEventCallback(update);
  const overflowOptions = React302.useMemo(() => ({
    overflowAxis,
    overflowDirection,
    padding,
    minimumVisible,
    onUpdateItemVisibility,
    onUpdateOverflow
  }), [
    minimumVisible,
    onUpdateItemVisibility,
    overflowAxis,
    overflowDirection,
    padding,
    onUpdateOverflow
  ]);
  const firstMount = useFirstMount();
  const containerRef = React302.useRef(null);
  const [overflowManager, setOverflowManager] = React302.useState(() => canUseDOM() ? createOverflowManager() : null);
  useIsomorphicLayoutEffect(() => {
    if (firstMount && containerRef.current) {
      overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.observe(containerRef.current, overflowOptions);
    }
  }, [
    firstMount,
    overflowManager,
    overflowOptions
  ]);
  useIsomorphicLayoutEffect(() => {
    if (!containerRef.current || !canUseDOM() || firstMount) {
      return;
    }
    const newOverflowManager = createOverflowManager();
    newOverflowManager.observe(containerRef.current, overflowOptions);
    setOverflowManager(newOverflowManager);
  }, [
    overflowOptions
  ]);
  React302.useEffect(() => () => {
    overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.disconnect();
  }, [
    overflowManager
  ]);
  const registerItem = React302.useCallback((item) => {
    overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.addItem(item);
    item.element.setAttribute(DATA_OVERFLOW_ITEM, "");
    return () => {
      item.element.removeAttribute(DATA_OVERFLOWING2);
      item.element.removeAttribute(DATA_OVERFLOW_ITEM);
      overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.removeItem(item.id);
    };
  }, [
    overflowManager
  ]);
  const registerDivider = React302.useCallback((divider) => {
    const el = divider.element;
    overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.addDivider(divider);
    el.setAttribute(DATA_OVERFLOW_DIVIDER, "");
    return () => {
      divider.groupId && (overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.removeDivider(divider.groupId));
      el.removeAttribute(DATA_OVERFLOW_DIVIDER);
    };
  }, [
    overflowManager
  ]);
  const registerOverflowMenu = React302.useCallback((el) => {
    overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.addOverflowMenu(el);
    el.setAttribute(DATA_OVERFLOW_MENU, "");
    return () => {
      overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.removeOverflowMenu();
      el.removeAttribute(DATA_OVERFLOW_MENU);
    };
  }, [
    overflowManager
  ]);
  const updateOverflow = React302.useCallback(() => {
    overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.update();
  }, [
    overflowManager
  ]);
  return {
    registerItem,
    registerDivider,
    registerOverflowMenu,
    updateOverflow,
    containerRef
  };
};
var updateVisibilityAttribute = ({ item, visible }) => {
  if (visible) {
    item.element.removeAttribute(DATA_OVERFLOWING2);
  } else {
    item.element.setAttribute(DATA_OVERFLOWING2, "");
  }
};

// node_modules/@fluentui/react-overflow/lib/components/useOverflowStyles.styles.js
var useOverflowStyles = __styles2({
  overflowMenu: {
    Brvla84: "fyfkpbf"
  },
  overflowingItems: {
    zb22lx: "f10570jf"
  }
}, {
  d: [".fyfkpbf [data-overflow-menu]{flex-shrink:0;}", ".f10570jf [data-overflowing]{display:none;}"]
});

// node_modules/@fluentui/react-overflow/lib/components/Overflow.js
var Overflow = React303.forwardRef((props, ref) => {
  const styles = useOverflowStyles();
  const { children: children2, minimumVisible, overflowAxis = "horizontal", overflowDirection, padding, onOverflowChange } = props;
  const [overflowState, setOverflowState] = React303.useState({
    hasOverflow: false,
    itemVisibility: {},
    groupVisibility: {}
  });
  const update = (data) => {
    const { visibleItems, invisibleItems, groupVisibility } = data;
    const itemVisibility = {};
    visibleItems.forEach((item) => {
      itemVisibility[item.id] = true;
    });
    invisibleItems.forEach((x) => itemVisibility[x.id] = false);
    const newState = {
      hasOverflow: data.invisibleItems.length > 0,
      itemVisibility,
      groupVisibility
    };
    onOverflowChange === null || onOverflowChange === void 0 ? void 0 : onOverflowChange(null, {
      ...newState
    });
    setOverflowState(newState);
  };
  const { containerRef, registerItem, updateOverflow, registerOverflowMenu, registerDivider } = useOverflowContainer(update, {
    overflowDirection,
    overflowAxis,
    padding,
    minimumVisible,
    onUpdateItemVisibility: updateVisibilityAttribute
  });
  const child = getTriggerChild(children2);
  const clonedChild = applyTriggerPropsToChildren(children2, {
    ref: useMergedRefs(containerRef, ref, getReactElementRef(child)),
    className: mergeClasses("fui-Overflow", styles.overflowMenu, styles.overflowingItems, child === null || child === void 0 ? void 0 : child.props.className)
  });
  return React303.createElement(OverflowContext.Provider, {
    value: {
      itemVisibility: overflowState.itemVisibility,
      groupVisibility: overflowState.groupVisibility,
      hasOverflow: overflowState.hasOverflow,
      registerItem,
      updateOverflow,
      registerOverflowMenu,
      registerDivider
    }
  }, clonedChild);
});

// node_modules/@fluentui/react-overflow/lib/useIsOverflowGroupVisible.js
function useIsOverflowGroupVisible(id) {
  return useOverflowContext((ctx) => ctx.groupVisibility[id]);
}

// node_modules/@fluentui/react-overflow/lib/useIsOverflowItemVisible.js
function useIsOverflowItemVisible(id) {
  return !!useOverflowContext((ctx) => ctx.itemVisibility[id]);
}

// node_modules/@fluentui/react-overflow/lib/useOverflowCount.js
var useOverflowCount = () => useOverflowContext((v) => {
  return Object.entries(v.itemVisibility).reduce((acc, [id, visible]) => {
    if (!visible) {
      acc++;
    }
    return acc;
  }, 0);
});

// node_modules/@fluentui/react-overflow/lib/useOverflowItem.js
var React304 = __toESM(require_react());
function useOverflowItem(id, priority, groupId) {
  const ref = React304.useRef(null);
  const registerItem = useOverflowContext((v) => v.registerItem);
  useIsomorphicLayoutEffect(() => {
    if (ref.current) {
      return registerItem({
        element: ref.current,
        id,
        priority: priority !== null && priority !== void 0 ? priority : 0,
        groupId
      });
    }
  }, [
    id,
    priority,
    registerItem,
    groupId
  ]);
  return ref;
}

// node_modules/@fluentui/react-overflow/lib/useOverflowMenu.js
var React305 = __toESM(require_react());
function useOverflowMenu(id) {
  const elementId = useId2("overflow-menu", id);
  const overflowCount = useOverflowCount();
  const registerOverflowMenu = useOverflowContext((v) => v.registerOverflowMenu);
  const updateOverflow = useOverflowContext((v) => v.updateOverflow);
  const ref = React305.useRef(null);
  const isOverflowing = overflowCount > 0;
  useIsomorphicLayoutEffect(() => {
    if (ref.current) {
      return registerOverflowMenu(ref.current);
    }
  }, [
    registerOverflowMenu,
    isOverflowing,
    elementId
  ]);
  useIsomorphicLayoutEffect(() => {
    if (isOverflowing) {
      updateOverflow();
    }
  }, [
    isOverflowing,
    updateOverflow,
    ref
  ]);
  return {
    ref,
    overflowCount,
    isOverflowing
  };
}

// node_modules/@fluentui/react-overflow/lib/useOverflowDivider.js
var React306 = __toESM(require_react());
function useOverflowDivider(groupId) {
  const ref = React306.useRef(null);
  const registerDivider = useOverflowContext((v) => v.registerDivider);
  useIsomorphicLayoutEffect(() => {
    if (ref.current && groupId) {
      return registerDivider({
        element: ref.current,
        groupId
      });
    }
  }, [
    registerDivider,
    groupId
  ]);
  return ref;
}

// node_modules/@fluentui/react-overflow/lib/useOverflowVisibility.js
var React307 = __toESM(require_react());
function useOverflowVisibility() {
  const itemVisibility = useOverflowContext((ctx) => ctx.itemVisibility);
  const groupVisibility = useOverflowContext((ctx) => ctx.groupVisibility);
  return React307.useMemo(() => ({
    itemVisibility,
    groupVisibility
  }), [
    itemVisibility,
    groupVisibility
  ]);
}

// node_modules/@fluentui/react-overflow/lib/components/OverflowItem/OverflowItem.js
var React308 = __toESM(require_react());
var OverflowItem = React308.forwardRef((props, ref) => {
  const { id, groupId, priority, children: children2 } = props;
  const containerRef = useOverflowItem(id, priority, groupId);
  const child = getTriggerChild(children2);
  return applyTriggerPropsToChildren(children2, {
    ref: useMergedRefs(containerRef, ref, getReactElementRef(child))
  });
});
OverflowItem.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-overflow/lib/components/OverflowDivider/OverflowDivider.js
var React309 = __toESM(require_react());
var OverflowDivider = React309.forwardRef((props, ref) => {
  const { groupId, children: children2 } = props;
  const containerRef = useOverflowDivider(groupId);
  return applyTriggerPropsToChildren(children2, {
    ref: useMergedRefs(containerRef, ref)
  });
});

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/Toolbar.js
var React311 = __toESM(require_react());

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/useToolbar.js
var React310 = __toESM(require_react());
var useToolbar_unstable = (props, ref) => {
  const { size: size3 = "medium", vertical = false } = props;
  const arrowNavigationProps = useArrowNavigationGroup({
    circular: true,
    axis: "both"
  });
  const initialState = {
    size: size3,
    vertical,
    // TODO add appropriate props/defaults
    components: {
      // TODO add each slot's element type or component
      root: "div"
    },
    // TODO add appropriate slots, for example:
    // mySlot: resolveShorthand(props.mySlot),
    root: slot_exports.always(getIntrinsicElementProps("div", {
      role: "toolbar",
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...vertical && {
        "aria-orientation": "vertical"
      },
      ...arrowNavigationProps,
      ...props
    }), {
      elementType: "div"
    })
  };
  const [checkedValues, onCheckedValueChange] = useToolbarSelectableState({
    checkedValues: props.checkedValues,
    defaultCheckedValues: props.defaultCheckedValues,
    onCheckedValueChange: props.onCheckedValueChange
  });
  const handleToggleButton = useEventCallback((e, name, value, checked) => {
    if (name && value) {
      const checkedItems = (checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name]) || [];
      const newCheckedItems = [
        ...checkedItems
      ];
      if (checked) {
        newCheckedItems.splice(newCheckedItems.indexOf(value), 1);
      } else {
        newCheckedItems.push(value);
      }
      onCheckedValueChange === null || onCheckedValueChange === void 0 ? void 0 : onCheckedValueChange(e, {
        name,
        checkedItems: newCheckedItems
      });
    }
  });
  const handleRadio = useEventCallback((e, name, value, checked) => {
    if (name && value) {
      onCheckedValueChange === null || onCheckedValueChange === void 0 ? void 0 : onCheckedValueChange(e, {
        name,
        checkedItems: [
          value
        ]
      });
    }
  });
  return {
    ...initialState,
    handleToggleButton,
    handleRadio,
    checkedValues: checkedValues !== null && checkedValues !== void 0 ? checkedValues : {}
  };
};
var useToolbarSelectableState = (state) => {
  const [checkedValues, setCheckedValues] = useControllableState({
    state: state.checkedValues,
    defaultState: state.defaultCheckedValues,
    initialState: {}
  });
  const { onCheckedValueChange: onCheckedValueChangeOriginal } = state;
  const onCheckedValueChange = useEventCallback((e, { name, checkedItems }) => {
    if (onCheckedValueChangeOriginal) {
      onCheckedValueChangeOriginal(e, {
        name,
        checkedItems
      });
    }
    setCheckedValues((s) => {
      return s ? {
        ...s,
        [name]: checkedItems
      } : {
        [name]: checkedItems
      };
    });
  });
  return [
    checkedValues,
    onCheckedValueChange
  ];
};

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/ToolbarContext.js
var ToolbarContext = createContext13(void 0);
var toolbarContextDefaultValue = {
  size: "medium",
  handleToggleButton: () => null,
  handleRadio: () => null,
  vertical: false,
  checkedValues: {}
};
var useToolbarContext_unstable = (selector) => useContextSelector(ToolbarContext, (ctx = toolbarContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/renderToolbar.js
var renderToolbar_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(ToolbarContext.Provider, {
    value: contextValues.toolbar,
    children: jsx(state.root, {
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/useToolbarStyles.styles.js
var toolbarClassNames = {
  root: "fui-Toolbar"
};
var useStyles37 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1yqiaad"
  },
  vertical: {
    Beiy3e4: "f1vx9l62",
    a9b677: "f1acs6jw"
  },
  small: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fvz760z"
  },
  medium: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1yqiaad"
  },
  large: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1ms6bdn"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}", [".f1yqiaad{padding:4px 8px;}", {
    p: -1
  }], ".f1vx9l62{flex-direction:column;}", ".f1acs6jw{width:fit-content;}", [".fvz760z{padding:0px 4px;}", {
    p: -1
  }], [".f1yqiaad{padding:4px 8px;}", {
    p: -1
  }], [".f1ms6bdn{padding:4px 20px;}", {
    p: -1
  }]]
});
var useToolbarStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles37();
  const {
    vertical,
    size: size3
  } = state;
  state.root.className = mergeClasses(toolbarClassNames.root, styles.root, vertical && styles.vertical, size3 === "small" && !vertical && styles.small, size3 === "medium" && !vertical && styles.medium, size3 === "large" && !vertical && styles.large, state.root.className);
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/useToolbarContextValues.js
function useToolbarContextValues_unstable(state) {
  const { size: size3, handleToggleButton, vertical, checkedValues, handleRadio } = state;
  const toolbar = {
    size: size3,
    vertical,
    handleToggleButton,
    handleRadio,
    checkedValues
  };
  return {
    toolbar
  };
}

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/Toolbar.js
var Toolbar = React311.forwardRef((props, ref) => {
  const state = useToolbar_unstable(props, ref);
  const contextValues = useToolbarContextValues_unstable(state);
  useToolbarStyles_unstable(state);
  useCustomStyleHook("useToolbarStyles_unstable")(state);
  return renderToolbar_unstable(state, contextValues);
});
Toolbar.displayName = "Toolbar";

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarButton/ToolbarButton.js
var React313 = __toESM(require_react());

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarButton/useToolbarButtonStyles.styles.js
var useBaseStyles2 = __styles2({
  vertical: {
    Beiy3e4: "f1vx9l62"
  },
  verticalIcon: {
    Be2twd7: "f1rt2boy",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao"
  }
}, {
  d: [".f1vx9l62{flex-direction:column;}", ".f1rt2boy{font-size:24px;}", [".f1s184ao{margin:0;}", {
    p: -1
  }]]
});
var useToolbarButtonStyles_unstable = (state) => {
  "use no memo";
  const buttonStyles = useBaseStyles2();
  state.root.className = mergeClasses(state.vertical && buttonStyles.vertical, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(state.vertical && buttonStyles.verticalIcon, state.icon.className);
  }
  useButtonStyles_unstable(state);
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarButton/useToolbarButton.js
var React312 = __toESM(require_react());
var useToolbarButton_unstable = (props, ref) => {
  const { vertical = false, ...buttonProps } = props;
  const state = useButton_unstable({
    appearance: "subtle",
    ...buttonProps,
    size: "medium"
  }, ref);
  return {
    vertical,
    ...state
  };
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarButton/ToolbarButton.js
var ToolbarButton = React313.forwardRef((props, ref) => {
  const state = useToolbarButton_unstable(props, ref);
  useToolbarButtonStyles_unstable(state);
  useCustomStyleHook("useToolbarButtonStyles_unstable")(state);
  return renderButton_unstable(state);
});
ToolbarButton.displayName = "ToolbarButton";

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarDivider/ToolbarDivider.js
var React315 = __toESM(require_react());

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarDivider/useToolbarDividerStyles.styles.js
var useBaseStyles3 = __styles2({
  root: {
    mc9l5x: "ftuwxu6",
    B2u0y6b: "f1lwjmbk",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1oic3e7"
  },
  vertical: {
    B2u0y6b: "fe668z"
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".f1lwjmbk{max-width:1px;}", [".f1oic3e7{padding:0 12px;}", {
    p: -1
  }], ".fe668z{max-width:initial;}"]
});
var useToolbarDividerStyles_unstable = (state) => {
  "use no memo";
  useDividerStyles_unstable(state);
  const {
    vertical
  } = state;
  const toolbarDividerStyles = useBaseStyles3();
  state.root.className = mergeClasses(toolbarDividerStyles.root, !vertical && toolbarDividerStyles.vertical, state.root.className);
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarDivider/useToolbarDivider.js
var React314 = __toESM(require_react());
var useToolbarDivider_unstable = (props, ref) => {
  const vertical = useToolbarContext_unstable((ctx) => ctx.vertical);
  return useDivider_unstable({
    vertical: !vertical,
    ...props
  }, ref);
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarDivider/ToolbarDivider.js
var ToolbarDivider = React315.forwardRef((props, ref) => {
  const state = useToolbarDivider_unstable(props, ref);
  useToolbarDividerStyles_unstable(state);
  useCustomStyleHook("useToolbarDividerStyles_unstable")(state);
  return renderDivider_unstable(state);
});
ToolbarDivider.displayName = "ToolbarDivider";

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarToggleButton/ToolbarToggleButton.js
var React317 = __toESM(require_react());

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarToggleButton/useToolbarToggleButton.js
var React316 = __toESM(require_react());
var useToolbarToggleButton_unstable = (props, ref) => {
  const handleToggleButton = useToolbarContext_unstable((ctx) => ctx.handleToggleButton);
  const checked = useToolbarContext_unstable((ctx) => {
    var _ctx_checkedValues_props_name;
    return !!((_ctx_checkedValues_props_name = ctx.checkedValues[props.name]) === null || _ctx_checkedValues_props_name === void 0 ? void 0 : _ctx_checkedValues_props_name.includes(props.value));
  });
  const { onClick: onClickOriginal } = props;
  const toggleButtonState = useToggleButton_unstable({
    checked,
    ...props
  }, ref);
  const state = {
    ...toggleButtonState,
    name: props.name,
    value: props.value
  };
  const handleOnClick = (e) => {
    if (state.disabled) {
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    handleToggleButton === null || handleToggleButton === void 0 ? void 0 : handleToggleButton(e, state.name, state.value, state.checked);
    onClickOriginal === null || onClickOriginal === void 0 ? void 0 : onClickOriginal(e);
  };
  state.root.onClick = handleOnClick;
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarToggleButton/useToolbarToggleButtonStyles.styles.js
var useBaseStyles4 = __styles2({
  selected: {
    De3pzq: "fq5gl1p",
    sj55zd: "f1eryozh"
  },
  iconSelected: {
    sj55zd: "f1qj7y59"
  }
}, {
  d: [".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1eryozh{color:var(--colorNeutralForeground2Selected);}", ".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"]
});
var useToolbarToggleButtonStyles_unstable = (state) => {
  "use no memo";
  const toggleButtonStyles = useBaseStyles4();
  state.root.className = mergeClasses(state.checked && toggleButtonStyles.selected, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(state.checked && toggleButtonStyles.iconSelected, state.icon.className);
  }
  useToggleButtonStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarToggleButton/ToolbarToggleButton.js
var ToolbarToggleButton = React317.forwardRef((props, ref) => {
  const state = useToolbarToggleButton_unstable(props, ref);
  useToolbarToggleButtonStyles_unstable(state);
  useCustomStyleHook("useToolbarToggleButtonStyles_unstable")(state);
  return renderButton_unstable(state);
});
ToolbarToggleButton.displayName = "ToolbarToggleButton";

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioButton/ToolbarRadioButton.js
var React319 = __toESM(require_react());

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioButton/useToolbarRadioButton.js
var React318 = __toESM(require_react());
var useToolbarRadioButton_unstable = (props, ref) => {
  const handleRadio = useToolbarContext_unstable((ctx) => ctx.handleRadio);
  const checked = useToolbarContext_unstable((ctx) => {
    var _ctx_checkedValues_props_name;
    return !!((_ctx_checkedValues_props_name = ctx.checkedValues[props.name]) === null || _ctx_checkedValues_props_name === void 0 ? void 0 : _ctx_checkedValues_props_name.includes(props.value));
  });
  const size3 = useToolbarContext_unstable((ctx) => ctx.size);
  const { onClick: onClickOriginal } = props;
  const toggleButtonState = useToggleButton_unstable({
    size: size3,
    checked,
    role: "radio",
    "aria-checked": checked,
    ...props
  }, ref);
  const state = {
    ...toggleButtonState,
    name: props.name,
    value: props.value
  };
  const handleOnClick = useEventCallback((e) => {
    handleRadio === null || handleRadio === void 0 ? void 0 : handleRadio(e, state.name, state.value, state.checked);
    onClickOriginal === null || onClickOriginal === void 0 ? void 0 : onClickOriginal(e);
  });
  state.root["aria-pressed"] = void 0;
  state.root.onClick = handleOnClick;
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioButton/useToolbarRadioButtonStyles.styles.js
var useBaseStyles5 = __styles2({
  selected: {
    De3pzq: "fq5gl1p",
    sj55zd: "f1eryozh"
  },
  iconSelected: {
    sj55zd: "f1qj7y59"
  }
}, {
  d: [".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1eryozh{color:var(--colorNeutralForeground2Selected);}", ".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"]
});
var useToolbarRadioButtonStyles_unstable = (state) => {
  "use no memo";
  const toggleButtonStyles = useBaseStyles5();
  state.root.className = mergeClasses(state.checked && toggleButtonStyles.selected, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(state.checked && toggleButtonStyles.iconSelected, state.icon.className);
  }
  useToggleButtonStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioButton/ToolbarRadioButton.js
var ToolbarRadioButton = React319.forwardRef((props, ref) => {
  const state = useToolbarRadioButton_unstable(props, ref);
  useToolbarRadioButtonStyles_unstable(state);
  useCustomStyleHook("useToolbarRadioButtonStyles_unstable")(state);
  return renderButton_unstable(state);
});
ToolbarRadioButton.displayName = "ToolbarRadioButton";

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/ToolbarGroup.js
var React321 = __toESM(require_react());

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/useToolbarGroup.js
var React320 = __toESM(require_react());
var useToolbarGroup_unstable = (props, ref) => {
  const vertical = useToolbarContext_unstable((ctx) => ctx.vertical);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      role: "presentation",
      ...props
    }), {
      elementType: "div"
    }),
    vertical
  };
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/useToolbarGroupStyles.styles.js
var toolbarGroupClassNames = {
  root: "fui-ToolbarGroup"
};
var useStyles38 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59"
  },
  vertical: {
    Beiy3e4: "f1vx9l62",
    a9b677: "f1acs6jw"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}", ".f1vx9l62{flex-direction:column;}", ".f1acs6jw{width:fit-content;}"]
});
var useToolbarGroupStyles_unstable = (state) => {
  "use no memo";
  const {
    vertical
  } = state;
  const styles = useStyles38();
  state.root.className = mergeClasses(toolbarGroupClassNames.root, styles.root, vertical && styles.vertical, state.root.className);
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/renderToolbarGroup.js
var renderToolbarGroup_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: state.root.children
  });
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/ToolbarGroup.js
var ToolbarGroup = React321.forwardRef((props, ref) => {
  const state = useToolbarGroup_unstable(props, ref);
  useToolbarGroupStyles_unstable(state);
  useCustomStyleHook("useToolbarGroupStyles_unstable")(state);
  return renderToolbarGroup_unstable(state);
});
ToolbarGroup.displayName = "ToolbarGroup";

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioGroup/ToolbarRadioGroup.js
var React322 = __toESM(require_react());
var ToolbarRadioGroup = React322.forwardRef((props, ref) => {
  const state = useToolbarGroup_unstable({
    role: "radiogroup",
    ...props
  }, ref);
  useToolbarGroupStyles_unstable(state);
  useCustomStyleHook("useToolbarGroupStyles_unstable")(state);
  return renderToolbarGroup_unstable(state);
});
ToolbarRadioGroup.displayName = "ToolbarRadioGroup";

// node_modules/@fluentui/react-table/lib/hooks/useTableFeatures.js
var React332 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/hooks/useTableSelection.js
var React323 = __toESM(require_react());
var noop5 = () => void 0;
var defaultTableSelectionState = {
  allRowsSelected: false,
  clearRows: noop5,
  deselectRow: noop5,
  isRowSelected: () => false,
  selectRow: noop5,
  selectedRows: /* @__PURE__ */ new Set(),
  someRowsSelected: false,
  toggleAllRows: noop5,
  toggleRow: noop5,
  selectionMode: "multiselect"
};
function useTableSelection(options) {
  "use no memo";
  return (tableState) => useTableSelectionState(tableState, options);
}
function useTableSelectionState(tableState, options) {
  const { items, getRowId } = tableState;
  const { selectionMode, defaultSelectedItems, selectedItems, onSelectionChange } = options;
  const [selected, selectionMethods] = useSelection({
    selectionMode,
    defaultSelectedItems,
    selectedItems,
    onSelectionChange
  });
  const selectableRowIds = React323.useMemo(() => {
    const rowIds = /* @__PURE__ */ new Set();
    for (let i = 0; i < items.length; i++) {
      var _getRowId;
      rowIds.add((_getRowId = getRowId === null || getRowId === void 0 ? void 0 : getRowId(items[i])) !== null && _getRowId !== void 0 ? _getRowId : i);
    }
    return rowIds;
  }, [
    items,
    getRowId
  ]);
  const allRowsSelected = React323.useMemo(() => {
    if (selectionMode === "single") {
      const selectedRow = Array.from(selected)[0];
      return selectableRowIds.has(selectedRow);
    }
    if (selected.size < selectableRowIds.size) {
      return false;
    }
    if (selectableRowIds.size === 0) {
      return false;
    }
    let res = true;
    selectableRowIds.forEach((selectableRowId) => {
      if (!selected.has(selectableRowId)) {
        res = false;
      }
    });
    return res;
  }, [
    selectableRowIds,
    selected,
    selectionMode
  ]);
  const someRowsSelected = React323.useMemo(() => {
    if (selected.size <= 0) {
      return false;
    }
    let res = false;
    selectableRowIds.forEach((selectableRowId) => {
      if (selected.has(selectableRowId)) {
        res = true;
      }
    });
    return res;
  }, [
    selectableRowIds,
    selected
  ]);
  const toggleAllRows = useEventCallback((e) => {
    selectionMethods.toggleAllItems(e, items.map((item, i) => {
      var _getRowId;
      return (_getRowId = getRowId === null || getRowId === void 0 ? void 0 : getRowId(item)) !== null && _getRowId !== void 0 ? _getRowId : i;
    }));
  });
  const toggleRow = useEventCallback((e, rowId) => selectionMethods.toggleItem(e, rowId));
  const deselectRow = useEventCallback((e, rowId) => selectionMethods.deselectItem(e, rowId));
  const selectRow = useEventCallback((e, rowId) => selectionMethods.selectItem(e, rowId));
  const isRowSelected = (rowId) => selectionMethods.isSelected(rowId);
  const clearRows = useEventCallback((e) => selectionMethods.clearItems(e));
  return {
    ...tableState,
    selection: {
      selectionMode,
      someRowsSelected,
      allRowsSelected,
      selectedRows: selected,
      toggleRow,
      toggleAllRows,
      clearRows,
      deselectRow,
      selectRow,
      isRowSelected
    }
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableSort.js
var React324 = __toESM(require_react());
var noop6 = () => void 0;
var defaultTableSortState = {
  getSortDirection: () => "ascending",
  setColumnSort: noop6,
  sort: (rows) => [
    ...rows
  ],
  sortColumn: void 0,
  sortDirection: "ascending",
  toggleColumnSort: noop6
};
function useTableSort(options) {
  "use no memo";
  return (tableState) => useTableSortState(tableState, options);
}
function useTableSortState(tableState, options) {
  const { columns } = tableState;
  const { sortState, defaultSortState, onSortChange: onSortChangeProp = noop6 } = options;
  const [sorted, setSorted] = useControllableState({
    initialState: {
      sortDirection: "ascending",
      sortColumn: void 0
    },
    defaultState: defaultSortState,
    state: sortState
  });
  const { sortColumn, sortDirection } = sorted;
  const onSortChange = useEventCallback(onSortChangeProp);
  const toggleColumnSort = React324.useCallback((e, columnId) => {
    setSorted((s) => {
      const newState = {
        ...s,
        sortColumn: columnId
      };
      if (s.sortColumn === columnId) {
        newState.sortDirection = s.sortDirection === "ascending" ? "descending" : "ascending";
      } else {
        newState.sortDirection = "ascending";
      }
      onSortChange === null || onSortChange === void 0 ? void 0 : onSortChange(e, newState);
      return newState;
    });
  }, [
    onSortChange,
    setSorted
  ]);
  const setColumnSort = (e, nextSortColumn, nextSortDirection) => {
    const newState = {
      sortColumn: nextSortColumn,
      sortDirection: nextSortDirection
    };
    onSortChange === null || onSortChange === void 0 ? void 0 : onSortChange(e, newState);
    setSorted(newState);
  };
  const sort = React324.useCallback((rows) => {
    return rows.slice().sort((a, b) => {
      const sortColumnDef = columns.find((column) => column.columnId === sortColumn);
      if (!(sortColumnDef === null || sortColumnDef === void 0 ? void 0 : sortColumnDef.compare)) {
        return 0;
      }
      const mod = sortDirection === "ascending" ? 1 : -1;
      return sortColumnDef.compare(a.item, b.item) * mod;
    });
  }, [
    columns,
    sortColumn,
    sortDirection
  ]);
  const getSortDirection = (columnId) => {
    return sortColumn === columnId ? sortDirection : void 0;
  };
  return {
    ...tableState,
    sort: {
      sort,
      sortColumn,
      sortDirection,
      setColumnSort,
      toggleColumnSort,
      getSortDirection
    }
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnSizing.js
var React331 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/TableResizeHandle.js
var React326 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/useTableResizeHandle.js
var React325 = __toESM(require_react());
var useTableResizeHandle_unstable = (props, ref) => {
  const onClick = useEventCallback((event) => {
    var _props_onClick;
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, event);
    event.stopPropagation();
  });
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props,
      onClick
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/renderTableResizeHandle.js
var renderTableResizeHandle_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/useTableResizeHandleStyles.styles.js
var tableResizeHandleClassNames = {
  root: "fui-TableResizeHandle"
};
var useStyles39 = __styles2({
  root: {
    qhf8xq: "f1euv43f",
    j35jbq: ["f1e31b4d", "f1vgc2s3"],
    Bhzewxz: "f15twtuk",
    B5kzvoi: "f1yab3r1",
    a9b677: "fjw5fx7",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "fg06o1j",
    Bceei9c: "fc3en1c",
    abs64n: "fk73vx1",
    Bmy1vo4: "f13u1uyl",
    B3o57yi: "fezquic",
    Bj3rh1h: "f19g0ac",
    B3cna0y: "f1tkae59",
    Brovlpu: "ftqa4ok",
    B7zu5sd: "f15pjodv",
    Bsft5z2: "f1rcdj94",
    ap17g6: "f2gz7yw",
    a2br6o: "ff2ryt5",
    E3zdtr: "f1mdlcz9",
    Eqx8gd: ["f10awi5f", "f1nzedbg"],
    bn5sak: "frwkxtg",
    By385i5: "fo72kxq",
    Bjyk6c5: "fdlpgxj"
  }
}, {
  d: [".f1euv43f{position:absolute;}", ".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f15twtuk{top:0;}", ".f1yab3r1{bottom:0;}", ".fjw5fx7{width:16px;}", [".fg06o1j{margin:0 -8px;}", {
    p: -1
  }], ".fc3en1c{cursor:col-resize;}", ".fk73vx1{opacity:0;}", ".f13u1uyl{transition-property:opacity;}", ".fezquic{transition-duration:.2s;}", ".f19g0ac{z-index:1;}", '.f1rcdj94::after{content:" ";}', ".f2gz7yw::after{display:block;}", ".ff2ryt5::after{width:1px;}", ".f1mdlcz9::after{position:absolute;}", ".f10awi5f::after{left:50%;}", ".f1nzedbg::after{right:50%;}", ".frwkxtg::after{top:0;}", ".fo72kxq::after{bottom:0;}", ".fdlpgxj::after{background-color:var(--colorNeutralStroke1);}"],
  f: [".f1tkae59:focus{opacity:1;}", ".ftqa4ok:focus{outline-style:none;}"],
  h: [".f15pjodv:hover{opacity:1;}"]
});
var useTableResizeHandleStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles39();
  state.root.className = mergeClasses(tableResizeHandleClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/TableResizeHandle.js
var TableResizeHandle = React326.forwardRef((props, ref) => {
  const state = useTableResizeHandle_unstable(props, ref);
  useTableResizeHandleStyles_unstable(state);
  useCustomStyleHook("useTableResizeHandleStyles_unstable")(state);
  return renderTableResizeHandle_unstable(state);
});
TableResizeHandle.displayName = "TableResizeHandle";

// node_modules/@fluentui/react-table/lib/hooks/useMeasureElement.js
var React327 = __toESM(require_react());
function useMeasureElement() {
  const [width, setWidth] = React327.useState(0);
  const container = React327.useRef(void 0);
  const resizeObserverRef = React327.useRef(null);
  const { targetDocument } = useFluent();
  const handleResize = React327.useCallback(() => {
    var _container_current;
    const containerWidth = (_container_current = container.current) === null || _container_current === void 0 ? void 0 : _container_current.getBoundingClientRect().width;
    setWidth(containerWidth || 0);
  }, []);
  const measureElementRef = React327.useCallback((el) => {
    if (!targetDocument) {
      return;
    }
    if (!el && resizeObserverRef.current && container.current) {
      resizeObserverRef.current.unobserve(container.current);
    }
    container.current = void 0;
    if (el === null || el === void 0 ? void 0 : el.parentElement) {
      var _resizeObserverRef_current;
      container.current = el.parentElement;
      handleResize();
      (_resizeObserverRef_current = resizeObserverRef.current) === null || _resizeObserverRef_current === void 0 ? void 0 : _resizeObserverRef_current.observe(container.current);
    }
  }, [
    targetDocument,
    handleResize
  ]);
  React327.useEffect(() => {
    resizeObserverRef.current = createResizeObserverFromDocument(targetDocument, handleResize);
    if (!container.current || !resizeObserverRef.current) {
      return;
    }
    resizeObserverRef.current.observe(container.current);
    return () => {
      var _resizeObserverRef_current;
      (_resizeObserverRef_current = resizeObserverRef.current) === null || _resizeObserverRef_current === void 0 ? void 0 : _resizeObserverRef_current.disconnect();
    };
  }, [
    handleResize,
    targetDocument
  ]);
  return {
    width,
    measureElementRef
  };
}
function createResizeObserverFromDocument(targetDocument, callback) {
  var _targetDocument_defaultView;
  if (!(targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.ResizeObserver)) {
    return null;
  }
  return new targetDocument.defaultView.ResizeObserver(callback);
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnResizeMouseHandler.js
var React328 = __toESM(require_react());
function useTableColumnResizeMouseHandler(columnResizeState) {
  const mouseX = React328.useRef(0);
  const currentWidth = React328.useRef(0);
  const colId = React328.useRef(void 0);
  const [dragging, setDragging] = React328.useState(false);
  const { targetDocument } = useFluent();
  const { getColumnWidth: getColumnWidth2, setColumnWidth } = columnResizeState;
  const recalculatePosition = React328.useCallback((e) => {
    const { clientX } = getEventClientCoords(e);
    const dx = clientX - mouseX.current;
    currentWidth.current += dx;
    colId.current && setColumnWidth(e, {
      columnId: colId.current,
      width: currentWidth.current
    });
    mouseX.current = clientX;
  }, [
    setColumnWidth
  ]);
  const [requestRecalcFrame] = useAnimationFrame();
  const onDrag = React328.useCallback((e) => {
    requestRecalcFrame(() => recalculatePosition(e));
  }, [
    requestRecalcFrame,
    recalculatePosition
  ]);
  const onDragEnd = React328.useCallback((event) => {
    if (isMouseEvent(event)) {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("mouseup", onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("mousemove", onDrag);
    }
    if (isTouchEvent(event)) {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("touchend", onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("touchmove", onDrag);
    }
    setDragging(false);
  }, [
    onDrag,
    targetDocument
  ]);
  const getOnMouseDown = React328.useCallback((columnId) => (event) => {
    currentWidth.current = getColumnWidth2(columnId);
    mouseX.current = getEventClientCoords(event).clientX;
    colId.current = columnId;
    if (isMouseEvent(event)) {
      if (event.target !== event.currentTarget || event.button !== 0) {
        return;
      }
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("mouseup", onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("mousemove", onDrag);
      setDragging(true);
    }
    if (isTouchEvent(event)) {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("touchend", onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("touchmove", onDrag);
      setDragging(true);
    }
  }, [
    getColumnWidth2,
    onDrag,
    onDragEnd,
    targetDocument
  ]);
  return {
    getOnMouseDown,
    dragging
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnResizeState.js
var React329 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/utils/columnResizeUtils.js
var DEFAULT_WIDTH = 150;
var DEFAULT_MIN_WIDTH = 100;
function columnDefinitionsToState(columns, state = [], columnSizingOptions = {}) {
  let updated = false;
  const stateMap = new Map(state.map((s) => [
    s.columnId,
    s
  ]));
  const updatedState = columns.map((column) => {
    const existingColumnState = stateMap.get(column.columnId);
    if (existingColumnState) {
      var _columnSizingOptions_column_columnId;
      const { idealWidth: idealWidth2 = existingColumnState.idealWidth, minWidth: minWidth2 = existingColumnState.minWidth, padding: padding2 = existingColumnState.padding } = (_columnSizingOptions_column_columnId = columnSizingOptions[column.columnId]) !== null && _columnSizingOptions_column_columnId !== void 0 ? _columnSizingOptions_column_columnId : {};
      if (idealWidth2 !== existingColumnState.idealWidth || minWidth2 !== existingColumnState.minWidth || padding2 !== existingColumnState.padding) {
        updated = true;
        return {
          ...existingColumnState,
          idealWidth: idealWidth2,
          width: idealWidth2,
          minWidth: minWidth2,
          padding: padding2
        };
      }
      return existingColumnState;
    }
    var _columnSizingOptions_column_columnId1;
    const { defaultWidth, idealWidth = DEFAULT_WIDTH, minWidth = DEFAULT_MIN_WIDTH, padding } = (_columnSizingOptions_column_columnId1 = columnSizingOptions[column.columnId]) !== null && _columnSizingOptions_column_columnId1 !== void 0 ? _columnSizingOptions_column_columnId1 : {};
    updated = true;
    return {
      columnId: column.columnId,
      width: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),
      minWidth,
      idealWidth: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),
      padding: padding !== null && padding !== void 0 ? padding : 16
    };
  });
  if (updatedState.length !== state.length || updated) {
    const column = updatedState.find((col) => col.width > col.idealWidth);
    if (column) {
      column.width = column.idealWidth;
    }
    updated = true;
  }
  return updated ? updatedState : state;
}
function getColumnById(state, columnId) {
  return state.find((c) => c.columnId === columnId);
}
function getColumnByIndex(state, index) {
  return state[index];
}
function getTotalWidth(state) {
  return state.reduce((sum, column) => sum + column.width + column.padding, 0);
}
function getColumnWidth(state, columnId) {
  const column = getColumnById(state, columnId);
  var _column_width;
  return (_column_width = column === null || column === void 0 ? void 0 : column.width) !== null && _column_width !== void 0 ? _column_width : 0;
}
function setColumnProperty(localState, columnId, property, value) {
  const currentColumn = getColumnById(localState, columnId);
  if (!currentColumn || (currentColumn === null || currentColumn === void 0 ? void 0 : currentColumn[property]) === value) {
    return localState;
  }
  const updatedColumn = {
    ...currentColumn,
    [property]: value
  };
  const newState = localState.reduce((acc, current) => {
    if (current.columnId === updatedColumn.columnId) {
      return [
        ...acc,
        updatedColumn
      ];
    }
    return [
      ...acc,
      current
    ];
  }, []);
  return newState;
}
function adjustColumnWidthsToFitContainer(state, containerWidth) {
  let newState = state;
  const totalWidth = getTotalWidth(newState);
  if (totalWidth < containerWidth) {
    let difference = containerWidth - totalWidth;
    let i = 0;
    while (i < newState.length && difference > 0) {
      const currentCol = getColumnByIndex(newState, i);
      if (!currentCol) {
        break;
      }
      const colAdjustment = Math.min(currentCol.idealWidth - currentCol.width, difference);
      newState = setColumnProperty(newState, currentCol.columnId, "width", currentCol.width + colAdjustment);
      difference -= colAdjustment;
      if (i === newState.length - 1 && difference !== 0) {
        const lastCol = getColumnByIndex(newState, i);
        if (lastCol) {
          newState = setColumnProperty(newState, lastCol.columnId, "width", lastCol.width + difference);
        }
      }
      i++;
    }
  } else if (totalWidth >= containerWidth) {
    let difference = totalWidth - containerWidth;
    let j = newState.length - 1;
    while (j >= 0 && difference > 0) {
      const currentCol = getColumnByIndex(newState, j);
      if (!currentCol) {
        j--;
        continue;
      }
      if (currentCol.width > currentCol.minWidth) {
        const colAdjustment = Math.min(currentCol.width - currentCol.minWidth, difference);
        difference -= colAdjustment;
        newState = setColumnProperty(newState, currentCol.columnId, "width", currentCol.width - colAdjustment);
      }
      j--;
    }
  }
  return newState;
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnResizeState.js
var createReducer = (autoFitColumns) => (state, action) => {
  switch (action.type) {
    case "CONTAINER_WIDTH_UPDATED":
      return {
        ...state,
        containerWidth: action.containerWidth,
        columnWidthState: autoFitColumns ? adjustColumnWidthsToFitContainer(state.columnWidthState, action.containerWidth) : state.columnWidthState
      };
    case "COLUMNS_UPDATED":
      const newS = columnDefinitionsToState(action.columns, state.columnWidthState, state.columnSizingOptions);
      return {
        ...state,
        columns: action.columns,
        columnWidthState: autoFitColumns ? adjustColumnWidthsToFitContainer(newS, state.containerWidth) : newS
      };
    case "COLUMN_SIZING_OPTIONS_UPDATED":
      const newState = columnDefinitionsToState(state.columns, state.columnWidthState, action.columnSizingOptions);
      return {
        ...state,
        columnSizingOptions: action.columnSizingOptions,
        columnWidthState: autoFitColumns ? adjustColumnWidthsToFitContainer(newState, state.containerWidth) : newState
      };
    case "SET_COLUMN_WIDTH":
      const { columnId, width } = action;
      const { containerWidth } = state;
      const column = getColumnById(state.columnWidthState, columnId);
      let newColumnWidthState = [
        ...state.columnWidthState
      ];
      if (!column) {
        return state;
      }
      newColumnWidthState = setColumnProperty(newColumnWidthState, columnId, "width", width);
      newColumnWidthState = setColumnProperty(newColumnWidthState, columnId, "idealWidth", width);
      if (autoFitColumns) {
        newColumnWidthState = adjustColumnWidthsToFitContainer(newColumnWidthState, containerWidth);
      }
      return {
        ...state,
        columnWidthState: newColumnWidthState
      };
  }
};
function useTableColumnResizeState(columns, containerWidth, params = {}) {
  const { onColumnResize, columnSizingOptions, autoFitColumns = true } = params;
  const reducer = React329.useMemo(() => createReducer(autoFitColumns), [
    autoFitColumns
  ]);
  const [state, dispatch] = React329.useReducer(reducer, {
    columns,
    containerWidth: 0,
    columnWidthState: columnDefinitionsToState(columns, void 0, columnSizingOptions),
    columnSizingOptions
  });
  useIsomorphicLayoutEffect(() => {
    dispatch({
      type: "CONTAINER_WIDTH_UPDATED",
      containerWidth
    });
  }, [
    containerWidth
  ]);
  useIsomorphicLayoutEffect(() => {
    dispatch({
      type: "COLUMNS_UPDATED",
      columns
    });
  }, [
    columns
  ]);
  useIsomorphicLayoutEffect(() => {
    dispatch({
      type: "COLUMN_SIZING_OPTIONS_UPDATED",
      columnSizingOptions
    });
  }, [
    columnSizingOptions
  ]);
  const setColumnWidth = useEventCallback((event, data) => {
    let { width } = data;
    const { columnId } = data;
    const col = getColumnById(state.columnWidthState, columnId);
    if (!col) {
      return;
    }
    width = Math.max(col.minWidth || 0, width);
    if (onColumnResize) {
      onColumnResize(event, {
        columnId,
        width
      });
    }
    dispatch({
      type: "SET_COLUMN_WIDTH",
      columnId,
      width
    });
  });
  return {
    getColumnById: React329.useCallback((colId) => getColumnById(state.columnWidthState, colId), [
      state.columnWidthState
    ]),
    getColumns: React329.useCallback(() => state.columnWidthState, [
      state.columnWidthState
    ]),
    getColumnWidth: React329.useCallback((colId) => getColumnWidth(state.columnWidthState, colId), [
      state.columnWidthState
    ]),
    setColumnWidth
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useKeyboardResizing.js
var React330 = __toESM(require_react());
var STEP = 20;
var PRECISION_MODIFIER = Shift;
var PRECISION_FACTOR = 1 / 4;
function useKeyboardResizing(columnResizeState) {
  const [columnId, setColumnId] = React330.useState();
  const onChangeRef = React330.useRef(void 0);
  const { findPrevFocusable } = useFocusFinders();
  const columnResizeStateRef = React330.useRef(columnResizeState);
  React330.useEffect(() => {
    columnResizeStateRef.current = columnResizeState;
  }, [
    columnResizeState
  ]);
  const [resizeHandleRefs] = React330.useState(() => /* @__PURE__ */ new Map());
  const keyboardHandler = useEventCallback((event) => {
    if (!columnId) {
      return;
    }
    const width = columnResizeStateRef.current.getColumnWidth(columnId);
    const precisionModifier = event.getModifierState(PRECISION_MODIFIER);
    const stopEvent = () => {
      event.preventDefault();
      event.stopPropagation();
    };
    switch (event.key) {
      case ArrowLeft:
        stopEvent();
        columnResizeStateRef.current.setColumnWidth(event.nativeEvent, {
          columnId,
          width: width - (precisionModifier ? STEP * PRECISION_FACTOR : STEP)
        });
        return;
      case ArrowRight:
        stopEvent();
        columnResizeStateRef.current.setColumnWidth(event.nativeEvent, {
          columnId,
          width: width + (precisionModifier ? STEP * PRECISION_FACTOR : STEP)
        });
        return;
      case Space:
      case Enter:
      case Escape:
        var _resizeHandleRefs_get_current, _resizeHandleRefs_get;
        stopEvent();
        (_resizeHandleRefs_get = resizeHandleRefs.get(columnId)) === null || _resizeHandleRefs_get === void 0 ? void 0 : (_resizeHandleRefs_get_current = _resizeHandleRefs_get.current) === null || _resizeHandleRefs_get_current === void 0 ? void 0 : _resizeHandleRefs_get_current.blur();
        break;
    }
  });
  const enableInteractiveMode = React330.useCallback((colId) => {
    var _onChangeRef_current, _resizeHandleRefs_get;
    setColumnId(colId);
    (_onChangeRef_current = onChangeRef.current) === null || _onChangeRef_current === void 0 ? void 0 : _onChangeRef_current.call(onChangeRef, colId, true);
    const handle = (_resizeHandleRefs_get = resizeHandleRefs.get(colId)) === null || _resizeHandleRefs_get === void 0 ? void 0 : _resizeHandleRefs_get.current;
    if (handle) {
      handle.setAttribute("tabindex", "-1");
      handle.tabIndex = -1;
      handle.focus();
    }
  }, [
    resizeHandleRefs
  ]);
  const disableInteractiveMode = React330.useCallback(() => {
    var _onChangeRef_current, _resizeHandleRefs_get;
    if (!columnId) {
      return;
    }
    (_onChangeRef_current = onChangeRef.current) === null || _onChangeRef_current === void 0 ? void 0 : _onChangeRef_current.call(onChangeRef, columnId, false);
    const el = (_resizeHandleRefs_get = resizeHandleRefs.get(columnId)) === null || _resizeHandleRefs_get === void 0 ? void 0 : _resizeHandleRefs_get.current;
    if (el) {
      var _findPrevFocusable;
      (_findPrevFocusable = findPrevFocusable(el)) === null || _findPrevFocusable === void 0 ? void 0 : _findPrevFocusable.focus();
      el.removeAttribute("tabindex");
    }
    setColumnId(void 0);
  }, [
    columnId,
    findPrevFocusable,
    resizeHandleRefs
  ]);
  const toggleInteractiveMode = (colId, onChange) => {
    onChangeRef.current = onChange;
    if (!columnId) {
      enableInteractiveMode(colId);
    } else if (colId && columnId !== colId) {
      enableInteractiveMode(colId);
      setColumnId(colId);
    } else {
      disableInteractiveMode();
    }
  };
  const getKeyboardResizingRef = React330.useCallback((colId) => {
    const ref = resizeHandleRefs.get(colId) || React330.createRef();
    resizeHandleRefs.set(colId, ref);
    return ref;
  }, [
    resizeHandleRefs
  ]);
  const tabsterAttrs = useTabsterAttributes({
    focusable: {
      ignoreKeydown: {
        ArrowLeft: true,
        ArrowRight: true
      }
    }
  });
  return {
    toggleInteractiveMode,
    columnId,
    getKeyboardResizingProps: React330.useCallback((colId, currentWidth) => ({
      onKeyDown: keyboardHandler,
      onBlur: disableInteractiveMode,
      ref: getKeyboardResizingRef(colId),
      role: "separator",
      "aria-label": "Resize column",
      "aria-valuetext": `${currentWidth} pixels`,
      "aria-hidden": colId === columnId ? false : true,
      tabIndex: colId === columnId ? 0 : void 0,
      ...tabsterAttrs
    }), [
      columnId,
      disableInteractiveMode,
      getKeyboardResizingRef,
      keyboardHandler,
      tabsterAttrs
    ])
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnSizing.js
var defaultColumnSizingState = {
  getColumnWidths: () => [],
  getOnMouseDown: () => () => null,
  setColumnWidth: () => null,
  getTableProps: () => ({}),
  getTableHeaderCellProps: () => ({
    style: {},
    columnId: ""
  }),
  getTableCellProps: () => ({
    style: {},
    columnId: ""
  }),
  enableKeyboardMode: () => () => null
};
function useTableColumnSizing_unstable(params) {
  "use no memo";
  return (tableState) => (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useTableColumnSizingState(tableState, {
      autoFitColumns: true,
      ...params
    })
  );
}
function getColumnStyles(column, dragging) {
  const width = column.width;
  return {
    // native styles
    width,
    // non-native element styles (flex layout)
    minWidth: width,
    maxWidth: width,
    // Fixed the unwanted sort: https://github.com/microsoft/fluentui/issues/27803
    ...dragging ? {
      pointerEvents: "none"
    } : {}
  };
}
function useTableColumnSizingState(tableState, params = {}) {
  const { columns } = tableState;
  const { width, measureElementRef } = useMeasureElement();
  const columnResizeState = useTableColumnResizeState(columns, width + ((params === null || params === void 0 ? void 0 : params.containerWidthOffset) || 0), params);
  const mouseHandler = useTableColumnResizeMouseHandler(columnResizeState);
  const { toggleInteractiveMode, getKeyboardResizingProps } = useKeyboardResizing(columnResizeState);
  const { autoFitColumns } = params;
  const enableKeyboardMode = React331.useCallback((columnId, onChange) => (e) => {
    e.preventDefault();
    e.nativeEvent.stopPropagation();
    toggleInteractiveMode(columnId, onChange);
  }, [
    toggleInteractiveMode
  ]);
  const { getColumnById: getColumnById2, setColumnWidth, getColumns } = columnResizeState;
  const { getOnMouseDown, dragging } = mouseHandler;
  return {
    ...tableState,
    tableRef: measureElementRef,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    columnSizing_unstable: {
      getOnMouseDown,
      setColumnWidth: (columnId, w) => setColumnWidth(void 0, {
        columnId,
        width: w
      }),
      getColumnWidths: getColumns,
      getTableProps: (props = {}) => {
        return {
          ...props,
          style: {
            minWidth: "fit-content",
            ...props.style || {}
          }
        };
      },
      getTableHeaderCellProps: React331.useCallback((columnId) => {
        var _columns_;
        const col = getColumnById2(columnId);
        const isLastColumn = ((_columns_ = columns[columns.length - 1]) === null || _columns_ === void 0 ? void 0 : _columns_.columnId) === columnId;
        const aside = isLastColumn && autoFitColumns ? null : React331.createElement(TableResizeHandle, {
          onMouseDown: getOnMouseDown(columnId),
          onTouchStart: getOnMouseDown(columnId),
          ...getKeyboardResizingProps(columnId, (col === null || col === void 0 ? void 0 : col.width) || 0)
        });
        return col ? {
          style: getColumnStyles(col, dragging),
          aside
        } : {};
      }, [
        getColumnById2,
        columns,
        dragging,
        getKeyboardResizingProps,
        getOnMouseDown,
        autoFitColumns
      ]),
      getTableCellProps: React331.useCallback((columnId) => {
        const col = getColumnById2(columnId);
        return col ? {
          style: getColumnStyles(col)
        } : {};
      }, [
        getColumnById2
      ]),
      enableKeyboardMode
    }
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableFeatures.js
var defaultRowEnhancer = (row) => row;
var defaultTableState = {
  selection: defaultTableSelectionState,
  sort: defaultTableSortState,
  getRows: () => [],
  getRowId: () => "",
  items: [],
  columns: [],
  // eslint-disable-next-line @typescript-eslint/naming-convention
  columnSizing_unstable: defaultColumnSizingState,
  tableRef: React332.createRef()
};
function useTableFeatures(options, plugins = []) {
  const { items, getRowId, columns } = options;
  const getRows = React332.useCallback((rowEnhancer = defaultRowEnhancer) => {
    return items.map((item, i) => {
      var _getRowId;
      return rowEnhancer({
        item,
        rowId: (_getRowId = getRowId === null || getRowId === void 0 ? void 0 : getRowId(item)) !== null && _getRowId !== void 0 ? _getRowId : i
      });
    });
  }, [
    items,
    getRowId
  ]);
  const initialState = {
    getRowId,
    items,
    columns,
    getRows,
    selection: defaultTableSelectionState,
    sort: defaultTableSortState,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    columnSizing_unstable: defaultColumnSizingState,
    tableRef: React332.createRef()
  };
  return plugins.reduce((state, plugin) => plugin(state), initialState);
}

// node_modules/@fluentui/react-table/lib/hooks/createColumn.js
var React333 = __toESM(require_react());
var defaultCompare = () => 0;
var defaultRenderCell = () => {
  if (true) {
    console.warn("@fluentui/react-table: You are using the default column renderCell function that renders null");
  }
  return null;
};
var defaultRenderHeaderCell = () => {
  if (true) {
    console.warn("@fluentui/react-table: You are using the default column renderHeaderCell function that renders null");
  }
  return null;
};
function createTableColumn(options) {
  const { columnId, renderCell = defaultRenderCell, renderHeaderCell = defaultRenderHeaderCell, compare = defaultCompare } = options;
  return {
    columnId,
    renderCell,
    renderHeaderCell,
    compare
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableCompositeNavigation.js
var React334 = __toESM(require_react());
function useTableCompositeNavigation() {
  const horizontalAttr = useArrowNavigationGroup({
    axis: "horizontal"
  });
  const gridAttr = useArrowNavigationGroup({
    axis: "grid"
  });
  const groupperAttr = useFocusableGroup({
    tabBehavior: "limited-trap-focus"
  });
  const { findFirstFocusable } = useFocusFinders();
  const { targetDocument } = useFluent();
  const rowAttr = useMergedTabsterAttributes_unstable(horizontalAttr, groupperAttr);
  const onKeyDown = React334.useCallback((e) => {
    if (!targetDocument) {
      return;
    }
    let activeElement = targetDocument.activeElement;
    if (!activeElement || !e.currentTarget.contains(activeElement)) {
      return;
    }
    const activeElementRole = activeElement.getAttribute("role");
    if (e.key === ArrowRight && activeElementRole === "row" && isHTMLElement(activeElement)) {
      var _findFirstFocusable;
      (_findFirstFocusable = findFirstFocusable(activeElement)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
    }
    if (activeElementRole === "row") {
      return;
    }
    const isInCell = (() => {
      let cur = isHTMLElement(activeElement) ? activeElement : null;
      while (cur) {
        const curRole = cur.getAttribute("role");
        if (curRole === "cell" || curRole === "gridcell") {
          return true;
        }
        cur = cur.parentElement;
      }
      return false;
    })();
    if (e.key === ArrowLeft && isInCell) {
      activeElement.dispatchEvent(new GroupperMoveFocusEvent({
        action: GroupperMoveFocusActions.Escape
      }));
      return;
    }
    if ((e.key === ArrowDown || e.key === ArrowUp) && isInCell) {
      activeElement.dispatchEvent(new GroupperMoveFocusEvent({
        action: GroupperMoveFocusActions.Escape
      }));
      activeElement = targetDocument.activeElement;
      if (activeElement) {
        activeElement.dispatchEvent(new MoverMoveFocusEvent({
          key: MoverKeys[e.key]
        }));
      }
    }
  }, [
    targetDocument,
    findFirstFocusable
  ]);
  return {
    onTableKeyDown: onKeyDown,
    tableTabsterAttribute: gridAttr,
    tableRowTabsterAttribute: rowAttr
  };
}

// node_modules/@fluentui/react-table/lib/components/TableCell/TableCell.js
var React337 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableCell/useTableCell.js
var React336 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/contexts/tableContext.js
var React335 = __toESM(require_react());
var tableContext = React335.createContext(void 0);
var tableContextDefaultValue = {
  size: "medium",
  noNativeElements: false,
  sortable: false
};
var TableContextProvider = tableContext.Provider;
var useTableContext = () => {
  var _React_useContext;
  return (_React_useContext = React335.useContext(tableContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tableContextDefaultValue;
};

// node_modules/@fluentui/react-table/lib/components/TableCell/useTableCell.js
var useTableCell_unstable = (props, ref) => {
  const { noNativeElements, size: size3 } = useTableContext();
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "td";
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: rootComponent === "div" ? "cell" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    noNativeElements,
    size: size3
  };
};

// node_modules/@fluentui/react-table/lib/components/TableCell/renderTableCell.js
var renderTableCell_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableCell/useTableCellStyles.styles.js
var tableCellClassName = "fui-TableCell";
var tableCellClassNames = {
  root: tableCellClassName
};
var useTableLayoutStyles = __styles2({
  root: {
    mc9l5x: "f15pt5es",
    ha4doy: "fmrv4ls"
  },
  medium: {
    Bqenvij: "f1ft4266"
  },
  small: {
    Bqenvij: "fbsu25e"
  },
  "extra-small": {
    Bqenvij: "frvgh55"
  }
}, {
  d: [".f15pt5es{display:table-cell;}", ".fmrv4ls{vertical-align:middle;}", ".f1ft4266{height:44px;}", ".fbsu25e{height:34px;}", ".frvgh55{height:24px;}"]
});
var useFlexLayoutStyles = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bf4jedk: "f10tiqix",
    Bt984gj: "f122n59",
    xawz: 0,
    Bh6795r: 0,
    Bnnss6s: 0,
    fkmc3a: "f1izfyrr"
  },
  medium: {
    sshi5w: "f5pgtk9"
  },
  small: {
    sshi5w: "fcep9tg"
  },
  "extra-small": {
    sshi5w: "f1pha7fy"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f10tiqix{min-width:0px;}", ".f122n59{align-items:center;}", [".f1izfyrr{flex:1 1 0px;}", {
    p: -1
  }], ".f5pgtk9{min-height:44px;}", ".fcep9tg{min-height:34px;}", ".f1pha7fy{min-height:24px;}"]
});
var useStyles40 = __styles2({
  root: {
    qhf8xq: "f10pi13n",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f3gpkru",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f1dxfoyt",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w"
  }
}, {
  d: [".f10pi13n{position:relative;}", [".f3gpkru{padding:0px var(--spacingHorizontalS);}", {
    p: -1
  }], [".f1dxfoyt[data-fui-focus-visible]{outline:2px solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }]]
});
var useTableCellStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles40();
  const layoutStyles = {
    table: useTableLayoutStyles(),
    flex: useFlexLayoutStyles()
  };
  state.root.className = mergeClasses(tableCellClassNames.root, styles.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.noNativeElements ? layoutStyles.flex[state.size] : layoutStyles.table[state.size], state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableCell/TableCell.js
var TableCell = React337.forwardRef((props, ref) => {
  const state = useTableCell_unstable(props, ref);
  useTableCellStyles_unstable(state);
  useCustomStyleHook("useTableCellStyles_unstable")(state);
  return renderTableCell_unstable(state);
});
TableCell.displayName = "TableCell";

// node_modules/@fluentui/react-table/lib/components/TableRow/TableRow.js
var React340 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableRow/useTableRow.js
var React339 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/contexts/tableHeaderContext.js
var React338 = __toESM(require_react());
var tableHeaderContext = React338.createContext(void 0);
var tableHeaderContextDefaultValue = "";
var TableHeaderContextProvider = tableHeaderContext.Provider;
var useIsInTableHeader = () => React338.useContext(tableHeaderContext) === tableHeaderContextDefaultValue;

// node_modules/@fluentui/react-table/lib/components/TableRow/useTableRow.js
var useTableRow_unstable = (props, ref) => {
  const { noNativeElements, size: size3 } = useTableContext();
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "tr";
  const focusVisibleRef = useFocusVisible();
  const focusWithinRef = useFocusWithin();
  const isHeaderRow = useIsInTableHeader();
  var _props_appearance;
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, focusVisibleRef, focusWithinRef),
      role: rootComponent === "div" ? "row" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    size: size3,
    noNativeElements,
    appearance: (_props_appearance = props.appearance) !== null && _props_appearance !== void 0 ? _props_appearance : "none",
    isHeaderRow
  };
};

// node_modules/@fluentui/react-table/lib/components/TableRow/renderTableRow.js
var renderTableRow_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableCellActions/useTableCellActionsStyles.styles.js
var tableCellActionsClassNames = {
  root: "fui-TableCellActions"
};
var useStyles41 = __styles2({
  root: {
    De3pzq: "f1u2r49w",
    qhf8xq: "f1euv43f",
    j35jbq: ["f10k790i", "f1xynx9j"],
    Bhzewxz: "f1i1t8d1",
    Bz10aip: "f188r07x",
    abs64n: "fk73vx1",
    Frg6f3: ["fcgxt0o", "f1ujusj6"]
  },
  visible: {
    abs64n: "f5p0z4x"
  }
}, {
  d: [".f1u2r49w{background-color:inherit;}", ".f1euv43f{position:absolute;}", ".f10k790i{right:0px;}", ".f1xynx9j{left:0px;}", ".f1i1t8d1{top:50%;}", ".f188r07x{transform:translateY(-50%);}", ".fk73vx1{opacity:0;}", ".fcgxt0o{margin-left:auto;}", ".f1ujusj6{margin-right:auto;}", ".f5p0z4x{opacity:1;}"]
});
var useTableCellActionsStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles41();
  state.root.className = mergeClasses(tableCellActionsClassNames.root, styles.root, state.visible && styles.visible, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/useTableSelectionCellStyles.styles.js
var CELL_WIDTH = 44;
var tableSelectionCellClassNames = {
  root: "fui-TableSelectionCell",
  checkboxIndicator: "fui-TableSelectionCell__checkboxIndicator",
  radioIndicator: "fui-TableSelectionCell__radioIndicator"
};
var useTableLayoutStyles2 = __styles2({
  root: {
    mc9l5x: "f15pt5es",
    a9b677: "fksc0bp"
  }
}, {
  d: [".f15pt5es{display:table-cell;}", ".fksc0bp{width:44px;}"]
});
var useFlexLayoutStyles2 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    xawz: 0,
    Bh6795r: 0,
    Bnnss6s: 0,
    fkmc3a: "f1izfyrr",
    Bf4jedk: "fvrlu0f",
    B2u0y6b: "f1c71y05",
    Brf1p80: "f4d9j23"
  }
}, {
  d: [".f22iagw{display:flex;}", [".f1izfyrr{flex:1 1 0px;}", {
    p: -1
  }], ".fvrlu0f{min-width:44px;}", ".f1c71y05{max-width:44px;}", ".f4d9j23{justify-content:center;}"]
});
var useStyles42 = __styles2({
  root: {
    fsow6f: "f17mccla",
    Huce71: "fz5stix",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f1dxfoyt",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w"
  },
  radioIndicator: {
    mc9l5x: "f22iagw",
    Bh6795r: "fqerorx",
    Bt984gj: "f122n59",
    Brf1p80: "f4d9j23"
  },
  subtle: {
    abs64n: "fk73vx1",
    B8a84jv: "f1y7ij6c"
  },
  hidden: {
    abs64n: "fk73vx1"
  }
}, {
  d: [".f17mccla{text-align:center;}", ".fz5stix{white-space:nowrap;}", [".f1mk8lai{padding:0;}", {
    p: -1
  }], [".f1dxfoyt[data-fui-focus-visible]{outline:2px solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".fqerorx{flex-grow:1;}", ".f122n59{align-items:center;}", ".f4d9j23{justify-content:center;}", ".fk73vx1{opacity:0;}", ".f1y7ij6c[data-fui-focus-within]:focus-within{opacity:1;}"]
});
var useTableSelectionCellStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles42();
  const layoutStyles = {
    table: useTableLayoutStyles2(),
    flex: useFlexLayoutStyles2()
  };
  state.root.className = mergeClasses(tableSelectionCellClassNames.root, styles.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.subtle && state.checked === false && styles.subtle, state.hidden && styles.hidden, state.root.className);
  if (state.checkboxIndicator) {
    state.checkboxIndicator.className = mergeClasses(tableSelectionCellClassNames.checkboxIndicator, state.checkboxIndicator.className);
  }
  if (state.radioIndicator) {
    state.radioIndicator.className = mergeClasses(tableSelectionCellClassNames.radioIndicator, styles.radioIndicator, state.radioIndicator.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableRow/useTableRowStyles.styles.js
var tableRowClassName = "fui-TableRow";
var tableRowClassNames = {
  root: tableRowClassName
};
var useTableLayoutStyles3 = __styles2({
  root: {
    mc9l5x: "f1u0rzck"
  }
}, {
  d: [".f1u0rzck{display:table-row;}"]
});
var useFlexLayoutStyles3 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}"]
});
var useStyles43 = __styles2({
  root: {
    sj55zd: "f19n0e5",
    B7ck84d: "f1ewtqcl",
    Bconypa: "f1jazu75",
    B6guboy: "f1xeqee6",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f1dxfoyt",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w"
  },
  rootInteractive: {
    B6guboy: "f1xeqee6",
    ecr2s2: "f1wfn5kd",
    lj723h: "f1g4hkjv",
    B43xm9u: "f15ngxrw",
    i921ia: "fjbbrdp",
    Jwef8y: "f1t94bn6",
    Bi91k9c: "feu1g3u",
    Bpt6rm4: "f1uorfem",
    ff6mpl: "fw60kww",
    ze5xyy: "f4xjyn1",
    pgvf35: "ff1wgvm",
    Bh7lczh: ["fiob0tu", "f1x4h75k"],
    dpv3f4: "f1j6scgf",
    Bpnjhaq: ["f1x4h75k", "fiob0tu"]
  },
  medium: {
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f1facbz3"
  },
  small: {
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f1facbz3"
  },
  "extra-small": {
    Be2twd7: "fy9rknc"
  },
  brand: {
    De3pzq: "f16xkysk",
    g2u3we: "f1bh3yvw",
    h3c5rm: ["fmi79ni", "f11fozsx"],
    B9xav0g: "fnzw4c6",
    zhjwy3: ["f11fozsx", "fmi79ni"],
    ecr2s2: "f7tkmfy",
    lj723h: "f1r2dosr",
    uu68id: 0,
    Bxeuatn: 0,
    felo30: 0,
    Bc736ss: 0,
    Bhz882k: 0,
    n51gp8: 0,
    Eshu5l: 0,
    Bk6ri7n: 0,
    v49c4f: 0,
    Bn1d65q: 0,
    c4eypz: 0,
    v3aym: 0,
    hft9gk: 0,
    Bjwas2f: 0,
    Bk5ld8o: 0,
    gwxt9v: 0,
    B6k8go: "f95l9gw",
    h6lo6r: 0,
    Beo2b4z: 0,
    w1pwid: 0,
    Btyw6ap: 0,
    Hkxhyr: "fw8kmcu",
    Brwvgy3: "fd94n53",
    yadkgm: "f1e0wld5"
  },
  neutral: {
    uu68id: 0,
    Bxeuatn: 0,
    felo30: 0,
    Bc736ss: 0,
    Bhz882k: 0,
    n51gp8: 0,
    Eshu5l: 0,
    Bk6ri7n: 0,
    v49c4f: 0,
    Bn1d65q: 0,
    c4eypz: 0,
    v3aym: 0,
    hft9gk: 0,
    Bjwas2f: 0,
    Bk5ld8o: 0,
    gwxt9v: 0,
    B6k8go: "f95l9gw",
    h6lo6r: 0,
    Beo2b4z: 0,
    w1pwid: 0,
    Btyw6ap: 0,
    Hkxhyr: "fw8kmcu",
    Brwvgy3: "fd94n53",
    yadkgm: "f1e0wld5",
    De3pzq: "fq5gl1p",
    sj55zd: "f1cgsbmv",
    Jwef8y: "f1uqaxdt",
    ecr2s2: "fa9o754",
    g2u3we: "frmsihh",
    h3c5rm: ["frttxa5", "f11o2r7f"],
    B9xav0g: "fem5et0",
    zhjwy3: ["f11o2r7f", "frttxa5"]
  },
  none: {}
}, {
  d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1ewtqcl{box-sizing:border-box;}", ".f1jazu75[data-fui-focus-within]:focus-within .fui-TableSelectionCell{opacity:1;}", ".f1xeqee6[data-fui-focus-within]:focus-within .fui-TableCellActions{opacity:1;}", [".f1dxfoyt[data-fui-focus-visible]{outline:2px solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f1facbz3{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStroke2);}", {
    p: -1
  }], [".f1facbz3{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStroke2);}", {
    p: -1
  }], ".fy9rknc{font-size:var(--fontSizeBase200);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".f1bh3yvw{border-top-color:var(--colorTransparentStrokeInteractive);}", ".fmi79ni{border-right-color:var(--colorTransparentStrokeInteractive);}", ".f11fozsx{border-left-color:var(--colorTransparentStrokeInteractive);}", ".fnzw4c6{border-bottom-color:var(--colorTransparentStrokeInteractive);}", ".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1cgsbmv{color:var(--colorNeutralForeground1Hover);}", ".frmsihh{border-top-color:var(--colorNeutralStrokeOnBrand);}", ".frttxa5{border-right-color:var(--colorNeutralStrokeOnBrand);}", ".f11o2r7f{border-left-color:var(--colorNeutralStrokeOnBrand);}", ".fem5et0{border-bottom-color:var(--colorNeutralStrokeOnBrand);}"],
  a: [".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}", ".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}", ".f15ngxrw:active .fui-TableCellActions{opacity:1;}", ".fjbbrdp:active .fui-TableSelectionCell{opacity:1;}", ".f7tkmfy:active{background-color:var(--colorBrandBackground2);}", ".f1r2dosr:active{color:var(--colorNeutralForeground1);}", ".fa9o754:active{background-color:var(--colorSubtleBackgroundSelected);}"],
  h: [".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f1uorfem:hover .fui-TableCellActions{opacity:1;}", ".fw60kww:hover .fui-TableSelectionCell{opacity:1;}", ".f1uqaxdt:hover{background-color:var(--colorSubtleBackgroundSelected);}"],
  m: [["@media (forced-colors: active){.f4xjyn1:hover{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.ff1wgvm:hover{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1x4h75k:hover{border-left-color:Highlight;}.fiob0tu:hover{border-right-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1j6scgf:hover{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f95l9gw{border:2px solid transparent;}}", {
    p: -2,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fw8kmcu{border-radius:var(--borderRadiusMedium);}}", {
    p: -1,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fd94n53{box-sizing:border-box;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1e0wld5:focus-visible{outline-offset:-4px;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useTableRowStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles43();
  const layoutStyles = {
    table: useTableLayoutStyles3(),
    flex: useFlexLayoutStyles3()
  };
  state.root.className = mergeClasses(tableRowClassNames.root, styles.root, !state.isHeaderRow && styles.rootInteractive, styles[state.size], state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, styles[state.appearance], state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableRow/TableRow.js
var TableRow = React340.forwardRef((props, ref) => {
  const state = useTableRow_unstable(props, ref);
  useTableRowStyles_unstable(state);
  useCustomStyleHook("useTableRowStyles_unstable")(state);
  return renderTableRow_unstable(state);
});
TableRow.displayName = "TableRow";

// node_modules/@fluentui/react-table/lib/components/TableBody/TableBody.js
var React342 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableBody/useTableBody.js
var React341 = __toESM(require_react());
var useTableBody_unstable = (props, ref) => {
  const { noNativeElements } = useTableContext();
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "tbody";
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: rootComponent === "div" ? "rowgroup" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    noNativeElements
  };
};

// node_modules/@fluentui/react-table/lib/components/TableBody/renderTableBody.js
var renderTableBody_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableBody/useTableBodyStyles.styles.js
var useTableLayoutStyles4 = __styles2({
  root: {
    mc9l5x: "f1tp1avn"
  }
}, {
  d: [".f1tp1avn{display:table-row-group;}"]
});
var useFlexLayoutStyles4 = __styles2({
  root: {
    mc9l5x: "ftgm304"
  }
}, {
  d: [".ftgm304{display:block;}"]
});
var tableBodyClassName = "fui-TableBody";
var tableBodyClassNames = {
  root: "fui-TableBody"
};
var useTableBodyStyles_unstable = (state) => {
  "use no memo";
  const layoutStyles = {
    table: useTableLayoutStyles4(),
    flex: useFlexLayoutStyles4()
  };
  state.root.className = mergeClasses(tableBodyClassName, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableBody/TableBody.js
var TableBody = React342.forwardRef((props, ref) => {
  const state = useTableBody_unstable(props, ref);
  useTableBodyStyles_unstable(state);
  useCustomStyleHook("useTableBodyStyles_unstable")(state);
  return renderTableBody_unstable(state);
});
TableBody.displayName = "TableBody";

// node_modules/@fluentui/react-table/lib/components/Table/Table.js
var React345 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/Table/useTable.js
var React343 = __toESM(require_react());
var useTable_unstable = (props, ref) => {
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : props.noNativeElements) ? "div" : "table";
  var _props_size, _props_noNativeElements, _props_sortable;
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: rootComponent === "div" ? "table" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    size: (_props_size = props.size) !== null && _props_size !== void 0 ? _props_size : "medium",
    noNativeElements: (_props_noNativeElements = props.noNativeElements) !== null && _props_noNativeElements !== void 0 ? _props_noNativeElements : false,
    sortable: (_props_sortable = props.sortable) !== null && _props_sortable !== void 0 ? _props_sortable : false
  };
};

// node_modules/@fluentui/react-table/lib/components/Table/renderTable.js
var renderTable_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(TableContextProvider, {
    value: contextValues.table,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-table/lib/components/Table/useTableStyles.styles.js
var tableClassName = "fui-Table";
var tableClassNames = {
  root: "fui-Table"
};
var useTableLayoutStyles5 = __styles2({
  root: {
    mc9l5x: "f1w4nmp0",
    ha4doy: "fmrv4ls",
    a9b677: "fly5x3f",
    B73mfa3: "f14m3nip"
  }
}, {
  d: [".f1w4nmp0{display:table;}", ".fmrv4ls{vertical-align:middle;}", ".fly5x3f{width:100%;}", ".f14m3nip{table-layout:fixed;}"]
});
var useFlexLayoutStyles5 = __styles2({
  root: {
    mc9l5x: "ftgm304"
  }
}, {
  d: [".ftgm304{display:block;}"]
});
var useStyles44 = __styles2({
  root: {
    po53p8: "fgkb47j",
    De3pzq: "fhovq9v"
  }
}, {
  d: [".fgkb47j{border-collapse:collapse;}", ".fhovq9v{background-color:var(--colorSubtleBackground);}"]
});
var useTableStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles44();
  const layoutStyles = {
    table: useTableLayoutStyles5(),
    flex: useFlexLayoutStyles5()
  };
  state.root.className = mergeClasses(tableClassName, styles.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/Table/useTableContextValues.js
var React344 = __toESM(require_react());
function useTableContextValues_unstable(state) {
  const { size: size3, noNativeElements, sortable } = state;
  const tableContext2 = React344.useMemo(() => ({
    noNativeElements,
    size: size3,
    sortable
  }), [
    noNativeElements,
    size3,
    sortable
  ]);
  return {
    table: tableContext2
  };
}

// node_modules/@fluentui/react-table/lib/components/Table/Table.js
var Table = React345.forwardRef((props, ref) => {
  const state = useTable_unstable(props, ref);
  useTableStyles_unstable(state);
  useCustomStyleHook("useTableStyles_unstable")(state);
  return renderTable_unstable(state, useTableContextValues_unstable(state));
});
Table.displayName = "Table";

// node_modules/@fluentui/react-table/lib/components/TableHeader/TableHeader.js
var React347 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableHeader/useTableHeader.js
var React346 = __toESM(require_react());
var useTableHeader_unstable = (props, ref) => {
  const { noNativeElements } = useTableContext();
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "thead";
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: rootComponent === "div" ? "rowgroup" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    noNativeElements
  };
};

// node_modules/@fluentui/react-table/lib/components/TableHeader/renderTableHeader.js
var renderTableHeader_unstable = (state) => {
  assertSlots(state);
  return jsx(TableHeaderContextProvider, {
    value: "",
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-table/lib/components/TableHeader/useTableHeaderStyles.styles.js
var tableHeaderClassName = "fui-TableHeader";
var tableHeaderClassNames = {
  root: "fui-TableHeader"
};
var useFlexLayoutStyles6 = __styles2({
  root: {
    mc9l5x: "ftgm304"
  }
}, {
  d: [".ftgm304{display:block;}"]
});
var useTableLayoutStyles6 = __styles2({
  root: {
    mc9l5x: "f1tp1avn"
  }
}, {
  d: [".f1tp1avn{display:table-row-group;}"]
});
var useTableHeaderStyles_unstable = (state) => {
  "use no memo";
  const layoutStyles = {
    table: useTableLayoutStyles6(),
    flex: useFlexLayoutStyles6()
  };
  state.root.className = mergeClasses(tableHeaderClassName, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableHeader/TableHeader.js
var TableHeader = React347.forwardRef((props, ref) => {
  const state = useTableHeader_unstable(props, ref);
  useTableHeaderStyles_unstable(state);
  useCustomStyleHook("useTableHeaderStyles_unstable")(state);
  return renderTableHeader_unstable(state);
});
TableHeader.displayName = "TableHeader";

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/TableHeaderCell.js
var React349 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/useTableHeaderCell.js
var React348 = __toESM(require_react());
var sortIcons = {
  ascending: React348.createElement(ArrowUpRegular, {
    fontSize: 12
  }),
  descending: React348.createElement(ArrowDownRegular, {
    fontSize: 12
  })
};
var useTableHeaderCell_unstable = (props, ref) => {
  const { noNativeElements, sortable: contextSortable } = useTableContext();
  const { sortable = contextSortable } = props;
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "th";
  const buttonSlot = slot_exports.always(props.button, {
    elementType: "div",
    defaultProps: {
      as: "div",
      ...!sortable && {
        role: "presentation",
        tabIndex: void 0
      }
    }
  });
  var _props_sortDirection;
  return {
    components: {
      root: rootComponent,
      button: "div",
      sortIcon: "span",
      aside: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, useFocusWithin()),
      role: rootComponent === "div" ? "columnheader" : void 0,
      "aria-sort": sortable ? (_props_sortDirection = props.sortDirection) !== null && _props_sortDirection !== void 0 ? _props_sortDirection : "none" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    aside: slot_exports.optional(props.aside, {
      elementType: "span"
    }),
    sortIcon: slot_exports.optional(props.sortIcon, {
      renderByDefault: !!props.sortDirection,
      defaultProps: {
        children: props.sortDirection ? sortIcons[props.sortDirection] : void 0
      },
      elementType: "span"
    }),
    button: useARIAButtonProps(buttonSlot.as, buttonSlot),
    sortable,
    noNativeElements
  };
};

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/renderTableHeaderCell.js
var renderTableHeaderCell_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsxs(state.button, {
        children: [
          state.root.children,
          state.sortIcon && jsx(state.sortIcon, {})
        ]
      }),
      state.aside && jsx(state.aside, {})
    ]
  });
};

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/useTableHeaderCellStyles.styles.js
var tableHeaderCellClassName = "fui-TableHeaderCell";
var tableHeaderCellClassNames = {
  root: "fui-TableHeaderCell",
  button: "fui-TableHeaderCell__button",
  sortIcon: "fui-TableHeaderCell__sortIcon",
  aside: "fui-TableHeaderCell__aside"
};
var useTableLayoutStyles7 = __styles2({
  root: {
    mc9l5x: "f15pt5es",
    ha4doy: "fmrv4ls"
  }
}, {
  d: [".f15pt5es{display:table-cell;}", ".fmrv4ls{vertical-align:middle;}"]
});
var useFlexLayoutStyles7 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    xawz: 0,
    Bh6795r: 0,
    Bnnss6s: 0,
    fkmc3a: "f1izfyrr",
    Bf4jedk: "f10tiqix"
  }
}, {
  d: [".f22iagw{display:flex;}", [".f1izfyrr{flex:1 1 0px;}", {
    p: -1
  }], ".f10tiqix{min-width:0px;}"]
});
var useStyles45 = __styles2({
  root: {
    Bhrd7zp: "figsok6",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f3gpkru",
    robkg1: 0,
    Bmvh20x: 0,
    B3nxjsc: 0,
    Bmkhcsx: "f14ym4q2",
    B8osjzx: 0,
    pehzd3: 0,
    Blsv9te: 0,
    u7xebq: 0,
    Bsvwmf7: "f1euou18",
    qhf8xq: "f10pi13n"
  },
  rootInteractive: {
    Bi91k9c: "feu1g3u",
    Jwef8y: "f1t94bn6",
    lj723h: "f1g4hkjv",
    ecr2s2: "f1wfn5kd"
  },
  resetButton: {
    B3rzk8w: "fq6nmtn",
    B7ck84d: "f1e4lqlz",
    De3pzq: "f1u2r49w",
    sj55zd: "f1ym3bx4",
    Bahqtrf: "f1mo0ibp",
    Be2twd7: "fjoy568",
    Bg96gwp: "fytdu2e",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1gl81tg",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    fsow6f: "fgusgyc"
  },
  button: {
    qhf8xq: "f10pi13n",
    a9b677: "fly5x3f",
    mc9l5x: "f22iagw",
    Bh6795r: 0,
    Bqenvij: "f1l02sjl",
    Bt984gj: "f122n59",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "fkln5zr",
    sshi5w: "f1nxs5xn",
    xawz: 0,
    Bnnss6s: 0,
    fkmc3a: "f1izfyrr",
    oeaueh: "f1s6fcnf"
  },
  sortable: {
    Bceei9c: "f1k6fduh"
  },
  sortIcon: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    z8tnut: "fclwglc"
  },
  resizeHandle: {}
}, {
  d: [".figsok6{font-weight:var(--fontWeightRegular);}", [".f3gpkru{padding:0px var(--spacingHorizontalS);}", {
    p: -1
  }], [".f14ym4q2[data-fui-focus-within]:focus-within{outline:2px solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f1euou18[data-fui-focus-within]:focus-within{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f10pi13n{position:relative;}", ".fq6nmtn{resize:horizontal;}", ".f1e4lqlz{box-sizing:content-box;}", ".f1u2r49w{background-color:inherit;}", ".f1ym3bx4{color:inherit;}", ".f1mo0ibp{font-family:inherit;}", ".fjoy568{font-size:inherit;}", ".fytdu2e{line-height:normal;}", [".f1gl81tg{overflow:visible;}", {
    p: -1
  }], [".f1mk8lai{padding:0;}", {
    p: -1
  }], [".f3bhgqh{border:none;}", {
    p: -2
  }], ".fgusgyc{text-align:unset;}", ".fly5x3f{width:100%;}", ".f22iagw{display:flex;}", ".fqerorx{flex-grow:1;}", ".f1l02sjl{height:100%;}", ".f122n59{align-items:center;}", [".fkln5zr{gap:var(--spacingHorizontalXS);}", {
    p: -1
  }], ".f1nxs5xn{min-height:32px;}", [".f1izfyrr{flex:1 1 0px;}", {
    p: -1
  }], ".f1s6fcnf{outline-style:none;}", ".f1k6fduh{cursor:pointer;}", ".fclwglc{padding-top:var(--spacingVerticalXXS);}"],
  h: [".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}"],
  a: [".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}", ".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}"]
});
var useTableHeaderCellStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles45();
  const layoutStyles = {
    table: useTableLayoutStyles7(),
    flex: useFlexLayoutStyles7()
  };
  state.root.className = mergeClasses(tableHeaderCellClassNames.root, styles.root, state.sortable && styles.rootInteractive, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
  state.button.className = mergeClasses(tableHeaderCellClassNames.button, styles.resetButton, styles.button, state.sortable && styles.sortable, state.button.className);
  if (state.sortIcon) {
    state.sortIcon.className = mergeClasses(tableHeaderCellClassNames.sortIcon, styles.sortIcon, state.sortIcon.className);
  }
  if (state.aside) {
    state.aside.className = mergeClasses(tableHeaderCellClassNames.aside, styles.resizeHandle, state.aside.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/TableHeaderCell.js
var TableHeaderCell = React349.forwardRef((props, ref) => {
  const state = useTableHeaderCell_unstable(props, ref);
  useTableHeaderCellStyles_unstable(state);
  useCustomStyleHook("useTableHeaderCellStyles_unstable")(state);
  return renderTableHeaderCell_unstable(state);
});
TableHeaderCell.displayName = "TableHeaderCell";

// node_modules/@fluentui/react-table/lib/contexts/columnIdContext.js
var React350 = __toESM(require_react());
var columnIdContext = React350.createContext(void 0);
var columnIdContextDefaultValue = "";
var useColumnIdContext = () => {
  var _React_useContext;
  return (_React_useContext = React350.useContext(columnIdContext)) !== null && _React_useContext !== void 0 ? _React_useContext : columnIdContextDefaultValue;
};
var ColumnIdContextProvider = columnIdContext.Provider;

// node_modules/@fluentui/react-table/lib/contexts/rowIdContext.js
var React351 = __toESM(require_react());
var rowIdContext = React351.createContext(void 0);
var tableRowIdContextDefaultValue = "";
var useTableRowIdContext = () => {
  var _React_useContext;
  return (_React_useContext = React351.useContext(rowIdContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tableRowIdContextDefaultValue;
};
var TableRowIdContextProvider = rowIdContext.Provider;

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/TableSelectionCell.js
var React353 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/useTableSelectionCell.js
var React352 = __toESM(require_react());
var useTableSelectionCell_unstable = (props, ref) => {
  const tableCellState = useTableCell_unstable(props, useMergedRefs(ref, useFocusWithin()));
  const { noNativeElements } = useTableContext();
  const {
    type = "checkbox",
    checked = false,
    subtle = false,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    hidden = false,
    invisible = false
  } = props;
  return {
    ...tableCellState,
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...tableCellState.components,
      checkboxIndicator: Checkbox,
      radioIndicator: Radio
    },
    checkboxIndicator: slot_exports.optional(props.checkboxIndicator, {
      renderByDefault: type === "checkbox",
      defaultProps: {
        checked: props.checked
      },
      elementType: Checkbox
    }),
    radioIndicator: slot_exports.optional(props.radioIndicator, {
      renderByDefault: type === "radio",
      defaultProps: {
        checked: !!checked,
        input: {
          name: useId2("table-selection-radio")
        }
      },
      elementType: Radio
    }),
    type,
    checked,
    noNativeElements,
    subtle,
    hidden: invisible || hidden
  };
};

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/renderTableSelectionCell.js
var renderTableSelectionCell_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.type === "checkbox" && state.checkboxIndicator && jsx(state.checkboxIndicator, {}),
      state.type === "radio" && state.radioIndicator && jsx(state.radioIndicator, {})
    ]
  });
};

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/TableSelectionCell.js
var TableSelectionCell = React353.forwardRef((props, ref) => {
  const state = useTableSelectionCell_unstable(props, ref);
  useTableSelectionCellStyles_unstable(state);
  useCustomStyleHook("useTableSelectionCellStyles_unstable")(state);
  return renderTableSelectionCell_unstable(state);
});
TableSelectionCell.displayName = "TableSelectionCell";

// node_modules/@fluentui/react-table/lib/components/TableCellActions/TableCellActions.js
var React355 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableCellActions/useTableCellActions.js
var React354 = __toESM(require_react());
var useTableCellActions_unstable = (props, ref) => {
  var _props_visible;
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    visible: (_props_visible = props.visible) !== null && _props_visible !== void 0 ? _props_visible : false
  };
};

// node_modules/@fluentui/react-table/lib/components/TableCellActions/renderTableCellActions.js
var renderTableCellActions_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableCellActions/TableCellActions.js
var TableCellActions = React355.forwardRef((props, ref) => {
  const state = useTableCellActions_unstable(props, ref);
  useTableCellActionsStyles_unstable(state);
  useCustomStyleHook("useTableCellActionsStyles_unstable")(state);
  return renderTableCellActions_unstable(state);
});
TableCellActions.displayName = "TableCellActions";

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/TableCellLayout.js
var React358 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/useTableCellLayout.js
var React356 = __toESM(require_react());
var tableAvatarSizeMap = {
  medium: 32,
  small: 24,
  "extra-small": 20
};
var useTableCellLayout_unstable = (props, ref) => {
  const { size: size3 } = useTableContext();
  return {
    components: {
      root: "div",
      main: "span",
      description: "span",
      content: "div",
      media: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps(
      "div",
      {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      },
      // `content` is a slot and it's type clashes with the HTMLElement `content` attribute
      [
        "content"
      ]
    ), {
      elementType: "div"
    }),
    appearance: props.appearance,
    truncate: props.truncate,
    main: slot_exports.optional(props.main, {
      renderByDefault: true,
      elementType: "span"
    }),
    media: slot_exports.optional(props.media, {
      elementType: "span"
    }),
    description: slot_exports.optional(props.description, {
      elementType: "span"
    }),
    content: slot_exports.optional(props.content, {
      renderByDefault: !!props.description || !!props.children,
      elementType: "div"
    }),
    avatarSize: tableAvatarSizeMap[size3],
    size: size3
  };
};

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/renderTableCellLayout.js
var renderTableCellLayout_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.media && jsx(AvatarContextProvider, {
        value: contextValues.avatar,
        children: jsx(state.media, {})
      }),
      state.content && jsxs(state.content, {
        children: [
          state.main && jsx(state.main, {
            children: state.root.children
          }),
          state.description && jsx(state.description, {})
        ]
      })
    ]
  });
};

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/useTableCellLayoutStyles.styles.js
var tableCellLayoutClassNames = {
  root: "fui-TableCellLayout",
  media: "fui-TableCellLayout__media",
  main: "fui-TableCellLayout__main",
  description: "fui-TableCellLayout__description",
  content: "fui-TableCellLayout__content"
};
var useStyles46 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "faqewft",
    xawz: 0,
    Bh6795r: 0,
    Bnnss6s: 0,
    fkmc3a: "f1izfyrr"
  },
  rootTruncate: {
    B68tc82: "f1p9o1ba"
  },
  content: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62"
  },
  contentTruncate: {
    B68tc82: "f1p9o1ba"
  },
  media: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59"
  },
  mediaExtraSmall: {
    Be2twd7: "f4ybsrx"
  },
  mediaSmallAndMedium: {
    Be2twd7: "fe5j1ua"
  },
  mediaPrimary: {
    Be2twd7: "f1rt2boy"
  },
  mainPrimary: {
    Bhrd7zp: "fl43uef"
  },
  mainTruncate: {
    B68tc82: "f1p9o1ba",
    Huce71: "fz5stix",
    ygn44y: "f1cmbuwj"
  },
  description: {
    sj55zd: "fkfq4zb",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}", [".faqewft{gap:var(--spacingHorizontalS);}", {
    p: -1
  }], [".f1izfyrr{flex:1 1 0px;}", {
    p: -1
  }], ".f1p9o1ba{overflow-x:hidden;}", ".f1vx9l62{flex-direction:column;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fz5stix{white-space:nowrap;}", ".f1cmbuwj{text-overflow:ellipsis;}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}"]
});
var useTableCellLayoutStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles46();
  const {
    truncate
  } = state;
  state.root.className = mergeClasses(tableCellLayoutClassNames.root, styles.root, truncate && styles.rootTruncate, state.root.className);
  const primary = state.appearance === "primary";
  if (state.media) {
    const mediaSizedStyles = {
      small: styles.mediaSmallAndMedium,
      medium: styles.mediaSmallAndMedium,
      "extra-small": styles.mediaExtraSmall
    };
    state.media.className = mergeClasses(tableCellLayoutClassNames.media, styles.media, mediaSizedStyles[state.size], primary && styles.mediaPrimary, state.media.className);
  }
  if (state.main) {
    state.main.className = mergeClasses(tableCellLayoutClassNames.main, truncate && styles.mainTruncate, primary && styles.mainPrimary, state.main.className);
  }
  if (state.description) {
    state.description.className = mergeClasses(tableCellLayoutClassNames.description, styles.description, state.description.className);
  }
  if (state.content) {
    state.content.className = mergeClasses(tableCellLayoutClassNames.content, styles.content, truncate && styles.contentTruncate, state.content.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/useTableCellLayoutContextValues.js
var React357 = __toESM(require_react());
function useTableCellLayoutContextValues_unstable(state) {
  const { avatarSize } = state;
  const avatar = React357.useMemo(() => ({
    size: avatarSize
  }), [
    avatarSize
  ]);
  return {
    avatar
  };
}

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/TableCellLayout.js
var TableCellLayout = React358.forwardRef((props, ref) => {
  const state = useTableCellLayout_unstable(props, ref);
  useTableCellLayoutStyles_unstable(state);
  useCustomStyleHook("useTableCellLayoutStyles_unstable")(state);
  return renderTableCellLayout_unstable(state, useTableCellLayoutContextValues_unstable(state));
});
TableCellLayout.displayName = "TableCellLayout";

// node_modules/@fluentui/react-table/lib/components/DataGridCell/DataGridCell.js
var React360 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridCell/useDataGridCell.js
var React359 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/contexts/dataGridContext.js
var dataGridContext = createContext13(void 0);
var dataGridContextDefaultValue = {
  ...defaultTableState,
  subtleSelection: false,
  selectableRows: false,
  selectionAppearance: "brand",
  focusMode: "none",
  compositeRowTabsterAttribute: {}
};
var DataGridContextProvider = dataGridContext.Provider;
var useDataGridContext_unstable = (selector) => useContextSelector(dataGridContext, (ctx = dataGridContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-table/lib/components/DataGridCell/useDataGridCell.js
var useDataGridCell_unstable = (props, ref) => {
  const { focusMode = "cell" } = props;
  const columnId = useColumnIdContext();
  const tabbable = useDataGridContext_unstable((ctx) => (ctx.focusMode === "cell" || ctx.focusMode === "composite") && focusMode !== "none");
  const resizableColumns = useDataGridContext_unstable((ctx) => ctx.resizableColumns);
  const getTableCellProps = useDataGridContext_unstable((ctx) => {
    return ctx.columnSizing_unstable.getTableCellProps;
  });
  const focusableGroupAttr = useFocusableGroup({
    tabBehavior: "limited-trap-focus"
  });
  return useTableCell_unstable({
    as: "div",
    role: "gridcell",
    ...focusMode === "group" && focusableGroupAttr,
    tabIndex: tabbable ? 0 : void 0,
    ...resizableColumns ? getTableCellProps(columnId) : {},
    ...props
  }, ref);
};

// node_modules/@fluentui/react-table/lib/components/DataGridCell/renderDataGridCell.js
var renderDataGridCell_unstable = (state) => {
  return renderTableCell_unstable(state);
};

// node_modules/@fluentui/react-table/lib/components/DataGridCell/useDataGridCellStyles.styles.js
var dataGridCellClassNames = {
  root: "fui-DataGridCell"
};
var useDataGridCellStyles_unstable = (state) => {
  "use no memo";
  useTableCellStyles_unstable(state);
  state.root.className = mergeClasses(dataGridCellClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridCell/DataGridCell.js
var DataGridCell = React360.forwardRef((props, ref) => {
  const state = useDataGridCell_unstable(props, ref);
  useDataGridCellStyles_unstable(state);
  useCustomStyleHook("useDataGridCellStyles_unstable")(state);
  return renderDataGridCell_unstable(state);
});
DataGridCell.displayName = "DataGridCell";

// node_modules/@fluentui/react-table/lib/components/DataGridRow/DataGridRow.js
var React364 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridRow/useDataGridRow.js
var React363 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/DataGridSelectionCell.js
var React362 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/useDataGridSelectionCell.js
var React361 = __toESM(require_react());
var useDataGridSelectionCell_unstable = (props, ref) => {
  const isHeader = useIsInTableHeader();
  const rowId = useTableRowIdContext();
  const subtle = useDataGridContext_unstable((ctx) => ctx.subtleSelection);
  const checked = useDataGridContext_unstable((ctx) => {
    if (isHeader && ctx.selection.selectionMode === "multiselect") {
      return ctx.selection.allRowsSelected ? true : ctx.selection.someRowsSelected ? "mixed" : false;
    }
    return ctx.selection.isRowSelected(rowId);
  });
  const toggleAllRows = useDataGridContext_unstable((ctx) => ctx.selection.toggleAllRows);
  const type = useDataGridContext_unstable((ctx) => ctx.selection.selectionMode === "multiselect" ? "checkbox" : "radio");
  const onClick = useEventCallback((e) => {
    var _props_onClick;
    if (isHeader) {
      toggleAllRows(e);
    }
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, e);
  });
  return useTableSelectionCell_unstable({
    as: "div",
    role: "gridcell",
    checked,
    type,
    invisible: isHeader && type === "radio",
    "aria-selected": checked === "mixed" ? void 0 : checked,
    subtle,
    radioIndicator: isHeader ? null : void 0,
    ...props,
    onClick
  }, ref);
};

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/renderDataGridSelectionCell.js
var renderDataGridSelectionCell_unstable = (state) => {
  return renderTableSelectionCell_unstable(state);
};

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/useDataGridSelectionCellStyles.styles.js
var dataGridSelectionCellClassNames = {
  root: "fui-DataGridSelectionCell",
  checkboxIndicator: "fui-DataGridSelectionCell__checkboxIndicator",
  radioIndicator: "fui-DataGridSelectionCell__radioIndicator"
};
var useDataGridSelectionCellStyles_unstable = (state) => {
  "use no memo";
  useTableSelectionCellStyles_unstable(state);
  state.root.className = mergeClasses(dataGridSelectionCellClassNames.root, state.root.className);
  if (state.checkboxIndicator) {
    state.checkboxIndicator.className = mergeClasses(dataGridSelectionCellClassNames.checkboxIndicator, state.checkboxIndicator.className);
  }
  if (state.radioIndicator) {
    state.radioIndicator.className = mergeClasses(dataGridSelectionCellClassNames.radioIndicator, state.radioIndicator.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/DataGridSelectionCell.js
var DataGridSelectionCell = React362.forwardRef((props, ref) => {
  const state = useDataGridSelectionCell_unstable(props, ref);
  useDataGridSelectionCellStyles_unstable(state);
  useCustomStyleHook("useDataGridSelectionCellStyles_unstable")(state);
  return renderDataGridSelectionCell_unstable(state);
});
DataGridSelectionCell.displayName = "DataGridSelectionCell";

// node_modules/@fluentui/react-table/lib/components/DataGridRow/useDataGridRow.js
var useDataGridRow_unstable = (props, ref) => {
  const rowId = useTableRowIdContext();
  const isHeader = useIsInTableHeader();
  const columnDefs = useDataGridContext_unstable((ctx) => ctx.columns);
  const selectable = useDataGridContext_unstable((ctx) => ctx.selectableRows);
  const selected = useDataGridContext_unstable((ctx) => ctx.selection.isRowSelected(rowId));
  const focusMode = useDataGridContext_unstable((ctx) => ctx.focusMode);
  const compositeRowTabsterAttribute = useDataGridContext_unstable((ctx) => ctx.compositeRowTabsterAttribute);
  const tabbable = focusMode === "row_unstable" || focusMode === "composite";
  const appearance = useDataGridContext_unstable((ctx) => {
    if (!isHeader && selectable && ctx.selection.isRowSelected(rowId)) {
      return ctx.selectionAppearance;
    }
    return "none";
  });
  const toggleRow = useDataGridContext_unstable((ctx) => ctx.selection.toggleRow);
  const onClick = useEventCallback((e) => {
    var _props_onClick;
    if (selectable && !isHeader) {
      toggleRow(e, rowId);
    }
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, e);
  });
  const onKeyDown = useEventCallback((e) => {
    var _props_onKeyDown;
    if (selectable && !isHeader && e.key === Space && !isInteractiveHTMLElement(e.target)) {
      e.preventDefault();
      toggleRow(e, rowId);
    }
    (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, e);
  });
  const baseState = useTableRow_unstable({
    appearance,
    "aria-selected": selectable ? selected : void 0,
    tabIndex: tabbable && !isHeader ? 0 : void 0,
    ...focusMode === "composite" && !isHeader && compositeRowTabsterAttribute,
    ...props,
    onClick,
    onKeyDown,
    children: null,
    as: "div"
  }, ref);
  return {
    ...baseState,
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...baseState.components,
      selectionCell: DataGridSelectionCell
    },
    selectionCell: slot_exports.optional(props.selectionCell, {
      renderByDefault: selectable,
      elementType: DataGridSelectionCell
    }),
    renderCell: props.children,
    columnDefs,
    // This context value should not be used internally
    // It's intended to help power user render functions
    dataGridContextValue: useStableDataGridContextValue()
  };
};
function useStableDataGridContextValue() {
  const ref = React363.useRef(dataGridContextDefaultValue);
  useDataGridContext_unstable((ctx) => {
    ref.current = ctx;
    return null;
  });
  return ref.current;
}

// node_modules/@fluentui/react-table/lib/components/DataGridRow/renderDataGridRow.js
var renderDataGridRow_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.selectionCell && jsx(state.selectionCell, {}),
      state.columnDefs.map((columnDef) => jsx(ColumnIdContextProvider, {
        value: columnDef.columnId,
        children: state.renderCell(columnDef, state.dataGridContextValue)
      }, columnDef.columnId))
    ]
  });
};

// node_modules/@fluentui/react-table/lib/components/DataGridRow/useDataGridRowStyles.styles.js
var dataGridRowClassNames = {
  root: "fui-DataGridRow",
  selectionCell: "fui-DataGridRow__selectionCell"
};
var useStyles47 = __styles2({
  subtleSelection: {
    Bconypa: "f1jazu75",
    ff6mpl: "fw60kww"
  }
}, {
  d: [".f1jazu75[data-fui-focus-within]:focus-within .fui-TableSelectionCell{opacity:1;}"],
  h: [".fw60kww:hover .fui-TableSelectionCell{opacity:1;}"]
});
var useDataGridRowStyles_unstable = (state) => {
  "use no memo";
  const isSubtle = useDataGridContext_unstable((ctx) => ctx.subtleSelection);
  const styles = useStyles47();
  useTableRowStyles_unstable(state);
  state.root.className = mergeClasses(dataGridRowClassNames.root, state.root.className, isSubtle && styles.subtleSelection);
  if (state.selectionCell) {
    state.selectionCell.className = mergeClasses(dataGridRowClassNames.selectionCell, state.selectionCell.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridRow/DataGridRow.js
var DataGridRow = React364.forwardRef((props, ref) => {
  const state = useDataGridRow_unstable(props, ref);
  useDataGridRowStyles_unstable(state);
  useCustomStyleHook("useDataGridRowStyles_unstable")(state);
  return renderDataGridRow_unstable(state);
});
DataGridRow.displayName = "DataGridRow";

// node_modules/@fluentui/react-table/lib/components/DataGridBody/DataGridBody.js
var React366 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridBody/useDataGridBody.js
var React365 = __toESM(require_react());
var useDataGridBody_unstable = (props, ref) => {
  const { sortable } = useTableContext();
  const getRows = useDataGridContext_unstable((ctx) => ctx.getRows);
  const sort = useDataGridContext_unstable((ctx) => ctx.sort.sort);
  const rows = sortable ? sort(getRows()) : getRows();
  const baseState = useTableBody_unstable({
    ...props,
    children: null,
    as: "div"
  }, ref);
  return {
    ...baseState,
    rows,
    renderRow: props.children
  };
};

// node_modules/@fluentui/react-table/lib/components/DataGridBody/renderDataGridBody.js
var renderDataGridBody_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: state.rows.map((row) => jsx(TableRowIdContextProvider, {
      value: row.rowId,
      children: state.renderRow(row)
    }, row.rowId))
  });
};

// node_modules/@fluentui/react-table/lib/components/DataGridBody/useDataGridBodyStyles.styles.js
var dataGridBodyClassNames = {
  root: "fui-DataGridBody"
};
var useDataGridBodyStyles_unstable = (state) => {
  "use no memo";
  useTableBodyStyles_unstable(state);
  state.root.className = mergeClasses(dataGridBodyClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridBody/DataGridBody.js
var DataGridBody = React366.forwardRef((props, ref) => {
  const state = useDataGridBody_unstable(props, ref);
  useDataGridBodyStyles_unstable(state);
  useCustomStyleHook("useDataGridBodyStyles_unstable")(state);
  return renderDataGridBody_unstable(state);
});
DataGridBody.displayName = "DataGridBody";

// node_modules/@fluentui/react-table/lib/components/DataGrid/DataGrid.js
var React369 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGrid/useDataGrid.js
var React367 = __toESM(require_react());
var useDataGrid_unstable = (props, ref) => {
  const { items, columns, focusMode = "cell", selectionMode, onSortChange, onSelectionChange, defaultSortState, sortState, selectedItems, defaultSelectedItems, subtleSelection = false, selectionAppearance = "brand", getRowId, resizableColumns, columnSizingOptions, onColumnResize, containerWidthOffset, resizableColumnsOptions = {} } = props;
  const widthOffset = containerWidthOffset !== null && containerWidthOffset !== void 0 ? containerWidthOffset : selectionMode ? -CELL_WIDTH : 0;
  const gridTabsterAttribute = useArrowNavigationGroup({
    axis: "grid"
  });
  const { onTableKeyDown: onCompositeKeyDown, tableTabsterAttribute: compositeTabsterAttribute, tableRowTabsterAttribute: compositeRowTabsterAttribute } = useTableCompositeNavigation();
  var _resizableColumnsOptions_autoFitColumns;
  const tableState = useTableFeatures({
    items,
    columns,
    getRowId
  }, [
    useTableSort({
      defaultSortState,
      sortState,
      onSortChange
    }),
    useTableSelection({
      defaultSelectedItems,
      selectedItems,
      onSelectionChange,
      selectionMode: selectionMode !== null && selectionMode !== void 0 ? selectionMode : "multiselect"
    }),
    useTableColumnSizing_unstable({
      onColumnResize,
      columnSizingOptions,
      // The selection cell is not part of the columns, therefore its width needs to be subtracted
      // from the container to make sure the columns don't overflow the table.
      containerWidthOffset: widthOffset,
      // Disables automatic resizing of columns when the container overflows.
      // This allows the sum of the columns to be larger than the container.
      autoFitColumns: (_resizableColumnsOptions_autoFitColumns = resizableColumnsOptions.autoFitColumns) !== null && _resizableColumnsOptions_autoFitColumns !== void 0 ? _resizableColumnsOptions_autoFitColumns : true
    })
  ]);
  const innerRef = React367.useRef(null);
  const { findFirstFocusable, findLastFocusable } = useFocusFinders();
  const onKeyDown = useEventCallback((e) => {
    var _props_onKeyDown;
    (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, e);
    focusMode === "composite" && onCompositeKeyDown(e);
    if (!innerRef.current || !e.ctrlKey || e.defaultPrevented) {
      return;
    }
    if (e.key === Home) {
      const firstRow = innerRef.current.querySelector('[role="row"]');
      if (firstRow) {
        var _findFirstFocusable;
        (_findFirstFocusable = findFirstFocusable(firstRow)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
      }
    }
    if (e.key === End) {
      const rows = innerRef.current.querySelectorAll('[role="row"]');
      if (rows.length) {
        var _findLastFocusable;
        const lastRow = rows.item(rows.length - 1);
        (_findLastFocusable = findLastFocusable(lastRow)) === null || _findLastFocusable === void 0 ? void 0 : _findLastFocusable.focus();
      }
    }
  });
  const baseTableState = useTable_unstable({
    role: "grid",
    as: "div",
    noNativeElements: true,
    ...focusMode === "cell" && gridTabsterAttribute,
    ...focusMode === "composite" && compositeTabsterAttribute,
    ...props,
    onKeyDown,
    ...resizableColumns ? tableState.columnSizing_unstable.getTableProps(props) : {}
  }, useMergedRefs(ref, tableState.tableRef, innerRef));
  return {
    ...baseTableState,
    focusMode,
    tableState,
    selectableRows: !!selectionMode,
    subtleSelection,
    selectionAppearance,
    resizableColumns,
    compositeRowTabsterAttribute
  };
};

// node_modules/@fluentui/react-table/lib/components/DataGrid/renderDataGrid.js
var React368 = __toESM(require_react());
var renderDataGrid_unstable = (state, contextValues) => {
  return React368.createElement(DataGridContextProvider, {
    value: contextValues.dataGrid
  }, renderTable_unstable(state, contextValues));
};

// node_modules/@fluentui/react-table/lib/components/DataGrid/useDataGridStyles.styles.js
var dataGridClassNames = {
  root: "fui-DataGrid"
};
var useDataGridStyles_unstable = (state) => {
  "use no memo";
  useTableStyles_unstable(state);
  state.root.className = mergeClasses(dataGridClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGrid/useDataGridContextValues.js
function useDataGridContextValues_unstable(state) {
  const tableContextValues = useTableContextValues_unstable(state);
  const { tableState, focusMode, selectableRows, subtleSelection, selectionAppearance, resizableColumns, compositeRowTabsterAttribute } = state;
  return {
    ...tableContextValues,
    dataGrid: {
      ...tableState,
      focusMode,
      selectableRows,
      subtleSelection,
      selectionAppearance,
      resizableColumns,
      compositeRowTabsterAttribute
    }
  };
}

// node_modules/@fluentui/react-table/lib/components/DataGrid/DataGrid.js
var DataGrid = React369.forwardRef((props, ref) => {
  const state = useDataGrid_unstable(props, ref);
  useDataGridStyles_unstable(state);
  useCustomStyleHook("useDataGridStyles_unstable")(state);
  return renderDataGrid_unstable(state, useDataGridContextValues_unstable(state));
});
DataGrid.displayName = "DataGrid";

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/DataGridHeader.js
var React371 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/useDataGridHeader.js
var React370 = __toESM(require_react());
var useDataGridHeader_unstable = (props, ref) => {
  return useTableHeader_unstable({
    ...props,
    as: "div"
  }, ref);
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/renderDataGridHeader.js
var renderDataGridHeader_unstable = (state) => {
  return renderTableHeader_unstable(state);
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/useDataGridHeaderStyles.styles.js
var dataGridHeaderClassNames = {
  root: "fui-DataGridHeader"
};
var useDataGridHeaderStyles_unstable = (state) => {
  "use no memo";
  useTableHeaderStyles_unstable(state);
  state.root.className = mergeClasses(dataGridHeaderClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/DataGridHeader.js
var DataGridHeader = React371.forwardRef((props, ref) => {
  const state = useDataGridHeader_unstable(props, ref);
  useDataGridHeaderStyles_unstable(state);
  useCustomStyleHook("useDataGridHeaderStyles_unstable")(state);
  return renderDataGridHeader_unstable(state);
});
DataGridHeader.displayName = "DataGridHeader";

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/DataGridHeaderCell.js
var React373 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/useDataGridHeaderCell.js
var React372 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/utils/isColumnSortable.js
function isColumnSortable(column) {
  return column.compare.length > 0;
}

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/useDataGridHeaderCell.js
var useDataGridHeaderCell_unstable = (props, ref) => {
  const columnId = useColumnIdContext();
  const { sortable: gridSortable } = useTableContext();
  const toggleColumnSort = useDataGridContext_unstable((ctx) => ctx.sort.toggleColumnSort);
  const sortable = useDataGridContext_unstable((ctx) => {
    const columnSortable = !!ctx.columns.find((c) => c.columnId === columnId && isColumnSortable(c));
    if (!gridSortable) {
      return false;
    }
    return columnSortable;
  });
  const sortDirection = useDataGridContext_unstable((ctx) => sortable ? ctx.sort.getSortDirection(columnId) : void 0);
  const resizableColumns = useDataGridContext_unstable((ctx) => ctx.resizableColumns);
  const getTableHeaderCellProps = useDataGridContext_unstable((ctx) => {
    return ctx.columnSizing_unstable.getTableHeaderCellProps;
  });
  const onClick = useEventCallback((e) => {
    var _props_onClick;
    if (sortable) {
      toggleColumnSort(e, columnId);
    }
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, e);
  });
  return useTableHeaderCell_unstable({
    sortable,
    sortDirection,
    as: "div",
    tabIndex: sortable ? void 0 : 0,
    ...resizableColumns ? getTableHeaderCellProps(columnId) : {},
    ...props,
    onClick
  }, ref);
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/renderDataGridHeaderCell.js
var renderDataGridHeaderCell_unstable = (state) => {
  return renderTableHeaderCell_unstable(state);
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/useDataGridHeaderCellStyles.styles.js
var dataGridHeaderCellClassNames = {
  root: "fui-DataGridHeaderCell",
  button: "fui-DataGridHeaderCell__button",
  sortIcon: "fui-DataGridHeaderCell__sortIcon",
  aside: "fui-DataGridHeaderCell__aside"
};
var useDataGridHeaderCellStyles_unstable = (state) => {
  "use no memo";
  useTableHeaderCellStyles_unstable(state);
  state.root.className = mergeClasses(dataGridHeaderCellClassNames.root, state.root.className);
  if (state.button) {
    state.button.className = mergeClasses(dataGridHeaderCellClassNames.button, state.button.className);
  }
  if (state.sortIcon) {
    state.sortIcon.className = mergeClasses(dataGridHeaderCellClassNames.sortIcon, state.sortIcon.className);
  }
  if (state.aside) {
    state.aside.className = mergeClasses(dataGridHeaderCellClassNames.aside, state.aside.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/DataGridHeaderCell.js
var DataGridHeaderCell = React373.forwardRef((props, ref) => {
  const state = useDataGridHeaderCell_unstable(props, ref);
  useDataGridHeaderCellStyles_unstable(state);
  useCustomStyleHook("useDataGridHeaderCellStyles_unstable")(state);
  return renderDataGridHeaderCell_unstable(state);
});
DataGridHeaderCell.displayName = "DataGridHeaderCell";

// node_modules/@fluentui/react-card/lib/components/Card/Card.js
var React378 = __toESM(require_react());

// node_modules/@fluentui/react-card/lib/components/Card/useCard.js
var React376 = __toESM(require_react());

// node_modules/@fluentui/react-card/lib/components/Card/useCardSelectable.js
var React374 = __toESM(require_react());
var useCardSelectable = (props, { referenceLabel, referenceId }, cardRef) => {
  const { checkbox = {}, onSelectionChange, floatingAction, onClick, onKeyDown, disabled } = props;
  const { findAllFocusable } = useFocusFinders();
  const checkboxRef = React374.useRef(null);
  const [selected, setSelected] = useControllableState({
    state: props.selected,
    defaultState: props.defaultSelected,
    initialState: false
  });
  const selectable = [
    props.selected,
    props.defaultSelected,
    onSelectionChange
  ].some((prop) => typeof prop !== "undefined");
  const [selectFocused, setSelectFocused] = React374.useState(false);
  const shouldRestrictTriggerAction = React374.useCallback((event) => {
    if (!cardRef.current) {
      return false;
    }
    const focusableElements = findAllFocusable(cardRef.current);
    const target = event.target;
    const isElementInFocusableGroup = focusableElements.some((element) => element.contains(target));
    const isCheckboxSlot = (checkboxRef === null || checkboxRef === void 0 ? void 0 : checkboxRef.current) === target;
    return isElementInFocusableGroup && !isCheckboxSlot;
  }, [
    cardRef,
    findAllFocusable
  ]);
  const onChangeHandler = React374.useCallback((event) => {
    if (disabled || shouldRestrictTriggerAction(event)) {
      return;
    }
    const newCheckedValue = !selected;
    setSelected(newCheckedValue);
    if (onSelectionChange) {
      onSelectionChange(event, {
        selected: newCheckedValue
      });
    }
  }, [
    disabled,
    onSelectionChange,
    selected,
    setSelected,
    shouldRestrictTriggerAction
  ]);
  const onKeyDownHandler = React374.useCallback((event) => {
    if ([
      Enter
    ].includes(event.key)) {
      event.preventDefault();
      onChangeHandler(event);
    }
  }, [
    onChangeHandler
  ]);
  const checkboxSlot = React374.useMemo(() => {
    if (!selectable || floatingAction) {
      return;
    }
    const selectableCheckboxProps = {};
    if (referenceId) {
      selectableCheckboxProps["aria-labelledby"] = referenceId;
    } else if (referenceLabel) {
      selectableCheckboxProps["aria-label"] = referenceLabel;
    }
    return slot_exports.optional(checkbox, {
      defaultProps: {
        ref: checkboxRef,
        type: "checkbox",
        checked: selected,
        disabled,
        onChange: (event) => onChangeHandler(event),
        onFocus: () => setSelectFocused(true),
        onBlur: () => setSelectFocused(false),
        ...selectableCheckboxProps
      },
      elementType: "input"
    });
  }, [
    checkbox,
    disabled,
    floatingAction,
    selected,
    selectable,
    onChangeHandler,
    referenceId,
    referenceLabel
  ]);
  const floatingActionSlot = React374.useMemo(() => {
    if (!floatingAction) {
      return;
    }
    return slot_exports.optional(floatingAction, {
      defaultProps: {
        ref: checkboxRef
      },
      elementType: "div"
    });
  }, [
    floatingAction
  ]);
  const selectableCardProps = React374.useMemo(() => {
    if (!selectable) {
      return null;
    }
    return {
      onClick: mergeCallbacks(onClick, onChangeHandler),
      onKeyDown: mergeCallbacks(onKeyDown, onKeyDownHandler)
    };
  }, [
    selectable,
    onChangeHandler,
    onClick,
    onKeyDown,
    onKeyDownHandler
  ]);
  return {
    selected,
    selectable,
    selectFocused,
    selectableCardProps,
    checkboxSlot,
    floatingActionSlot
  };
};

// node_modules/@fluentui/react-card/lib/components/Card/CardContext.js
var React375 = __toESM(require_react());
var cardContext = React375.createContext(void 0);
var cardContextDefaultValue = {
  selectableA11yProps: {
    referenceId: void 0,
    setReferenceId() {
    },
    referenceLabel: void 0,
    setReferenceLabel() {
    }
  }
};
var CardProvider = cardContext.Provider;
var useCardContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React375.useContext(cardContext)) !== null && _React_useContext !== void 0 ? _React_useContext : cardContextDefaultValue;
};

// node_modules/@fluentui/react-card/lib/components/Card/useCard.js
var focusMap = {
  off: void 0,
  "no-tab": "limited-trap-focus",
  "tab-exit": "limited",
  "tab-only": "unlimited"
};
var useCardInteractive = ({ focusMode: initialFocusMode, disabled = false, ...props }) => {
  const interactive = [
    "onClick",
    "onDoubleClick",
    "onMouseUp",
    "onMouseDown",
    "onPointerUp",
    "onPointerDown",
    "onTouchStart",
    "onTouchEnd",
    "onDragStart",
    "onDragEnd"
  ].some((prop) => props[prop]);
  const focusMode = initialFocusMode !== null && initialFocusMode !== void 0 ? initialFocusMode : interactive ? "no-tab" : "off";
  const groupperAttrs = useFocusableGroup({
    tabBehavior: focusMap[focusMode]
  });
  if (disabled) {
    return {
      interactive: false,
      focusAttributes: null
    };
  }
  if (focusMode === "off") {
    return {
      interactive,
      focusAttributes: null
    };
  }
  return {
    interactive,
    focusAttributes: {
      ...groupperAttrs,
      tabIndex: 0
    }
  };
};
var useCard_unstable = (props, ref) => {
  const { appearance = "filled", orientation = "vertical", size: size3 = "medium", disabled = false, ...restProps } = props;
  const [referenceId, setReferenceId] = React376.useState(cardContextDefaultValue.selectableA11yProps.referenceId);
  const [referenceLabel, setReferenceLabel] = React376.useState(cardContextDefaultValue.selectableA11yProps.referenceId);
  const cardBaseRef = useFocusWithin();
  const { selectable, selected, selectableCardProps, selectFocused, checkboxSlot, floatingActionSlot } = useCardSelectable(props, {
    referenceId,
    referenceLabel
  }, cardBaseRef);
  const cardRef = useMergedRefs(cardBaseRef, ref);
  const { interactive, focusAttributes } = useCardInteractive(props);
  let cardRootProps = {
    ...!selectable ? focusAttributes : null,
    ...restProps,
    ...selectableCardProps
  };
  if (disabled) {
    cardRootProps = {
      ...restProps,
      "aria-disabled": true,
      onClick: void 0
    };
  }
  return {
    appearance,
    orientation,
    size: size3,
    interactive,
    selectable,
    selectFocused,
    selected,
    disabled,
    selectableA11yProps: {
      setReferenceId,
      referenceId,
      referenceLabel,
      setReferenceLabel
    },
    components: {
      root: "div",
      floatingAction: "div",
      checkbox: "input"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: cardRef,
      role: "group",
      ...cardRootProps
    }), {
      elementType: "div"
    }),
    floatingAction: floatingActionSlot,
    checkbox: checkboxSlot
  };
};

// node_modules/@fluentui/react-card/lib/components/Card/renderCard.js
var renderCard_unstable = (state, cardContextValue) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsxs(CardProvider, {
      value: cardContextValue,
      children: [
        state.checkbox ? jsx(state.checkbox, {}) : null,
        state.floatingAction ? jsx(state.floatingAction, {}) : null,
        state.root.children
      ]
    })
  });
};

// node_modules/@fluentui/react-card/lib/components/Card/useCardStyles.styles.js
var React377 = __toESM(require_react());

// node_modules/@fluentui/react-card/lib/components/CardPreview/useCardPreviewStyles.styles.js
var cardPreviewClassNames = {
  root: "fui-CardPreview",
  logo: "fui-CardPreview__logo"
};
var useStyles48 = __styles2({
  root: {
    qhf8xq: "f10pi13n",
    Byfpedg: "fgourly",
    Btj6oj6: "f1vui7lx",
    B1m4t4s: "fda5zwx"
  },
  logo: {
    qhf8xq: "f1euv43f",
    B5kzvoi: "f1gcvs1y",
    oyh7mz: ["f1t6tvco", "ffrfxm3"],
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10"
  }
}, {
  d: [".f10pi13n{position:relative;}", ".fgourly>:not(.fui-CardPreview__logo){display:block;}", ".f1vui7lx>:not(.fui-CardPreview__logo){height:100%;}", ".fda5zwx>:not(.fui-CardPreview__logo){width:100%;}", ".f1euv43f{position:absolute;}", ".f1gcvs1y{bottom:12px;}", ".f1t6tvco{left:12px;}", ".ffrfxm3{right:12px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}"]
});
var useCardPreviewStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles48();
  state.root.className = mergeClasses(cardPreviewClassNames.root, styles.root, state.root.className);
  if (state.logo) {
    state.logo.className = mergeClasses(cardPreviewClassNames.logo, styles.logo, state.logo.className);
  }
  return state;
};

// node_modules/@fluentui/react-card/lib/components/CardHeader/useCardHeaderStyles.styles.js
var cardHeaderClassNames = {
  root: "fui-CardHeader",
  image: "fui-CardHeader__image",
  header: "fui-CardHeader__header",
  description: "fui-CardHeader__description",
  action: "fui-CardHeader__action"
};
var cardHeaderCSSVars = {
  cardHeaderGapVar: "--fui-CardHeader--gap"
};
var useStyles49 = __styles2({
  root: {
    Bkc6ea2: "fkufhic",
    Bt984gj: "f122n59"
  },
  image: {
    mc9l5x: "ftuwxu6",
    t21cq0: ["fql5097", "f6yss9k"]
  },
  header: {
    mc9l5x: "f22iagw"
  },
  description: {
    mc9l5x: "f22iagw"
  },
  action: {
    Frg6f3: ["f6yss9k", "fql5097"],
    B7frvx2: "f1ndzpm5",
    B06c7xf: ["f1fkeggc", "f1u45u6i"],
    B8uq84v: "f16eyofs",
    snkdo8: ["f1u45u6i", "f1fkeggc"],
    Bpf22ct: "f1wkmkig",
    apjfyd: "f18alut9"
  }
}, {
  d: [".fkufhic{--fui-CardHeader--gap:12px;}", ".f122n59{align-items:center;}", ".ftuwxu6{display:inline-flex;}", ".fql5097{margin-right:var(--fui-CardHeader--gap);}", ".f6yss9k{margin-left:var(--fui-CardHeader--gap);}", ".f22iagw{display:flex;}"],
  m: [["@media (forced-colors: active){.f1ndzpm5 .fui-Button,.f1ndzpm5 .fui-Link{border-top-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1fkeggc .fui-Button,.f1fkeggc .fui-Link{border-right-color:currentColor;}.f1u45u6i .fui-Button,.f1u45u6i .fui-Link{border-left-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f16eyofs .fui-Button,.f16eyofs .fui-Link{border-bottom-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1wkmkig .fui-Button,.f1wkmkig .fui-Link{color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f18alut9 .fui-Button,.f18alut9 .fui-Link{outline-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useStylesGrid = __styles2({
  root: {
    mc9l5x: "f13qh94s",
    t4k1zu: "f8a668j"
  },
  image: {
    Br312pm: "fwpfdsa",
    Ijaq50: "fldnz9j"
  },
  header: {
    Br312pm: "fd46tj4",
    Ijaq50: "f16hsg94"
  },
  description: {
    Br312pm: "fd46tj4",
    Ijaq50: "faunodf"
  },
  action: {
    Br312pm: "fis13di",
    Ijaq50: "fldnz9j"
  }
}, {
  d: [".f13qh94s{display:grid;}", ".f8a668j{grid-auto-columns:min-content 1fr min-content;}", ".fwpfdsa{grid-column-start:1;}", ".fldnz9j{grid-row-start:span 2;}", ".fd46tj4{grid-column-start:2;}", ".f16hsg94{grid-row-start:1;}", ".faunodf{grid-row-start:2;}", ".fis13di{grid-column-start:3;}"]
});
var useStylesFlex = __styles2({
  root: {
    mc9l5x: "f22iagw"
  },
  header: {
    Bh6795r: "fqerorx"
  },
  image: {},
  description: {},
  action: {}
}, {
  d: [".f22iagw{display:flex;}", ".fqerorx{flex-grow:1;}"]
});
var useCardHeaderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles49();
  const stylesGrid = useStylesGrid();
  const stylesFlex = useStylesFlex();
  const boxModelStyles = state.description ? stylesGrid : stylesFlex;
  const getSlotStyles = (slotName) => {
    var _state_slotName;
    return mergeClasses(cardHeaderClassNames[slotName], styles[slotName], boxModelStyles[slotName], (_state_slotName = state[slotName]) === null || _state_slotName === void 0 ? void 0 : _state_slotName.className);
  };
  state.root.className = getSlotStyles("root");
  if (state.image) {
    state.image.className = getSlotStyles("image");
  }
  if (state.header) {
    state.header.className = getSlotStyles("header");
  }
  if (state.description) {
    state.description.className = getSlotStyles("description");
  }
  if (state.action) {
    state.action.className = getSlotStyles("action");
  }
  return state;
};

// node_modules/@fluentui/react-card/lib/components/CardFooter/useCardFooterStyles.styles.js
var cardFooterClassNames = {
  root: "fui-CardFooter",
  action: "fui-CardFooter__action"
};
var useStyles50 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "fsbu5mz"
  },
  action: {
    Frg6f3: ["fcgxt0o", "f1ujusj6"],
    B7frvx2: "f1ndzpm5",
    B06c7xf: ["f1fkeggc", "f1u45u6i"],
    B8uq84v: "f16eyofs",
    snkdo8: ["f1u45u6i", "f1fkeggc"],
    Bpf22ct: "f1wkmkig",
    apjfyd: "f18alut9"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", [".fsbu5mz{gap:12px;}", {
    p: -1
  }], ".fcgxt0o{margin-left:auto;}", ".f1ujusj6{margin-right:auto;}"],
  m: [["@media (forced-colors: active){.f1ndzpm5 .fui-Button,.f1ndzpm5 .fui-Link{border-top-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1fkeggc .fui-Button,.f1fkeggc .fui-Link{border-right-color:currentColor;}.f1u45u6i .fui-Button,.f1u45u6i .fui-Link{border-left-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f16eyofs .fui-Button,.f16eyofs .fui-Link{border-bottom-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1wkmkig .fui-Button,.f1wkmkig .fui-Link{color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f18alut9 .fui-Button,.f18alut9 .fui-Link{outline-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useCardFooterStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles50();
  state.root.className = mergeClasses(cardFooterClassNames.root, styles.root, state.root.className);
  if (state.action) {
    state.action.className = mergeClasses(cardFooterClassNames.action, styles.action, state.action.className);
  }
  return state;
};

// node_modules/@fluentui/react-card/lib/components/Card/useCardStyles.styles.js
var cardClassNames = {
  root: "fui-Card",
  floatingAction: "fui-Card__floatingAction",
  checkbox: "fui-Card__checkbox"
};
var cardCSSVars = {
  cardSizeVar: "--fui-Card--size",
  cardBorderRadiusVar: "--fui-Card--border-radius"
};
var focusOutlineStyle = {
  outlineRadius: `var(${cardCSSVars.cardBorderRadiusVar})`,
  outlineWidth: tokens.strokeWidthThick,
  outlineOffset: "-2px"
};
var useCardResetStyles = __resetStyles("rfxo2k2", "rgle7w9", [".rfxo2k2{overflow:hidden;border-radius:var(--fui-Card--border-radius);padding:var(--fui-Card--size);gap:var(--fui-Card--size);display:flex;position:relative;box-sizing:border-box;color:var(--colorNeutralForeground1);}", '.rfxo2k2::after{position:absolute;top:0;left:0;right:0;bottom:0;content:"";pointer-events:none;border-top-style:solid;border-right-style:solid;border-bottom-style:solid;border-left-style:solid;border-top-width:var(--strokeWidthThin);border-right-width:var(--strokeWidthThin);border-bottom-width:var(--strokeWidthThin);border-left-width:var(--strokeWidthThin);border-radius:var(--fui-Card--border-radius);}', ".rfxo2k2>.fui-CardHeader,.rfxo2k2>.fui-CardFooter{flex-shrink:0;}", ".rgle7w9{overflow:hidden;border-radius:var(--fui-Card--border-radius);padding:var(--fui-Card--size);gap:var(--fui-Card--size);display:flex;position:relative;box-sizing:border-box;color:var(--colorNeutralForeground1);}", '.rgle7w9::after{position:absolute;top:0;right:0;left:0;bottom:0;content:"";pointer-events:none;border-top-style:solid;border-left-style:solid;border-bottom-style:solid;border-right-style:solid;border-top-width:var(--strokeWidthThin);border-left-width:var(--strokeWidthThin);border-bottom-width:var(--strokeWidthThin);border-right-width:var(--strokeWidthThin);border-radius:var(--fui-Card--border-radius);}', ".rgle7w9>.fui-CardHeader,.rgle7w9>.fui-CardFooter{flex-shrink:0;}"]);
var disabledStyles = {
  cursor: "not-allowed",
  userSelect: "none",
  color: tokens.colorNeutralForegroundDisabled,
  backgroundColor: tokens.colorNeutralBackgroundDisabled,
  boxShadow: tokens.shadow2,
  ...shorthands.borderColor(tokens.colorNeutralStrokeDisabled),
  "::before": {
    content: '""',
    position: "absolute",
    inset: 0,
    zIndex: `calc(${tokens.zIndexContent} + 1)`
  },
  "::after": {
    ...shorthands.borderColor(tokens.colorNeutralStrokeDisabled)
  }
};
var useCardStyles = __styles2({
  focused: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Bb7d1vk: "f226i61",
    zhwhgb: ["f13kzufm", "fsx75g8"],
    dhy2o1: "flujwa2",
    Gfyso: ["fsx75g8", "f13kzufm"],
    Bm4h7ae: "f15bsgw9",
    B7ys5i9: "f14e48fq",
    Busjfv9: "f18yb2kv",
    Bhk32uz: "fd6o370",
    f6g5ot: 0,
    Boxcth7: 0,
    Bhdgwq3: 0,
    hgwjuy: 0,
    Bshpdp8: 0,
    Bsom6fd: 0,
    Blkhhs4: 0,
    Bonggc9: 0,
    Ddfuxk: 0,
    i03rao: 0,
    kclons: 0,
    clg4pj: 0,
    Bpqj9nj: 0,
    B6dhp37: 0,
    Bf4ptjt: 0,
    Bqtpl0w: 0,
    i4rwgc: "fpqizxz",
    Dah5zi: 0,
    B1tsrr9: 0,
    qqdqy8: 0,
    Bkh64rk: 0,
    e3fwne: "fnd8nzh",
    J0r882: "f15fr7a0",
    Bule8hv: ["fwsq40z", "fy0y4wt"],
    Bjwuhne: "f34ld9f",
    Ghsupd: ["fy0y4wt", "fwsq40z"]
  },
  selectableFocused: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    Bssx7fj: "f1b1k54r",
    uh7if5: ["f4ne723", "fqqcjud"],
    clntm0: "fh7aioi",
    Dlk2r6: ["fqqcjud", "f4ne723"],
    Bm3wd5j: "f1k55ka9",
    Bbrhkcr: ["fgclinu", "f16pcs8n"],
    f1oku: "fycbxed",
    aywvf2: ["f16pcs8n", "fgclinu"],
    B2j2mmj: "ffht0p2",
    wigs8: "f1p0ul1q",
    pbfy6t: "f1c901ms",
    B0v4ure: "f1alokd7",
    Byrf0fs: 0,
    Bsiemmq: 0,
    Bwckmig: 0,
    skfxo0: 0,
    Iidy0u: 0,
    B98u21t: 0,
    Bvwlmkc: 0,
    jo1ztg: 0,
    Ba1iezr: 0,
    Blmvk6g: 0,
    B24cy0v: 0,
    Bil7v7r: 0,
    Br3gin4: 0,
    nr063g: 0,
    ghq09: 0,
    Bbgo44z: 0,
    Bseh09z: "f1i978nd",
    az1dzo: 0,
    Ba3ybja: 0,
    B6352mv: 0,
    vppk2z: 0,
    Biaj6j7: "f1nh8hsq",
    B2pnrqr: "f1amxum7",
    B29w5g4: ["f1cec8w7", "f554mv0"],
    Bhhzhcn: "f1sj6kbr",
    Bec0n69: ["f554mv0", "f1cec8w7"]
  },
  orientationHorizontal: {
    Beiy3e4: "f1063pyq",
    Bt984gj: "f122n59",
    Binpb3b: "ftrw7vg",
    qrt8p2: "f18opajm",
    k6ws3r: ["f13002it", "fqo182t"],
    Btcwela: ["f18yna97", "f1kd6wh7"],
    Fer9m8: "f4i4759"
  },
  orientationVertical: {
    Beiy3e4: "f1vx9l62",
    B5nvv7i: ["f14k419y", "f1fgo9fz"],
    Baxg94k: ["f1fgo9fz", "f14k419y"],
    tn21ii: "fvqmfsm",
    B0ud6bj: "f3am6yf",
    Bgdo4j: "f1r5wgso"
  },
  sizeSmall: {
    B7balbw: "f1pi9uxy",
    B1h88n7: "f1h1zgly"
  },
  sizeMedium: {
    B7balbw: "frsmuga",
    B1h88n7: "fuldkky"
  },
  sizeLarge: {
    B7balbw: "f1qua4xo",
    B1h88n7: "fimkt6v"
  },
  interactive: {
    rhjd8f: "f1epqm3e"
  },
  filled: {
    De3pzq: "fxugw4r",
    E5pizo: "f1whvlc6",
    B0n5ga8: "f16gxe2i",
    s924m2: ["fpgykix", "fzybk4o"],
    B1q35kw: "f1osi826",
    Gp14am: ["fzybk4o", "fpgykix"]
  },
  filledInteractive: {
    Bceei9c: "f1k6fduh",
    De3pzq: "fxugw4r",
    E5pizo: "f1whvlc6",
    B0n5ga8: "f16gxe2i",
    s924m2: ["fpgykix", "fzybk4o"],
    B1q35kw: "f1osi826",
    Gp14am: ["fzybk4o", "fpgykix"],
    Bi91k9c: "feu1g3u",
    Jwef8y: "f1knas48",
    Bvxd0ez: "f1m145df",
    ecr2s2: "fb40n2d"
  },
  filledInteractiveSelected: {
    De3pzq: "f1nfm20t",
    B0n5ga8: "f16eln5f",
    s924m2: ["fa2okxs", "fg4zq3l"],
    B1q35kw: "ff6932p",
    Gp14am: ["fg4zq3l", "fa2okxs"],
    Bi91k9c: "fx9teim",
    Jwef8y: "f1kz6goq"
  },
  filledAlternative: {
    De3pzq: "f1dmdbja",
    E5pizo: "f1whvlc6",
    B0n5ga8: "f16gxe2i",
    s924m2: ["fpgykix", "fzybk4o"],
    B1q35kw: "f1osi826",
    Gp14am: ["fzybk4o", "fpgykix"]
  },
  filledAlternativeInteractive: {
    Bceei9c: "f1k6fduh",
    De3pzq: "f1dmdbja",
    E5pizo: "f1whvlc6",
    B0n5ga8: "f16gxe2i",
    s924m2: ["fpgykix", "fzybk4o"],
    B1q35kw: "f1osi826",
    Gp14am: ["fzybk4o", "fpgykix"],
    Bi91k9c: "fnwyq0v",
    Jwef8y: "f1uvynv3",
    Bvxd0ez: "f1m145df",
    ecr2s2: "f1yhgkbh"
  },
  filledAlternativeInteractiveSelected: {
    De3pzq: "fjxa0vh",
    B0n5ga8: "f16eln5f",
    s924m2: ["fa2okxs", "fg4zq3l"],
    B1q35kw: "ff6932p",
    Gp14am: ["fg4zq3l", "fa2okxs"],
    Bi91k9c: "f1luvkty",
    Jwef8y: "fehi0vp"
  },
  outline: {
    De3pzq: "f1c21dwh",
    E5pizo: "f1couhl3",
    B0n5ga8: "ft83z1f",
    s924m2: ["f1g4150c", "f192dr6e"],
    B1q35kw: "f1qnawh6",
    Gp14am: ["f192dr6e", "f1g4150c"]
  },
  outlineInteractive: {
    Bceei9c: "f1k6fduh",
    De3pzq: "f1c21dwh",
    E5pizo: "f1couhl3",
    B0n5ga8: "ft83z1f",
    s924m2: ["f1g4150c", "f192dr6e"],
    B1q35kw: "f1qnawh6",
    Gp14am: ["f192dr6e", "f1g4150c"],
    Bi91k9c: "feu1g3u",
    Jwef8y: "fjxutwb",
    Be0v6ae: "f1llr77y",
    B5kxglz: ["fzk0khw", "fjj8tog"],
    B3pwyw6: "fb1u8ub",
    Bymgtzf: ["fjj8tog", "fzk0khw"],
    ecr2s2: "fophhak",
    dmfk: "f1uohb70",
    B4ofi8: ["f1jm7v1n", "f1bus3rq"],
    jgq6uv: "f1fbu7rr",
    Baxewws: ["f1bus3rq", "f1jm7v1n"]
  },
  outlineInteractiveSelected: {
    De3pzq: "f1q9pm1r",
    B0n5ga8: "f16eln5f",
    s924m2: ["fa2okxs", "fg4zq3l"],
    B1q35kw: "ff6932p",
    Gp14am: ["fg4zq3l", "fa2okxs"],
    Bi91k9c: "fx9teim",
    Jwef8y: "fg59vm4"
  },
  outlineDisabled: {
    De3pzq: "f1c21dwh",
    E5pizo: "f1couhl3",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    ezxybo: "f1ls5moo",
    wc7uws: "f1qiza15",
    B0n5ga8: "f13dj02",
    s924m2: ["f9wngki", "f17v59j0"],
    B1q35kw: "f1vxzwsp",
    Gp14am: ["f17v59j0", "f9wngki"]
  },
  subtle: {
    De3pzq: "fhovq9v",
    E5pizo: "f1couhl3",
    B0n5ga8: "f16gxe2i",
    s924m2: ["fpgykix", "fzybk4o"],
    B1q35kw: "f1osi826",
    Gp14am: ["fzybk4o", "fpgykix"]
  },
  subtleInteractive: {
    Bceei9c: "f1k6fduh",
    De3pzq: "fhovq9v",
    E5pizo: "f1couhl3",
    B0n5ga8: "f16gxe2i",
    s924m2: ["fpgykix", "fzybk4o"],
    B1q35kw: "f1osi826",
    Gp14am: ["fzybk4o", "fpgykix"],
    Bi91k9c: "feu1g3u",
    Jwef8y: "f1t94bn6",
    ecr2s2: "f1wfn5kd"
  },
  subtleInteractiveSelected: {
    De3pzq: "fq5gl1p",
    B0n5ga8: "f16eln5f",
    s924m2: ["fa2okxs", "fg4zq3l"],
    B1q35kw: "ff6932p",
    Gp14am: ["fg4zq3l", "fa2okxs"],
    Bi91k9c: "fx9teim",
    Jwef8y: "f1uqaxdt"
  },
  highContrastSelected: {
    ycbfsm: "fkc42ay",
    Bsw6fvg: "f1rirnrt",
    Bbusuzp: "f1lkg8j3",
    xgfqdd: "f1nkj0oa",
    Bmmdzwq: "fey3rwa",
    zkpvhj: ["f5jhx11", "fff9uym"],
    B20bydw: "fm7n0jy",
    Bwwwggl: ["fff9uym", "f5jhx11"]
  },
  highContrastInteractive: {
    h1vhog: "fpfvv3l",
    kslmdy: "f1oamsm6",
    Baaf6ca: "f1il21bs",
    x9zz3d: "fnn5dk0",
    Bmmdzwq: "fey3rwa",
    zkpvhj: ["f5jhx11", "fff9uym"],
    B20bydw: "fm7n0jy",
    Bwwwggl: ["fff9uym", "f5jhx11"]
  },
  select: {
    qhf8xq: "f1euv43f",
    Bhzewxz: "fqclxi7",
    j35jbq: ["fiv86kb", "f36uhnt"],
    Bj3rh1h: "fom9my7"
  },
  hiddenCheckbox: {
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    a9b677: "frkrog8",
    Bqenvij: "f1mpe4l3",
    qhf8xq: "f1euv43f",
    Bh84pgu: "fmf1zke",
    Bgl5zvf: "f1wch0ki",
    Huce71: "fz5stix"
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    famaaq: "f1xqy1su",
    sj55zd: "f1s2aq7o",
    De3pzq: "f1bg9a2p",
    E5pizo: "fyed02w",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    Ftih45: "f1wl9k8s",
    Brfgrao: "f1j7ml58",
    lawp4y: 0,
    Fbdkly: 0,
    mdwyqc: 0,
    Bciustq: 0,
    gc50h5: "f13vvzas",
    Ehzi8l: "f198lalb",
    B0n5ga8: "f13dj02",
    s924m2: ["f9wngki", "f17v59j0"],
    B1q35kw: "f1vxzwsp",
    Gp14am: ["f17v59j0", "f9wngki"],
    Bikrtoi: "f11og98d",
    G8qf51: "f1rg3h4v",
    Brxh4y7: "fbm2y3b",
    ezxybo: "f4yodeu",
    wc7uws: "fcwfbwp",
    gp3uxg: "f1repx37",
    Fohawp: ["f1ybi8ct", "f1h4eg6q"],
    Bxulg6k: "f18mejnb",
    vcjq4m: ["f1h4eg6q", "f1ybi8ct"],
    Bsqkqe9: "f1nift3m",
    fskg1g: "f1wu3i8x",
    iwiei9: 0,
    Effecx: 0,
    Bkt1b9m: 0,
    jfmxvr: 0,
    orauir: "f6v4vfa",
    B2yd9ot: "folrdqs",
    Fn9tzk: "f168z5yf",
    Bv0wker: ["fpor7gj", "fzextn6"],
    Bp2dl5b: "f1yaw79v",
    pzn0iz: ["fzextn6", "fpor7gj"]
  }
}, {
  f: [".ftqa4ok:focus{outline-style:none;}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"],
  d: [".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", '.f15bsgw9[data-fui-focus-visible]::after{content:"";}', ".f14e48fq[data-fui-focus-visible]::after{position:absolute;}", ".f18yb2kv[data-fui-focus-visible]::after{pointer-events:none;}", ".fd6o370[data-fui-focus-visible]::after{z-index:1;}", [".fpqizxz[data-fui-focus-visible]::after{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".fnd8nzh[data-fui-focus-visible]::after{border-radius:var(--fui-Card--border-radius);}", {
    p: -1
  }], ".f15fr7a0[data-fui-focus-visible]::after{top:calc(0px - var(--strokeWidthThick) - -2px);}", ".fwsq40z[data-fui-focus-visible]::after{right:calc(0px - var(--strokeWidthThick) - -2px);}", ".fy0y4wt[data-fui-focus-visible]::after{left:calc(0px - var(--strokeWidthThick) - -2px);}", ".f34ld9f[data-fui-focus-visible]::after{bottom:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}", ".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}", ".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}", ".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}", '.ffht0p2[data-fui-focus-within]:focus-within::after{content:"";}', ".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}", ".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}", ".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}", [".f1i978nd[data-fui-focus-within]:focus-within::after{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1nh8hsq[data-fui-focus-within]:focus-within::after{border-radius:var(--fui-Card--border-radius);}", {
    p: -1
  }], ".f1amxum7[data-fui-focus-within]:focus-within::after{top:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1cec8w7[data-fui-focus-within]:focus-within::after{right:calc(0px - var(--strokeWidthThick) - -2px);}", ".f554mv0[data-fui-focus-within]:focus-within::after{left:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1sj6kbr[data-fui-focus-within]:focus-within::after{bottom:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1063pyq{flex-direction:row;}", ".f122n59{align-items:center;}", ".ftrw7vg>.fui-CardPreview{margin-top:calc(var(--fui-Card--size) * -1);}", ".f18opajm>.fui-CardPreview{margin-bottom:calc(var(--fui-Card--size) * -1);}", '.f13002it>:not([aria-hidden="true"]).fui-CardPreview:first-of-type{margin-left:calc(var(--fui-Card--size) * -1);}', '.fqo182t>:not([aria-hidden="true"]).fui-CardPreview:first-of-type{margin-right:calc(var(--fui-Card--size) * -1);}', '.f18yna97>:not([aria-hidden="true"]).fui-CardPreview:last-of-type{margin-right:calc(var(--fui-Card--size) * -1);}', '.f1kd6wh7>:not([aria-hidden="true"]).fui-CardPreview:last-of-type{margin-left:calc(var(--fui-Card--size) * -1);}', ".f4i4759>.fui-CardHeader:last-of-type,.f4i4759>.fui-CardFooter:last-of-type{flex-grow:1;}", ".f1vx9l62{flex-direction:column;}", ".f14k419y>.fui-CardPreview{margin-left:calc(var(--fui-Card--size) * -1);}", ".f1fgo9fz>.fui-CardPreview{margin-right:calc(var(--fui-Card--size) * -1);}", '.fvqmfsm>:not([aria-hidden="true"]).fui-CardPreview:first-of-type{margin-top:calc(var(--fui-Card--size) * -1);}', ".f3am6yf>.fui-Card__floatingAction+.fui-CardPreview{margin-top:calc(var(--fui-Card--size) * -1);}", '.f1r5wgso>:not([aria-hidden="true"]).fui-CardPreview:last-of-type{margin-bottom:calc(var(--fui-Card--size) * -1);}', ".f1pi9uxy{--fui-Card--size:8px;}", ".f1h1zgly{--fui-Card--border-radius:var(--borderRadiusSmall);}", ".frsmuga{--fui-Card--size:12px;}", ".fuldkky{--fui-Card--border-radius:var(--borderRadiusMedium);}", ".f1qua4xo{--fui-Card--size:16px;}", ".fimkt6v{--fui-Card--border-radius:var(--borderRadiusLarge);}", ".f1epqm3e .fui-Text{color:currentColor;}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1whvlc6{box-shadow:var(--shadow4);}", ".f16gxe2i::after{border-top-color:var(--colorTransparentStroke);}", ".fpgykix::after{border-right-color:var(--colorTransparentStroke);}", ".fzybk4o::after{border-left-color:var(--colorTransparentStroke);}", ".f1osi826::after{border-bottom-color:var(--colorTransparentStroke);}", ".f1k6fduh{cursor:pointer;}", ".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}", ".f16eln5f::after{border-top-color:var(--colorNeutralStroke1Selected);}", ".fa2okxs::after{border-right-color:var(--colorNeutralStroke1Selected);}", ".fg4zq3l::after{border-left-color:var(--colorNeutralStroke1Selected);}", ".ff6932p::after{border-bottom-color:var(--colorNeutralStroke1Selected);}", ".f1dmdbja{background-color:var(--colorNeutralBackground2);}", ".fjxa0vh{background-color:var(--colorNeutralBackground2Selected);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1couhl3{box-shadow:none;}", ".ft83z1f::after{border-top-color:var(--colorNeutralStroke1);}", ".f1g4150c::after{border-right-color:var(--colorNeutralStroke1);}", ".f192dr6e::after{border-left-color:var(--colorNeutralStroke1);}", ".f1qnawh6::after{border-bottom-color:var(--colorNeutralStroke1);}", ".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f13dj02::after{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f9wngki::after{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f17v59j0::after{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1vxzwsp::after{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1euv43f{position:absolute;}", ".fqclxi7{top:4px;}", ".fiv86kb{right:4px;}", ".f36uhnt{left:4px;}", ".fom9my7{z-index:var(--zIndexContent, 1);}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], ".frkrog8{width:1px;}", ".f1mpe4l3{height:1px;}", ".fmf1zke{clip:rect(0 0 0 0);}", ".f1wch0ki{clip-path:inset(50%);}", ".fz5stix{white-space:nowrap;}", ".fdrzuqr{cursor:not-allowed;}", ".f1xqy1su{-webkit-user-select:none;-moz-user-select:none;user-select:none;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".fyed02w{box-shadow:var(--shadow2);}", '.f1wl9k8s::before{content:"";}', ".f1j7ml58::before{position:absolute;}", [".f13vvzas::before{inset:0;}", {
    p: -1
  }], ".f198lalb::before{z-index:calc(var(--zIndexContent, 1) + 1);}"],
  m: [["@media (forced-colors: active){.f226i61[data-fui-focus-visible]::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f13kzufm[data-fui-focus-visible]::after{border-right-color:Highlight;}.fsx75g8[data-fui-focus-visible]::after{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.flujwa2[data-fui-focus-visible]::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1k55ka9[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f16pcs8n[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}.fgclinu[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fycbxed[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fkc42ay{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1rirnrt{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1lkg8j3{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1nkj0oa .fui-CardPreview,.f1nkj0oa .fui-CardFooter{forced-color-adjust:auto;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fey3rwa::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f5jhx11::after{border-right-color:Highlight;}.fff9uym::after{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fm7n0jy::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fpfvv3l:hover,.fpfvv3l :active{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1oamsm6:hover,.f1oamsm6 :active{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1il21bs:hover,.f1il21bs :active{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fnn5dk0:hover .fui-CardPreview,.fnn5dk0 :active .fui-CardPreview,.fnn5dk0:hover .fui-CardFooter,.fnn5dk0 :active .fui-CardFooter{forced-color-adjust:auto;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}", ".f1m145df:hover{box-shadow:var(--shadow8);}", ".fx9teim:hover{color:var(--colorNeutralForeground1Selected);}", ".f1kz6goq:hover{background-color:var(--colorNeutralBackground1Selected);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".f1uvynv3:hover{background-color:var(--colorNeutralBackground2Hover);}", ".f1luvkty:hover{color:var(--colorNeutralForeground2Selected);}", ".fehi0vp:hover{background-color:var(--colorNeutralBackground2Selected);}", ".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".f1llr77y:hover::after{border-top-color:var(--colorNeutralStroke1Hover);}", ".fzk0khw:hover::after{border-right-color:var(--colorNeutralStroke1Hover);}", ".fjj8tog:hover::after{border-left-color:var(--colorNeutralStroke1Hover);}", ".fb1u8ub:hover::after{border-bottom-color:var(--colorNeutralStroke1Hover);}", ".fg59vm4:hover{background-color:var(--colorTransparentBackgroundSelected);}", ".f1ls5moo:hover,.f1ls5moo:active{background-color:var(--colorTransparentBackground);}", ".f1qiza15:hover,.f1qiza15:active{box-shadow:none;}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".f1uqaxdt:hover{background-color:var(--colorSubtleBackgroundSelected);}", ".f11og98d:hover,.f11og98d:active{cursor:not-allowed;}", ".f1rg3h4v:hover,.f1rg3h4v:active{-webkit-user-select:none;-moz-user-select:none;user-select:none;}", ".fbm2y3b:hover,.fbm2y3b:active{color:var(--colorNeutralForegroundDisabled);}", ".f4yodeu:hover,.f4yodeu:active{background-color:var(--colorNeutralBackgroundDisabled);}", ".fcwfbwp:hover,.fcwfbwp:active{box-shadow:var(--shadow2);}", ".f1repx37:hover,.f1repx37:active{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1ybi8ct:hover,.f1ybi8ct:active{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f1h4eg6q:hover,.f1h4eg6q:active{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f18mejnb:hover,.f18mejnb:active{border-bottom-color:var(--colorNeutralStrokeDisabled);}", '.f1nift3m:hover::before,.f1nift3m:active::before{content:"";}', ".f1wu3i8x:hover::before,.f1wu3i8x:active::before{position:absolute;}", [".f6v4vfa:hover::before,.f6v4vfa:active::before{inset:0;}", {
    p: -1
  }], ".folrdqs:hover::before,.folrdqs:active::before{z-index:calc(var(--zIndexContent, 1) + 1);}", ".f168z5yf:hover::after,.f168z5yf:active::after{border-top-color:var(--colorNeutralStrokeDisabled);}", ".fpor7gj:hover::after,.fpor7gj:active::after{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fzextn6:hover::after,.fzextn6:active::after{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1yaw79v:hover::after,.f1yaw79v:active::after{border-bottom-color:var(--colorNeutralStrokeDisabled);}"],
  a: [".fb40n2d:active{background-color:var(--colorNeutralBackground1Pressed);}", ".f1yhgkbh:active{background-color:var(--colorNeutralBackground2Pressed);}", ".fophhak:active{background-color:var(--colorTransparentBackgroundPressed);}", ".f1uohb70:active::after{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1jm7v1n:active::after{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f1bus3rq:active::after{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1fbu7rr:active::after{border-bottom-color:var(--colorNeutralStroke1Pressed);}", ".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}"]
});
var useCardStyles_unstable = (state) => {
  "use no memo";
  const resetStyles = useCardResetStyles();
  const styles = useCardStyles();
  const orientationMap = {
    horizontal: styles.orientationHorizontal,
    vertical: styles.orientationVertical
  };
  const sizeMap = {
    small: styles.sizeSmall,
    medium: styles.sizeMedium,
    large: styles.sizeLarge
  };
  const appearanceMap = {
    filled: styles.filled,
    "filled-alternative": styles.filledAlternative,
    outline: styles.outline,
    subtle: styles.subtle
  };
  const selectedMap = {
    filled: styles.filledInteractiveSelected,
    "filled-alternative": styles.filledAlternativeInteractiveSelected,
    outline: styles.outlineInteractiveSelected,
    subtle: styles.subtleInteractiveSelected
  };
  const interactiveMap = {
    filled: styles.filledInteractive,
    "filled-alternative": styles.filledAlternativeInteractive,
    outline: styles.outlineInteractive,
    subtle: styles.subtleInteractive
  };
  const isSelectableOrInteractive = !state.disabled && (state.interactive || state.selectable);
  const focusedClassName = React377.useMemo(() => {
    if (state.disabled) {
      return "";
    }
    if (state.selectable) {
      if (state.selectFocused) {
        return styles.selectableFocused;
      }
      return "";
    }
    return styles.focused;
  }, [state.disabled, state.selectFocused, state.selectable, styles.focused, styles.selectableFocused]);
  state.root.className = mergeClasses(cardClassNames.root, resetStyles, orientationMap[state.orientation], sizeMap[state.size], appearanceMap[state.appearance], isSelectableOrInteractive && styles.interactive, isSelectableOrInteractive && interactiveMap[state.appearance], state.selected && selectedMap[state.appearance], focusedClassName, isSelectableOrInteractive && styles.highContrastInteractive, state.selected && styles.highContrastSelected, state.disabled && styles.disabled, state.disabled && state.appearance === "outline" && styles.outlineDisabled, state.root.className);
  if (state.floatingAction) {
    state.floatingAction.className = mergeClasses(cardClassNames.floatingAction, styles.select, state.floatingAction.className);
  }
  if (state.checkbox) {
    state.checkbox.className = mergeClasses(cardClassNames.checkbox, styles.hiddenCheckbox, state.checkbox.className);
  }
  return state;
};

// node_modules/@fluentui/react-card/lib/components/Card/useCardContextValue.js
function useCardContextValue({ selectableA11yProps }) {
  return {
    selectableA11yProps
  };
}

// node_modules/@fluentui/react-card/lib/components/Card/Card.js
var Card = React378.forwardRef((props, ref) => {
  const state = useCard_unstable(props, ref);
  const cardContextValue = useCardContextValue(state);
  useCardStyles_unstable(state);
  useCustomStyleHook("useCardStyles_unstable")(state);
  return renderCard_unstable(state, cardContextValue);
});
Card.displayName = "Card";

// node_modules/@fluentui/react-card/lib/components/CardFooter/CardFooter.js
var React380 = __toESM(require_react());

// node_modules/@fluentui/react-card/lib/components/CardFooter/useCardFooter.js
var React379 = __toESM(require_react());
var useCardFooter_unstable = (props, ref) => {
  const { action } = props;
  return {
    components: {
      root: "div",
      action: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    action: slot_exports.optional(action, {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-card/lib/components/CardFooter/renderCardFooter.js
var renderCardFooter_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.root.children,
      state.action && jsx(state.action, {})
    ]
  });
};

// node_modules/@fluentui/react-card/lib/components/CardFooter/CardFooter.js
var CardFooter = React380.forwardRef((props, ref) => {
  const state = useCardFooter_unstable(props, ref);
  useCardFooterStyles_unstable(state);
  useCustomStyleHook("useCardFooterStyles_unstable")(state);
  return renderCardFooter_unstable(state);
});
CardFooter.displayName = "CardFooter";

// node_modules/@fluentui/react-card/lib/components/CardHeader/CardHeader.js
var React382 = __toESM(require_react());

// node_modules/@fluentui/react-card/lib/components/CardHeader/useCardHeader.js
var React381 = __toESM(require_react());
function getChildWithId(header) {
  function isReactElementWithIdProp(element) {
    return React381.isValidElement(element) && Boolean(element.props.id);
  }
  return React381.Children.toArray(header).find(isReactElementWithIdProp);
}
function getReferenceId(headerId, childWithId, generatedId) {
  if (headerId) {
    return headerId;
  }
  if (childWithId === null || childWithId === void 0 ? void 0 : childWithId.props.id) {
    return childWithId.props.id;
  }
  return generatedId;
}
var useCardHeader_unstable = (props, ref) => {
  const { image, header, description, action } = props;
  const { selectableA11yProps: { referenceId, setReferenceId } } = useCardContext_unstable();
  const headerRef = React381.useRef(null);
  const hasChildId = React381.useRef(false);
  const generatedId = useId2(cardHeaderClassNames.header, referenceId);
  const headerSlot = slot_exports.optional(header, {
    renderByDefault: true,
    defaultProps: {
      ref: headerRef,
      id: !hasChildId.current ? referenceId : void 0
    },
    elementType: "div"
  });
  React381.useEffect(() => {
    var _headerRef_current;
    const headerId = !hasChildId.current ? (_headerRef_current = headerRef.current) === null || _headerRef_current === void 0 ? void 0 : _headerRef_current.id : void 0;
    const childWithId = getChildWithId(headerSlot === null || headerSlot === void 0 ? void 0 : headerSlot.children);
    hasChildId.current = Boolean(childWithId);
    setReferenceId(getReferenceId(headerId, childWithId, generatedId));
  }, [
    generatedId,
    header,
    headerSlot,
    setReferenceId
  ]);
  return {
    components: {
      root: "div",
      image: "div",
      header: "div",
      description: "div",
      action: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    image: slot_exports.optional(image, {
      elementType: "div"
    }),
    header: headerSlot,
    description: slot_exports.optional(description, {
      elementType: "div"
    }),
    action: slot_exports.optional(action, {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-card/lib/components/CardHeader/renderCardHeader.js
var renderCardHeader_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.image && jsx(state.image, {}),
      state.header && jsx(state.header, {}),
      state.description && jsx(state.description, {}),
      state.action && jsx(state.action, {})
    ]
  });
};

// node_modules/@fluentui/react-card/lib/components/CardHeader/CardHeader.js
var CardHeader = React382.forwardRef((props, ref) => {
  const state = useCardHeader_unstable(props, ref);
  useCardHeaderStyles_unstable(state);
  useCustomStyleHook("useCardHeaderStyles_unstable")(state);
  return renderCardHeader_unstable(state);
});
CardHeader.displayName = "CardHeader";

// node_modules/@fluentui/react-card/lib/components/CardPreview/CardPreview.js
var React384 = __toESM(require_react());

// node_modules/@fluentui/react-card/lib/components/CardPreview/useCardPreview.js
var React383 = __toESM(require_react());
var useCardPreview_unstable = (props, ref) => {
  const { logo } = props;
  const { selectableA11yProps: { referenceLabel, referenceId, setReferenceLabel, setReferenceId } } = useCardContext_unstable();
  const previewRef = useMergedRefs(ref, React383.useRef(null));
  React383.useEffect(() => {
    if (referenceLabel && referenceId) {
      return;
    }
    if (previewRef.current && previewRef.current.parentNode) {
      const img = previewRef.current.parentNode.querySelector(`.${cardPreviewClassNames.root} > img`);
      if (img) {
        const ariaLabel = img.getAttribute("aria-label");
        const ariaDescribedby = img.getAttribute("aria-describedby");
        if (ariaDescribedby) {
          setReferenceId(ariaDescribedby);
        } else if (img.alt) {
          setReferenceLabel(img.alt);
        } else if (ariaLabel) {
          setReferenceLabel(ariaLabel);
        }
      }
    }
  }, [
    setReferenceLabel,
    referenceLabel,
    previewRef,
    referenceId,
    setReferenceId
  ]);
  return {
    components: {
      root: "div",
      logo: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: previewRef,
      ...props
    }), {
      elementType: "div"
    }),
    logo: slot_exports.optional(logo, {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-card/lib/components/CardPreview/renderCardPreview.js
var renderCardPreview_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.root.children,
      state.logo && jsx(state.logo, {})
    ]
  });
};

// node_modules/@fluentui/react-card/lib/components/CardPreview/CardPreview.js
var CardPreview = React384.forwardRef((props, ref) => {
  const state = useCardPreview_unstable(props, ref);
  useCardPreviewStyles_unstable(state);
  useCustomStyleHook("useCardPreviewStyles_unstable")(state);
  return renderCardPreview_unstable(state);
});
CardPreview.displayName = "CardPreview";

// node_modules/@fluentui/react-toast/lib/state/useToaster.js
var React386 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/state/constants.js
var EVENTS = {
  show: "fui-toast-show",
  dismiss: "fui-toast-dismiss",
  dismissAll: "fui-toast-dismiss-all",
  update: "fui-toast-update",
  pause: "fui-toast-pause",
  play: "fui-toast-play"
};
var TOAST_POSITIONS = {
  bottom: "bottom",
  bottomEnd: "bottom-end",
  bottomStart: "bottom-start",
  top: "top",
  topEnd: "top-end",
  topStart: "top-start"
};

// node_modules/@fluentui/react-toast/lib/state/vanilla/dispatchToast.js
var counter2 = 0;
function dispatchToast(content, options = {}, targetDocument) {
  var _options_toastId;
  const detail = {
    ...options,
    content,
    toastId: (_options_toastId = options.toastId) !== null && _options_toastId !== void 0 ? _options_toastId : (counter2++).toString()
  };
  const event = new CustomEvent(EVENTS.show, {
    bubbles: false,
    cancelable: false,
    detail
  });
  targetDocument.dispatchEvent(event);
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/dismissToast.js
function dismissToast(toastId, toasterId = void 0, targetDocument) {
  const event = new CustomEvent(EVENTS.dismiss, {
    bubbles: false,
    cancelable: false,
    detail: {
      toastId,
      toasterId
    }
  });
  targetDocument.dispatchEvent(event);
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/dismissAllToasts.js
function dismissAllToasts(toasterId = void 0, targetDocument) {
  const event = new CustomEvent(EVENTS.dismissAll, {
    bubbles: false,
    cancelable: false,
    detail: {
      toasterId
    }
  });
  targetDocument.dispatchEvent(event);
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/updateToast.js
function updateToast(options, targetDocument) {
  const event = new CustomEvent(EVENTS.update, {
    bubbles: false,
    cancelable: false,
    detail: options
  });
  targetDocument.dispatchEvent(event);
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/pauseToast.js
function pauseToast(toastId, toasterId = void 0, targetDocument) {
  const event = new CustomEvent(EVENTS.pause, {
    bubbles: false,
    cancelable: false,
    detail: {
      toastId,
      toasterId
    }
  });
  targetDocument.dispatchEvent(event);
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/playToast.js
function playToast(toastId, toasterId = void 0, targetDocument) {
  const event = new CustomEvent(EVENTS.play, {
    bubbles: false,
    cancelable: false,
    detail: {
      toastId,
      toasterId
    }
  });
  targetDocument.dispatchEvent(event);
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/createToaster.js
var React385 = __toESM(require_react());
function assignDefined(a, b) {
  for (const [key, prop] of Object.entries(b)) {
    if (prop != void 0) {
      a[key] = prop;
    }
  }
}
var defaulToastOptions = {
  onStatusChange: void 0,
  priority: 0,
  pauseOnHover: false,
  pauseOnWindowBlur: false,
  position: "bottom-end",
  timeout: 3e3
};
var counter3 = 0;
function createToaster(options) {
  const { limit = Number.POSITIVE_INFINITY } = options;
  const visibleToasts = /* @__PURE__ */ new Set();
  const toasts = /* @__PURE__ */ new Map();
  const queue = createPriorityQueue((ta, tb) => {
    const a = toasts.get(ta);
    const b = toasts.get(tb);
    if (!a || !b) {
      return 0;
    }
    if (a.priority === b.priority) {
      return a.order - b.order;
    }
    return a.priority - b.priority;
  });
  const isToastVisible = (toastId) => {
    return visibleToasts.has(toastId);
  };
  const updateToast2 = (toastOptions) => {
    const { toastId } = toastOptions;
    const toastToUpdate = toasts.get(toastId);
    if (!toastToUpdate) {
      return;
    }
    Object.assign(toastToUpdate, toastOptions);
    toastToUpdate.updateId++;
  };
  const dismissToast2 = (toastId) => {
    visibleToasts.delete(toastId);
  };
  const dismissAllToasts2 = () => {
    visibleToasts.clear();
    queue.clear();
  };
  const buildToast = (toastOptions, onUpdate) => {
    var _toast_onStatusChange;
    const { toastId, content, toasterId } = toastOptions;
    if (toasts.has(toastId)) {
      return;
    }
    const close = () => {
      var _toast_onStatusChange2;
      const toast2 = toasts.get(toastId);
      if (!toast2) {
        return;
      }
      visibleToasts.delete(toastId);
      onUpdate();
      (_toast_onStatusChange2 = toast2.onStatusChange) === null || _toast_onStatusChange2 === void 0 ? void 0 : _toast_onStatusChange2.call(toast2, null, {
        status: "dismissed",
        ...toast2
      });
    };
    const remove = () => {
      const toast2 = toasts.get(toastId);
      if (!toast2) {
        return;
      }
      toasts.delete(toastId);
      if (visibleToasts.size < limit && queue.peek()) {
        const nextToast = toasts.get(queue.dequeue());
        if (!nextToast) {
          return;
        }
        visibleToasts.add(nextToast.toastId);
      }
      onUpdate();
    };
    const toast = {
      ...defaulToastOptions,
      close,
      remove,
      toastId,
      content,
      updateId: 0,
      toasterId,
      order: counter3++,
      data: {},
      imperativeRef: React385.createRef()
    };
    assignDefined(toast, options);
    assignDefined(toast, toastOptions);
    toasts.set(toastId, toast);
    (_toast_onStatusChange = toast.onStatusChange) === null || _toast_onStatusChange === void 0 ? void 0 : _toast_onStatusChange.call(toast, null, {
      status: "queued",
      ...toast
    });
    if (visibleToasts.size >= limit) {
      queue.enqueue(toastId);
    } else {
      visibleToasts.add(toastId);
    }
  };
  return {
    buildToast,
    dismissAllToasts: dismissAllToasts2,
    dismissToast: dismissToast2,
    isToastVisible,
    updateToast: updateToast2,
    visibleToasts,
    toasts
  };
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/getPositionStyles.js
var getPositionStyles = (position, dir, offset4) => {
  const positionStyles = {};
  var _offset_position;
  const offsetStyles = offset4 ? isShorthandOffset(offset4) ? offset4 : (_offset_position = offset4[position]) !== null && _offset_position !== void 0 ? _offset_position : {} : {};
  const centered = position === "top" || position === "bottom";
  const { horizontal = centered ? 0 : 20, vertical = 16 } = offsetStyles;
  const start = dir === "ltr" ? "left" : "right";
  const end = dir === "ltr" ? "right" : "left";
  switch (position) {
    case "top":
      Object.assign(positionStyles, {
        top: vertical,
        left: `calc(50% + ${horizontal}px)`,
        transform: "translateX(-50%)"
      });
      break;
    case "bottom":
      Object.assign(positionStyles, {
        bottom: vertical,
        left: `calc(50% + ${horizontal}px)`,
        transform: "translateX(-50%)"
      });
      break;
    case "top-start":
      Object.assign(positionStyles, {
        top: vertical,
        [start]: horizontal
      });
      break;
    case "top-end":
      Object.assign(positionStyles, {
        top: vertical,
        [end]: horizontal
      });
      break;
    case "bottom-start":
      Object.assign(positionStyles, {
        bottom: vertical,
        [start]: horizontal
      });
      break;
    case "bottom-end":
      Object.assign(positionStyles, {
        bottom: vertical,
        [end]: horizontal
      });
      break;
  }
  return positionStyles;
};
function isShorthandOffset(offset4) {
  return "horizontal" in offset4 || "vertical" in offset4;
}

// node_modules/@fluentui/react-toast/lib/state/useToaster.js
function useToaster(options = {}) {
  const forceUpdate = useForceUpdate();
  const { toasterId: userToasterId, shortcuts } = options;
  const [toaster] = React386.useState(() => createToaster(options));
  const { targetDocument } = useFluent();
  const lastActiveElementRef = React386.useRef(null);
  const isCorrectToaster = useEventCallback((toasterId) => {
    return toasterId === userToasterId;
  });
  const isFocusShortcut = useEventCallback((e) => {
    if (shortcuts === null || shortcuts === void 0 ? void 0 : shortcuts.focus) {
      return shortcuts.focus(e);
    }
  });
  const pauseAllToasts = React386.useCallback(() => {
    toaster.visibleToasts.forEach((toastId) => {
      var _toast_imperativeRef_current;
      const toast = toaster.toasts.get(toastId);
      toast === null || toast === void 0 ? void 0 : (_toast_imperativeRef_current = toast.imperativeRef.current) === null || _toast_imperativeRef_current === void 0 ? void 0 : _toast_imperativeRef_current.pause();
    });
  }, [
    toaster
  ]);
  const playAllToasts = React386.useCallback(() => {
    toaster.visibleToasts.forEach((toastId) => {
      var _toast_imperativeRef_current;
      const toast = toaster.toasts.get(toastId);
      toast === null || toast === void 0 ? void 0 : (_toast_imperativeRef_current = toast.imperativeRef.current) === null || _toast_imperativeRef_current === void 0 ? void 0 : _toast_imperativeRef_current.play();
    });
  }, [
    toaster
  ]);
  const getMostRecentVisibleToast = React386.useCallback(() => {
    return Array.from(toaster.visibleToasts).reduce((cur, next) => {
      const toast = toaster.toasts.get(next);
      if (!toast) {
        return cur;
      }
      if (!cur) {
        return toast;
      }
      if (cur.order < (toast === null || toast === void 0 ? void 0 : toast.order)) {
        return toast;
      }
      return cur;
    }, void 0);
  }, [
    toaster
  ]);
  const tryRestoreFocus = React386.useCallback(() => {
    const mostRecentToast = getMostRecentVisibleToast();
    if (mostRecentToast === null || mostRecentToast === void 0 ? void 0 : mostRecentToast.imperativeRef.current) {
      mostRecentToast.imperativeRef.current.focus();
    } else {
      var _lastActiveElementRef_current;
      (_lastActiveElementRef_current = lastActiveElementRef.current) === null || _lastActiveElementRef_current === void 0 ? void 0 : _lastActiveElementRef_current.focus();
      lastActiveElementRef.current = null;
    }
  }, [
    getMostRecentVisibleToast
  ]);
  const closeAllToasts = React386.useCallback(() => {
    toaster.visibleToasts.forEach((toastId) => {
      const toast = toaster.toasts.get(toastId);
      toast === null || toast === void 0 ? void 0 : toast.close();
    });
    tryRestoreFocus();
  }, [
    toaster,
    tryRestoreFocus
  ]);
  React386.useEffect(() => {
    if (!targetDocument) {
      return;
    }
    const addToastListener = (eventType, callback) => {
      const listener = (e) => {
        if (!isCorrectToaster(e.detail.toasterId)) {
          return;
        }
        callback(e);
        forceUpdate();
      };
      targetDocument.addEventListener(eventType, listener);
      return () => targetDocument.removeEventListener(eventType, listener);
    };
    const buildToast = (e) => {
      toaster.buildToast(e.detail, forceUpdate);
    };
    const dismissToast2 = (e) => {
      toaster.dismissToast(e.detail.toastId);
    };
    const updateToast2 = (e) => {
      toaster.updateToast(e.detail);
    };
    const dismissAllToasts2 = (e) => {
      toaster.dismissAllToasts();
    };
    const pauseToast2 = (e) => {
      const toast = toaster.toasts.get(e.detail.toastId);
      if (toast) {
        var _toast_imperativeRef_current;
        (_toast_imperativeRef_current = toast.imperativeRef.current) === null || _toast_imperativeRef_current === void 0 ? void 0 : _toast_imperativeRef_current.pause();
      }
    };
    const playToast2 = (e) => {
      const toast = toaster.toasts.get(e.detail.toastId);
      if (toast) {
        var _toast_imperativeRef_current;
        (_toast_imperativeRef_current = toast.imperativeRef.current) === null || _toast_imperativeRef_current === void 0 ? void 0 : _toast_imperativeRef_current.play();
      }
    };
    const cleanupBuildListener = addToastListener(EVENTS.show, buildToast);
    const cleanupUpdateListener = addToastListener(EVENTS.update, updateToast2);
    const cleanupDismissListener = addToastListener(EVENTS.dismiss, dismissToast2);
    const cleanupDismissAllListener = addToastListener(EVENTS.dismissAll, dismissAllToasts2);
    const cleanupPauseListener = addToastListener(EVENTS.pause, pauseToast2);
    const cleanupPlayListener = addToastListener(EVENTS.play, playToast2);
    const focusShortcutListener = (e) => {
      if (isFocusShortcut(e)) {
        pauseAllToasts();
        const mostRecentToast = getMostRecentVisibleToast();
        if (mostRecentToast) {
          var _mostRecentToast_imperativeRef_current;
          lastActiveElementRef.current = isHTMLElement(targetDocument.activeElement) ? targetDocument.activeElement : null;
          (_mostRecentToast_imperativeRef_current = mostRecentToast.imperativeRef.current) === null || _mostRecentToast_imperativeRef_current === void 0 ? void 0 : _mostRecentToast_imperativeRef_current.focus();
        }
      }
    };
    targetDocument.addEventListener("keydown", focusShortcutListener);
    return () => {
      cleanupBuildListener();
      cleanupDismissAllListener();
      cleanupUpdateListener();
      cleanupDismissListener();
      cleanupPauseListener();
      cleanupPlayListener();
      targetDocument.removeEventListener("keydown", focusShortcutListener);
    };
  }, [
    toaster,
    forceUpdate,
    targetDocument,
    isCorrectToaster,
    pauseAllToasts,
    getMostRecentVisibleToast,
    isFocusShortcut
  ]);
  const toastsToRender = (() => {
    if (!toaster) {
      return /* @__PURE__ */ new Map();
    }
    const toRender = /* @__PURE__ */ new Map();
    const toasts = Array.from(toaster.toasts.values());
    toasts.forEach((toast) => {
      const { position } = toast;
      toRender.has(position) || toRender.set(position, []);
      if (position.startsWith("bottom")) {
        toRender.get(position).push(toast);
      } else {
        toRender.get(position).unshift(toast);
      }
    });
    return toRender;
  })();
  return {
    isToastVisible: toaster.isToastVisible,
    toastsToRender,
    pauseAllToasts,
    playAllToasts,
    tryRestoreFocus,
    closeAllToasts
  };
}

// node_modules/@fluentui/react-toast/lib/state/useToastController.js
var React387 = __toESM(require_react());
var noop7 = () => void 0;
function useToastController(toasterId) {
  const { targetDocument } = useFluent();
  return React387.useMemo(() => {
    if (!targetDocument) {
      return {
        dispatchToast: noop7,
        dismissToast: noop7,
        dismissAllToasts: noop7,
        updateToast: noop7,
        pauseToast: noop7,
        playToast: noop7
      };
    }
    return {
      dispatchToast: (content, options) => {
        dispatchToast(content, {
          ...options,
          toasterId,
          data: {
            root: options === null || options === void 0 ? void 0 : options.root
          }
        }, targetDocument);
      },
      dismissToast: (toastId) => {
        dismissToast(toastId, toasterId, targetDocument);
      },
      dismissAllToasts: () => {
        dismissAllToasts(toasterId, targetDocument);
      },
      updateToast: (options) => {
        updateToast({
          ...options,
          data: {
            root: options.root
          },
          toasterId
        }, targetDocument);
      },
      pauseToast: (toastId) => {
        pauseToast(toastId, toasterId, targetDocument);
      },
      playToast: (toastId) => {
        playToast(toastId, toasterId, targetDocument);
      }
    };
  }, [
    targetDocument,
    toasterId
  ]);
}

// node_modules/@fluentui/react-toast/lib/components/ToastTrigger/ToastTrigger.js
var React390 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/ToastTrigger/useToastTrigger.js
var React389 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/contexts/toastContainerContext.js
var React388 = __toESM(require_react());
var toastContainerContextDefaultValue = {
  close: () => null,
  intent: void 0,
  bodyId: "",
  titleId: ""
};
var ToastContainerContext = React388.createContext(void 0);
var ToastContainerContextProvider = ToastContainerContext.Provider;
var useToastContainerContext = () => {
  var _React_useContext;
  return (_React_useContext = React388.useContext(ToastContainerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : toastContainerContextDefaultValue;
};

// node_modules/@fluentui/react-toast/lib/components/ToastTrigger/useToastTrigger.js
var useToastTrigger_unstable = (props) => {
  const { children: children2, disableButtonEnhancement = false } = props;
  const { close } = useToastContainerContext();
  const child = getTriggerChild(children2);
  const handleClick = useEventCallback((e) => {
    var _child_props_onClick, _child_props;
    child === null || child === void 0 ? void 0 : (_child_props_onClick = (_child_props = child.props).onClick) === null || _child_props_onClick === void 0 ? void 0 : _child_props_onClick.call(_child_props, e);
    if (!e.isDefaultPrevented()) {
      close();
    }
  });
  const triggerChildProps = {
    ...child === null || child === void 0 ? void 0 : child.props,
    ref: getReactElementRef(child),
    onClick: handleClick
  };
  const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", {
    ...triggerChildProps,
    type: "button"
  });
  return {
    children: applyTriggerPropsToChildren(children2, disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)
  };
};

// node_modules/@fluentui/react-toast/lib/components/ToastTrigger/renderToastTrigger.js
var renderToastTrigger_unstable = (state) => state.children;

// node_modules/@fluentui/react-toast/lib/components/ToastTrigger/ToastTrigger.js
var ToastTrigger = (props) => {
  const state = useToastTrigger_unstable(props);
  return renderToastTrigger_unstable(state);
};
ToastTrigger.displayName = "ToastTrigger";

// node_modules/@fluentui/react-toast/lib/components/Toaster/Toaster.js
var React400 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/Toaster/useToaster.js
var React397 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/ToastContainer.js
var React394 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/useToastContainer.js
var React392 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/Timer/Timer.js
var React391 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/Timer/useTimerStyles.styles.js
var useBaseAnimationStyles = __resetStyles("r16zaflb", "r75casi", [".r16zaflb{animation-name:rsacmq1;}", "@keyframes rsacmq1{from{opacity:0;}to{opacity:0;}}", ".r75casi{animation-name:rsacmq1;}"]);

// node_modules/@fluentui/react-toast/lib/components/Timer/Timer.js
var Timer = React391.forwardRef((props, ref) => {
  const baseAnimationStyles = useBaseAnimationStyles();
  const { running, timeout: timeout2, onTimeout } = props;
  const style = {
    animationDuration: `${timeout2}ms`,
    animationPlayState: running ? "running" : "paused"
  };
  if (timeout2 < 0) {
    return null;
  }
  return React391.createElement("span", {
    onAnimationEnd: onTimeout,
    "data-timer-status": style.animationPlayState,
    ref,
    style,
    className: baseAnimationStyles
  });
});
Timer.displayName = "Timer";

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/useToastContainer.js
var intentPolitenessMap = {
  success: "assertive",
  warning: "assertive",
  error: "assertive",
  info: "polite"
};
var useToastContainer_unstable = (props, ref) => {
  const { visible, children: children2, close: closeProp, remove, updateId, announce, data, timeout: timerTimeout, politeness: desiredPoliteness, intent = "info", pauseOnHover, pauseOnWindowBlur, imperativeRef, tryRestoreFocus, content: _content, ...rest } = props;
  const titleId = useId2("toast-title");
  const bodyId = useId2("toast-body");
  const toastRef = React392.useRef(null);
  const { targetDocument } = useFluent();
  const [running, setRunning] = React392.useState(false);
  const imperativePauseRef = React392.useRef(false);
  const focusedToastBeforeClose = React392.useRef(false);
  const focusableGroupAttribute = useFocusableGroup({
    tabBehavior: "limited-trap-focus",
    // Users should only use Tab to focus into the toast
    // Escape is already reserved to dismiss all toasts
    ignoreDefaultKeydown: {
      Tab: true,
      Escape: true,
      Enter: true
    }
  });
  const close = useEventCallback(() => {
    var _toastRef_current;
    const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
    if (activeElement && ((_toastRef_current = toastRef.current) === null || _toastRef_current === void 0 ? void 0 : _toastRef_current.contains(activeElement))) {
      focusedToastBeforeClose.current = true;
    }
    closeProp();
  });
  const onStatusChange = useEventCallback((status) => {
    var _props_onStatusChange;
    return (_props_onStatusChange = props.onStatusChange) === null || _props_onStatusChange === void 0 ? void 0 : _props_onStatusChange.call(props, null, {
      status,
      ...props
    });
  });
  const pause = useEventCallback(() => setRunning(false));
  const play = useEventCallback(() => {
    var _toastRef_current;
    if (imperativePauseRef.current) {
      return;
    }
    var _targetDocument_activeElement;
    const containsActive = !!((_toastRef_current = toastRef.current) === null || _toastRef_current === void 0 ? void 0 : _toastRef_current.contains((_targetDocument_activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) !== null && _targetDocument_activeElement !== void 0 ? _targetDocument_activeElement : null));
    if (timerTimeout < 0) {
      setRunning(true);
      return;
    }
    if (!containsActive) {
      setRunning(true);
    }
  });
  React392.useImperativeHandle(imperativeRef, () => ({
    focus: () => {
      if (!toastRef.current) {
        return;
      }
      toastRef.current.focus();
    },
    play: () => {
      imperativePauseRef.current = false;
      play();
    },
    pause: () => {
      imperativePauseRef.current = true;
      pause();
    }
  }));
  React392.useEffect(() => {
    return () => onStatusChange("unmounted");
  }, [
    onStatusChange
  ]);
  React392.useEffect(() => {
    if (!targetDocument) {
      return;
    }
    if (pauseOnWindowBlur) {
      var _targetDocument_defaultView, _targetDocument_defaultView1;
      (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.addEventListener("focus", play);
      (_targetDocument_defaultView1 = targetDocument.defaultView) === null || _targetDocument_defaultView1 === void 0 ? void 0 : _targetDocument_defaultView1.addEventListener("blur", pause);
      return () => {
        var _targetDocument_defaultView2, _targetDocument_defaultView12;
        (_targetDocument_defaultView2 = targetDocument.defaultView) === null || _targetDocument_defaultView2 === void 0 ? void 0 : _targetDocument_defaultView2.removeEventListener("focus", play);
        (_targetDocument_defaultView12 = targetDocument.defaultView) === null || _targetDocument_defaultView12 === void 0 ? void 0 : _targetDocument_defaultView12.removeEventListener("blur", pause);
      };
    }
  }, [
    targetDocument,
    pause,
    play,
    pauseOnWindowBlur
  ]);
  const userRootSlot = data.root;
  const onMotionFinish = React392.useCallback((_, { direction }) => {
    if (direction === "exit") {
      remove();
    }
    if (direction === "enter") {
      play();
      onStatusChange("visible");
    }
  }, [
    onStatusChange,
    play,
    remove
  ]);
  const onMouseEnter = useEventCallback((e) => {
    var _userRootSlot_onMouseEnter;
    pause();
    userRootSlot === null || userRootSlot === void 0 ? void 0 : (_userRootSlot_onMouseEnter = userRootSlot.onMouseEnter) === null || _userRootSlot_onMouseEnter === void 0 ? void 0 : _userRootSlot_onMouseEnter.call(userRootSlot, e);
  });
  const onMouseLeave = useEventCallback((e) => {
    var _userRootSlot_onMouseEnter;
    play();
    userRootSlot === null || userRootSlot === void 0 ? void 0 : (_userRootSlot_onMouseEnter = userRootSlot.onMouseEnter) === null || _userRootSlot_onMouseEnter === void 0 ? void 0 : _userRootSlot_onMouseEnter.call(userRootSlot, e);
  });
  const { findFirstFocusable, findLastFocusable } = useFocusFinders();
  const onKeyDown = useEventCallback((e) => {
    var _userRootSlot_onKeyDown;
    if (e.key === Delete) {
      e.preventDefault();
      close();
    }
    if (e.key === Tab && e.currentTarget === e.target) {
      e.preventDefault();
      if (e.shiftKey) {
        var _findLastFocusable;
        (_findLastFocusable = findLastFocusable(e.currentTarget)) === null || _findLastFocusable === void 0 ? void 0 : _findLastFocusable.focus();
      } else {
        var _findFirstFocusable;
        (_findFirstFocusable = findFirstFocusable(e.currentTarget)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
      }
    }
    userRootSlot === null || userRootSlot === void 0 ? void 0 : (_userRootSlot_onKeyDown = userRootSlot.onKeyDown) === null || _userRootSlot_onKeyDown === void 0 ? void 0 : _userRootSlot_onKeyDown.call(userRootSlot, e);
  });
  React392.useEffect(() => {
    var _toastRef_current;
    if (!visible) {
      return;
    }
    const politeness = desiredPoliteness !== null && desiredPoliteness !== void 0 ? desiredPoliteness : intentPolitenessMap[intent];
    var _toastRef_current_textContent;
    announce((_toastRef_current_textContent = (_toastRef_current = toastRef.current) === null || _toastRef_current === void 0 ? void 0 : _toastRef_current.textContent) !== null && _toastRef_current_textContent !== void 0 ? _toastRef_current_textContent : "", {
      politeness
    });
  }, [
    announce,
    desiredPoliteness,
    toastRef,
    visible,
    updateId,
    intent
  ]);
  React392.useEffect(() => {
    return () => {
      if (focusedToastBeforeClose.current) {
        focusedToastBeforeClose.current = false;
        tryRestoreFocus();
      }
    };
  }, [
    tryRestoreFocus
  ]);
  return {
    components: {
      timer: Timer,
      root: "div"
    },
    timer: slot_exports.always({
      onTimeout: close,
      running,
      timeout: timerTimeout !== null && timerTimeout !== void 0 ? timerTimeout : -1
    }, {
      elementType: Timer
    }),
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, toastRef),
      children: children2,
      tabIndex: 0,
      role: "listitem",
      "aria-labelledby": titleId,
      "aria-describedby": bodyId,
      ...rest,
      ...userRootSlot,
      ...focusableGroupAttribute,
      onMouseEnter,
      onMouseLeave,
      onKeyDown
    }), {
      elementType: "div"
    }),
    timerTimeout,
    transitionTimeout: 0,
    running,
    visible,
    remove,
    close,
    onTransitionEntering: () => {
    },
    updateId,
    nodeRef: toastRef,
    intent,
    titleId,
    bodyId,
    onMotionFinish
  };
};

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/renderToastContainer.js
var renderToastContainer_unstable = (state, contextValues) => {
  const { onMotionFinish, visible, updateId } = state;
  assertSlots(state);
  return jsx(ToastContainerContextProvider, {
    value: contextValues.toast,
    children: jsx(CollapseDelayed, {
      appear: true,
      onMotionFinish,
      visible,
      unmountOnExit: true,
      children: jsxs(state.root, {
        children: [
          state.root.children,
          jsx(state.timer, {}, updateId)
        ]
      })
    })
  });
};

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/useToastContainerStyles.styles.js
var toastContainerClassNames = {
  root: "fui-ToastContainer",
  timer: "fui-ToastContainer__timer"
};
var useRootBaseClassName6 = __resetStyles("r98b696", null, [".r98b696{box-sizing:border-box;margin-top:16px;pointer-events:all;border-radius:var(--borderRadiusMedium);}", ".r98b696[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}"]);
var useToastContainerStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName6();
  state.root.className = mergeClasses(toastContainerClassNames.root, rootBaseClassName, state.root.className);
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/useToastContainerContextValues.js
var React393 = __toESM(require_react());
function useToastContainerContextValues_unstable(state) {
  const { close, intent, titleId, bodyId } = state;
  const toastContainerContext = React393.useMemo(() => ({
    close,
    intent,
    titleId,
    bodyId
  }), [
    close,
    intent,
    titleId,
    bodyId
  ]);
  return {
    toast: toastContainerContext
  };
}

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/ToastContainer.js
var ToastContainer = React394.forwardRef((props, ref) => {
  const state = useToastContainer_unstable(props, ref);
  useToastContainerStyles_unstable(state);
  useCustomStyleHook("useToastContainerStyles_unstable")(state);
  return renderToastContainer_unstable(state, useToastContainerContextValues_unstable(state));
});
ToastContainer.displayName = "ToastContainer";

// node_modules/@fluentui/react-toast/lib/components/Toaster/useToasterFocusManagement.js
var React395 = __toESM(require_react());
var noop8 = () => void 0;
function useToasterFocusManagement_unstable(pauseAllToasts, playAllToasts) {
  const { targetDocument } = useFluent();
  const cleanupListenersRef = React395.useRef(noop8);
  return React395.useCallback((el) => {
    if (!el || !targetDocument) {
      cleanupListenersRef.current();
      cleanupListenersRef.current = noop8;
      return;
    }
    const toastContainerWalker = targetDocument.createTreeWalker(el, NodeFilter.SHOW_ELEMENT, {
      acceptNode(node) {
        if (isHTMLElement(node) && node.classList.contains(toastContainerClassNames.root)) {
          return NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_SKIP;
      }
    });
    const keydownListener = (e) => {
      const { target, key } = e;
      if (!isHTMLElement(target)) {
        return;
      }
      if (key === ArrowDown) {
        toastContainerWalker.currentNode = target;
        let nextToastContainer = toastContainerWalker.nextNode();
        if (!nextToastContainer) {
          toastContainerWalker.currentNode = el;
          nextToastContainer = toastContainerWalker.nextNode();
        }
        if (isHTMLElement(nextToastContainer)) {
          nextToastContainer.focus();
        }
      }
      if (key === ArrowUp) {
        toastContainerWalker.currentNode = target;
        let prevToastContainer = toastContainerWalker.previousNode();
        if (prevToastContainer && prevToastContainer.contains(target)) {
          prevToastContainer = toastContainerWalker.previousNode();
        }
        if (!prevToastContainer) {
          toastContainerWalker.currentNode = el;
          prevToastContainer = toastContainerWalker.lastChild();
        }
        if (isHTMLElement(prevToastContainer)) {
          prevToastContainer.focus();
        }
      }
    };
    const focusInListener = (e) => {
      if (isHTMLElement(e.currentTarget) && !e.currentTarget.contains(isHTMLElement(e.relatedTarget) ? e.relatedTarget : null)) {
        pauseAllToasts();
      }
    };
    const focusOutListener = (e) => {
      if (isHTMLElement(e.currentTarget) && !e.currentTarget.contains(isHTMLElement(e.relatedTarget) ? e.relatedTarget : null)) {
        playAllToasts();
      }
    };
    el.addEventListener("keydown", keydownListener);
    el.addEventListener("focusin", focusInListener);
    el.addEventListener("focusout", focusOutListener);
    cleanupListenersRef.current = () => {
      el.removeEventListener("keydown", keydownListener);
      el.removeEventListener("focusin", focusInListener);
      el.removeEventListener("focusout", focusOutListener);
    };
  }, [
    targetDocument,
    pauseAllToasts,
    playAllToasts
  ]);
}

// node_modules/@fluentui/react-toast/lib/components/Toaster/useToastAnnounce.js
var React396 = __toESM(require_react());
function useToastAnnounce(announce) {
  const activeRef = React396.useRef(true);
  const cleanupRef = React396.useRef(() => void 0);
  const announceToast = React396.useCallback((message, options) => {
    if (activeRef.current) {
      announce(message, options);
    }
  }, [
    announce
  ]);
  const toasterRef = React396.useCallback((el) => {
    if (!el) {
      cleanupRef.current();
      return;
    }
    const onFocusIn = (e) => {
      if (isHTMLElement(e.currentTarget) && e.currentTarget.contains(isHTMLElement(e.relatedTarget) ? e.relatedTarget : null)) {
        return;
      }
      activeRef.current = false;
    };
    const onFocusOut = (e) => {
      if (isHTMLElement(e.currentTarget) && e.currentTarget.contains(isHTMLElement(e.relatedTarget) ? e.relatedTarget : null)) {
        return;
      }
      activeRef.current = true;
    };
    el.addEventListener("focusin", onFocusIn);
    el.addEventListener("focusout", onFocusOut);
    cleanupRef.current = () => {
      el.removeEventListener("focusin", onFocusIn);
      el.removeEventListener("focusout", onFocusOut);
    };
  }, []);
  return {
    announceToast,
    toasterRef
  };
}

// node_modules/@fluentui/react-toast/lib/components/Toaster/useToaster.js
var useToaster_unstable = (props) => {
  "use no memo";
  const { offset: offset4, announce: announceProp, mountNode, inline: inline2 = false, ...rest } = props;
  const announceRef = React397.useRef(() => null);
  const { toastsToRender, isToastVisible, pauseAllToasts, playAllToasts, tryRestoreFocus, closeAllToasts } = useToaster(rest);
  const announce = React397.useCallback((message, options) => announceRef.current(message, options), []);
  const { dir } = useFluent();
  const { onKeyDown: onKeyDownProp, ...rootProps } = slot_exports.always(getIntrinsicElementProps("div", rest), {
    elementType: "div"
  });
  const focusableGroupAttr = useFocusableGroup({
    tabBehavior: "limited-trap-focus",
    ignoreDefaultKeydown: {
      Escape: true
    }
  });
  const onKeyDown = useEventCallback((e) => {
    if (e.key === Escape) {
      e.preventDefault();
      closeAllToasts();
    }
    onKeyDownProp === null || onKeyDownProp === void 0 ? void 0 : onKeyDownProp(e);
  });
  const usePositionSlot = (toastPosition) => {
    var _toastsToRender_get;
    const focusManagementRef = useToasterFocusManagement_unstable(pauseAllToasts, playAllToasts);
    const { announceToast, toasterRef } = useToastAnnounce(announceProp !== null && announceProp !== void 0 ? announceProp : announce);
    return slot_exports.optional(toastsToRender.has(toastPosition) ? rootProps : null, {
      defaultProps: {
        ref: useMergedRefs(focusManagementRef, toasterRef),
        children: (_toastsToRender_get = toastsToRender.get(toastPosition)) === null || _toastsToRender_get === void 0 ? void 0 : _toastsToRender_get.map((toast) => React397.createElement(ToastContainer, {
          ...toast,
          tryRestoreFocus,
          intent: toast.intent,
          announce: announceToast,
          key: toast.toastId,
          visible: isToastVisible(toast.toastId)
        }, toast.content)),
        onKeyDown,
        ...focusableGroupAttr,
        "data-toaster-position": toastPosition,
        role: "list"
      },
      elementType: "div"
    });
  };
  return {
    dir,
    mountNode,
    components: {
      root: "div",
      bottomStart: "div",
      bottomEnd: "div",
      topStart: "div",
      topEnd: "div",
      top: "div",
      bottom: "div"
    },
    root: slot_exports.always(rootProps, {
      elementType: "div"
    }),
    bottomStart: usePositionSlot(TOAST_POSITIONS.bottomStart),
    bottomEnd: usePositionSlot(TOAST_POSITIONS.bottomEnd),
    topStart: usePositionSlot(TOAST_POSITIONS.topStart),
    topEnd: usePositionSlot(TOAST_POSITIONS.topEnd),
    top: usePositionSlot(TOAST_POSITIONS.top),
    bottom: usePositionSlot(TOAST_POSITIONS.bottom),
    announceRef,
    offset: offset4,
    announce: announceProp !== null && announceProp !== void 0 ? announceProp : announce,
    renderAriaLive: !announceProp,
    inline: inline2
  };
};

// node_modules/@fluentui/react-toast/lib/components/AriaLive/AriaLive.js
var React399 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/AriaLive/useAriaLive.js
var React398 = __toESM(require_react());
var MESSAGE_DURATION2 = 500;
var useAriaLive_unstable = (props) => {
  const [currentMessage, setCurrentMessage] = React398.useState(void 0);
  const order = React398.useRef(0);
  const [messageQueue] = React398.useState(() => createPriorityQueue((a, b) => {
    if (a.politeness === b.politeness) {
      return a.createdAt - b.createdAt;
    }
    return a.politeness === "assertive" ? -1 : 1;
  }));
  const announce = useEventCallback((message, options) => {
    const { politeness } = options;
    if (message === (currentMessage === null || currentMessage === void 0 ? void 0 : currentMessage.message)) {
      return;
    }
    const liveMessage = {
      message,
      politeness,
      createdAt: order.current++
    };
    if (!currentMessage) {
      setCurrentMessage(liveMessage);
    } else {
      messageQueue.enqueue(liveMessage);
    }
  });
  const [setMessageTimeout, clearMessageTimeout] = useTimeout();
  React398.useEffect(() => {
    setMessageTimeout(() => {
      if (messageQueue.peek()) {
        setCurrentMessage(messageQueue.dequeue());
      } else {
        setCurrentMessage(void 0);
      }
    }, MESSAGE_DURATION2);
    return () => clearMessageTimeout();
  }, [
    currentMessage,
    messageQueue,
    setMessageTimeout,
    clearMessageTimeout
  ]);
  React398.useImperativeHandle(props.announceRef, () => announce);
  const politeMessage = (currentMessage === null || currentMessage === void 0 ? void 0 : currentMessage.politeness) === "polite" ? currentMessage.message : void 0;
  const assertiveMessage = (currentMessage === null || currentMessage === void 0 ? void 0 : currentMessage.politeness) === "assertive" ? currentMessage.message : void 0;
  return {
    components: {
      assertive: "div",
      polite: "div"
    },
    assertive: slot_exports.always(props.assertive, {
      defaultProps: {
        "aria-live": "assertive",
        children: assertiveMessage
      },
      elementType: "div"
    }),
    polite: slot_exports.always(props.polite, {
      defaultProps: {
        "aria-live": "polite",
        children: politeMessage
      },
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-toast/lib/components/AriaLive/renderAriaLive.js
var renderAriaLive_unstable = (state) => {
  assertSlots(state);
  return jsxs(import_react.Fragment, {
    children: [
      jsx(state.assertive, {}),
      jsx(state.polite, {})
    ]
  });
};

// node_modules/@fluentui/react-toast/lib/components/AriaLive/useAriaLiveStyles.styles.js
var ariaLiveClassNames = {
  assertive: "fui-AriaLive__assertive",
  polite: "fui-AriaLive__polite"
};
var useResetStyles3 = __resetStyles("rrd10u0", null, [".rrd10u0{clip:rect(0px, 0px, 0px, 0px);height:1px;margin:-1px;overflow:hidden;padding:0px;width:1px;position:absolute;}"]);
var useAriaLiveStyles_unstable = (state) => {
  "use no memo";
  const visuallyHidden = useResetStyles3();
  state.assertive.className = mergeClasses(visuallyHidden, ariaLiveClassNames.assertive, state.assertive.className);
  state.polite.className = mergeClasses(visuallyHidden, ariaLiveClassNames.polite, state.polite.className);
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/AriaLive/AriaLive.js
var AriaLive = (props) => {
  const state = useAriaLive_unstable(props);
  useAriaLiveStyles_unstable(state);
  return renderAriaLive_unstable(state);
};
AriaLive.displayName = "AriaLive";

// node_modules/@fluentui/react-toast/lib/components/Toaster/renderToaster.js
var renderToaster_unstable = (state) => {
  const { announceRef, renderAriaLive, inline: inline2, mountNode } = state;
  assertSlots(state);
  const hasToasts = !!state.bottomStart || !!state.bottomEnd || !!state.topStart || !!state.topEnd || !!state.top || !!state.bottom;
  const ariaLive = renderAriaLive ? jsx(AriaLive, {
    announceRef
  }) : null;
  const positionSlots = jsxs(import_react.Fragment, {
    children: [
      state.bottom ? jsx(state.bottom, {}) : null,
      state.bottomStart ? jsx(state.bottomStart, {}) : null,
      state.bottomEnd ? jsx(state.bottomEnd, {}) : null,
      state.topStart ? jsx(state.topStart, {}) : null,
      state.topEnd ? jsx(state.topEnd, {}) : null,
      state.top ? jsx(state.top, {}) : null
    ]
  });
  if (inline2) {
    return jsxs(import_react.Fragment, {
      children: [
        ariaLive,
        hasToasts ? positionSlots : null
      ]
    });
  }
  return jsxs(import_react.Fragment, {
    children: [
      ariaLive,
      hasToasts ? jsx(Portal, {
        mountNode,
        children: positionSlots
      }) : null
    ]
  });
};

// node_modules/@fluentui/react-toast/lib/components/Toaster/useToasterStyles.styles.js
var toasterClassNames = {
  root: "fui-Toaster"
};
var useRootBaseClassName7 = __resetStyles("r3hfdjz", null, [".r3hfdjz{position:fixed;width:292px;pointer-events:none;}"]);
var useToasterStyles = __styles2({
  inline: {
    qhf8xq: "f1euv43f"
  }
}, {
  d: [".f1euv43f{position:absolute;}"]
});
var useToasterStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName7();
  const styles = useToasterStyles();
  const className = mergeClasses(toasterClassNames.root, rootBaseClassName, state.inline && styles.inline, state.root.className);
  if (state.bottomStart) {
    var _state_bottomStart;
    state.bottomStart.className = className;
    var _style;
    (_style = (_state_bottomStart = state.bottomStart).style) !== null && _style !== void 0 ? _style : _state_bottomStart.style = {};
    Object.assign(state.bottomStart.style, getPositionStyles(TOAST_POSITIONS.bottomStart, state.dir, state.offset));
  }
  if (state.bottomEnd) {
    var _state_bottomEnd;
    state.bottomEnd.className = className;
    var _style1;
    (_style1 = (_state_bottomEnd = state.bottomEnd).style) !== null && _style1 !== void 0 ? _style1 : _state_bottomEnd.style = {};
    Object.assign(state.bottomEnd.style, getPositionStyles(TOAST_POSITIONS.bottomEnd, state.dir, state.offset));
  }
  if (state.topStart) {
    var _state_topStart;
    state.topStart.className = className;
    var _style2;
    (_style2 = (_state_topStart = state.topStart).style) !== null && _style2 !== void 0 ? _style2 : _state_topStart.style = {};
    Object.assign(state.topStart.style, getPositionStyles(TOAST_POSITIONS.topStart, state.dir, state.offset));
  }
  if (state.topEnd) {
    var _state_topEnd;
    state.topEnd.className = className;
    var _style3;
    (_style3 = (_state_topEnd = state.topEnd).style) !== null && _style3 !== void 0 ? _style3 : _state_topEnd.style = {};
    Object.assign(state.topEnd.style, getPositionStyles(TOAST_POSITIONS.topEnd, state.dir, state.offset));
  }
  if (state.top) {
    var _state_top;
    state.top.className = className;
    var _style4;
    (_style4 = (_state_top = state.top).style) !== null && _style4 !== void 0 ? _style4 : _state_top.style = {};
    Object.assign(state.top.style, getPositionStyles(TOAST_POSITIONS.top, state.dir, state.offset));
  }
  if (state.bottom) {
    var _state_bottom;
    state.bottom.className = className;
    var _style5;
    (_style5 = (_state_bottom = state.bottom).style) !== null && _style5 !== void 0 ? _style5 : _state_bottom.style = {};
    Object.assign(state.bottom.style, getPositionStyles(TOAST_POSITIONS.bottom, state.dir, state.offset));
  }
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/Toaster/Toaster.js
var Toaster = (props) => {
  const state = useToaster_unstable(props);
  useToasterStyles_unstable(state);
  useCustomStyleHook("useToasterStyles_unstable")(state);
  return renderToaster_unstable(state);
};
Toaster.displayName = "Toaster";

// node_modules/@fluentui/react-toast/lib/components/Toast/Toast.js
var React402 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/Toast/useToast.js
var React401 = __toESM(require_react());
var useToast_unstable = (props, ref) => {
  const { intent } = useToastContainerContext();
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    backgroundAppearance: props.appearance,
    intent
  };
};

// node_modules/@fluentui/react-toast/lib/components/Toast/renderToast.js
var renderToast_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(BackgroundAppearanceProvider, {
    value: contextValues.backgroundAppearance,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-toast/lib/components/Toast/useToastStyles.styles.js
var toastClassNames = {
  root: "fui-Toast"
};
var useRootBaseClassName8 = __resetStyles("rhf7k35", null, [".rhf7k35{display:grid;grid-template-columns:auto 1fr auto;padding:12px;border-radius:var(--borderRadiusMedium);border:1px solid var(--colorTransparentStroke);box-shadow:var(--shadow8);font-size:var(--fontSizeBase300);line-height:20px;font-weight:var(--fontWeightSemibold);color:var(--colorNeutralForeground1);background-color:var(--colorNeutralBackground1);}"]);
var useStyles51 = __styles2({
  inverted: {
    sj55zd: "f1w7i9ko",
    De3pzq: "f5pduvr"
  }
}, {
  d: [".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}", ".f5pduvr{background-color:var(--colorNeutralBackgroundInverted);}"]
});
var useToastStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName8();
  const styles = useStyles51();
  state.root.className = mergeClasses(toastClassNames.root, rootBaseClassName, state.backgroundAppearance === "inverted" && styles.inverted, state.root.className);
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/Toast/useToastContextValues.js
function useToastContextValues_unstable(state) {
  const { backgroundAppearance } = state;
  return {
    backgroundAppearance
  };
}

// node_modules/@fluentui/react-toast/lib/components/Toast/Toast.js
var Toast = React402.forwardRef((props, ref) => {
  const state = useToast_unstable(props, ref);
  useToastStyles_unstable(state);
  useCustomStyleHook("useToastStyles_unstable")(state);
  return renderToast_unstable(state, useToastContextValues_unstable(state));
});
Toast.displayName = "Toast";

// node_modules/@fluentui/react-toast/lib/components/ToastTitle/ToastTitle.js
var React404 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/ToastTitle/useToastTitle.js
var React403 = __toESM(require_react());
var useToastTitle_unstable = (props, ref) => {
  const { intent, titleId } = useToastContainerContext();
  const backgroundAppearance = useBackgroundAppearance();
  let defaultIcon;
  switch (intent) {
    case "success":
      defaultIcon = React403.createElement(CheckmarkCircleFilled, null);
      break;
    case "error":
      defaultIcon = React403.createElement(DismissCircleFilled, null);
      break;
    case "warning":
      defaultIcon = React403.createElement(WarningFilled, null);
      break;
    case "info":
      defaultIcon = React403.createElement(InfoFilled, null);
      break;
  }
  return {
    action: slot_exports.optional(props.action, {
      elementType: "div"
    }),
    components: {
      root: "div",
      media: "div",
      action: "div"
    },
    media: slot_exports.optional(props.media, {
      renderByDefault: !!intent,
      defaultProps: {
        children: defaultIcon
      },
      elementType: "div"
    }),
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      children: props.children,
      id: titleId,
      ...props
    }), {
      elementType: "div"
    }),
    intent,
    backgroundAppearance
  };
};

// node_modules/@fluentui/react-toast/lib/components/ToastTitle/renderToastTitle.js
var renderToastTitle_unstable = (state) => {
  assertSlots(state);
  return jsxs(import_react.Fragment, {
    children: [
      state.media ? jsx(state.media, {}) : null,
      jsx(state.root, {}),
      state.action ? jsx(state.action, {}) : null
    ]
  });
};

// node_modules/@fluentui/react-toast/lib/components/ToastTitle/useToastTitleStyles.styles.js
var toastTitleClassNames = {
  root: "fui-ToastTitle",
  media: "fui-ToastTitle__media",
  action: "fui-ToastTitle__action"
};
var useRootBaseClassName9 = __resetStyles("rdjap1e", null, [".rdjap1e{display:flex;grid-column-end:3;color:var(--colorNeutralForeground1);word-break:break-word;}"]);
var useMediaBaseClassName = __resetStyles("r8x5mrd", "r1soj19y", [".r8x5mrd{display:flex;padding-top:2px;grid-column-end:2;padding-right:8px;font-size:16px;color:var(--colorNeutralForeground1);}", ".r1soj19y{display:flex;padding-top:2px;grid-column-end:2;padding-left:8px;font-size:16px;color:var(--colorNeutralForeground1);}"]);
var useActionBaseClassName = __resetStyles("r2j19ip", "rjfozdo", [".r2j19ip{display:flex;align-items:start;padding-left:12px;grid-column-end:-1;color:var(--colorBrandForeground1);}", ".rjfozdo{display:flex;align-items:start;padding-right:12px;grid-column-end:-1;color:var(--colorBrandForeground1);}"]);
var useInvertedStyles = __styles2({
  root: {
    sj55zd: "f1w7i9ko"
  },
  action: {
    sj55zd: "f1qz2gb0"
  },
  media: {
    sj55zd: "fqpbvvt"
  }
}, {
  d: [".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}", ".f1qz2gb0{color:var(--colorBrandForegroundInverted);}", ".fqpbvvt{color:var(--colorNeutralForegroundInverted);}"]
});
var useIntentIconStyles = __styles2({
  success: {
    sj55zd: "f36rra6"
  },
  error: {
    sj55zd: "f1ca9wz"
  },
  warning: {
    sj55zd: "f13isgzr"
  },
  info: {
    sj55zd: "fkfq4zb"
  }
}, {
  d: [".f36rra6{color:var(--colorStatusSuccessForeground1);}", ".f1ca9wz{color:var(--colorStatusDangerForeground1);}", ".f13isgzr{color:var(--colorStatusWarningForeground1);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}"]
});
var useIntentIconStylesInverted = __styles2({
  success: {
    sj55zd: "ff3wk4x"
  },
  error: {
    sj55zd: "fbq2gqr"
  },
  warning: {
    sj55zd: "fx6hq1t"
  },
  info: {
    sj55zd: "f1w7i9ko"
  }
}, {
  d: [".ff3wk4x{color:var(--colorStatusSuccessForegroundInverted);}", ".fbq2gqr{color:var(--colorStatusDangerForegroundInverted);}", ".fx6hq1t{color:var(--colorStatusWarningForegroundInverted);}", ".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}"]
});
var useToastTitleStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName9();
  const actionBaseClassName = useActionBaseClassName();
  const mediaBaseClassName = useMediaBaseClassName();
  const intentIconStyles = useIntentIconStyles();
  const intentIconStylesInverted = useIntentIconStylesInverted();
  const {
    intent
  } = state;
  const invertedStyles = useInvertedStyles();
  state.root.className = mergeClasses(toastTitleClassNames.root, rootBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.root, state.root.className);
  if (state.media) {
    state.media.className = mergeClasses(toastTitleClassNames.media, mediaBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.media, intent && intentIconStyles[intent], intent && state.backgroundAppearance === "inverted" && intentIconStylesInverted[intent], state.media.className);
  }
  if (state.action) {
    state.action.className = mergeClasses(toastTitleClassNames.action, actionBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.action, state.action.className);
  }
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/ToastTitle/ToastTitle.js
var ToastTitle = React404.forwardRef((props, ref) => {
  const state = useToastTitle_unstable(props, ref);
  useToastTitleStyles_unstable(state);
  useCustomStyleHook("useToastTitleStyles_unstable")(state);
  return renderToastTitle_unstable(state);
});
ToastTitle.displayName = "ToastTitle";

// node_modules/@fluentui/react-toast/lib/components/ToastBody/ToastBody.js
var React406 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/ToastBody/useToastBody.js
var React405 = __toESM(require_react());
var useToastBody_unstable = (props, ref) => {
  const backgroundAppearance = useBackgroundAppearance();
  const { bodyId } = useToastContainerContext();
  return {
    components: {
      root: "div",
      subtitle: "div"
    },
    subtitle: slot_exports.optional(props.subtitle, {
      elementType: "div"
    }),
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      id: bodyId,
      ...props
    }), {
      elementType: "div"
    }),
    backgroundAppearance
  };
};

// node_modules/@fluentui/react-toast/lib/components/ToastBody/renderToastBody.js
var renderToastBody_unstable = (state) => {
  assertSlots(state);
  return jsxs(import_react.Fragment, {
    children: [
      jsx(state.root, {}),
      state.subtitle ? jsx(state.subtitle, {}) : null
    ]
  });
};

// node_modules/@fluentui/react-toast/lib/components/ToastBody/useToastBodyStyles.styles.js
var toastBodyClassNames = {
  root: "fui-ToastBody",
  subtitle: "fui-ToastBody__subtitle"
};
var useRootBaseClassName10 = __resetStyles("rciajo9", null, [".rciajo9{grid-column-start:2;grid-column-end:3;padding-top:6px;font-size:var(--fontSizeBase300);line-height:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);color:var(--colorNeutralForeground1);word-break:break-word;}"]);
var useSubtitleBaseClassName = __resetStyles("rzjw1xk", null, [".rzjw1xk{padding-top:4px;grid-column-start:2;grid-column-end:3;font-size:var(--fontSizeBase200);line-height:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);color:var(--colorNeutralForeground2);}"]);
var useInvertedStyles2 = __styles2({
  root: {
    sj55zd: "f1w7i9ko"
  },
  subtitle: {
    sj55zd: "f1w7i9ko"
  }
}, {
  d: [".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}"]
});
var useToastBodyStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName10();
  const subtitleBaseClassName = useSubtitleBaseClassName();
  const invertedStyles = useInvertedStyles2();
  state.root.className = mergeClasses(toastBodyClassNames.root, rootBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.root, state.root.className);
  if (state.subtitle) {
    state.subtitle.className = mergeClasses(toastBodyClassNames.subtitle, subtitleBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.subtitle, state.subtitle.className);
  }
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/ToastBody/ToastBody.js
var ToastBody = React406.forwardRef((props, ref) => {
  const state = useToastBody_unstable(props, ref);
  useToastBodyStyles_unstable(state);
  useCustomStyleHook("useToastBodyStyles_unstable")(state);
  return renderToastBody_unstable(state);
});
ToastBody.displayName = "ToastBody";

// node_modules/@fluentui/react-toast/lib/components/ToastFooter/ToastFooter.js
var React408 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/ToastFooter/useToastFooter.js
var React407 = __toESM(require_react());
var useToastFooter_unstable = (props, ref) => {
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-toast/lib/components/ToastFooter/renderToastFooter.js
var renderToastFooter_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-toast/lib/components/ToastFooter/useToastFooterStyles.styles.js
var toastFooterClassNames = {
  root: "fui-ToastFooter"
};
var useRootBaseClassName11 = __resetStyles("r56x6h2", null, [".r56x6h2{padding-top:16px;grid-column-start:2;grid-column-end:3;display:flex;align-items:center;gap:14px;}"]);
var useToastFooterStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName11();
  state.root.className = mergeClasses(toastFooterClassNames.root, rootBaseClassName, state.root.className);
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/ToastFooter/ToastFooter.js
var ToastFooter = React408.forwardRef((props, ref) => {
  const state = useToastFooter_unstable(props, ref);
  useToastFooterStyles_unstable(state);
  useCustomStyleHook("useToastFooterStyles_unstable")(state);
  return renderToastFooter_unstable(state);
});
ToastFooter.displayName = "ToastFooter";

// node_modules/@fluentui/react-tree/lib/components/Tree/Tree.js
var React424 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/Tree/useTree.js
var React421 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/hooks/useControllableOpenItems.js
var React409 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/utils/ImmutableSet.js
var internalSetSymbol = Symbol("#internalSet");
var _internalSetSymbol = internalSetSymbol;
var ImmutableSet = class _ImmutableSet {
  static dangerouslyGetInternalSet(set) {
    return set[internalSetSymbol];
  }
  static copy(immutableSet) {
    return new _ImmutableSet(new Set(immutableSet[internalSetSymbol]));
  }
  /**
  * Creates a new {@link ImmutableSet} from an iterable.
  * If the iterable is undefined, {@link ImmutableSet.empty} will be returned.
  * If the iterable is already an {@link ImmutableSet}, it will be returned as is no copy will be made.
  */
  static from(iterable) {
    if (iterable === void 0) {
      return this.empty;
    }
    if (iterable instanceof this) {
      return iterable;
    }
    return new this(new Set(iterable));
  }
  static [Symbol.hasInstance](instance) {
    return Boolean(typeof instance === "object" && instance && internalSetSymbol in instance);
  }
  add(value) {
    if (this.has(value)) {
      return this;
    }
    const copy = _ImmutableSet.copy(this);
    copy[internalSetSymbol].add(value);
    return copy;
  }
  delete(value) {
    if (!this.has(value)) {
      return this;
    }
    const copy = _ImmutableSet.copy(this);
    copy[internalSetSymbol].delete(value);
    return copy;
  }
  has(value) {
    return this[internalSetSymbol].has(value);
  }
  [Symbol.iterator]() {
    return this[internalSetSymbol].values();
  }
  /**
  * Do not use this constructor directly, use {@link ImmutableSet.from} instead.
  * {@link ImmutableSet.from} handles instance verification (which might be problematic on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof#instanceof_and_multiple_realms | multiple realms}),
  * avoid unnecessary copies, supports iterables and ensures that the internal set is never exposed.
  *
  *⚠️⚠️  _By using this constructor directly, you might end up with a mutable set, as it is not guaranteed that the internal set is not exposed._ ⚠️⚠️
  */
  constructor(internalSet) {
    _define_property(this, "size", void 0);
    _define_property(this, _internalSetSymbol, void 0);
    this[internalSetSymbol] = internalSet;
    this.size = this[internalSetSymbol].size;
  }
};
_define_property(ImmutableSet, "empty", new ImmutableSet(/* @__PURE__ */ new Set()));

// node_modules/@fluentui/react-tree/lib/hooks/useControllableOpenItems.js
function useControllableOpenItems(props) {
  return useControllableState({
    state: React409.useMemo(() => props.openItems && ImmutableSet.from(props.openItems), [
      props.openItems
    ]),
    defaultState: props.defaultOpenItems && (() => ImmutableSet.from(props.defaultOpenItems)),
    initialState: ImmutableSet.empty
  });
}
function createNextOpenItems(data, previousOpenItems) {
  return data.open ? previousOpenItems.add(data.value) : previousOpenItems.delete(data.value);
}

// node_modules/@fluentui/react-tree/lib/components/Tree/useNestedControllableCheckedItems.js
var React410 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/utils/ImmutableMap.js
var internalMapSymbol = Symbol("#internalMap");
var _internalMapSymbol = internalMapSymbol;
var ImmutableMap = class _ImmutableMap {
  static dangerouslyGetInternalMap(immutableMap) {
    return immutableMap[internalMapSymbol];
  }
  static copy(immutableMap) {
    return this.from(immutableMap[internalMapSymbol]);
  }
  static from(iterable, mapFn) {
    if (iterable === void 0) {
      return this.empty;
    }
    if (!mapFn) {
      if (iterable instanceof this) {
        return iterable;
      }
      const iterableAsTuple = iterable;
      return new this(new Map(iterableAsTuple));
    }
    const map = /* @__PURE__ */ new Map();
    for (const value of iterable) {
      map.set(...mapFn(value));
    }
    return new this(map);
  }
  static [Symbol.hasInstance](instance) {
    return Boolean(typeof instance === "object" && instance && internalMapSymbol in instance);
  }
  delete(key) {
    if (!this.has(key)) {
      return this;
    }
    const copy = _ImmutableMap.copy(this);
    copy[internalMapSymbol].delete(key);
    return copy;
  }
  get(key) {
    return this[internalMapSymbol].get(key);
  }
  has(key) {
    return this[internalMapSymbol].has(key);
  }
  set(key, value) {
    if (this.get(key) === value) {
      return this;
    }
    const copy = _ImmutableMap.copy(this);
    copy[internalMapSymbol].set(key, value);
    return copy;
  }
  [Symbol.iterator]() {
    return this[internalMapSymbol].entries();
  }
  /**
  * Do not use this constructor directly, use {@link ImmutableMap.from} instead.
  * {@link ImmutableMap.from} handles instance verification (which might be problematic on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof#instanceof_and_multiple_realms | multiple realms}),
  * avoid unnecessary copies, supports iterables and ensures that the internal map is never exposed.
  *
  *⚠️⚠️  _By using this constructor directly, you might end up with a mutable map, as it is not guaranteed that the internal map is not exposed._ ⚠️⚠️
  */
  constructor(internalMap) {
    _define_property(this, "size", void 0);
    _define_property(this, _internalMapSymbol, void 0);
    this[internalMapSymbol] = internalMap;
    this.size = this[internalMapSymbol].size;
  }
};
_define_property(ImmutableMap, "empty", new ImmutableMap(/* @__PURE__ */ new Map()));

// node_modules/@fluentui/react-tree/lib/utils/createCheckedItems.js
var tuplifyCheckedItem = (value) => Array.isArray(value) ? value : [
  value,
  true
];
var createCheckedItems = (iterable) => ImmutableMap.from(iterable, tuplifyCheckedItem);

// node_modules/@fluentui/react-tree/lib/components/Tree/useNestedControllableCheckedItems.js
function useNestedCheckedItems(props) {
  return React410.useMemo(() => createCheckedItems(props.checkedItems), [
    props.checkedItems
  ]);
}
function createNextNestedCheckedItems(data, previousCheckedItems) {
  if (data.selectionMode === "single") {
    return ImmutableMap.from([
      [
        data.value,
        data.checked
      ]
    ]);
  }
  if (data.selectionMode === "multiselect") {
    return previousCheckedItems.set(data.value, data.checked);
  }
  return previousCheckedItems;
}

// node_modules/@fluentui/react-tree/lib/contexts/subtreeContext.js
var React411 = __toESM(require_react());
var defaultSubTreeContextValue = {
  level: 0,
  contextType: "subtree"
};
var SubtreeContext = React411.createContext(void 0);
var useSubtreeContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React411.useContext(SubtreeContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultSubTreeContextValue;
};

// node_modules/@fluentui/react-tree/lib/hooks/useRootTree.js
var React412 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/utils/tokens.js
var treeItemLevelToken = "--fluent-TreeItem--level";
var treeAvatarSize = {
  medium: 32,
  small: 24
};
var treeDataTypes = {
  ArrowLeft,
  ArrowRight,
  Enter,
  Click: "Click",
  ExpandIconClick: "ExpandIconClick",
  End,
  Home,
  ArrowUp,
  ArrowDown,
  TypeAhead: "TypeAhead",
  Change: "Change"
};

// node_modules/@fluentui/react-tree/lib/hooks/useRootTree.js
function useRootTree(props, ref) {
  warnIfNoProperPropsRootTree(props);
  const { appearance = "subtle", size: size3 = "medium", selectionMode = "none" } = props;
  const openItems = React412.useMemo(() => ImmutableSet.from(props.openItems), [
    props.openItems
  ]);
  const checkedItems = React412.useMemo(() => createCheckedItems(props.checkedItems), [
    props.checkedItems
  ]);
  const requestOpenChange = (request) => {
    var _props_onOpenChange;
    (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, request.event, {
      ...request,
      openItems: ImmutableSet.dangerouslyGetInternalSet(createNextOpenItems(request, openItems))
    });
  };
  const requestCheckedChange = (request) => {
    var _props_onCheckedChange;
    if (selectionMode === "none") {
      return;
    }
    (_props_onCheckedChange = props.onCheckedChange) === null || _props_onCheckedChange === void 0 ? void 0 : _props_onCheckedChange.call(props, request.event, {
      ...request,
      selectionMode,
      checkedItems: ImmutableMap.dangerouslyGetInternalMap(checkedItems)
    });
  };
  const requestNavigation = (request) => {
    var _props_onNavigation;
    let isScrollPrevented = false;
    (_props_onNavigation = props.onNavigation) === null || _props_onNavigation === void 0 ? void 0 : _props_onNavigation.call(props, request.event, {
      ...request,
      preventScroll: () => {
        isScrollPrevented = true;
      },
      isScrollPrevented: () => isScrollPrevented
    });
    switch (request.type) {
      case treeDataTypes.ArrowDown:
      case treeDataTypes.ArrowUp:
      case treeDataTypes.Home:
      case treeDataTypes.End:
        request.event.preventDefault();
    }
  };
  const requestTreeResponse = useEventCallback((request) => {
    switch (request.requestType) {
      case "navigate":
        return requestNavigation(request);
      case "open":
        return requestOpenChange(request);
      case "selection":
        return requestCheckedChange(request);
    }
  });
  var _props_navigationMode;
  return {
    components: {
      root: "div",
      collapseMotion: Collapse
    },
    contextType: "root",
    selectionMode,
    navigationMode: (_props_navigationMode = props.navigationMode) !== null && _props_navigationMode !== void 0 ? _props_navigationMode : "tree",
    open: true,
    appearance,
    size: size3,
    level: 1,
    openItems,
    checkedItems,
    requestTreeResponse,
    forceUpdateRovingTabIndex: () => {
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: "tree",
      "aria-multiselectable": selectionMode === "multiselect" ? true : void 0,
      ...props
    }), {
      elementType: "div"
    }),
    collapseMotion: void 0
  };
}
function warnIfNoProperPropsRootTree(props) {
  if (true) {
    if (!props["aria-label"] && !props["aria-labelledby"]) {
      console.warn(`@fluentui/react-tree [useRootTree]:
Tree must have either a \`aria-label\` or \`aria-labelledby\` property defined`);
    }
  }
}

// node_modules/@fluentui/react-tree/lib/hooks/useSubtree.js
var React414 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/contexts/treeContext.js
var defaultTreeContextValue = {
  level: 0,
  contextType: "root",
  treeType: "nested",
  selectionMode: "none",
  openItems: ImmutableSet.empty,
  checkedItems: ImmutableMap.empty,
  requestTreeResponse: noop9,
  forceUpdateRovingTabIndex: noop9,
  appearance: "subtle",
  size: "medium",
  navigationMode: "tree"
};
function noop9() {
}
var TreeContext = createContext13(void 0);
var useTreeContext_unstable = (selector) => useContextSelector(TreeContext, (ctx = defaultTreeContextValue) => selector(ctx));

// node_modules/@fluentui/react-tree/lib/contexts/treeItemContext.js
var React413 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/utils/createHeadlessTree.js
function createHeadlessTree(initialProps = []) {
  const root = createHeadlessTreeRootItem();
  const itemsPerValue = /* @__PURE__ */ new Map([
    [
      root.value,
      root
    ]
  ]);
  const headlessTree = {
    root,
    get size() {
      return itemsPerValue.size;
    },
    getParent: (key) => {
      var _itemsPerValue_get;
      var _itemsPerValue_get_parentValue, _itemsPerValue_get1;
      return (_itemsPerValue_get1 = itemsPerValue.get((_itemsPerValue_get_parentValue = (_itemsPerValue_get = itemsPerValue.get(key)) === null || _itemsPerValue_get === void 0 ? void 0 : _itemsPerValue_get.parentValue) !== null && _itemsPerValue_get_parentValue !== void 0 ? _itemsPerValue_get_parentValue : root.value)) !== null && _itemsPerValue_get1 !== void 0 ? _itemsPerValue_get1 : root;
    },
    get: (key) => itemsPerValue.get(key),
    has: (key) => itemsPerValue.has(key),
    add(props) {
      const { parentValue = headlessTreeRootId, ...propsWithoutParentValue } = props;
      const parentItem = itemsPerValue.get(parentValue);
      if (!parentItem) {
        if (true) {
          console.error(`@fluentui/react-tree [createHeadlessTree]:
TreeItem "${props.value}" is wrongly positioned, did you properly ordered provided item props? make sure provided items are organized, parents should come before children`);
        }
        return;
      }
      parentItem.itemType = "branch";
      var _propsWithoutParentValue_itemType;
      const item = {
        value: props.value,
        getTreeItemProps: () => ({
          ...propsWithoutParentValue,
          parentValue,
          "aria-level": item.level,
          "aria-posinset": item.position,
          "aria-setsize": parentItem.childrenValues.length,
          itemType: item.itemType
        }),
        itemType: (_propsWithoutParentValue_itemType = propsWithoutParentValue.itemType) !== null && _propsWithoutParentValue_itemType !== void 0 ? _propsWithoutParentValue_itemType : "leaf",
        level: parentItem.level + 1,
        parentValue,
        childrenValues: [],
        index: -1,
        position: parentItem.childrenValues.push(props.value)
      };
      itemsPerValue.set(item.value, item);
    },
    subtree: (key) => HeadlessTreeSubtreeGenerator(key, headlessTree),
    children: (key) => HeadlessTreeChildrenGenerator(key, headlessTree),
    ancestors: (key) => HeadlessTreeAncestorsGenerator(key, headlessTree),
    visibleItems: (openItems) => HeadlessTreeVisibleItemsGenerator(openItems, headlessTree)
  };
  initialProps.forEach(headlessTree.add);
  return headlessTree;
}
var headlessTreeRootId = "__fuiHeadlessTreeRoot";
function createHeadlessTreeRootItem() {
  return {
    parentValue: void 0,
    value: headlessTreeRootId,
    itemType: "branch",
    getTreeItemProps: () => {
      if (true) {
        console.error(`@fluentui/react-tree [createHeadlessTree]:
Internal error, trying to access treeitem props from invalid root element`);
      }
      return {
        id: headlessTreeRootId,
        parentValue: void 0,
        value: headlessTreeRootId,
        "aria-setsize": -1,
        "aria-level": -1,
        "aria-posinset": -1,
        itemType: "branch"
      };
    },
    childrenValues: [],
    get index() {
      if (true) {
        console.error(`@fluentui/react-tree [createHeadlessTree]:
Internal error, trying to access treeitem props from invalid root element`);
      }
      return -1;
    },
    get position() {
      if (true) {
        console.error(`@fluentui/react-tree [createHeadlessTree]:
Internal error, trying to access treeitem props from invalid root element`);
      }
      return -1;
    },
    level: 0
  };
}
function* HeadlessTreeSubtreeGenerator(key, virtualTreeItems) {
  const item = virtualTreeItems.get(key);
  if (!item || item.childrenValues.length === 0) {
    return;
  }
  for (const childValue of item.childrenValues) {
    yield virtualTreeItems.get(childValue);
    yield* HeadlessTreeSubtreeGenerator(childValue, virtualTreeItems);
  }
}
function* HeadlessTreeChildrenGenerator(key, virtualTreeItems) {
  const item = virtualTreeItems.get(key);
  if (!item || item.childrenValues.length === 0) {
    return;
  }
  for (const childValue of item.childrenValues) {
    yield virtualTreeItems.get(childValue);
  }
}
function* HeadlessTreeAncestorsGenerator(key, virtualTreeItems) {
  let parent2 = virtualTreeItems.getParent(key);
  while (parent2 !== virtualTreeItems.root) {
    yield parent2;
    parent2 = virtualTreeItems.getParent(parent2.value);
  }
}
function* HeadlessTreeVisibleItemsGenerator(openItems, virtualTreeItems) {
  let index = 0;
  for (const item of HeadlessTreeSubtreeGenerator(virtualTreeItems.root.value, virtualTreeItems)) {
    if (isItemVisible(item, openItems, virtualTreeItems)) {
      item.index = index++;
      yield item;
    }
  }
}
function isItemVisible(item, openItems, virtualTreeItems) {
  if (item.level === 1) {
    return true;
  }
  while (item.parentValue && item.parentValue !== virtualTreeItems.root.value) {
    if (!openItems.has(item.parentValue)) {
      return false;
    }
    const parent2 = virtualTreeItems.get(item.parentValue);
    if (!parent2) {
      return false;
    }
    item = parent2;
  }
  return true;
}

// node_modules/@fluentui/react-tree/lib/contexts/treeItemContext.js
var defaultContextValue3 = {
  value: headlessTreeRootId,
  selectionRef: React413.createRef(),
  layoutRef: React413.createRef(),
  treeItemRef: React413.createRef(),
  subtreeRef: React413.createRef(),
  actionsRef: React413.createRef(),
  expandIconRef: React413.createRef(),
  isActionsVisible: false,
  isAsideVisible: false,
  itemType: "leaf",
  open: false,
  checked: false
};
var TreeItemContext = createContext13(void 0);
var { Provider: TreeItemProvider } = TreeItemContext;
var useTreeItemContext_unstable = (selector) => useContextSelector(TreeItemContext, (ctx = defaultContextValue3) => selector(ctx));

// node_modules/@fluentui/react-tree/lib/hooks/useSubtree.js
function useSubtree(props, ref) {
  const subtreeRef = useTreeItemContext_unstable((ctx) => ctx.subtreeRef);
  const { level: parentLevel } = useSubtreeContext_unstable();
  const open = useTreeItemContext_unstable((ctx) => ctx.open);
  return {
    contextType: "subtree",
    open,
    components: {
      root: "div",
      collapseMotion: Collapse
    },
    level: parentLevel + 1,
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, subtreeRef),
      role: "group",
      ...props
    }), {
      elementType: "div"
    }),
    collapseMotion: presenceMotionSlot(props.collapseMotion, {
      elementType: Collapse,
      defaultProps: {
        visible: open,
        unmountOnExit: true
      }
    })
  };
}

// node_modules/@fluentui/react-tree/lib/utils/nextTypeAheadElement.js
function nextTypeAheadElement(treeWalker, key) {
  const keyToLowerCase = key.toLowerCase();
  const typeAheadFilter = (element) => {
    var _element_textContent;
    return ((_element_textContent = element.textContent) === null || _element_textContent === void 0 ? void 0 : _element_textContent.trim().charAt(0).toLowerCase()) === keyToLowerCase ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  };
  let nextElement = treeWalker.nextElement(typeAheadFilter);
  if (!nextElement) {
    treeWalker.currentElement = treeWalker.root;
    nextElement = treeWalker.nextElement(typeAheadFilter);
  }
  return nextElement;
}

// node_modules/@fluentui/react-tree/lib/hooks/useRovingTabIndexes.js
var React415 = __toESM(require_react());
var findTreeItemRoot = (element) => {
  let parent2 = element.parentElement;
  while (parent2 && parent2.getAttribute("role") !== "tree") {
    parent2 = parent2.parentElement;
  }
  return parent2;
};
function useRovingTabIndex() {
  const currentElementRef = React415.useRef(null);
  const walkerRef = React415.useRef(null);
  const { targetDocument } = useFluent();
  useFocusedElementChange((element) => {
    if ((element === null || element === void 0 ? void 0 : element.getAttribute("role")) === "treeitem" && walkerRef.current && walkerRef.current.root.contains(element)) {
      const treeitemRoot = findTreeItemRoot(element);
      if (walkerRef.current.root !== treeitemRoot) {
        return;
      }
      rove(element);
    }
  });
  const initialize = React415.useCallback((walker) => {
    walkerRef.current = walker;
    walker.currentElement = walker.root;
    let tabbableChild = walker.firstChild((element) => element.tabIndex === 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);
    walker.currentElement = walker.root;
    tabbableChild !== null && tabbableChild !== void 0 ? tabbableChild : tabbableChild = walker.firstChild();
    if (!tabbableChild) {
      return;
    }
    tabbableChild.tabIndex = 0;
    currentElementRef.current = tabbableChild;
    let nextElement = null;
    while ((nextElement = walker.nextElement()) && nextElement !== tabbableChild) {
      nextElement.tabIndex = -1;
    }
  }, []);
  const rove = React415.useCallback((nextElement, focusOptions) => {
    if (!currentElementRef.current) {
      return;
    }
    currentElementRef.current.tabIndex = -1;
    nextElement.tabIndex = 0;
    nextElement.focus(focusOptions);
    currentElementRef.current = nextElement;
  }, []);
  const forceUpdate = React415.useCallback(() => {
    if ((currentElementRef.current === null || !(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body.contains(currentElementRef.current))) && walkerRef.current) {
      initialize(walkerRef.current);
    }
  }, [
    targetDocument,
    initialize
  ]);
  return {
    rove,
    initialize,
    forceUpdate
  };
}

// node_modules/@fluentui/react-tree/lib/hooks/useTreeNavigation.js
var React420 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/hooks/useHTMLElementWalkerRef.js
var React416 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/utils/createHTMLElementWalker.js
function createHTMLElementWalker(root, targetDocument, filter = () => NodeFilter.FILTER_ACCEPT) {
  let temporaryFilter;
  const treeWalker = targetDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node) {
      if (!isHTMLElement(node)) {
        return NodeFilter.FILTER_REJECT;
      }
      const filterResult = filter(node);
      var _temporaryFilter;
      return filterResult === NodeFilter.FILTER_ACCEPT ? (_temporaryFilter = temporaryFilter === null || temporaryFilter === void 0 ? void 0 : temporaryFilter(node)) !== null && _temporaryFilter !== void 0 ? _temporaryFilter : filterResult : filterResult;
    }
  });
  return {
    get root() {
      return treeWalker.root;
    },
    get currentElement() {
      return treeWalker.currentNode;
    },
    set currentElement(element) {
      treeWalker.currentNode = element;
    },
    firstChild: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.firstChild();
      temporaryFilter = void 0;
      return result;
    },
    lastChild: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.lastChild();
      temporaryFilter = void 0;
      return result;
    },
    nextElement: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.nextNode();
      temporaryFilter = void 0;
      return result;
    },
    nextSibling: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.nextSibling();
      temporaryFilter = void 0;
      return result;
    },
    parentElement: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.parentNode();
      temporaryFilter = void 0;
      return result;
    },
    previousElement: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.previousNode();
      temporaryFilter = void 0;
      return result;
    },
    previousSibling: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.previousSibling();
      temporaryFilter = void 0;
      return result;
    }
  };
}

// node_modules/@fluentui/react-tree/lib/utils/treeItemFilter.js
var treeItemFilter = (element) => {
  return element.getAttribute("role") === "treeitem" ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
};

// node_modules/@fluentui/react-tree/lib/hooks/useHTMLElementWalkerRef.js
function useHTMLElementWalkerRef() {
  const { targetDocument } = useFluent();
  const walkerRef = React416.useRef(void 0);
  const rootRef = React416.useCallback((root) => {
    walkerRef.current = targetDocument && root ? createHTMLElementWalker(root, targetDocument, treeItemFilter) : void 0;
  }, [
    targetDocument
  ]);
  return {
    walkerRef,
    rootRef
  };
}

// node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/TreeItemLayout.js
var React419 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/useTreeItemLayout.js
var React418 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/TreeItemChevron.js
var React417 = __toESM(require_react());
var TreeItemChevron = React417.memo(() => {
  const open = useTreeItemContext_unstable((ctx) => ctx.open);
  const { dir } = useFluent();
  const expandIconRotation = open ? 90 : dir !== "rtl" ? 0 : 180;
  return React417.createElement(ChevronRight12Regular, {
    style: {
      ...expandIconInlineStyles[expandIconRotation],
      transition: `transform ${durations2.durationNormal}ms ${curves2.curveEasyEaseMax}`
    }
  });
});
TreeItemChevron.displayName = "TreeItemChevron";
var expandIconInlineStyles = {
  90: {
    transform: `rotate(90deg)`
  },
  0: {
    transform: `rotate(0deg)`
  },
  180: {
    transform: `rotate(180deg)`
  }
};

// node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/useTreeItemLayout.js
var useTreeItemLayout_unstable = (props, ref) => {
  "use no memo";
  const { main, iconAfter, iconBefore } = props;
  const layoutRef = useTreeItemContext_unstable((ctx) => ctx.layoutRef);
  const selectionMode = useTreeContext_unstable((ctx) => ctx.selectionMode);
  const navigationMode = useTreeContext_unstable((ctx) => {
    var _ctx_navigationMode;
    return (_ctx_navigationMode = ctx.navigationMode) !== null && _ctx_navigationMode !== void 0 ? _ctx_navigationMode : "tree";
  });
  const [isActionsVisibleFromProps, onActionVisibilityChange] = isResolvedShorthand(props.actions) ? [
    props.actions.visible,
    props.actions.onVisibilityChange
  ] : [
    void 0,
    void 0
  ];
  const [isActionsVisible, setIsActionsVisible] = useControllableState({
    state: isActionsVisibleFromProps,
    initialState: false
  });
  const selectionRef = useTreeItemContext_unstable((ctx) => ctx.selectionRef);
  const expandIconRef = useTreeItemContext_unstable((ctx) => ctx.expandIconRef);
  const actionsRef = useTreeItemContext_unstable((ctx) => ctx.actionsRef);
  const actionsRefInternal = React418.useRef(null);
  const treeItemRef = useTreeItemContext_unstable((ctx) => ctx.treeItemRef);
  const subtreeRef = useTreeItemContext_unstable((ctx) => ctx.subtreeRef);
  const checked = useTreeItemContext_unstable((ctx) => ctx.checked);
  const isBranch = useTreeItemContext_unstable((ctx) => ctx.itemType === "branch");
  assertIsRefObject(treeItemRef);
  assertIsRefObject(subtreeRef);
  const setActionsVisibleIfNotFromSubtree = React418.useCallback((event) => {
    const isTargetFromSubtree = Boolean(subtreeRef.current && elementContains(subtreeRef.current, event.target));
    if (!isTargetFromSubtree) {
      onActionVisibilityChange === null || onActionVisibilityChange === void 0 ? void 0 : onActionVisibilityChange(event, {
        visible: true,
        event,
        type: event.type
      });
      if (event.defaultPrevented) {
        return;
      }
      setIsActionsVisible(true);
    }
  }, [
    subtreeRef,
    setIsActionsVisible,
    onActionVisibilityChange
  ]);
  const { targetDocument } = useFluent();
  const isNavigatingWithKeyboard = useIsNavigatingWithKeyboard();
  const setActionsInvisibleIfNotFromSubtree = React418.useCallback((event) => {
    const isRelatedTargetFromActions = () => Boolean(actionsRefInternal.current && elementContains(actionsRefInternal.current, event.relatedTarget));
    const isRelatedTargetFromTreeItem = () => Boolean(treeItemRef.current && elementContains(treeItemRef.current, event.relatedTarget));
    const isTargetFromActions = () => {
      var _actionsRefInternal_current;
      return Boolean((_actionsRefInternal_current = actionsRefInternal.current) === null || _actionsRefInternal_current === void 0 ? void 0 : _actionsRefInternal_current.contains(event.target));
    };
    if (isRelatedTargetFromActions()) {
      onActionVisibilityChange === null || onActionVisibilityChange === void 0 ? void 0 : onActionVisibilityChange(event, {
        visible: true,
        event,
        type: event.type
      });
      if (event.defaultPrevented) {
        return;
      }
      setIsActionsVisible(true);
      return;
    }
    if (isTargetFromActions() && isRelatedTargetFromTreeItem()) {
      return;
    }
    if (event.type === "mouseout" && isNavigatingWithKeyboard() && ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === treeItemRef.current || elementContains(actionsRefInternal.current, targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement))) {
      return;
    }
    onActionVisibilityChange === null || onActionVisibilityChange === void 0 ? void 0 : onActionVisibilityChange(event, {
      visible: false,
      event,
      type: event.type
    });
    if (event.defaultPrevented) {
      return;
    }
    setIsActionsVisible(false);
  }, [
    setIsActionsVisible,
    onActionVisibilityChange,
    treeItemRef,
    isNavigatingWithKeyboard,
    targetDocument
  ]);
  const expandIcon = slot_exports.optional(props.expandIcon, {
    renderByDefault: isBranch,
    defaultProps: {
      children: React418.createElement(TreeItemChevron, null),
      "aria-hidden": true
    },
    elementType: "div"
  });
  const expandIconRefs = useMergedRefs(expandIcon === null || expandIcon === void 0 ? void 0 : expandIcon.ref, expandIconRef);
  if (expandIcon) {
    expandIcon.ref = expandIconRefs;
  }
  const arrowNavigationProps = useArrowNavigationGroup({
    circular: navigationMode === "tree",
    axis: "horizontal"
  });
  const actions = isActionsVisible ? slot_exports.optional(props.actions, {
    defaultProps: {
      ...arrowNavigationProps,
      role: "toolbar"
    },
    elementType: "div"
  }) : void 0;
  actions === null || actions === void 0 ? true : delete actions.visible;
  actions === null || actions === void 0 ? true : delete actions.onVisibilityChange;
  const actionsRefs = useMergedRefs(actions === null || actions === void 0 ? void 0 : actions.ref, actionsRef, actionsRefInternal);
  const handleActionsBlur = useEventCallback((event) => {
    if (isResolvedShorthand(props.actions)) {
      var _props_actions_onBlur, _props_actions;
      (_props_actions_onBlur = (_props_actions = props.actions).onBlur) === null || _props_actions_onBlur === void 0 ? void 0 : _props_actions_onBlur.call(_props_actions, event);
    }
    const isRelatedTargetFromActions = Boolean(elementContains(event.currentTarget, event.relatedTarget));
    onActionVisibilityChange === null || onActionVisibilityChange === void 0 ? void 0 : onActionVisibilityChange(event, {
      visible: isRelatedTargetFromActions,
      event,
      type: event.type
    });
    setIsActionsVisible(isRelatedTargetFromActions);
  });
  if (actions) {
    actions.ref = actionsRefs;
    actions.onBlur = handleActionsBlur;
  }
  const hasActions = Boolean(props.actions);
  React418.useEffect(() => {
    if (treeItemRef.current && hasActions) {
      const treeItemElement = treeItemRef.current;
      const handleMouseOver = setActionsVisibleIfNotFromSubtree;
      const handleMouseOut = setActionsInvisibleIfNotFromSubtree;
      const handleFocus = setActionsVisibleIfNotFromSubtree;
      const handleBlur = setActionsInvisibleIfNotFromSubtree;
      treeItemElement.addEventListener("mouseover", handleMouseOver);
      treeItemElement.addEventListener("mouseout", handleMouseOut);
      treeItemElement.addEventListener("focus", handleFocus);
      treeItemElement.addEventListener("blur", handleBlur);
      return () => {
        treeItemElement.removeEventListener("mouseover", handleMouseOver);
        treeItemElement.removeEventListener("mouseout", handleMouseOut);
        treeItemElement.removeEventListener("focus", handleFocus);
        treeItemElement.removeEventListener("blur", handleBlur);
      };
    }
  }, [
    hasActions,
    treeItemRef,
    setActionsVisibleIfNotFromSubtree,
    setActionsInvisibleIfNotFromSubtree
  ]);
  return {
    components: {
      root: "div",
      expandIcon: "div",
      iconBefore: "div",
      main: "div",
      iconAfter: "div",
      actions: "div",
      aside: "div",
      // Casting here to a union between checkbox and radio
      selector: selectionMode === "multiselect" ? Checkbox : Radio
    },
    buttonContextValue: {
      size: "small"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ...props,
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, layoutRef)
    }), {
      elementType: "div"
    }),
    iconBefore: slot_exports.optional(iconBefore, {
      elementType: "div"
    }),
    main: slot_exports.always(main, {
      elementType: "div"
    }),
    iconAfter: slot_exports.optional(iconAfter, {
      elementType: "div"
    }),
    aside: !isActionsVisible ? slot_exports.optional(props.aside, {
      elementType: "div"
    }) : void 0,
    actions,
    expandIcon,
    selector: slot_exports.optional(props.selector, {
      renderByDefault: selectionMode !== "none",
      defaultProps: {
        checked,
        tabIndex: -1,
        "aria-hidden": true,
        ref: selectionRef
      },
      elementType: selectionMode === "multiselect" ? Checkbox : Radio
    })
  };
};
function assertIsRefObject(ref) {
  if (true) {
    if (typeof ref !== "object" || ref === null || !("current" in ref)) {
      throw new Error(`
        @fluentui/react-tree [${useTreeItemLayout_unstable.name}]:
        Internal Error: contextual ref is not a RefObject! Please report this bug immediately, as contextual refs should be RefObjects.
      `);
    }
  }
}

// node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/renderTreeItemLayout.js
var renderTreeItemLayout_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.expandIcon && jsx(state.expandIcon, {}),
      state.selector && jsx(state.selector, {}),
      state.iconBefore && jsx(state.iconBefore, {}),
      jsx(state.main, {
        children: state.root.children
      }),
      state.iconAfter && jsx(state.iconAfter, {}),
      jsxs(ButtonContextProvider, {
        value: state.buttonContextValue,
        children: [
          state.actions && jsx(state.actions, {}),
          state.aside && jsx(state.aside, {})
        ]
      })
    ]
  });
};

// node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/useTreeItemLayoutStyles.styles.js
var treeItemLayoutClassNames = {
  root: "fui-TreeItemLayout",
  iconBefore: "fui-TreeItemLayout__iconBefore",
  main: "fui-TreeItemLayout__main",
  iconAfter: "fui-TreeItemLayout__iconAfter",
  expandIcon: "fui-TreeItemLayout__expandIcon",
  aside: "fui-TreeItemLayout__aside",
  actions: "fui-TreeItemLayout__actions",
  selector: "fui-TreeItemLayout__selector"
};
var useRootBaseStyles2 = __resetStyles("ryb8khq", null, [".ryb8khq{display:flex;align-items:center;min-height:32px;box-sizing:border-box;grid-area:layout;}", ".ryb8khq:hover{color:var(--colorNeutralForeground2Hover);background-color:var(--colorSubtleBackgroundHover);}", ".ryb8khq:hover .fui-TreeItemLayout__expandIcon{color:var(--colorNeutralForeground3Hover);}", ".ryb8khq:active{color:var(--colorNeutralForeground2Pressed);background-color:var(--colorSubtleBackgroundPressed);}", ".ryb8khq:active .fui-TreeItemLayout__expandIcon{color:var(--colorNeutralForeground3Pressed);}"]);
var useRootStyles18 = __styles2({
  leaf: {
    uwmqm3: ["f1k1erfc", "faevyjx"]
  },
  branch: {
    uwmqm3: ["fo100m9", "f6yw3pu"]
  },
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  small: {
    sshi5w: "f1pha7fy",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  subtle: {},
  "subtle-alpha": {
    Jwef8y: "f146ro5n",
    ecr2s2: "fkam630"
  },
  transparent: {
    De3pzq: "f1c21dwh",
    Jwef8y: "fjxutwb",
    ecr2s2: "fophhak"
  }
}, {
  d: [".f1k1erfc{padding-left:calc(var(--fluent-TreeItem--level, 1) * var(--spacingHorizontalXXL));}", ".faevyjx{padding-right:calc(var(--fluent-TreeItem--level, 1) * var(--spacingHorizontalXXL));}", ".fo100m9{padding-left:calc((var(--fluent-TreeItem--level, 1) - 1) * var(--spacingHorizontalXXL));}", ".f6yw3pu{padding-right:calc((var(--fluent-TreeItem--level, 1) - 1) * var(--spacingHorizontalXXL));}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1pha7fy{min-height:24px;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}"],
  h: [".f146ro5n:hover{background-color:var(--colorSubtleBackgroundLightAlphaHover);}", ".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}"],
  a: [".fkam630:active{background-color:var(--colorSubtleBackgroundLightAlphaPressed);}", ".fophhak:active{background-color:var(--colorTransparentBackgroundPressed);}"]
});
var useActionsBaseStyles = __resetStyles("rzvs2in", "r17h8a29", [".rzvs2in{display:flex;margin-left:auto;position:relative;z-index:1;grid-area:aside;padding:0 var(--spacingHorizontalS);}", ".r17h8a29{display:flex;margin-right:auto;position:relative;z-index:1;grid-area:aside;padding:0 var(--spacingHorizontalS);}"]);
var useAsideBaseStyles = __resetStyles("r1825u21", "rezy0yk", [".r1825u21{display:flex;margin-left:auto;align-items:center;z-index:0;grid-area:aside;padding:0 var(--spacingHorizontalM);gap:var(--spacingHorizontalXS);}", ".rezy0yk{display:flex;margin-right:auto;align-items:center;z-index:0;grid-area:aside;padding:0 var(--spacingHorizontalM);gap:var(--spacingHorizontalXS);}"]);
var useExpandIconBaseStyles = __resetStyles("rh4pu5o", null, [".rh4pu5o{display:flex;align-items:center;justify-content:center;min-width:24px;box-sizing:border-box;color:var(--colorNeutralForeground3);flex:0 0 auto;padding:var(--spacingVerticalXS) 0;}"]);
var useMainBaseStyles = __resetStyles("rklbe47", null, [".rklbe47{padding:0 var(--spacingHorizontalXXS);}"]);
var useIconBaseStyles2 = __resetStyles("rphzgg1", null, [".rphzgg1{display:flex;align-items:center;color:var(--colorNeutralForeground2);line-height:var(--lineHeightBase500);font-size:var(--fontSizeBase500);}"]);
var useIconBeforeStyles = __styles2({
  medium: {
    z189sj: ["f7x41pl", "fruq291"]
  },
  small: {
    z189sj: ["ffczdla", "fgiv446"]
  }
}, {
  d: [".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}"]
});
var useIconAfterStyles = __styles2({
  medium: {
    uwmqm3: ["fruq291", "f7x41pl"]
  },
  small: {
    uwmqm3: ["fgiv446", "ffczdla"]
  }
}, {
  d: [".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}"]
});
var useTreeItemLayoutStyles_unstable = (state) => {
  "use no memo";
  const {
    main,
    iconAfter,
    iconBefore,
    expandIcon,
    root,
    aside,
    actions,
    selector
  } = state;
  const rootStyles = useRootStyles18();
  const rootBaseStyles = useRootBaseStyles2();
  const actionsBaseStyles = useActionsBaseStyles();
  const asideBaseStyles = useAsideBaseStyles();
  const mainBaseStyles = useMainBaseStyles();
  const expandIconBaseStyles = useExpandIconBaseStyles();
  const iconBaseStyles = useIconBaseStyles2();
  const iconBeforeStyles = useIconBeforeStyles();
  const iconAfterStyles = useIconAfterStyles();
  const size3 = useTreeContext_unstable((ctx) => ctx.size);
  const appearance = useTreeContext_unstable((ctx) => ctx.appearance);
  const itemType = useTreeItemContext_unstable((ctx) => ctx.itemType);
  root.className = mergeClasses(treeItemLayoutClassNames.root, rootBaseStyles, rootStyles[appearance], rootStyles[size3], rootStyles[itemType], root.className);
  main.className = mergeClasses(treeItemLayoutClassNames.main, mainBaseStyles, main.className);
  if (expandIcon) {
    expandIcon.className = mergeClasses(treeItemLayoutClassNames.expandIcon, expandIconBaseStyles, expandIcon.className);
  }
  if (iconBefore) {
    iconBefore.className = mergeClasses(treeItemLayoutClassNames.iconBefore, iconBaseStyles, iconBeforeStyles[size3], iconBefore.className);
  }
  if (iconAfter) {
    iconAfter.className = mergeClasses(treeItemLayoutClassNames.iconAfter, iconBaseStyles, iconAfterStyles[size3], iconAfter.className);
  }
  if (actions) {
    actions.className = mergeClasses(treeItemLayoutClassNames.actions, actionsBaseStyles, actions.className);
  }
  if (aside) {
    aside.className = mergeClasses(treeItemLayoutClassNames.aside, asideBaseStyles, aside.className);
  }
  if (selector) {
    selector.className = mergeClasses(treeItemLayoutClassNames.selector, selector.className);
  }
  return state;
};

// node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/TreeItemLayout.js
var TreeItemLayout = React419.forwardRef((props, ref) => {
  const state = useTreeItemLayout_unstable(props, ref);
  useTreeItemLayoutStyles_unstable(state);
  useCustomStyleHook("useTreeItemLayoutStyles_unstable")(state);
  return renderTreeItemLayout_unstable(state);
});
TreeItemLayout.displayName = "TreeItemLayout";

// node_modules/@fluentui/react-tree/lib/hooks/useTreeNavigation.js
function useTreeNavigation(navigationMode = "tree") {
  "use no memo";
  const { rove, initialize: initializeRovingTabIndex, forceUpdate: forceUpdateRovingTabIndex } = useRovingTabIndex();
  const { findFirstFocusable } = useFocusFinders();
  const { walkerRef, rootRef: walkerRootRef } = useHTMLElementWalkerRef();
  const rootRefCallback = React420.useCallback((root) => {
    if (root && walkerRef.current) {
      initializeRovingTabIndex(walkerRef.current);
    }
  }, [
    walkerRef,
    initializeRovingTabIndex
  ]);
  const getNextElement = (data) => {
    if (!walkerRef.current) {
      return null;
    }
    switch (data.type) {
      case treeDataTypes.Click:
        return data.target;
      case treeDataTypes.TypeAhead:
        walkerRef.current.currentElement = data.target;
        return nextTypeAheadElement(walkerRef.current, data.event.key);
      case treeDataTypes.ArrowLeft: {
        const actions = queryActions(data.target);
        if (navigationMode === "treegrid" && (actions === null || actions === void 0 ? void 0 : actions.contains(data.target.ownerDocument.activeElement))) {
          return data.target;
        }
        walkerRef.current.currentElement = data.target;
        return walkerRef.current.parentElement();
      }
      case treeDataTypes.ArrowRight:
        if (navigationMode === "treegrid") {
          const actions = queryActions(data.target);
          if (actions) {
            var _findFirstFocusable;
            (_findFirstFocusable = findFirstFocusable(actions)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
          }
          return null;
        }
        walkerRef.current.currentElement = data.target;
        return walkerRef.current.firstChild();
      case treeDataTypes.End:
        walkerRef.current.currentElement = walkerRef.current.root;
        return lastChildRecursive(walkerRef.current);
      case treeDataTypes.Home:
        walkerRef.current.currentElement = walkerRef.current.root;
        return walkerRef.current.firstChild();
      case treeDataTypes.ArrowDown:
        walkerRef.current.currentElement = data.target;
        return walkerRef.current.nextElement();
      case treeDataTypes.ArrowUp:
        walkerRef.current.currentElement = data.target;
        return walkerRef.current.previousElement();
    }
  };
  function navigate(data, focusOptions) {
    const nextElement = getNextElement(data);
    if (nextElement) {
      rove(nextElement, focusOptions);
    }
  }
  return {
    navigate,
    treeRef: useMergedRefs(walkerRootRef, rootRefCallback),
    forceUpdateRovingTabIndex
  };
}
function lastChildRecursive(walker) {
  let lastElement = null;
  let nextElement = null;
  while (nextElement = walker.lastChild()) {
    lastElement = nextElement;
  }
  return lastElement;
}
var queryActions = (target) => target.querySelector(`:scope > .${treeItemLayoutClassNames.root} > .${treeItemLayoutClassNames.actions}`);

// node_modules/@fluentui/react-tree/lib/components/Tree/useTree.js
var useTree_unstable = (props, ref) => {
  "use no memo";
  const isRoot = React421.useContext(SubtreeContext) === void 0;
  return isRoot ? useNestedRootTree(props, ref) : useNestedSubtree(props, ref);
};
function useNestedRootTree(props, ref) {
  "use no memo";
  const [openItems, setOpenItems] = useControllableOpenItems(props);
  const checkedItems = useNestedCheckedItems(props);
  const navigation = useTreeNavigation(props.navigationMode);
  return Object.assign(useRootTree({
    ...props,
    openItems,
    checkedItems,
    onOpenChange: useEventCallback((event, data) => {
      var _props_onOpenChange;
      const nextOpenItems = createNextOpenItems(data, openItems);
      (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, event, {
        ...data,
        openItems: ImmutableSet.dangerouslyGetInternalSet(nextOpenItems)
      });
      setOpenItems(nextOpenItems);
    }),
    onNavigation: useEventCallback((event, data) => {
      var _props_onNavigation;
      (_props_onNavigation = props.onNavigation) === null || _props_onNavigation === void 0 ? void 0 : _props_onNavigation.call(props, event, data);
      if (!event.isDefaultPrevented()) {
        navigation.navigate(data, {
          preventScroll: data.isScrollPrevented()
        });
      }
    }),
    onCheckedChange: useEventCallback((event, data) => {
      var _props_onCheckedChange;
      const nextCheckedItems = createNextNestedCheckedItems(data, checkedItems);
      (_props_onCheckedChange = props.onCheckedChange) === null || _props_onCheckedChange === void 0 ? void 0 : _props_onCheckedChange.call(props, event, {
        ...data,
        checkedItems: ImmutableMap.dangerouslyGetInternalMap(nextCheckedItems)
      });
    })
  }, useMergedRefs(ref, navigation.treeRef)), {
    treeType: "nested",
    forceUpdateRovingTabIndex: navigation.forceUpdateRovingTabIndex
  });
}
function useNestedSubtree(props, ref) {
  "use no memo";
  if (true) {
    const treeType = useTreeContext_unstable((ctx) => ctx.treeType);
    if (treeType === "flat") {
      throw new Error(`@fluentui/react-tree [useTree]:
Subtrees are not allowed in a FlatTree!
You cannot use a <Tree> component inside of a <FlatTree> component!`);
    }
  }
  return useSubtree(props, ref);
}

// node_modules/@fluentui/react-tree/lib/components/Tree/useTreeContextValues.js
var React422 = __toESM(require_react());
function useTreeContextValues_unstable(state) {
  "use no memo";
  if (state.contextType === "root") {
    const { openItems, level, contextType, treeType, checkedItems, selectionMode, navigationMode, appearance, size: size3, requestTreeResponse, forceUpdateRovingTabIndex } = state;
    const tree = {
      treeType,
      size: size3,
      openItems,
      appearance,
      checkedItems,
      selectionMode,
      navigationMode,
      contextType,
      level,
      requestTreeResponse,
      forceUpdateRovingTabIndex
    };
    return {
      tree
    };
  }
  return {
    // contextType is statically determined by the context
    // eslint-disable-next-line react-hooks/rules-of-hooks
    tree: React422.useMemo(() => ({
      level: state.level,
      contextType: "subtree"
    }), [
      state.level
    ])
  };
}

// node_modules/@fluentui/react-tree/lib/components/Tree/useTreeStyles.styles.js
var treeClassNames = {
  root: "fui-Tree"
};
var useBaseStyles6 = __resetStyles("rnv2ez3", null, [".rnv2ez3{display:flex;flex-direction:column;row-gap:var(--spacingVerticalXXS);}"]);
var useStyles52 = __styles2({
  subtree: {
    z8tnut: "fclwglc"
  }
}, {
  d: [".fclwglc{padding-top:var(--spacingVerticalXXS);}"]
});
var useTreeStyles_unstable = (state) => {
  "use no memo";
  const baseStyles3 = useBaseStyles6();
  const styles = useStyles52();
  const isSubTree = state.level > 1;
  state.root.className = mergeClasses(treeClassNames.root, baseStyles3, isSubTree && styles.subtree, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tree/lib/components/TreeProvider.js
var React423 = __toESM(require_react());
var rootSubtreeContextValue = {
  level: 1,
  contextType: "subtree"
};
var TreeProvider = (props) => {
  if (props.value.contextType === "subtree") {
    return React423.createElement(SubtreeContext.Provider, {
      value: props.value
    }, props.children);
  }
  return React423.createElement(TreeContext.Provider, {
    value: props.value
  }, React423.createElement(SubtreeContext.Provider, {
    value: rootSubtreeContextValue
  }, props.children));
};
TreeProvider.displayName = "TreeProvider";
var TreeRootReset = (props) => React423.createElement(SubtreeContext.Provider, {
  value: void 0
}, props.children);

// node_modules/@fluentui/react-tree/lib/components/Tree/renderTree.js
var renderTree_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(TreeProvider, {
    value: contextValues.tree,
    children: state.collapseMotion ? jsx(state.collapseMotion, {
      children: jsx(state.root, {})
    }) : jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-tree/lib/components/Tree/Tree.js
var Tree = React424.forwardRef((props, ref) => {
  const state = useTree_unstable(props, ref);
  const contextValues = useTreeContextValues_unstable(state);
  useTreeStyles_unstable(state);
  useCustomStyleHook("useTreeStyles_unstable")(state);
  return renderTree_unstable(state, contextValues);
});
Tree.displayName = "Tree";

// node_modules/@fluentui/react-tree/lib/components/FlatTree/FlatTree.js
var React427 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatTree.js
var React426 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/utils/getTreeItemValueFromElement.js
var dataTreeItemValueAttrName = "data-fui-tree-item-value";

// node_modules/@fluentui/react-tree/lib/hooks/useFlatTreeNavigation.js
var React425 = __toESM(require_react());
function useFlatTreeNavigation(navigationMode = "tree") {
  "use no memo";
  const { walkerRef, rootRef: walkerRootRef } = useHTMLElementWalkerRef();
  const { rove, forceUpdate: forceUpdateRovingTabIndex, initialize: initializeRovingTabIndex } = useRovingTabIndex();
  const { findFirstFocusable } = useFocusFinders();
  const rootRefCallback = React425.useCallback((root) => {
    if (walkerRef.current && root) {
      initializeRovingTabIndex(walkerRef.current);
    }
  }, [
    initializeRovingTabIndex,
    walkerRef
  ]);
  function getNextElement(data) {
    if (!walkerRef.current) {
      return null;
    }
    switch (data.type) {
      case treeDataTypes.Click:
        return data.target;
      case treeDataTypes.TypeAhead:
        walkerRef.current.currentElement = data.target;
        return nextTypeAheadElement(walkerRef.current, data.event.key);
      case treeDataTypes.ArrowLeft: {
        const actions = queryActions2(data.target);
        if (navigationMode === "treegrid" && (actions === null || actions === void 0 ? void 0 : actions.contains(data.target.ownerDocument.activeElement))) {
          return data.target;
        }
        const nextElement = parentElement(data.parentValue, walkerRef.current);
        if (!nextElement && true) {
          console.warn(`@fluentui/react-tree [useFlatTreeNavigation]:
'ArrowLeft' navigation was not possible.
No parent element found for the current element:`, data.target);
        }
        return nextElement;
      }
      case treeDataTypes.ArrowRight: {
        if (navigationMode === "treegrid") {
          const actions = queryActions2(data.target);
          if (actions) {
            var _findFirstFocusable;
            (_findFirstFocusable = findFirstFocusable(actions)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
          }
          return null;
        }
        walkerRef.current.currentElement = data.target;
        const nextElement = firstChild(data.target, walkerRef.current);
        if (!nextElement && true) {
          const ariaLevel = Number(data.target.getAttribute("aria-level"));
          console.warn(`@fluentui/react-tree [useFlatTreeNavigation]:
'ArrowRight' navigation was not possible.
No element with "aria-posinset=1" and "aria-level=${ariaLevel + 1}"
was found after the current element!`, data.target);
        }
        return nextElement;
      }
      case treeDataTypes.End:
        walkerRef.current.currentElement = walkerRef.current.root;
        return walkerRef.current.lastChild();
      case treeDataTypes.Home:
        walkerRef.current.currentElement = walkerRef.current.root;
        return walkerRef.current.firstChild();
      case treeDataTypes.ArrowDown:
        walkerRef.current.currentElement = data.target;
        return walkerRef.current.nextElement();
      case treeDataTypes.ArrowUp:
        walkerRef.current.currentElement = data.target;
        return walkerRef.current.previousElement();
    }
  }
  const navigate = useEventCallback((data) => {
    const nextElement = getNextElement(data);
    if (nextElement) {
      rove(nextElement);
    }
  });
  return {
    navigate,
    rootRef: useMergedRefs(walkerRootRef, rootRefCallback),
    forceUpdateRovingTabIndex
  };
}
function firstChild(target, treeWalker) {
  const nextElement = treeWalker.nextElement();
  if (!nextElement) {
    return null;
  }
  const nextElementAriaPosInSet = nextElement.getAttribute("aria-posinset");
  const nextElementAriaLevel = nextElement.getAttribute("aria-level");
  const targetAriaLevel = target.getAttribute("aria-level");
  if (nextElementAriaPosInSet === "1" && Number(nextElementAriaLevel) === Number(targetAriaLevel) + 1) {
    return nextElement;
  }
  return null;
}
function parentElement(parentValue, treeWalker) {
  if (parentValue === void 0) {
    return null;
  }
  return treeWalker.root.querySelector(`[${dataTreeItemValueAttrName}="${parentValue}"]`);
}
var queryActions2 = (target) => target.querySelector(`:scope > .${treeItemLayoutClassNames.root} > .${treeItemLayoutClassNames.actions}`);

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatTree.js
var useFlatTree_unstable = (props, ref) => {
  "use no memo";
  const isRoot = React426.useContext(SubtreeContext) === void 0;
  return isRoot ? useRootFlatTree(props, ref) : useSubFlatTree(props, ref);
};
function useRootFlatTree(props, ref) {
  const navigation = useFlatTreeNavigation(props.navigationMode);
  return Object.assign(useRootTree({
    ...props,
    onNavigation: useEventCallback((event, data) => {
      var _props_onNavigation;
      (_props_onNavigation = props.onNavigation) === null || _props_onNavigation === void 0 ? void 0 : _props_onNavigation.call(props, event, data);
      if (!event.isDefaultPrevented()) {
        navigation.navigate(data);
      }
    })
  }, useMergedRefs(ref, navigation.rootRef)), {
    treeType: "flat",
    forceUpdateRovingTabIndex: navigation.forceUpdateRovingTabIndex
  });
}
function useSubFlatTree(props, ref) {
  if (true) {
    throw new Error(`@fluentui/react-tree [useFlatTree]:
Subtrees are not allowed in a FlatTree!
You cannot use a <FlatTree> component inside of another <FlatTree> nor a <Tree> component!`);
  }
  return {
    ...useSubtree(props, ref),
    // ------ defaultTreeContextValue
    level: 0,
    contextType: "root",
    treeType: "nested",
    selectionMode: "none",
    openItems: ImmutableSet.empty,
    checkedItems: ImmutableMap.empty,
    requestTreeResponse: noop10,
    forceUpdateRovingTabIndex: noop10,
    appearance: "subtle",
    size: "medium",
    // ------ defaultTreeContextValue
    open: false
  };
}
function noop10() {
}

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatTreeStyles.styles.js
var flatTreeClassNames = {
  root: "fui-FlatTree"
};
var useBaseStyles7 = __resetStyles("rnv2ez3", null, [".rnv2ez3{display:flex;flex-direction:column;row-gap:var(--spacingVerticalXXS);}"]);
var useFlatTreeStyles_unstable = (state) => {
  "use no memo";
  const baseStyles3 = useBaseStyles7();
  state.root.className = mergeClasses(flatTreeClassNames.root, baseStyles3, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatTreeContextValues.js
var useFlatTreeContextValues_unstable = (state) => {
  const { openItems, level, contextType, treeType, checkedItems, selectionMode, navigationMode, appearance, size: size3, requestTreeResponse, forceUpdateRovingTabIndex } = state;
  const tree = {
    treeType,
    size: size3,
    openItems,
    appearance,
    checkedItems,
    selectionMode,
    navigationMode,
    contextType,
    level,
    requestTreeResponse,
    forceUpdateRovingTabIndex
  };
  return {
    tree
  };
};

// node_modules/@fluentui/react-tree/lib/components/FlatTree/renderFlatTree.js
var renderFlatTree_unstable = renderTree_unstable;

// node_modules/@fluentui/react-tree/lib/components/FlatTree/FlatTree.js
var FlatTree = React427.forwardRef((props, ref) => {
  const state = useFlatTree_unstable(props, ref);
  const contextValues = useFlatTreeContextValues_unstable(state);
  useFlatTreeStyles_unstable(state);
  useCustomStyleHook("useFlatTreeStyles_unstable")(state);
  return renderFlatTree_unstable(state, contextValues);
});
FlatTree.displayName = "FlatTree";

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useHeadlessFlatTree.js
var React429 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatControllableCheckedItems.js
var React428 = __toESM(require_react());
function useFlatControllableCheckedItems(props, headlessTree) {
  return useControllableState({
    initialState: ImmutableMap.empty,
    state: React428.useMemo(() => props.selectionMode ? props.checkedItems && createCheckedItems(props.checkedItems) : void 0, [
      props.checkedItems,
      props.selectionMode
    ]),
    defaultState: props.defaultCheckedItems ? () => initializeCheckedItems(props, headlessTree) : void 0
  });
}
function createNextFlatCheckedItems(data, previousCheckedItems, headlessTree) {
  if (data.selectionMode === "single") {
    return ImmutableMap.from([
      [
        data.value,
        data.checked
      ]
    ]);
  }
  const treeItem = headlessTree.get(data.value);
  if (!treeItem) {
    if (true) {
      console.error(`@fluentui/react-tree [useHeadlessFlatTree]:
Tree item ${data.value} not found.`);
    }
    return previousCheckedItems;
  }
  let nextCheckedItems = previousCheckedItems;
  for (const children2 of headlessTree.subtree(data.value)) {
    nextCheckedItems = nextCheckedItems.set(children2.value, data.checked);
  }
  nextCheckedItems = nextCheckedItems.set(data.value, data.checked);
  let isAncestorsMixed = false;
  for (const parent2 of headlessTree.ancestors(treeItem.value)) {
    if (isAncestorsMixed) {
      nextCheckedItems = nextCheckedItems.set(parent2.value, "mixed");
      continue;
    }
    let checkedChildrenAmount = 0;
    for (const child of headlessTree.children(parent2.value)) {
      if ((nextCheckedItems.get(child.value) || false) === data.checked) {
        checkedChildrenAmount++;
      }
    }
    if (checkedChildrenAmount === parent2.childrenValues.length) {
      nextCheckedItems = nextCheckedItems.set(parent2.value, data.checked);
    } else {
      isAncestorsMixed = true;
      nextCheckedItems = nextCheckedItems.set(parent2.value, "mixed");
    }
  }
  return nextCheckedItems;
}
function initializeCheckedItems(props, headlessTree) {
  if (!props.selectionMode) {
    return ImmutableMap.empty;
  }
  let state = createCheckedItems(props.defaultCheckedItems);
  if (props.selectionMode === "multiselect") {
    for (const [value, checked] of state) {
      state = createNextFlatCheckedItems({
        value,
        checked,
        selectionMode: props.selectionMode
      }, state, headlessTree);
    }
  }
  return state;
}

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useHeadlessFlatTree.js
function useHeadlessFlatTree_unstable(props, options = {}) {
  "use no memo";
  const headlessTree = React429.useMemo(() => createHeadlessTree(props), [
    props
  ]);
  const [openItems, setOpenItems] = useControllableOpenItems(options);
  const [checkedItems, setCheckedItems] = useFlatControllableCheckedItems(options, headlessTree);
  const navigation = useFlatTreeNavigation();
  const treeRef = React429.useRef(null);
  const handleOpenChange = useEventCallback((event, data) => {
    var _options_onOpenChange;
    const nextOpenItems = createNextOpenItems(data, openItems);
    (_options_onOpenChange = options.onOpenChange) === null || _options_onOpenChange === void 0 ? void 0 : _options_onOpenChange.call(options, event, {
      ...data,
      openItems: ImmutableSet.dangerouslyGetInternalSet(nextOpenItems)
    });
    setOpenItems(nextOpenItems);
  });
  const handleCheckedChange = useEventCallback((event, data) => {
    var _options_onCheckedChange;
    const nextCheckedItems = createNextFlatCheckedItems(data, checkedItems, headlessTree);
    (_options_onCheckedChange = options.onCheckedChange) === null || _options_onCheckedChange === void 0 ? void 0 : _options_onCheckedChange.call(options, event, {
      ...data,
      checkedItems: ImmutableMap.dangerouslyGetInternalMap(nextCheckedItems)
    });
    setCheckedItems(nextCheckedItems);
  });
  const getNextNavigableItem = useEventCallback((visibleItems, data) => {
    const item = headlessTree.get(data.value);
    if (item) {
      switch (data.type) {
        case treeDataTypes.TypeAhead:
          return item;
        case treeDataTypes.ArrowLeft:
          return headlessTree.get(item.parentValue);
        case treeDataTypes.ArrowRight:
          return visibleItems[item.index + 1];
        case treeDataTypes.End:
          return visibleItems[visibleItems.length - 1];
        case treeDataTypes.Home:
          return visibleItems[0];
        case treeDataTypes.ArrowDown:
          return visibleItems[item.index + 1];
        case treeDataTypes.ArrowUp:
          return visibleItems[item.index - 1];
      }
    }
  });
  const getElementFromItem = React429.useCallback((item) => {
    var _treeRef_current;
    return (_treeRef_current = treeRef.current) === null || _treeRef_current === void 0 ? void 0 : _treeRef_current.querySelector(`[${dataTreeItemValueAttrName}="${item.value}"]`);
  }, []);
  const ref = useMergedRefs(treeRef, navigation.rootRef);
  const getTreeProps = React429.useCallback(
    () => {
      var _options_onNavigation;
      return {
        ref,
        openItems,
        selectionMode: options.selectionMode,
        checkedItems,
        onOpenChange: handleOpenChange,
        onCheckedChange: handleCheckedChange,
        onNavigation: (_options_onNavigation = options.onNavigation) !== null && _options_onNavigation !== void 0 ? _options_onNavigation : noop11
      };
    },
    // ref, handleOpenChange - useEventCallback, handleCheckedChange - useEventCallback
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      openItems,
      checkedItems,
      options.selectionMode,
      options.onNavigation
    ]
  );
  const items = React429.useCallback(() => headlessTree.visibleItems(openItems), [
    openItems,
    headlessTree
  ]);
  const getItem = React429.useCallback((value) => headlessTree.get(value), [
    headlessTree
  ]);
  return React429.useMemo(() => ({
    navigate: navigation.navigate,
    getTreeProps,
    getNextNavigableItem,
    getElementFromItem,
    items,
    getItem
  }), [
    navigation.navigate,
    getTreeProps,
    getNextNavigableItem,
    getElementFromItem,
    items,
    getItem
  ]);
}
function noop11() {
}

// node_modules/@fluentui/react-tree/lib/components/TreeItem/TreeItem.js
var React431 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/TreeItem/useTreeItem.js
var React430 = __toESM(require_react());
var ReactDOM3 = __toESM(require_react_dom());
function useTreeItem_unstable(props, ref) {
  "use no memo";
  const treeType = useTreeContext_unstable((ctx) => ctx.treeType);
  if (treeType === "flat") {
    warnIfNoProperPropsFlatTreeItem(props);
  }
  const requestTreeResponse = useTreeContext_unstable((ctx) => ctx.requestTreeResponse);
  const navigationMode = useTreeContext_unstable((ctx) => {
    var _ctx_navigationMode;
    return (_ctx_navigationMode = ctx.navigationMode) !== null && _ctx_navigationMode !== void 0 ? _ctx_navigationMode : "tree";
  });
  const forceUpdateRovingTabIndex = useTreeContext_unstable((ctx) => ctx.forceUpdateRovingTabIndex);
  const { level: contextLevel } = useSubtreeContext_unstable();
  const parentValue = useTreeItemContext_unstable((ctx) => {
    var _props_parentValue;
    return (_props_parentValue = props.parentValue) !== null && _props_parentValue !== void 0 ? _props_parentValue : ctx.value;
  });
  const internalValue = useId2("fuiTreeItemValue-");
  var _props_value;
  const value = (_props_value = props.value) !== null && _props_value !== void 0 ? _props_value : internalValue;
  const { onClick, onKeyDown, onChange, as = "div", itemType = "leaf", "aria-level": level = contextLevel, "aria-selected": ariaSelected, "aria-expanded": ariaExpanded, ...rest } = props;
  const actionsRef = React430.useRef(null);
  const expandIconRef = React430.useRef(null);
  const layoutRef = React430.useRef(null);
  const subtreeRef = React430.useRef(null);
  const selectionRef = React430.useRef(null);
  const treeItemRef = React430.useRef(null);
  if (true) {
    const hasTreeContext = useHasParentContext(TreeContext);
    React430.useEffect(() => {
      var _treeItemRef_current;
      if (hasTreeContext) {
        return;
      }
      if ((_treeItemRef_current = treeItemRef.current) === null || _treeItemRef_current === void 0 ? void 0 : _treeItemRef_current.querySelector(`.${treeClassNames.root}`)) {
        console.error(`@fluentui/react-tree [useTreeItem]:
<TreeItem> should be declared inside a <Tree> component.`);
      }
    }, [
      hasTreeContext
    ]);
  }
  React430.useEffect(() => {
    forceUpdateRovingTabIndex === null || forceUpdateRovingTabIndex === void 0 ? void 0 : forceUpdateRovingTabIndex();
    const treeItem = treeItemRef.current;
    return () => {
      if (treeItem && treeItem.tabIndex === 0) {
        forceUpdateRovingTabIndex === null || forceUpdateRovingTabIndex === void 0 ? void 0 : forceUpdateRovingTabIndex();
      }
    };
  }, [
    forceUpdateRovingTabIndex
  ]);
  const open = useTreeContext_unstable((ctx) => {
    var _props_open;
    return (_props_open = props.open) !== null && _props_open !== void 0 ? _props_open : ctx.openItems.has(value);
  });
  const getNextOpen = () => itemType === "branch" ? !open : open;
  const selectionMode = useTreeContext_unstable((ctx) => ctx.selectionMode);
  const checked = useTreeContext_unstable((ctx) => {
    var _ctx_checkedItems_get;
    return (_ctx_checkedItems_get = ctx.checkedItems.get(value)) !== null && _ctx_checkedItems_get !== void 0 ? _ctx_checkedItems_get : false;
  });
  const handleClick = useEventCallback((event) => {
    var _expandIconRef_current;
    const isEventFromActions = () => actionsRef.current && elementContains(actionsRef.current, event.target);
    const isEventFromSubtree = () => subtreeRef.current && elementContains(subtreeRef.current, event.target);
    const isEventFromSelection = () => {
      var _selectionRef_current;
      return (_selectionRef_current = selectionRef.current) === null || _selectionRef_current === void 0 ? void 0 : _selectionRef_current.contains(event.target);
    };
    const isEventFromExpandIcon = (_expandIconRef_current = expandIconRef.current) === null || _expandIconRef_current === void 0 ? void 0 : _expandIconRef_current.contains(event.target);
    if (isEventFromActions() || isEventFromSubtree() || isEventFromSelection()) {
      return;
    } else if (!isEventFromExpandIcon) {
      onClick === null || onClick === void 0 ? void 0 : onClick(event);
    }
    if (event.isDefaultPrevented()) {
      return;
    }
    ReactDOM3.unstable_batchedUpdates(() => {
      const data = {
        event,
        value,
        open: getNextOpen(),
        target: event.currentTarget,
        type: isEventFromExpandIcon ? treeDataTypes.ExpandIconClick : treeDataTypes.Click
      };
      if (itemType !== "leaf") {
        var _props_onOpenChange;
        (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, event, data);
        requestTreeResponse({
          ...data,
          itemType,
          requestType: "open"
        });
      }
      requestTreeResponse({
        ...data,
        itemType,
        parentValue,
        requestType: "navigate",
        type: treeDataTypes.Click
      });
    });
  });
  const handleKeyDown = useEventCallback((event) => {
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
    if (event.isDefaultPrevented() || !treeItemRef.current) {
      return;
    }
    const isEventFromTreeItem = event.currentTarget === event.target;
    const isEventFromActions = actionsRef.current && actionsRef.current.contains(event.target);
    switch (event.key) {
      case Space: {
        if (!isEventFromTreeItem) {
          return;
        }
        if (selectionMode !== "none") {
          var _selectionRef_current;
          (_selectionRef_current = selectionRef.current) === null || _selectionRef_current === void 0 ? void 0 : _selectionRef_current.click();
          event.preventDefault();
        }
        return;
      }
      case treeDataTypes.Enter: {
        if (!isEventFromTreeItem) {
          return;
        }
        return event.currentTarget.click();
      }
      case treeDataTypes.End:
      case treeDataTypes.Home:
      case treeDataTypes.ArrowUp: {
        if (!isEventFromTreeItem && !isEventFromActions) {
          return;
        }
        return requestTreeResponse({
          requestType: "navigate",
          event,
          value,
          itemType,
          parentValue,
          type: event.key,
          target: event.currentTarget
        });
      }
      case treeDataTypes.ArrowDown: {
        if (!isEventFromTreeItem && !isEventFromActions) {
          return;
        }
        if (isEventFromActions && (!isHTMLElement(event.target) || event.target.hasAttribute("aria-haspopup"))) {
          return;
        }
        return requestTreeResponse({
          requestType: "navigate",
          event,
          value,
          itemType,
          parentValue,
          type: event.key,
          target: event.currentTarget
        });
      }
      case treeDataTypes.ArrowLeft: {
        if (event.altKey) {
          return;
        }
        const data = {
          value,
          event,
          open: getNextOpen(),
          type: event.key,
          itemType,
          parentValue,
          target: event.currentTarget
        };
        if (isEventFromActions && navigationMode === "treegrid") {
          requestTreeResponse({
            ...data,
            requestType: "navigate"
          });
          return;
        }
        if (!isEventFromTreeItem) {
          return;
        }
        if (level === 1 && !open) {
          return;
        }
        if (open) {
          var _props_onOpenChange;
          (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, event, data);
        }
        requestTreeResponse({
          ...data,
          requestType: open ? "open" : "navigate"
        });
        return;
      }
      case treeDataTypes.ArrowRight: {
        if (!isEventFromTreeItem) {
          return;
        }
        if (event.altKey) {
          return;
        }
        const data = {
          value,
          event,
          open: getNextOpen(),
          type: event.key,
          target: event.currentTarget
        };
        if (itemType === "branch" && !open) {
          var _props_onOpenChange1;
          (_props_onOpenChange1 = props.onOpenChange) === null || _props_onOpenChange1 === void 0 ? void 0 : _props_onOpenChange1.call(props, event, data);
          requestTreeResponse({
            ...data,
            itemType,
            requestType: "open"
          });
        } else {
          requestTreeResponse({
            ...data,
            itemType,
            parentValue,
            requestType: "navigate"
          });
        }
        return;
      }
    }
    if (!isEventFromTreeItem) {
      return;
    }
    const isTypeAheadCharacter = event.key.length === 1 && event.key.match(/\w/) && !event.altKey && !event.ctrlKey && !event.metaKey;
    if (isTypeAheadCharacter) {
      requestTreeResponse({
        requestType: "navigate",
        event,
        target: event.currentTarget,
        value,
        itemType,
        type: treeDataTypes.TypeAhead,
        parentValue
      });
    }
  });
  const handleChange = useEventCallback((event) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(event);
    if (event.isDefaultPrevented()) {
      return;
    }
    const isEventFromSubtree = subtreeRef.current && elementContains(subtreeRef.current, event.target);
    if (isEventFromSubtree) {
      return;
    }
    requestTreeResponse({
      requestType: "selection",
      event,
      value,
      itemType,
      type: "Change",
      target: event.currentTarget,
      checked: checked === "mixed" ? true : !checked
    });
  });
  return {
    value,
    open,
    checked,
    subtreeRef,
    layoutRef,
    selectionRef,
    expandIconRef,
    treeItemRef,
    actionsRef,
    itemType,
    level,
    components: {
      root: "div"
    },
    // FIXME: this property is not necessary anymore, but as removing it would be a breaking change, we need to keep it as false
    isAsideVisible: false,
    // FIXME: this property is not necessary anymore, but as removing it would be a breaking change, we need to keep it as false
    isActionsVisible: false,
    root: slot_exports.always(getIntrinsicElementProps(as, {
      tabIndex: -1,
      [dataTreeItemValueAttrName]: value,
      role: "treeitem",
      ...rest,
      ref: useMergedRefs(ref, treeItemRef),
      "aria-level": level,
      "aria-checked": selectionMode === "multiselect" ? checked : void 0,
      "aria-selected": ariaSelected !== void 0 ? ariaSelected : selectionMode === "single" ? !!checked : void 0,
      "aria-expanded": ariaExpanded !== void 0 ? ariaExpanded : itemType === "branch" ? open : void 0,
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      onChange: handleChange
    }), {
      elementType: "div"
    })
  };
}
function warnIfNoProperPropsFlatTreeItem(props) {
  if (true) {
    if (props["aria-posinset"] === void 0 || props["aria-setsize"] === void 0 || props["aria-level"] === void 0 || props.parentValue === void 0 && props["aria-level"] !== 1) {
      console.error(`@fluentui/react-tree [${useTreeItem_unstable.name}]:
A flat treeitem must have "aria-posinset", "aria-setsize", "aria-level"
and "parentValue" (if "aria-level" > 1) to ensure a11y and navigation.

- "aria-posinset": the position of this treeitem in the current level of the tree.
- "aria-setsize": the number of siblings in this level of the tree.
- "aria-level": the current level of the treeitem.
- "parentValue": the "value" property of the parent item of this item.`);
    }
  }
}

// node_modules/@fluentui/react-tree/lib/components/TreeItem/renderTreeItem.js
var renderTreeItem_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(TreeItemProvider, {
      value: contextValues.treeItem,
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/useTreeItemPersonaLayoutStyles.styles.js
var treeItemPersonaLayoutClassNames = {
  root: "fui-TreeItemPersonaLayout",
  media: "fui-TreeItemPersonaLayout__media",
  description: "fui-TreeItemPersonaLayout__description",
  main: "fui-TreeItemPersonaLayout__main",
  expandIcon: "fui-TreeItemPersonaLayout__expandIcon",
  aside: "fui-TreeItemPersonaLayout__aside",
  actions: "fui-TreeItemPersonaLayout__actions",
  selector: "fui-TreeItemPersonaLayout__selector"
};
var useRootBaseStyles3 = __resetStyles("r1r98egg", null, ['.r1r98egg{display:grid;grid-template-rows:1fr auto;grid-template-columns:auto auto 1fr auto;grid-template-areas:"expandIcon media main        aside" "expandIcon media description aside";align-items:center;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);}', ".r1r98egg:active{color:var(--colorNeutralForeground2Pressed);background-color:var(--colorSubtleBackgroundPressed);}", ".r1r98egg:active .fui-TreeItemPersonaLayout__expandIcon{color:var(--colorNeutralForeground3Pressed);}", ".r1r98egg:hover{color:var(--colorNeutralForeground2Hover);background-color:var(--colorSubtleBackgroundHover);}", ".r1r98egg:hover .fui-TreeItemPersonaLayout__expandIcon{color:var(--colorNeutralForeground3Hover);}"]);
var useRootStyles19 = __styles2({
  leaf: {
    uwmqm3: ["f1k1erfc", "faevyjx"]
  },
  branch: {
    uwmqm3: ["fo100m9", "f6yw3pu"]
  }
}, {
  d: [".f1k1erfc{padding-left:calc(var(--fluent-TreeItem--level, 1) * var(--spacingHorizontalXXL));}", ".faevyjx{padding-right:calc(var(--fluent-TreeItem--level, 1) * var(--spacingHorizontalXXL));}", ".fo100m9{padding-left:calc((var(--fluent-TreeItem--level, 1) - 1) * var(--spacingHorizontalXXL));}", ".f6yw3pu{padding-right:calc((var(--fluent-TreeItem--level, 1) - 1) * var(--spacingHorizontalXXL));}"]
});
var useMediaBaseStyles = __resetStyles("rkcde6g", "r1e986zr", [".rkcde6g{display:flex;align-items:center;width:32px;height:32px;grid-area:media;padding:0 var(--spacingHorizontalXS) 0 var(--spacingHorizontalXXS);}", ".r1e986zr{display:flex;align-items:center;width:32px;height:32px;grid-area:media;padding:0 var(--spacingHorizontalXXS) 0 var(--spacingHorizontalXS);}"]);
var useMainBaseStyles2 = __resetStyles("r1qjtz99", "rob5fcp", [".r1qjtz99{grid-area:main;padding:var(--spacingVerticalMNudge) var(--spacingHorizontalXS) var(--spacingVerticalMNudge) var(--spacingHorizontalS);}", ".rob5fcp{grid-area:main;padding:var(--spacingVerticalMNudge) var(--spacingHorizontalS) var(--spacingVerticalMNudge) var(--spacingHorizontalXS);}"]);
var useMainStyles = __styles2({
  withDescription: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1625emv", "f5y9hxg"]
  }
}, {
  d: [[".f1625emv{padding:var(--spacingVerticalMNudge) var(--spacingHorizontalXS) 0 var(--spacingHorizontalS);}", {
    p: -1
  }], [".f5y9hxg{padding:var(--spacingVerticalMNudge) var(--spacingHorizontalS) 0 var(--spacingHorizontalXS);}", {
    p: -1
  }]]
});
var useDescriptionBaseStyles = __resetStyles("r1bnsn1b", "r13x7gq", [".r1bnsn1b{grid-area:description;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);padding:0 var(--spacingHorizontalXS) var(--spacingVerticalMNudge) var(--spacingHorizontalS);}", ".r13x7gq{grid-area:description;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);padding:0 var(--spacingHorizontalS) var(--spacingVerticalMNudge) var(--spacingHorizontalXS);}"]);
var useActionsBaseStyles2 = __resetStyles("rzvs2in", "r17h8a29", [".rzvs2in{display:flex;margin-left:auto;position:relative;z-index:1;grid-area:aside;padding:0 var(--spacingHorizontalS);}", ".r17h8a29{display:flex;margin-right:auto;position:relative;z-index:1;grid-area:aside;padding:0 var(--spacingHorizontalS);}"]);
var useAsideBaseStyles2 = __resetStyles("r1825u21", "rezy0yk", [".r1825u21{display:flex;margin-left:auto;align-items:center;z-index:0;grid-area:aside;padding:0 var(--spacingHorizontalM);gap:var(--spacingHorizontalXS);}", ".rezy0yk{display:flex;margin-right:auto;align-items:center;z-index:0;grid-area:aside;padding:0 var(--spacingHorizontalM);gap:var(--spacingHorizontalXS);}"]);
var useExpandIconBaseStyles2 = __resetStyles("rn61xvs", null, [".rn61xvs{display:flex;align-items:center;justify-content:center;min-width:24px;box-sizing:border-box;color:var(--colorNeutralForeground3);grid-area:expandIcon;flex:0 0 auto;padding:var(--spacingVerticalXS) 0;}"]);
var useTreeItemPersonaLayoutStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyles = useRootBaseStyles3();
  const rootStyles = useRootStyles19();
  const mediaBaseStyles = useMediaBaseStyles();
  const descriptionBaseStyles = useDescriptionBaseStyles();
  const actionsBaseStyles = useActionsBaseStyles2();
  const asideBaseStyles = useAsideBaseStyles2();
  const expandIconBaseStyles = useExpandIconBaseStyles2();
  const mainBaseStyles = useMainBaseStyles2();
  const mainStyles = useMainStyles();
  const itemType = useTreeItemContext_unstable((ctx) => ctx.itemType);
  state.root.className = mergeClasses(treeItemPersonaLayoutClassNames.root, rootBaseStyles, rootStyles[itemType], state.root.className);
  state.media.className = mergeClasses(treeItemPersonaLayoutClassNames.media, mediaBaseStyles, state.media.className);
  if (state.main) {
    state.main.className = mergeClasses(treeItemPersonaLayoutClassNames.main, mainBaseStyles, state.description && mainStyles.withDescription, state.main.className);
  }
  if (state.description) {
    state.description.className = mergeClasses(treeItemPersonaLayoutClassNames.description, descriptionBaseStyles, state.description.className);
  }
  if (state.actions) {
    state.actions.className = mergeClasses(treeItemPersonaLayoutClassNames.actions, actionsBaseStyles, state.actions.className);
  }
  if (state.aside) {
    state.aside.className = mergeClasses(treeItemPersonaLayoutClassNames.aside, asideBaseStyles, state.aside.className);
  }
  if (state.expandIcon) {
    state.expandIcon.className = mergeClasses(treeItemPersonaLayoutClassNames.expandIcon, expandIconBaseStyles, state.expandIcon.className);
  }
  if (state.selector) {
    state.selector.className = mergeClasses(treeItemPersonaLayoutClassNames.selector, state.selector.className);
  }
  return state;
};

// node_modules/@fluentui/react-tree/lib/components/TreeItem/useTreeItemStyles.styles.js
var treeItemClassNames = {
  root: "fui-TreeItem"
};
var useBaseStyles8 = __resetStyles("r15xhw3a", "r2f6k57", [".r15xhw3a{position:relative;cursor:pointer;display:flex;flex-direction:column;box-sizing:border-box;background-color:var(--colorSubtleBackground);color:var(--colorNeutralForeground2);padding-right:var(--spacingHorizontalNone);}", ".r15xhw3a:focus{outline-style:none;}", ".r15xhw3a:focus-visible{outline-style:none;}", ".r15xhw3a[data-fui-focus-visible]>.fui-TreeItemLayout,.r15xhw3a[data-fui-focus-visible]>.fui-TreeItemPersonaLayout{border-radius:var(--borderRadiusMedium);outline-color:var(--colorStrokeFocus2);outline-radius:var(--borderRadiusMedium);outline-width:2px;outline-style:solid;}", ".r2f6k57{position:relative;cursor:pointer;display:flex;flex-direction:column;box-sizing:border-box;background-color:var(--colorSubtleBackground);color:var(--colorNeutralForeground2);padding-left:var(--spacingHorizontalNone);}", ".r2f6k57:focus{outline-style:none;}", ".r2f6k57:focus-visible{outline-style:none;}", ".r2f6k57[data-fui-focus-visible]>.fui-TreeItemLayout,.r2f6k57[data-fui-focus-visible]>.fui-TreeItemPersonaLayout{border-radius:var(--borderRadiusMedium);outline-color:var(--colorStrokeFocus2);outline-radius:var(--borderRadiusMedium);outline-width:2px;outline-style:solid;}"]);
var useStyles53 = __styles2({
  level1: {
    iytv0q: "f10bgyvd"
  },
  level2: {
    iytv0q: "f1h0rod3"
  },
  level3: {
    iytv0q: "fgoqafk"
  },
  level4: {
    iytv0q: "f75dvuh"
  },
  level5: {
    iytv0q: "fqk7yw6"
  },
  level6: {
    iytv0q: "f1r3z17b"
  },
  level7: {
    iytv0q: "f1hrpd1h"
  },
  level8: {
    iytv0q: "f1iy65d0"
  },
  level9: {
    iytv0q: "ftg42e5"
  },
  level10: {
    iytv0q: "fyat3t"
  }
}, {
  d: [".f10bgyvd{--fluent-TreeItem--level:1;}", ".f1h0rod3{--fluent-TreeItem--level:2;}", ".fgoqafk{--fluent-TreeItem--level:3;}", ".f75dvuh{--fluent-TreeItem--level:4;}", ".fqk7yw6{--fluent-TreeItem--level:5;}", ".f1r3z17b{--fluent-TreeItem--level:6;}", ".f1hrpd1h{--fluent-TreeItem--level:7;}", ".f1iy65d0{--fluent-TreeItem--level:8;}", ".ftg42e5{--fluent-TreeItem--level:9;}", ".fyat3t{--fluent-TreeItem--level:10;}"]
});
var useTreeItemStyles_unstable = (state) => {
  "use no memo";
  const baseStyles3 = useBaseStyles8();
  const styles = useStyles53();
  const {
    level
  } = state;
  state.root.className = mergeClasses(treeItemClassNames.root, baseStyles3, isStaticallyDefinedLevel(level) && styles[`level${level}`], state.root.className);
  return state;
};
function isStaticallyDefinedLevel(level) {
  return level >= 1 && level <= 10;
}

// node_modules/@fluentui/react-tree/lib/components/TreeItem/useTreeItemContextValues.js
function useTreeItemContextValues_unstable(state) {
  const {
    value,
    itemType,
    layoutRef,
    subtreeRef,
    open,
    expandIconRef,
    actionsRef,
    treeItemRef,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    isActionsVisible,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    isAsideVisible,
    selectionRef,
    checked
  } = state;
  const treeItem = {
    value,
    checked,
    itemType,
    layoutRef,
    subtreeRef,
    open,
    selectionRef,
    isActionsVisible,
    isAsideVisible,
    actionsRef,
    treeItemRef,
    expandIconRef
  };
  return {
    treeItem
  };
}

// node_modules/@fluentui/react-tree/lib/components/TreeItem/TreeItem.js
var TreeItem = React431.forwardRef((props, ref) => {
  const state = useTreeItem_unstable(props, ref);
  useTreeItemStyles_unstable(state);
  useCustomStyleHook("useTreeItemStyles_unstable")(state);
  const contextValues = useTreeItemContextValues_unstable(state);
  return renderTreeItem_unstable(state, contextValues);
});
TreeItem.displayName = "TreeItem";

// node_modules/@fluentui/react-tree/lib/components/FlatTreeItem/FlatTreeItem.js
var FlatTreeItem = TreeItem;

// node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/TreeItemPersonaLayout.js
var React434 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/useTreeItemPersonaLayout.js
var React432 = __toESM(require_react());
var useTreeItemPersonaLayout_unstable = (props, ref) => {
  const { media, children: children2, main, description } = props;
  const treeItemLayoutState = useTreeItemLayout_unstable({
    ...props,
    iconBefore: null,
    iconAfter: null
  }, ref);
  const size3 = useTreeContext_unstable((ctx) => ctx.size);
  const selectionMode = useTreeContext_unstable((ctx) => ctx.selectionMode);
  return {
    ...treeItemLayoutState,
    components: {
      expandIcon: "div",
      main: "div",
      description: "div",
      root: "div",
      media: "div",
      aside: "div",
      actions: "div",
      // Casting here to a union between checkbox and radio
      selector: selectionMode === "multiselect" ? Checkbox : Radio
    },
    avatarSize: treeAvatarSize[size3],
    main: slot_exports.always(main, {
      defaultProps: {
        children: children2
      },
      elementType: "div"
    }),
    media: slot_exports.always(media, {
      elementType: "div"
    }),
    description: slot_exports.optional(description, {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/renderTreeItemPersonaLayout.js
var renderTreeItemPersonaLayout_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.expandIcon && jsx(state.expandIcon, {}),
      state.selector && jsx(state.selector, {}),
      jsx(AvatarContextProvider, {
        value: contextValues.avatar,
        children: jsx(state.media, {})
      }),
      jsx(state.main, {}),
      state.description && jsx(state.description, {}),
      jsxs(ButtonContextProvider, {
        value: state.buttonContextValue,
        children: [
          state.actions && jsx(state.actions, {}),
          state.aside && jsx(state.aside, {})
        ]
      })
    ]
  });
};

// node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/useTreeItemPersonaLayoutContextValues.js
var React433 = __toESM(require_react());
function useTreeItemPersonaLayoutContextValues_unstable(state) {
  const { avatarSize } = state;
  const avatar = React433.useMemo(() => ({
    size: avatarSize
  }), [
    avatarSize
  ]);
  return {
    avatar
  };
}

// node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/TreeItemPersonaLayout.js
var TreeItemPersonaLayout = React434.forwardRef((props, ref) => {
  const state = useTreeItemPersonaLayout_unstable(props, ref);
  useTreeItemPersonaLayoutStyles_unstable(state);
  useCustomStyleHook("useTreeItemPersonaLayoutStyles_unstable")(state);
  const contextValues = useTreeItemPersonaLayoutContextValues_unstable(state);
  return renderTreeItemPersonaLayout_unstable(state, contextValues);
});
TreeItemPersonaLayout.displayName = "TreeItemPersonaLayout";

// node_modules/@fluentui/react-tree/lib/utils/flattenTree.js
function flattenTreeRecursive(items, parent2, level = 1) {
  return items.reduce((acc, { subtree, ...item }, index) => {
    const flatTreeItem = {
      "aria-level": level,
      "aria-posinset": index + 1,
      "aria-setsize": items.length,
      parentValue: parent2 === null || parent2 === void 0 ? void 0 : parent2.value,
      ...item
    };
    acc.push(flatTreeItem);
    if (subtree !== void 0) {
      acc.push(...flattenTreeRecursive(subtree, flatTreeItem, level + 1));
    }
    return acc;
  }, []);
}
var flattenTree_unstable = (items) => flattenTreeRecursive(items);

// node_modules/@fluentui/react-tags/lib/components/Tag/Tag.js
var React438 = __toESM(require_react());

// node_modules/@fluentui/react-tags/lib/components/Tag/useTag.js
var React436 = __toESM(require_react());

// node_modules/@fluentui/react-tags/lib/contexts/tagGroupContext.js
var React435 = __toESM(require_react());
var TagGroupContext = React435.createContext(void 0);
var tagGroupContextDefaultValue = {
  handleTagDismiss: () => ({}),
  size: "medium",
  role: "toolbar",
  handleTagSelect: void 0
};
var TagGroupContextProvider = TagGroupContext.Provider;
var useTagGroupContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React435.useContext(TagGroupContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tagGroupContextDefaultValue;
};

// node_modules/@fluentui/react-tags/lib/components/Tag/useTag.js
var tagAvatarSizeMap = {
  medium: 28,
  small: 20,
  "extra-small": 16
};
var tagAvatarShapeMap = {
  rounded: "square",
  circular: "circular"
};
var useTag_unstable = (props, ref) => {
  const { handleTagDismiss, size: contextSize, disabled: contextDisabled, appearance: contextAppearance, dismissible: contextDismissible, role: tagGroupRole } = useTagGroupContext_unstable();
  const id = useId2("fui-Tag", props.id);
  const { appearance = contextAppearance !== null && contextAppearance !== void 0 ? contextAppearance : "filled", disabled = false, dismissible = contextDismissible !== null && contextDismissible !== void 0 ? contextDismissible : false, selected, shape = "rounded", size: size3 = contextSize, value = id } = props;
  const dismissOnClick = useEventCallback((ev) => {
    var _props_onClick;
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, ev);
    if (!ev.defaultPrevented) {
      handleTagDismiss === null || handleTagDismiss === void 0 ? void 0 : handleTagDismiss(ev, {
        value
      });
    }
  });
  const dismissOnKeyDown = useEventCallback((ev) => {
    var _props_onKeyDown;
    props === null || props === void 0 ? void 0 : (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, ev);
    if (!ev.defaultPrevented && (ev.key === Delete || ev.key === Backspace)) {
      handleTagDismiss === null || handleTagDismiss === void 0 ? void 0 : handleTagDismiss(ev, {
        value
      });
    }
  });
  const elementType = dismissible ? "button" : "span";
  const selectedProp = tagGroupRole === "listbox" ? "aria-selected" : "aria-pressed";
  const selectable = typeof selected === "boolean" || tagGroupRole === "listbox";
  return {
    appearance,
    avatarShape: tagAvatarShapeMap[shape],
    avatarSize: tagAvatarSizeMap[size3],
    disabled: contextDisabled ? true : disabled,
    dismissible,
    selected: !!selected,
    shape,
    size: size3,
    components: {
      root: elementType,
      media: "span",
      icon: "span",
      primaryText: "span",
      secondaryText: "span",
      dismissIcon: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps(elementType, {
      ref,
      role: tagGroupRole === "listbox" ? "option" : void 0,
      [selectedProp]: selectable ? selected : void 0,
      ...props,
      disabled: contextDisabled ? true : disabled,
      id,
      ...dismissible && {
        onClick: dismissOnClick,
        onKeyDown: dismissOnKeyDown
      }
    }), {
      defaultProps: {
        type: elementType === "button" ? "button" : void 0
      },
      elementType
    }),
    media: slot_exports.optional(props.media, {
      elementType: "span"
    }),
    icon: slot_exports.optional(props.icon, {
      elementType: "span"
    }),
    primaryText: slot_exports.optional(props.primaryText, {
      renderByDefault: true,
      defaultProps: {
        children: props.children
      },
      elementType: "span"
    }),
    secondaryText: slot_exports.optional(props.secondaryText, {
      elementType: "span"
    }),
    dismissIcon: slot_exports.optional(props.dismissIcon, {
      renderByDefault: dismissible,
      defaultProps: {
        children: React436.createElement(DismissRegular, null)
      },
      elementType: "span"
    })
  };
};

// node_modules/@fluentui/react-tags/lib/components/Tag/renderTag.js
var renderTag_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.media && jsx(AvatarContextProvider, {
        value: contextValues.avatar,
        children: jsx(state.media, {})
      }),
      state.icon && jsx(state.icon, {}),
      state.primaryText && jsx(state.primaryText, {}),
      state.secondaryText && jsx(state.secondaryText, {}),
      state.dismissIcon && state.dismissible && jsx(state.dismissIcon, {})
    ]
  });
};

// node_modules/@fluentui/react-tags/lib/components/Tag/useTagStyles.styles.js
var tagClassNames = {
  root: "fui-Tag",
  media: "fui-Tag__media",
  icon: "fui-Tag__icon",
  primaryText: "fui-Tag__primaryText",
  secondaryText: "fui-Tag__secondaryText",
  dismissIcon: "fui-Tag__dismissIcon"
};
var baseStyles = {
  // reset default button style:
  fontFamily: "inherit",
  padding: "0px",
  appearance: "button",
  textAlign: "unset",
  display: "inline-grid",
  alignItems: "center",
  gridTemplateAreas: `
  "media primary   dismissIcon"
  "media secondary dismissIcon"
  `,
  boxSizing: "border-box",
  width: "fit-content",
  border: `${tokens.strokeWidthThin} solid ${tokens.colorTransparentStroke}`
};
var useRootRoundedBaseClassName = __resetStyles("r18f5o0q", "r1u2q8zc", {
  r: ['.r18f5o0q{font-family:inherit;padding:0px;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;display:inline-grid;align-items:center;grid-template-areas:"media primary   dismissIcon" "media secondary dismissIcon";box-sizing:border-box;width:fit-content;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusMedium);}', ".r18f5o0q[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", '.r1u2q8zc{font-family:inherit;padding:0px;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;display:inline-grid;align-items:center;grid-template-areas:"media primary   dismissIcon" "media secondary dismissIcon";box-sizing:border-box;width:fit-content;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusMedium);}', ".r1u2q8zc[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}"],
  s: ['@media (forced-colors: active){.r18f5o0q{position:relative;}.r18f5o0q::before{content:"";border-top:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);}}', '@media (forced-colors: active){.r1u2q8zc{position:relative;}.r1u2q8zc::before{content:"";border-top:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);}}']
});
var useRootCircularBaseClassName = __resetStyles("r1mko7zc", "r1wx1e29", {
  r: ['.r1mko7zc{font-family:inherit;padding:0px;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;display:inline-grid;align-items:center;grid-template-areas:"media primary   dismissIcon" "media secondary dismissIcon";box-sizing:border-box;width:fit-content;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusCircular);}', ".r1mko7zc[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", '.r1wx1e29{font-family:inherit;padding:0px;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;display:inline-grid;align-items:center;grid-template-areas:"media primary   dismissIcon" "media secondary dismissIcon";box-sizing:border-box;width:fit-content;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusCircular);}', ".r1wx1e29[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}"],
  s: ['@media (forced-colors: active){.r1mko7zc{position:relative;}.r1mko7zc::before{content:"";border-top:var(--strokeWidthThin) solid;border-left:var(--strokeWidthThin) solid;border-right:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-radius:var(--borderRadiusCircular);}}', '@media (forced-colors: active){.r1wx1e29{position:relative;}.r1wx1e29::before{content:"";border-top:var(--strokeWidthThin) solid;border-right:var(--strokeWidthThin) solid;border-left:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-radius:var(--borderRadiusCircular);}}']
});
var useRootStyles20 = __styles2({
  filled: {
    De3pzq: "f16xq7d1",
    sj55zd: "fkfq4zb"
  },
  outline: {
    De3pzq: "fhovq9v",
    sj55zd: "fkfq4zb",
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"]
  },
  brand: {
    De3pzq: "f16xkysk",
    sj55zd: "faj9fo0"
  },
  selected: {
    De3pzq: "ffp7eso",
    sj55zd: "f1phragk",
    g2u3we: "fk9qgl1",
    h3c5rm: ["f1vfbj5f", "f1qpacp7"],
    B9xav0g: "fdf0ba2",
    zhjwy3: ["f1qpacp7", "f1vfbj5f"],
    ycbfsm: "fkc42ay",
    Bsw6fvg: "f1rirnrt",
    Bbusuzp: "f1lkg8j3"
  },
  medium: {
    Bqenvij: "f1d2rq10"
  },
  small: {
    Bqenvij: "frvgh55"
  },
  "extra-small": {
    qhf8xq: "f10pi13n",
    Bqenvij: "fjamq6b",
    Bkdsyek: "fqiv1u6",
    Brfojbq: "fl6l3ok",
    B1yn5a7: "fiuoxex",
    Bihq2av: ["f1f187wz", "f12z4n6f"],
    B2k102m: "fxnjm4l",
    B1l11lz: "fa2n458",
    Bgr9gxd: "f1nrpwwh"
  }
}, {
  d: [".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".faj9fo0{color:var(--colorBrandForeground2);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fk9qgl1{border-top-color:var(--colorBrandStroke1);}", ".f1vfbj5f{border-right-color:var(--colorBrandStroke1);}", ".f1qpacp7{border-left-color:var(--colorBrandStroke1);}", ".fdf0ba2{border-bottom-color:var(--colorBrandStroke1);}", ".f1d2rq10{height:32px;}", ".frvgh55{height:24px;}", ".f10pi13n{position:relative;}", ".fjamq6b{height:20px;}"],
  m: [["@media (forced-colors: active){.fkc42ay{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1rirnrt{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1lkg8j3{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ['@media (forced-colors: none){.fqiv1u6:before,.fqiv1u6:after{content:"";}}', {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fl6l3ok:before,.fl6l3ok:after{position:absolute;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fiuoxex:before,.fiuoxex:after{height:2px;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f12z4n6f:before,.f12z4n6f:after{right:0;}.f1f187wz:before,.f1f187wz:after{left:0;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fxnjm4l:before,.fxnjm4l:after{width:100%;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fa2n458:before{bottom:100%;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f1nrpwwh:after{top:100%;}}", {
    m: "(forced-colors: none)"
  }]]
});
var useRootDisabledStyles3 = __styles2({
  filled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o",
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f250w3l",
    zhjwy3: ["fziff3p", "f1mxt3zg"]
  },
  outline: {
    Bceei9c: "fdrzuqr",
    De3pzq: "fhovq9v",
    sj55zd: "f1s2aq7o",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"]
  },
  brand: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o",
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f250w3l",
    zhjwy3: ["fziff3p", "f1mxt3zg"]
  }
}, {
  d: [".fdrzuqr{cursor:not-allowed;}", ".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fgig46g{border-top-color:var(--colorTransparentStrokeDisabled);}", ".f1mxt3zg{border-right-color:var(--colorTransparentStrokeDisabled);}", ".fziff3p{border-left-color:var(--colorTransparentStrokeDisabled);}", ".f250w3l{border-bottom-color:var(--colorTransparentStrokeDisabled);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"]
});
var useRootWithoutMediaStyles = __styles2({
  medium: {
    uwmqm3: ["f1rtp3s9", "f18k1jr3"]
  },
  small: {
    uwmqm3: ["f15vdbe4", "fwiuce9"]
  },
  "extra-small": {
    uwmqm3: ["f15vdbe4", "fwiuce9"]
  }
}, {
  d: [".f1rtp3s9{padding-left:7px;}", ".f18k1jr3{padding-right:7px;}", ".f15vdbe4{padding-left:5px;}", ".fwiuce9{padding-right:5px;}"]
});
var useRootWithoutDismissStyles = __styles2({
  medium: {
    z189sj: ["f18k1jr3", "f1rtp3s9"]
  },
  small: {
    z189sj: ["fwiuce9", "f15vdbe4"]
  },
  "extra-small": {
    z189sj: ["fwiuce9", "f15vdbe4"]
  }
}, {
  d: [".f18k1jr3{padding-right:7px;}", ".f1rtp3s9{padding-left:7px;}", ".fwiuce9{padding-right:5px;}", ".f15vdbe4{padding-left:5px;}"]
});
var useIconStyles8 = __styles2({
  base: {
    Bw0ie65: 0,
    Br312pm: 0,
    nk6f5a: 0,
    Ijaq50: 0,
    Bq1tomu: "fujjg13",
    mc9l5x: "f22iagw",
    B7ck84d: "f1e4lqlz"
  },
  medium: {
    uwmqm3: ["f1rtp3s9", "f18k1jr3"],
    z189sj: ["f7x41pl", "fruq291"],
    a9b677: "f64fuq3",
    Be2twd7: "fe5j1ua"
  },
  small: {
    uwmqm3: ["f15vdbe4", "fwiuce9"],
    z189sj: ["ffczdla", "fgiv446"],
    a9b677: "fjw5fx7",
    Be2twd7: "f4ybsrx"
  },
  "extra-small": {
    uwmqm3: ["f15vdbe4", "fwiuce9"],
    z189sj: ["ffczdla", "fgiv446"],
    a9b677: "frx94fk",
    Be2twd7: "f1ugzwwg"
  }
}, {
  d: [[".fujjg13{grid-area:media;}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".f1e4lqlz{box-sizing:content-box;}", ".f1rtp3s9{padding-left:7px;}", ".f18k1jr3{padding-right:7px;}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f64fuq3{width:20px;}", ".fe5j1ua{font-size:20px;}", ".f15vdbe4{padding-left:5px;}", ".fwiuce9{padding-right:5px;}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}", ".fjw5fx7{width:16px;}", ".f4ybsrx{font-size:16px;}", ".frx94fk{width:12px;}", ".f1ugzwwg{font-size:12px;}"]
});
var useMediaStyles = __styles2({
  base: {
    Bw0ie65: 0,
    Br312pm: 0,
    nk6f5a: 0,
    Ijaq50: 0,
    Bq1tomu: "fujjg13",
    mc9l5x: "f22iagw",
    uwmqm3: ["f10xn8zz", "f136y8j8"]
  },
  medium: {
    z189sj: ["f1vdfbxk", "f1f5gg8d"]
  },
  small: {
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  "extra-small": {
    z189sj: ["fdw0yi8", "fk8j09s"]
  }
}, {
  d: [[".fujjg13{grid-area:media;}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".f10xn8zz{padding-left:1px;}", ".f136y8j8{padding-right:1px;}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}"]
});
var useDismissIconStyles = __styles2({
  base: {
    Bw0ie65: 0,
    Br312pm: 0,
    nk6f5a: 0,
    Ijaq50: 0,
    Bq1tomu: "f1k1gsvr",
    mc9l5x: "f22iagw",
    ze5xyy: "f4xjyn1",
    oy3o9n: "f1xtr1b3"
  },
  medium: {
    uwmqm3: ["fruq291", "f7x41pl"],
    z189sj: ["f18k1jr3", "f1rtp3s9"],
    Be2twd7: "fe5j1ua"
  },
  small: {
    uwmqm3: ["fgiv446", "ffczdla"],
    z189sj: ["fwiuce9", "f15vdbe4"],
    Be2twd7: "f4ybsrx"
  },
  "extra-small": {
    uwmqm3: ["fgiv446", "ffczdla"],
    z189sj: ["fwiuce9", "f15vdbe4"],
    Be2twd7: "f1ugzwwg"
  },
  filled: {
    eoavqd: "f8491dx",
    Bi91k9c: "f3ymbdj",
    lj723h: "fryz5bw"
  },
  outline: {
    eoavqd: "f8491dx",
    Bi91k9c: "f3ymbdj",
    lj723h: "fryz5bw"
  },
  brand: {
    eoavqd: "f8491dx",
    Bi91k9c: "f3ymbdj",
    lj723h: "fryz5bw"
  },
  selected: {
    Bi91k9c: "f1rq72xc",
    lj723h: "f18otbis"
  }
}, {
  d: [[".f1k1gsvr{grid-area:dismissIcon;}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".f18k1jr3{padding-right:7px;}", ".f1rtp3s9{padding-left:7px;}", ".fe5j1ua{font-size:20px;}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}", ".fwiuce9{padding-right:5px;}", ".f15vdbe4{padding-left:5px;}", ".f4ybsrx{font-size:16px;}", ".f1ugzwwg{font-size:12px;}"],
  m: [["@media (forced-colors: active){.f4xjyn1:hover{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1xtr1b3:active{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".f8491dx:hover{cursor:pointer;}", ".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}"],
  a: [".fryz5bw:active{color:var(--colorCompoundBrandForeground1Pressed);}", ".f18otbis:active{color:var(--colorNeutralForegroundOnBrand);}"]
});
var usePrimaryTextStyles = __styles2({
  base: {
    Huce71: "fz5stix",
    uwmqm3: ["fgiv446", "ffczdla"],
    z189sj: ["ffczdla", "fgiv446"]
  },
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  small: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  "extra-small": {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  withoutSecondaryText: {
    Br312pm: "faqcfhe",
    Ijaq50: "f1q3ipgb",
    nk6f5a: "fc0ab3q",
    Byoj8tv: "f1g03r3y"
  },
  withSecondaryText: {
    Bw0ie65: 0,
    Br312pm: 0,
    nk6f5a: 0,
    Ijaq50: 0,
    Bq1tomu: "f1ebragv",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    B6of3ja: "f1ryq6si"
  }
}, {
  d: [".fz5stix{white-space:nowrap;}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".faqcfhe{grid-column-start:primary;}", ".f1q3ipgb{grid-row-start:primary;}", ".fc0ab3q{grid-row-end:secondary;}", ".f1g03r3y{padding-bottom:var(--spacingHorizontalXXS);}", [".f1ebragv{grid-area:primary;}", {
    p: -1
  }], ".f1ryq6si{margin-top:-2px;}"]
});
var useSecondaryTextBaseClassName2 = __resetStyles("r7hv1ps", "rnrslm9", [".r7hv1ps{grid-area:secondary;padding-left:var(--spacingHorizontalXXS);padding-right:var(--spacingHorizontalXXS);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase100);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase100);white-space:nowrap;}", ".rnrslm9{grid-area:secondary;padding-right:var(--spacingHorizontalXXS);padding-left:var(--spacingHorizontalXXS);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase100);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase100);white-space:nowrap;}"]);
var useTagStyles_unstable = (state) => {
  "use no memo";
  const rootRoundedBaseClassName = useRootRoundedBaseClassName();
  const rootCircularBaseClassName = useRootCircularBaseClassName();
  const rootStyles = useRootStyles20();
  const rootDisabledStyles = useRootDisabledStyles3();
  const rootWithoutMediaStyles = useRootWithoutMediaStyles();
  const rootWithoutDismissStyles = useRootWithoutDismissStyles();
  const iconStyles = useIconStyles8();
  const mediaStyles = useMediaStyles();
  const dismissIconStyles = useDismissIconStyles();
  const primaryTextStyles = usePrimaryTextStyles();
  const secondaryTextBaseClassName = useSecondaryTextBaseClassName2();
  const {
    disabled,
    shape,
    size: size3,
    appearance,
    selected
  } = state;
  state.root.className = mergeClasses(tagClassNames.root, shape === "rounded" ? rootRoundedBaseClassName : rootCircularBaseClassName, disabled ? rootDisabledStyles[appearance] : rootStyles[appearance], selected && !disabled && rootStyles.selected, rootStyles[size3], !state.media && !state.icon && rootWithoutMediaStyles[size3], !state.dismissIcon && rootWithoutDismissStyles[size3], state.root.className);
  if (state.media) {
    state.media.className = mergeClasses(tagClassNames.media, mediaStyles.base, mediaStyles[size3], state.media.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(tagClassNames.icon, iconStyles.base, iconStyles[size3], state.icon.className);
  }
  if (state.primaryText) {
    state.primaryText.className = mergeClasses(tagClassNames.primaryText, primaryTextStyles.base, primaryTextStyles[size3], state.secondaryText ? primaryTextStyles.withSecondaryText : primaryTextStyles.withoutSecondaryText, state.primaryText.className);
  }
  if (state.secondaryText) {
    state.secondaryText.className = mergeClasses(tagClassNames.secondaryText, secondaryTextBaseClassName, state.secondaryText.className);
  }
  if (state.dismissIcon) {
    state.dismissIcon.className = mergeClasses(tagClassNames.dismissIcon, dismissIconStyles.base, dismissIconStyles[size3], !disabled && dismissIconStyles[appearance], selected && !disabled && dismissIconStyles.selected, state.dismissIcon.className);
  }
  return state;
};

// node_modules/@fluentui/react-tags/lib/utils/useTagAvatarContextValues.js
var React437 = __toESM(require_react());
function useTagAvatarContextValues_unstable(state) {
  const { avatarSize, avatarShape } = state;
  const avatar = React437.useMemo(() => ({
    size: avatarSize,
    shape: avatarShape
  }), [
    avatarShape,
    avatarSize
  ]);
  return {
    avatar
  };
}

// node_modules/@fluentui/react-tags/lib/components/Tag/Tag.js
var Tag = React438.forwardRef((props, ref) => {
  const state = useTag_unstable(props, ref);
  useTagStyles_unstable(state);
  useCustomStyleHook("useTagStyles_unstable")(state);
  return renderTag_unstable(state, useTagAvatarContextValues_unstable(state));
});
Tag.displayName = "Tag";

// node_modules/@fluentui/react-tags/lib/components/InteractionTag/InteractionTag.js
var React442 = __toESM(require_react());

// node_modules/@fluentui/react-tags/lib/components/InteractionTag/useInteractionTag.js
var React439 = __toESM(require_react());
var useInteractionTag_unstable = (props, ref) => {
  const { handleTagDismiss, handleTagSelect, size: contextSize, disabled: contextDisabled, appearance: contextAppearance, selectedValues = [] } = useTagGroupContext_unstable();
  const id = useId2("fui-InteractionTag-", props.id);
  const interactionTagPrimaryId = useId2("fui-InteractionTagPrimary-");
  const { appearance = contextAppearance !== null && contextAppearance !== void 0 ? contextAppearance : "filled", disabled = false, selected = false, shape = "rounded", size: size3 = contextSize, value = id } = props;
  return {
    appearance,
    disabled: contextDisabled ? true : disabled,
    handleTagDismiss,
    handleTagSelect,
    interactionTagPrimaryId,
    selected: selectedValues.includes(value) || selected,
    selectedValues,
    shape,
    size: size3,
    value,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props,
      disabled: contextDisabled ? true : disabled,
      id
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-tags/lib/contexts/interactionTagContext.js
var React440 = __toESM(require_react());
var InteractionTagContext = React440.createContext(void 0);
var interactionTagContextDefaultValue = {
  appearance: "filled",
  disabled: false,
  handleTagDismiss: () => ({}),
  handleTagSelect: () => ({}),
  interactionTagPrimaryId: "",
  selected: false,
  selectedValues: [],
  shape: "rounded",
  size: "medium",
  value: ""
};
var InteractionTagContextProvider = InteractionTagContext.Provider;
var useInteractionTagContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React440.useContext(InteractionTagContext)) !== null && _React_useContext !== void 0 ? _React_useContext : interactionTagContextDefaultValue;
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTag/renderInteractionTag.js
var renderInteractionTag_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(InteractionTagContextProvider, {
    value: contextValues.interactionTag,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTag/useInteractionTagStyles.styles.js
var interactionTagClassNames = {
  root: "fui-InteractionTag"
};
var useRootBaseClassName12 = __resetStyles("r1y684pp", null, [".r1y684pp{display:inline-flex;align-items:center;box-sizing:border-box;width:fit-content;}"]);
var useRootStyles21 = __styles2({
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9"
  },
  medium: {
    Bqenvij: "f1d2rq10"
  },
  small: {
    Bqenvij: "frvgh55"
  },
  "extra-small": {
    Bqenvij: "fjamq6b"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".f1d2rq10{height:32px;}", ".frvgh55{height:24px;}", ".fjamq6b{height:20px;}"]
});
var useInteractionTagStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName12();
  const rootStyles = useRootStyles21();
  const {
    shape,
    size: size3
  } = state;
  state.root.className = mergeClasses(interactionTagClassNames.root, rootBaseClassName, rootStyles[shape], rootStyles[size3], state.root.className);
  return state;
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTag/useInteractionTagContextValues.js
var React441 = __toESM(require_react());
function useInteractionTagContextValues_unstable(state) {
  const { appearance, disabled, handleTagDismiss, handleTagSelect, interactionTagPrimaryId, selected, selectedValues, shape, size: size3, value } = state;
  return {
    interactionTag: React441.useMemo(() => ({
      appearance,
      disabled,
      handleTagDismiss,
      handleTagSelect,
      interactionTagPrimaryId,
      selected,
      selectedValues,
      shape,
      size: size3,
      value
    }), [
      appearance,
      disabled,
      handleTagDismiss,
      handleTagSelect,
      interactionTagPrimaryId,
      selected,
      selectedValues,
      shape,
      size3,
      value
    ])
  };
}

// node_modules/@fluentui/react-tags/lib/components/InteractionTag/InteractionTag.js
var InteractionTag = React442.forwardRef((props, ref) => {
  const state = useInteractionTag_unstable(props, ref);
  useInteractionTagStyles_unstable(state);
  useCustomStyleHook("useInteractionTagStyles_unstable")(state);
  return renderInteractionTag_unstable(state, useInteractionTagContextValues_unstable(state));
});
InteractionTag.displayName = "InteractionTag";

// node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/InteractionTagPrimary.js
var React444 = __toESM(require_react());

// node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/useInteractionTagPrimary.js
var React443 = __toESM(require_react());
var avatarSizeMap = {
  medium: 28,
  small: 20,
  "extra-small": 16
};
var avatarShapeMap = {
  rounded: "square",
  circular: "circular"
};
var useInteractionTagPrimary_unstable = (props, ref) => {
  const { appearance, disabled, handleTagSelect, interactionTagPrimaryId, selected: contextSelected, selectedValues, shape, size: size3, value } = useInteractionTagContext_unstable();
  const { hasSecondaryAction = false } = props;
  const onClick = useEventCallback(mergeCallbacks(props === null || props === void 0 ? void 0 : props.onClick, (event) => handleTagSelect === null || handleTagSelect === void 0 ? void 0 : handleTagSelect(event, {
    type: "click",
    event,
    value,
    selectedValues
  })));
  return {
    appearance,
    avatarShape: avatarShapeMap[shape],
    avatarSize: avatarSizeMap[size3],
    disabled,
    hasSecondaryAction,
    selected: contextSelected,
    shape,
    size: size3,
    components: {
      root: "button",
      media: "span",
      icon: "span",
      primaryText: "span",
      secondaryText: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      ref,
      disabled,
      id: interactionTagPrimaryId,
      ...handleTagSelect !== void 0 && {
        "aria-pressed": contextSelected
      },
      onClick,
      ...props
    }), {
      elementType: "button"
    }),
    media: slot_exports.optional(props.media, {
      elementType: "span"
    }),
    icon: slot_exports.optional(props.icon, {
      elementType: "span"
    }),
    primaryText: slot_exports.optional(props.primaryText, {
      renderByDefault: true,
      defaultProps: {
        children: props.children
      },
      elementType: "span"
    }),
    secondaryText: slot_exports.optional(props.secondaryText, {
      elementType: "span"
    })
  };
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/renderInteractionTagPrimary.js
var renderInteractionTagPrimary_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.media && jsx(AvatarContextProvider, {
        value: contextValues.avatar,
        children: jsx(state.media, {})
      }),
      state.icon && jsx(state.icon, {}),
      state.primaryText && jsx(state.primaryText, {}),
      state.secondaryText && jsx(state.secondaryText, {})
    ]
  });
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/useInteractionTagPrimaryStyles.styles.js
var interactionTagPrimaryClassNames = {
  root: "fui-InteractionTagPrimary",
  media: "fui-InteractionTagPrimary__media",
  icon: "fui-InteractionTagPrimary__icon",
  primaryText: "fui-InteractionTagPrimary__primaryText",
  secondaryText: "fui-InteractionTagPrimary__secondaryText"
};
var baseStyles2 = {
  // reset default button style:
  color: "inherit",
  fontFamily: "inherit",
  padding: "0px",
  borderStyle: "none",
  appearance: "button",
  textAlign: "unset",
  backgroundColor: "transparent",
  display: "inline-grid",
  height: "100%",
  alignItems: "center",
  gridTemplateAreas: `
  "media primary  "
  "media secondary"
  `,
  border: `${tokens.strokeWidthThin} solid ${tokens.colorTransparentStroke}`,
  ...createCustomFocusIndicatorStyle({
    outline: `${tokens.strokeWidthThick} solid ${tokens.colorStrokeFocus2}`,
    zIndex: 1
  })
};
var useRootRoundedBaseClassName2 = __resetStyles("r22quyo", "r1yd8tpa", {
  r: ['.r22quyo{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:inline-grid;height:100%;align-items:center;grid-template-areas:"media primary  " "media secondary";border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusMedium);}', ".r22quyo[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);z-index:1;}", '.r1yd8tpa{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:inline-grid;height:100%;align-items:center;grid-template-areas:"media primary  " "media secondary";border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusMedium);}', ".r1yd8tpa[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);z-index:1;}"],
  s: ['@media (forced-colors: active){.r22quyo{position:relative;}.r22quyo::before{content:"";border-top:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);}}', '@media (forced-colors: active){.r1yd8tpa{position:relative;}.r1yd8tpa::before{content:"";border-top:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);}}']
});
var useRootCircularBaseClassName2 = __resetStyles("r132q0f6", "r15qe99u", {
  r: ['.r132q0f6{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:inline-grid;height:100%;align-items:center;grid-template-areas:"media primary  " "media secondary";border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusCircular);}', ".r132q0f6[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);z-index:1;}", '.r15qe99u{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:inline-grid;height:100%;align-items:center;grid-template-areas:"media primary  " "media secondary";border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusCircular);}', ".r15qe99u[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);z-index:1;}"],
  s: ['@media (forced-colors: active){.r132q0f6{position:relative;}.r132q0f6::before{content:"";border-top:var(--strokeWidthThin) solid;border-left:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-left-radius:var(--borderRadiusCircular);border-bottom-left-radius:var(--borderRadiusCircular);}}', '@media (forced-colors: active){.r15qe99u{position:relative;}.r15qe99u::before{content:"";border-top:var(--strokeWidthThin) solid;border-right:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-right-radius:var(--borderRadiusCircular);border-bottom-right-radius:var(--borderRadiusCircular);}}']
});
var useRootCircularContrastStyles = __styles2({
  withoutSecondaryAction: {
    Bglfifq: "ff3fe07",
    hxi8he: 0,
    B33s42s: 0,
    G4pote: 0,
    gw1m2h: ["f19rnj73", "f1jjg5yc"],
    w20ur: ["f6k8nl2", "f1ik0cvg"],
    Byczuf6: ["f10f1qdh", "fmb7qm7"]
  }
}, {
  m: [["@media (forced-colors: active){.ff3fe07{position:relative;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f19rnj73::before{border-right:var(--strokeWidthThin) solid transparent;}.f1jjg5yc::before{border-left:var(--strokeWidthThin) solid transparent;}}", {
    p: -1,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ik0cvg::before{border-top-left-radius:var(--borderRadiusCircular);}.f6k8nl2::before{border-top-right-radius:var(--borderRadiusCircular);}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f10f1qdh::before{border-bottom-right-radius:var(--borderRadiusCircular);}.fmb7qm7::before{border-bottom-left-radius:var(--borderRadiusCircular);}}", {
    m: "(forced-colors: active)"
  }]]
});
var useRootStyles22 = __styles2({
  filled: {
    De3pzq: "f16xq7d1",
    sj55zd: "fkfq4zb",
    eoavqd: "f8491dx",
    Jwef8y: "f1h648pw",
    Bi91k9c: "fnwyq0v",
    ecr2s2: "fwdzr64",
    lj723h: "flvvhsy",
    Bqrx1nm: "fq7113v",
    kx9iu6: "fp3oj7s"
  },
  outline: {
    De3pzq: "fhovq9v",
    sj55zd: "fkfq4zb",
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"],
    eoavqd: "f8491dx",
    Jwef8y: "f1t94bn6",
    Bi91k9c: "fnwyq0v",
    Bk3fhr4: "ft1hn21",
    I6i3kg: "fqbfmpb",
    Bmfj8id: "fuxngvv",
    ecr2s2: "f1wfn5kd",
    lj723h: "flvvhsy",
    Bnrwwps: "fvpl5sy",
    weioyw: "f1xblose",
    Bpre390: "f8upcvr",
    Bqrx1nm: "fq7113v",
    kx9iu6: "fp3oj7s"
  },
  brand: {
    De3pzq: "f16xkysk",
    sj55zd: "faj9fo0",
    eoavqd: "f8491dx",
    Jwef8y: "f1yj72w4",
    Bi91k9c: "f3ymbdj",
    ecr2s2: "fy3sl2y",
    lj723h: "fryz5bw",
    Bqrx1nm: "fq7113v",
    kx9iu6: "fp3oj7s"
  },
  selected: {
    Bgh53k4: 0,
    B2eet1l: 0,
    De3pzq: 0,
    Bcmaq0h: 0,
    gk0gix: 0,
    B20660r: 0,
    B8a6bjv: 0,
    Bpptf2m: 0,
    e5kdtc: 0,
    Bkjc3bi: 0,
    ayd6f0: "f1tdnksq",
    sj55zd: "f1phragk",
    g2u3we: "fk9qgl1",
    h3c5rm: ["f1vfbj5f", "f1qpacp7"],
    B9xav0g: "fdf0ba2",
    zhjwy3: ["f1qpacp7", "f1vfbj5f"],
    ycbfsm: "fkc42ay",
    Bsw6fvg: "f1rirnrt",
    Bbusuzp: "f1lkg8j3",
    Jwef8y: "f15wkkf3",
    Bi91k9c: "f1rq72xc",
    I6i3kg: "f10jvnl4",
    Bqrx1nm: "fiu8gst",
    ze5xyy: "f1byx217",
    ecr2s2: "fsp1bjw",
    lj723h: "f18otbis",
    weioyw: "f3wpj5r",
    kx9iu6: "fkk6lp6",
    oy3o9n: "f1ojl2j2"
  },
  medium: {
    z189sj: ["f18k1jr3", "f1rtp3s9"]
  },
  small: {
    z189sj: ["fwiuce9", "f15vdbe4"]
  },
  "extra-small": {
    z189sj: ["fwiuce9", "f15vdbe4"],
    qhf8xq: "f10pi13n",
    Bkdsyek: "fqiv1u6",
    Brfojbq: "fl6l3ok",
    B1yn5a7: "fiuoxex",
    Bihq2av: ["f1f187wz", "f12z4n6f"],
    B2k102m: "fxnjm4l",
    B1l11lz: "fa2n458",
    Bgr9gxd: "f1nrpwwh"
  }
}, {
  d: [".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".faj9fo0{color:var(--colorBrandForeground2);}", [".f1tdnksq{background:var(--colorBrandBackground);}", {
    p: -2
  }], ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fk9qgl1{border-top-color:var(--colorBrandStroke1);}", ".f1vfbj5f{border-right-color:var(--colorBrandStroke1);}", ".f1qpacp7{border-left-color:var(--colorBrandStroke1);}", ".fdf0ba2{border-bottom-color:var(--colorBrandStroke1);}", ".f18k1jr3{padding-right:7px;}", ".f1rtp3s9{padding-left:7px;}", ".fwiuce9{padding-right:5px;}", ".f15vdbe4{padding-left:5px;}", ".f10pi13n{position:relative;}"],
  h: [".f8491dx:hover{cursor:pointer;}", ".f1h648pw:hover{background-color:var(--colorNeutralBackground3Hover);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".ft1hn21:hover .fui-Icon-filled{display:inline;}", ".fqbfmpb:hover .fui-Icon-filled{color:var(--colorNeutralForeground2BrandHover);}", ".fuxngvv:hover .fui-Icon-regular{display:none;}", ".f1yj72w4:hover{background-color:var(--colorBrandBackground2Hover);}", ".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}", ".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}", ".f10jvnl4:hover .fui-Icon-filled{color:var(--colorNeutralForegroundOnBrand);}"],
  a: [".fwdzr64:active{background-color:var(--colorNeutralBackground3Pressed);}", ".flvvhsy:active{color:var(--colorNeutralForeground2Pressed);}", ".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}", ".fvpl5sy:active .fui-Icon-filled{display:inline;}", ".f1xblose:active .fui-Icon-filled{color:var(--colorNeutralForeground2BrandPressed);}", ".f8upcvr:active .fui-Icon-regular{display:none;}", ".fy3sl2y:active{background-color:var(--colorBrandBackground2Pressed);}", ".fryz5bw:active{color:var(--colorCompoundBrandForeground1Pressed);}", ".fsp1bjw:active{background-color:var(--colorBrandBackgroundPressed);}", ".f18otbis:active{color:var(--colorNeutralForegroundOnBrand);}", ".f3wpj5r:active .fui-Icon-filled{color:var(--colorNeutralForegroundOnBrand);}"],
  m: [["@media (forced-colors: active){.fq7113v:hover{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fp3oj7s:active{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fkc42ay{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1rirnrt{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1lkg8j3{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fiu8gst:hover{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1byx217:hover{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fkk6lp6:active{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ojl2j2:active{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ['@media (forced-colors: none){.fqiv1u6:before,.fqiv1u6:after{content:"";}}', {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fl6l3ok:before,.fl6l3ok:after{position:absolute;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fiuoxex:before,.fiuoxex:after{height:2px;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f12z4n6f:before,.f12z4n6f:after{right:0;}.f1f187wz:before,.f1f187wz:after{left:0;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fxnjm4l:before,.fxnjm4l:after{width:100%;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fa2n458:before{bottom:100%;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f1nrpwwh:after{top:100%;}}", {
    m: "(forced-colors: none)"
  }]]
});
var useRootDisabledAppearances = __styles2({
  filled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o",
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f250w3l",
    zhjwy3: ["fziff3p", "f1mxt3zg"]
  },
  outline: {
    Bceei9c: "fdrzuqr",
    De3pzq: "fhovq9v",
    sj55zd: "f1s2aq7o",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"]
  },
  brand: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o",
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f250w3l",
    zhjwy3: ["fziff3p", "f1mxt3zg"]
  }
}, {
  d: [".fdrzuqr{cursor:not-allowed;}", ".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fgig46g{border-top-color:var(--colorTransparentStrokeDisabled);}", ".f1mxt3zg{border-right-color:var(--colorTransparentStrokeDisabled);}", ".fziff3p{border-left-color:var(--colorTransparentStrokeDisabled);}", ".f250w3l{border-bottom-color:var(--colorTransparentStrokeDisabled);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"]
});
var useRootWithoutMediaStyles2 = __styles2({
  medium: {
    uwmqm3: ["f1rtp3s9", "f18k1jr3"]
  },
  small: {
    uwmqm3: ["f15vdbe4", "fwiuce9"]
  },
  "extra-small": {
    uwmqm3: ["f15vdbe4", "fwiuce9"]
  }
}, {
  d: [".f1rtp3s9{padding-left:7px;}", ".f18k1jr3{padding-right:7px;}", ".f15vdbe4{padding-left:5px;}", ".fwiuce9{padding-right:5px;}"]
});
var useRootWithSecondaryActionStyles = __styles2({
  base: {
    B7oj6ja: ["f3fg2lr", "f13av6d4"],
    Bbmb7ep: ["fzi6hpg", "fyowgf4"],
    vrafjx: ["f1n71otn", "f1deefiw"],
    B6xbmo0: ["f146y5a9", "f1k2ftg"],
    kdpuga: ["f1ndz5i7", "f1co4qro"],
    w20ur: ["fjoni7s", "f1xmedr4"]
  },
  medium: {
    z189sj: ["f1vdfbxk", "f1f5gg8d"]
  },
  small: {
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  "extra-small": {
    z189sj: ["fdw0yi8", "fk8j09s"]
  }
}, {
  d: [".f3fg2lr{border-top-right-radius:var(--borderRadiusNone);}", ".f13av6d4{border-top-left-radius:var(--borderRadiusNone);}", ".fzi6hpg{border-bottom-right-radius:var(--borderRadiusNone);}", ".fyowgf4{border-bottom-left-radius:var(--borderRadiusNone);}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f146y5a9[data-fui-focus-visible]{border-top-right-radius:var(--borderRadiusNone);}", ".f1k2ftg[data-fui-focus-visible]{border-top-left-radius:var(--borderRadiusNone);}", ".f1ndz5i7[data-fui-focus-visible]{border-bottom-right-radius:var(--borderRadiusNone);}", ".f1co4qro[data-fui-focus-visible]{border-bottom-left-radius:var(--borderRadiusNone);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}"],
  m: [["@media (forced-colors: active){.f1xmedr4::before{border-top-left-radius:0;}.fjoni7s::before{border-top-right-radius:0;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useInteractionTagPrimaryStyles_unstable = (state) => {
  "use no memo";
  const rootRoundedBaseClassName = useRootRoundedBaseClassName2();
  const rootCircularBaseClassName = useRootCircularBaseClassName2();
  const rootStyles = useRootStyles22();
  const rootDisabledAppearances = useRootDisabledAppearances();
  const rootWithoutMediaStyles = useRootWithoutMediaStyles2();
  const rootWithSecondaryActionStyles = useRootWithSecondaryActionStyles();
  const iconStyles = useIconStyles8();
  const mediaStyles = useMediaStyles();
  const primaryTextStyles = usePrimaryTextStyles();
  const secondaryTextBaseClassName = useSecondaryTextBaseClassName2();
  const rootCircularContrastStyles = useRootCircularContrastStyles();
  const {
    disabled,
    shape,
    size: size3,
    appearance,
    selected
  } = state;
  state.root.className = mergeClasses(interactionTagPrimaryClassNames.root, shape === "rounded" ? rootRoundedBaseClassName : rootCircularBaseClassName, shape === "circular" && !state.hasSecondaryAction && rootCircularContrastStyles.withoutSecondaryAction, disabled ? rootDisabledAppearances[appearance] : rootStyles[appearance], selected && !disabled && rootStyles.selected, rootStyles[size3], !state.media && !state.icon && rootWithoutMediaStyles[size3], state.hasSecondaryAction && rootWithSecondaryActionStyles.base, state.hasSecondaryAction && rootWithSecondaryActionStyles[size3], state.root.className);
  if (state.media) {
    state.media.className = mergeClasses(interactionTagPrimaryClassNames.media, mediaStyles.base, mediaStyles[size3], state.media.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(interactionTagPrimaryClassNames.icon, iconStyles.base, iconStyles[size3], state.icon.className);
  }
  if (state.primaryText) {
    state.primaryText.className = mergeClasses(interactionTagPrimaryClassNames.primaryText, primaryTextStyles.base, primaryTextStyles[size3], state.secondaryText ? primaryTextStyles.withSecondaryText : primaryTextStyles.withoutSecondaryText, state.primaryText.className);
  }
  if (state.secondaryText) {
    state.secondaryText.className = mergeClasses(interactionTagPrimaryClassNames.secondaryText, secondaryTextBaseClassName, state.secondaryText.className);
  }
  return state;
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/InteractionTagPrimary.js
var InteractionTagPrimary = React444.forwardRef((props, ref) => {
  const state = useInteractionTagPrimary_unstable(props, ref);
  useInteractionTagPrimaryStyles_unstable(state);
  useCustomStyleHook("useInteractionTagPrimaryStyles_unstable")(state);
  return renderInteractionTagPrimary_unstable(state, useTagAvatarContextValues_unstable(state));
});
InteractionTagPrimary.displayName = "InteractionTagPrimary";

// node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/InteractionTagSecondary.js
var React446 = __toESM(require_react());

// node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/useInteractionTagSecondary.js
var React445 = __toESM(require_react());
var useInteractionTagSecondary_unstable = (props, ref) => {
  const { appearance, disabled, handleTagDismiss, interactionTagPrimaryId, selected, shape, size: size3, value } = useInteractionTagContext_unstable();
  const id = useId2("fui-InteractionTagSecondary-", props.id);
  const onClick = useEventCallback((ev) => {
    var _props_onClick;
    props === null || props === void 0 ? void 0 : (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, ev);
    if (!ev.defaultPrevented) {
      handleTagDismiss === null || handleTagDismiss === void 0 ? void 0 : handleTagDismiss(ev, {
        value
      });
    }
  });
  const onKeyDown = useEventCallback((ev) => {
    var _props_onKeyDown;
    props === null || props === void 0 ? void 0 : (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, ev);
    if (!ev.defaultPrevented && (ev.key === Delete || ev.key === Backspace)) {
      handleTagDismiss === null || handleTagDismiss === void 0 ? void 0 : handleTagDismiss(ev, {
        value
      });
    }
  });
  return {
    appearance,
    disabled,
    selected,
    shape,
    size: size3,
    components: {
      root: "button"
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      children: React445.createElement(DismissRegular, null),
      type: "button",
      disabled,
      ref,
      "aria-labelledby": `${interactionTagPrimaryId} ${id}`,
      ...props,
      id,
      onClick,
      onKeyDown
    }), {
      elementType: "button"
    })
  };
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/renderInteractionTagSecondary.js
var renderInteractionTagSecondary_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/useInteractionTagSecondaryStyles.styles.js
var interactionTagSecondaryClassNames = {
  root: "fui-InteractionTagSecondary"
};
var useRootBaseClassName13 = __resetStyles("rxqbxwz", "rdjx360", [".rxqbxwz{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:flex;height:100%;align-items:center;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-left-color:var(--colorNeutralStroke1);border-top-left-radius:var(--borderRadiusNone);border-bottom-left-radius:var(--borderRadiusNone);}", ".rxqbxwz[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", ".rdjx360{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:flex;height:100%;align-items:center;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-right-color:var(--colorNeutralStroke1);border-top-right-radius:var(--borderRadiusNone);border-bottom-right-radius:var(--borderRadiusNone);}", ".rdjx360[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}"]);
var useRootStyles23 = __styles2({
  filled: {
    De3pzq: "f16xq7d1",
    sj55zd: "fkfq4zb",
    B4j52fo: "fre7gi1",
    Bn0qgzm: "fqdk4by",
    eoavqd: "f8491dx",
    Jwef8y: "f1h648pw",
    Bi91k9c: "f139oj5f",
    ecr2s2: "fwdzr64",
    lj723h: "f19au66r",
    gwxt9v: "fah2lgh",
    Bc736ss: "fx7har",
    Bqrx1nm: "fq7113v",
    kx9iu6: "fp3oj7s"
  },
  outline: {
    De3pzq: "fhovq9v",
    sj55zd: "fkfq4zb",
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"],
    eoavqd: "f8491dx",
    Jwef8y: "f1t94bn6",
    Bi91k9c: "f139oj5f",
    ecr2s2: "f1wfn5kd",
    lj723h: "f19au66r",
    Bqrx1nm: "fq7113v",
    kx9iu6: "fp3oj7s"
  },
  brand: {
    De3pzq: "f16xkysk",
    sj55zd: "faj9fo0",
    zhjwy3: ["f1sl6hi9", "f1c8dzaj"],
    B4j52fo: "fre7gi1",
    Bn0qgzm: "fqdk4by",
    eoavqd: "f8491dx",
    Jwef8y: "f1yj72w4",
    Bi91k9c: "f3ymbdj",
    ecr2s2: "fy3sl2y",
    lj723h: "fryz5bw",
    gwxt9v: "fah2lgh",
    Bc736ss: "fx7har",
    Bqrx1nm: "fq7113v",
    kx9iu6: "fp3oj7s"
  },
  selected: {
    Bgh53k4: 0,
    B2eet1l: 0,
    De3pzq: 0,
    Bcmaq0h: 0,
    gk0gix: 0,
    B20660r: 0,
    B8a6bjv: 0,
    Bpptf2m: 0,
    e5kdtc: 0,
    Bkjc3bi: 0,
    ayd6f0: "f1tdnksq",
    sj55zd: "f1phragk",
    g2u3we: "fk9qgl1",
    h3c5rm: ["f1vfbj5f", "f1qpacp7"],
    B9xav0g: "fdf0ba2",
    zhjwy3: ["f4j9k2g", "f1mg2euo"],
    ycbfsm: "fkc42ay",
    Bsw6fvg: "f1rirnrt",
    Bbusuzp: "f1lkg8j3",
    Jwef8y: "f15wkkf3",
    Bi91k9c: "f1rq72xc",
    Bqrx1nm: "fiu8gst",
    ze5xyy: "f1byx217",
    ecr2s2: "fsp1bjw",
    lj723h: "f18otbis",
    kx9iu6: "fkk6lp6",
    oy3o9n: "f1ojl2j2"
  },
  rounded: {
    B7oj6ja: ["f1jar5jt", "fyu767a"],
    Bbmb7ep: ["f1aa9q02", "f16jpd5f"]
  },
  circular: {
    B7oj6ja: ["f1djnp8u", "f1s8kh49"],
    Bbmb7ep: ["f8fbkgy", "f1nfllo7"]
  },
  medium: {
    Be2twd7: "fe5j1ua",
    uwmqm3: ["f15vdbe4", "fwiuce9"],
    z189sj: ["fwiuce9", "f15vdbe4"]
  },
  small: {
    Be2twd7: "f4ybsrx",
    uwmqm3: ["f2lugmd", "f6zblan"],
    z189sj: ["f6zblan", "f2lugmd"]
  },
  "extra-small": {
    Be2twd7: "f1ugzwwg",
    uwmqm3: ["f15vdbe4", "fwiuce9"],
    z189sj: ["fwiuce9", "f15vdbe4"],
    qhf8xq: "f10pi13n",
    Bkdsyek: "fqiv1u6",
    Brfojbq: "fl6l3ok",
    B1yn5a7: "fiuoxex",
    Bihq2av: ["f1f187wz", "f12z4n6f"],
    B2k102m: "fxnjm4l",
    B1l11lz: "fa2n458",
    Bgr9gxd: "f1nrpwwh"
  }
}, {
  d: [".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".fre7gi1{border-top-width:0;}", ".fqdk4by{border-bottom-width:0;}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".faj9fo0{color:var(--colorBrandForeground2);}", ".f1sl6hi9{border-left-color:var(--colorBrandStroke2);}", ".f1c8dzaj{border-right-color:var(--colorBrandStroke2);}", [".f1tdnksq{background:var(--colorBrandBackground);}", {
    p: -2
  }], ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fk9qgl1{border-top-color:var(--colorBrandStroke1);}", ".f1vfbj5f{border-right-color:var(--colorBrandStroke1);}", ".f1qpacp7{border-left-color:var(--colorBrandStroke1);}", ".fdf0ba2{border-bottom-color:var(--colorBrandStroke1);}", ".f4j9k2g{border-left-color:var(--colorNeutralStrokeOnBrand2);}", ".f1mg2euo{border-right-color:var(--colorNeutralStrokeOnBrand2);}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1djnp8u{border-top-right-radius:var(--borderRadiusCircular);}", ".f1s8kh49{border-top-left-radius:var(--borderRadiusCircular);}", ".f8fbkgy{border-bottom-right-radius:var(--borderRadiusCircular);}", ".f1nfllo7{border-bottom-left-radius:var(--borderRadiusCircular);}", ".fe5j1ua{font-size:20px;}", ".f15vdbe4{padding-left:5px;}", ".fwiuce9{padding-right:5px;}", ".f4ybsrx{font-size:16px;}", ".f2lugmd{padding-left:3px;}", ".f6zblan{padding-right:3px;}", ".f1ugzwwg{font-size:12px;}", ".f10pi13n{position:relative;}"],
  h: [".f8491dx:hover{cursor:pointer;}", ".f1h648pw:hover{background-color:var(--colorNeutralBackground3Hover);}", ".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".f1yj72w4:hover{background-color:var(--colorBrandBackground2Hover);}", ".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}", ".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}"],
  a: [".fwdzr64:active{background-color:var(--colorNeutralBackground3Pressed);}", ".f19au66r:active{color:var(--colorNeutralForeground2BrandPressed);}", ".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}", ".fy3sl2y:active{background-color:var(--colorBrandBackground2Pressed);}", ".fryz5bw:active{color:var(--colorCompoundBrandForeground1Pressed);}", ".fsp1bjw:active{background-color:var(--colorBrandBackgroundPressed);}", ".f18otbis:active{color:var(--colorNeutralForegroundOnBrand);}"],
  m: [["@media (forced-colors: active){.fah2lgh{border-top-width:var(--strokeWidthThin);}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fx7har{border-bottom-width:var(--strokeWidthThin);}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fq7113v:hover{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fp3oj7s:active{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fkc42ay{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1rirnrt{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1lkg8j3{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fiu8gst:hover{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1byx217:hover{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fkk6lp6:active{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ojl2j2:active{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ['@media (forced-colors: none){.fqiv1u6:before,.fqiv1u6:after{content:"";}}', {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fl6l3ok:before,.fl6l3ok:after{position:absolute;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fiuoxex:before,.fiuoxex:after{height:2px;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f12z4n6f:before,.f12z4n6f:after{right:0;}.f1f187wz:before,.f1f187wz:after{left:0;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fxnjm4l:before,.fxnjm4l:after{width:100%;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fa2n458:before{bottom:100%;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f1nrpwwh:after{top:100%;}}", {
    m: "(forced-colors: none)"
  }]]
});
var useRootDisabledStyles4 = __styles2({
  filled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o",
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f250w3l",
    zhjwy3: ["fy0fskl", "f15xbau"]
  },
  outline: {
    Bceei9c: "fdrzuqr",
    De3pzq: "fhovq9v",
    sj55zd: "f1s2aq7o",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"]
  },
  brand: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o",
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f250w3l",
    zhjwy3: ["fy0fskl", "f15xbau"]
  }
}, {
  d: [".fdrzuqr{cursor:not-allowed;}", ".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fgig46g{border-top-color:var(--colorTransparentStrokeDisabled);}", ".f1mxt3zg{border-right-color:var(--colorTransparentStrokeDisabled);}", ".fziff3p{border-left-color:var(--colorTransparentStrokeDisabled);}", ".f250w3l{border-bottom-color:var(--colorTransparentStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"]
});
var useInteractionTagSecondaryStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName13();
  const rootStyles = useRootStyles23();
  const rootDisabledStyles = useRootDisabledStyles4();
  const {
    disabled,
    selected,
    shape,
    size: size3,
    appearance
  } = state;
  state.root.className = mergeClasses(interactionTagSecondaryClassNames.root, rootBaseClassName, disabled ? rootDisabledStyles[appearance] : rootStyles[appearance], rootStyles[shape], rootStyles[size3], selected && !disabled && rootStyles.selected, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/InteractionTagSecondary.js
var InteractionTagSecondary = React446.forwardRef((props, ref) => {
  const state = useInteractionTagSecondary_unstable(props, ref);
  useInteractionTagSecondaryStyles_unstable(state);
  useCustomStyleHook("useInteractionTagSecondaryStyles_unstable")(state);
  return renderInteractionTagSecondary_unstable(state);
});
InteractionTagSecondary.displayName = "InteractionTagSecondary";

// node_modules/@fluentui/react-tags/lib/components/TagGroup/TagGroup.js
var React449 = __toESM(require_react());

// node_modules/@fluentui/react-tags/lib/components/TagGroup/useTagGroup.js
var React447 = __toESM(require_react());
var useTagGroup_unstable = (props, ref) => {
  const { onDismiss, disabled = false, defaultSelectedValues, size: size3 = "medium", appearance = "filled", dismissible = false, role = "toolbar", onTagSelect, selectedValues, ...rest } = props;
  const innerRef = React447.useRef(void 0);
  const { targetDocument } = useFluent();
  const { findNextFocusable, findPrevFocusable } = useFocusFinders();
  const [items, setItems] = useControllableState({
    defaultState: defaultSelectedValues,
    state: selectedValues,
    initialState: []
  });
  const handleTagDismiss = useEventCallback((e, data) => {
    var _innerRef_current;
    onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(e, data);
    const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
    if ((_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.contains(activeElement)) {
      const next = findNextFocusable(activeElement, {
        container: innerRef.current
      });
      if (next) {
        next.focus();
        return;
      }
      if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.className.includes(interactionTagSecondaryClassNames.root)) {
        const prev = findPrevFocusable(activeElement.parentElement, {
          container: innerRef.current
        });
        prev === null || prev === void 0 ? void 0 : prev.focus();
      } else {
        const prev = findPrevFocusable(activeElement, {
          container: innerRef.current
        });
        prev === null || prev === void 0 ? void 0 : prev.focus();
      }
    }
  });
  const handleTagSelect = useEventCallback(mergeCallbacks(onTagSelect, (_, data) => {
    if (items.includes(data.value)) {
      setItems(items.filter((item) => item !== data.value));
    } else {
      setItems([
        ...items,
        data.value
      ]);
    }
  }));
  const arrowNavigationProps = useArrowNavigationGroup({
    circular: true,
    axis: "both",
    memorizeCurrent: true
  });
  return {
    handleTagDismiss,
    handleTagSelect: onTagSelect ? handleTagSelect : void 0,
    selectedValues: items,
    role,
    size: size3,
    disabled,
    appearance,
    dismissible,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, innerRef),
      role,
      "aria-disabled": disabled,
      ...arrowNavigationProps,
      ...rest
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-tags/lib/components/TagGroup/renderTagGroup.js
var renderTagGroup_unstable = (state, contextValue) => {
  assertSlots(state);
  return jsx(TagGroupContextProvider, {
    value: contextValue.tagGroup,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-tags/lib/components/TagGroup/useTagGroupStyles.styles.js
var tagGroupClassNames = {
  root: "fui-TagGroup"
};
var useRootStyles24 = __styles2({
  base: {
    mc9l5x: "ftuwxu6"
  },
  medium: {
    i8kkvl: "fsnqrgy"
  },
  small: {
    i8kkvl: "f1rjii52"
  },
  "extra-small": {
    i8kkvl: "f1ufnopg"
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".fsnqrgy{column-gap:var(--spacingHorizontalS);}", ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", ".f1ufnopg{column-gap:var(--spacingHorizontalXS);}"]
});
var useTagGroupStyles_unstable = (state) => {
  "use no memo";
  const styles = useRootStyles24();
  const {
    size: size3
  } = state;
  state.root.className = mergeClasses(tagGroupClassNames.root, styles.base, styles[size3], state.root.className);
  return state;
};

// node_modules/@fluentui/react-tags/lib/components/TagGroup/useTagGroupContextValues.js
var React448 = __toESM(require_react());
function useTagGroupContextValues_unstable(state) {
  const { handleTagDismiss, handleTagSelect, selectedValues, size: size3, disabled, appearance, dismissible, role } = state;
  return {
    tagGroup: React448.useMemo(() => ({
      handleTagDismiss,
      handleTagSelect,
      selectedValues,
      size: size3,
      disabled,
      appearance,
      dismissible,
      role
    }), [
      handleTagDismiss,
      handleTagSelect,
      selectedValues,
      size3,
      disabled,
      appearance,
      dismissible,
      role
    ])
  };
}

// node_modules/@fluentui/react-tags/lib/components/TagGroup/TagGroup.js
var TagGroup = React449.forwardRef((props, ref) => {
  const state = useTagGroup_unstable(props, ref);
  useTagGroupStyles_unstable(state);
  useCustomStyleHook("useTagGroupStyles_unstable")(state);
  return renderTagGroup_unstable(state, useTagGroupContextValues_unstable(state));
});
TagGroup.displayName = "TagGroup";

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/MessageBar.js
var React456 = __toESM(require_react());

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBar.js
var React453 = __toESM(require_react());

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/getIntentIcon.js
var React450 = __toESM(require_react());
function getIntentIcon(intent) {
  switch (intent) {
    case "info":
      return React450.createElement(InfoFilled, null);
    case "warning":
      return React450.createElement(WarningFilled, null);
    case "error":
      return React450.createElement(DismissCircleFilled, null);
    case "success":
      return React450.createElement(CheckmarkCircleFilled, null);
    default:
      return null;
  }
}

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBarReflow.js
var React451 = __toESM(require_react());
function useMessageBarReflow(enabled = false) {
  const { targetDocument } = useFluent();
  const forceUpdate = React451.useReducer(() => ({}), {})[1];
  const reflowingRef = React451.useRef(false);
  const resizeObserverRef = React451.useRef(null);
  const prevInlineSizeRef = React451.useRef(-1);
  const handleResize = React451.useCallback((entries) => {
    var _entry_borderBoxSize_, _entry_borderBoxSize;
    if (entries.length > 1) {
      console.error([
        "useMessageBarReflow: Resize observer should only have one entry. ",
        "If multiple entries are observed, the first entry will be used.",
        "This is a bug, please report it to the Fluent UI team."
      ].join(" "));
    }
    const entry = entries[0];
    var _entry_borderBoxSize__inlineSize;
    const inlineSize = (_entry_borderBoxSize__inlineSize = entry === null || entry === void 0 ? void 0 : (_entry_borderBoxSize = entry.borderBoxSize) === null || _entry_borderBoxSize === void 0 ? void 0 : (_entry_borderBoxSize_ = _entry_borderBoxSize[0]) === null || _entry_borderBoxSize_ === void 0 ? void 0 : _entry_borderBoxSize_.inlineSize) !== null && _entry_borderBoxSize__inlineSize !== void 0 ? _entry_borderBoxSize__inlineSize : entry === null || entry === void 0 ? void 0 : entry.target.getBoundingClientRect().width;
    if (inlineSize === void 0 || !entry) {
      return;
    }
    const { target } = entry;
    if (!isHTMLElement(target)) {
      return;
    }
    let nextReflowing;
    if (reflowingRef.current) {
      if (prevInlineSizeRef.current < inlineSize) {
        nextReflowing = false;
      }
    } else {
      const scrollWidth = target.scrollWidth;
      if (inlineSize < scrollWidth) {
        nextReflowing = true;
      }
    }
    prevInlineSizeRef.current = inlineSize;
    if (typeof nextReflowing !== "undefined" && reflowingRef.current !== nextReflowing) {
      reflowingRef.current = nextReflowing;
      forceUpdate();
    }
  }, [
    forceUpdate
  ]);
  const ref = React451.useCallback((el) => {
    var _resizeObserverRef_current;
    if (!enabled || !el || !(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView)) {
      return;
    }
    (_resizeObserverRef_current = resizeObserverRef.current) === null || _resizeObserverRef_current === void 0 ? void 0 : _resizeObserverRef_current.disconnect();
    const win = targetDocument.defaultView;
    const resizeObserver = new win.ResizeObserver(handleResize);
    resizeObserverRef.current = resizeObserver;
    resizeObserver.observe(el, {
      box: "border-box"
    });
  }, [
    targetDocument,
    handleResize,
    enabled
  ]);
  React451.useEffect(() => {
    return () => {
      var _resizeObserverRef_current;
      (_resizeObserverRef_current = resizeObserverRef.current) === null || _resizeObserverRef_current === void 0 ? void 0 : _resizeObserverRef_current.disconnect();
    };
  }, []);
  return {
    ref,
    reflowing: reflowingRef.current
  };
}

// node_modules/@fluentui/react-message-bar/lib/contexts/messageBarTransitionContext.js
var React452 = __toESM(require_react());
var messageBarTransitionContext = React452.createContext(void 0);
var messageBarTransitionContextDefaultValue = {
  className: "",
  nodeRef: React452.createRef()
};
var MessageBarTransitionContextProvider = messageBarTransitionContext.Provider;
var useMessageBarTransitionContext = () => {
  var _React_useContext;
  return (_React_useContext = React452.useContext(messageBarTransitionContext)) !== null && _React_useContext !== void 0 ? _React_useContext : messageBarTransitionContextDefaultValue;
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBar.js
var useMessageBar_unstable = (props, ref) => {
  const { layout = "auto", intent = "info", politeness, shape = "rounded" } = props;
  const computedPoliteness = (politeness !== null && politeness !== void 0 ? politeness : intent === "info") ? "polite" : "assertive";
  const autoReflow = layout === "auto";
  const { ref: reflowRef, reflowing } = useMessageBarReflow(autoReflow);
  const computedLayout = autoReflow ? reflowing ? "multiline" : "singleline" : layout;
  const { className: transitionClassName, nodeRef } = useMessageBarTransitionContext();
  const actionsRef = React453.useRef(null);
  const bodyRef = React453.useRef(null);
  const { announce } = useAnnounce();
  const titleId = useId2();
  React453.useEffect(() => {
    var _bodyRef_current, _actionsRef_current;
    const bodyMessage = (_bodyRef_current = bodyRef.current) === null || _bodyRef_current === void 0 ? void 0 : _bodyRef_current.textContent;
    const actionsMessage = (_actionsRef_current = actionsRef.current) === null || _actionsRef_current === void 0 ? void 0 : _actionsRef_current.textContent;
    const message = [
      bodyMessage,
      actionsMessage
    ].filter(Boolean).join(",");
    announce(message, {
      polite: computedPoliteness === "polite",
      alert: computedPoliteness === "assertive"
    });
  }, [
    bodyRef,
    actionsRef,
    announce,
    computedPoliteness
  ]);
  return {
    components: {
      root: "div",
      icon: "div",
      bottomReflowSpacer: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, reflowRef, nodeRef),
      role: "group",
      "aria-labelledby": titleId,
      ...props
    }), {
      elementType: "div"
    }),
    icon: slot_exports.optional(props.icon, {
      renderByDefault: true,
      elementType: "div",
      defaultProps: {
        children: getIntentIcon(intent)
      }
    }),
    bottomReflowSpacer: slot_exports.optional(props.bottomReflowSpacer, {
      renderByDefault: computedLayout === "multiline",
      elementType: "div"
    }),
    layout: computedLayout,
    intent,
    transitionClassName,
    actionsRef,
    bodyRef,
    titleId,
    shape
  };
};

// node_modules/@fluentui/react-message-bar/lib/contexts/messageBarContext.js
var React454 = __toESM(require_react());
var messageBarContext = React454.createContext(void 0);
var messageBarContextDefaultValue = {
  titleId: "",
  layout: "singleline",
  actionsRef: React454.createRef(),
  bodyRef: React454.createRef()
};
var MessageBarContextProvider = messageBarContext.Provider;
var useMessageBarContext = () => {
  var _React_useContext;
  return (_React_useContext = React454.useContext(messageBarContext)) !== null && _React_useContext !== void 0 ? _React_useContext : messageBarContextDefaultValue;
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/renderMessageBar.js
var renderMessageBar_unstable = (state, contexts) => {
  assertSlots(state);
  return jsx(MessageBarContextProvider, {
    value: contexts.messageBar,
    children: jsxs(state.root, {
      children: [
        state.icon && jsx(state.icon, {}),
        state.root.children,
        state.bottomReflowSpacer && jsx(state.bottomReflowSpacer, {})
      ]
    })
  });
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBarStyles.styles.js
var messageBarClassNames = {
  root: "fui-MessageBar",
  icon: "fui-MessageBar__icon",
  bottomReflowSpacer: "fui-MessageBar__bottomReflowSpacer"
};
var useRootBaseStyles4 = __resetStyles("r2oyxsj", "r1wuyrhw", ['.r2oyxsj{white-space:nowrap;display:grid;grid-template-columns:auto 1fr auto auto;grid-template-rows:1fr;grid-template-areas:"icon body secondaryActions actions";padding-left:var(--spacingHorizontalM);border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);border-radius:var(--borderRadiusMedium);align-items:center;min-height:36px;box-sizing:border-box;background-color:var(--colorNeutralBackground3);}', '.r1wuyrhw{white-space:nowrap;display:grid;grid-template-columns:auto 1fr auto auto;grid-template-rows:1fr;grid-template-areas:"icon body secondaryActions actions";padding-right:var(--spacingHorizontalM);border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);border-radius:var(--borderRadiusMedium);align-items:center;min-height:36px;box-sizing:border-box;background-color:var(--colorNeutralBackground3);}']);
var useIconBaseStyles3 = __resetStyles("r1df1z33", "rivnfjc", [".r1df1z33{grid-area:icon;font-size:var(--fontSizeBase500);margin-right:var(--spacingHorizontalS);color:var(--colorNeutralForeground3);display:flex;align-items:center;}", ".rivnfjc{grid-area:icon;font-size:var(--fontSizeBase500);margin-left:var(--spacingHorizontalS);color:var(--colorNeutralForeground3);display:flex;align-items:center;}"]);
var useReflowSpacerBaseStyles = __resetStyles("r1vx593n", null, [".r1vx593n{margin-bottom:var(--spacingVerticalS);grid-area:secondaryActions;}"]);
var useStyles54 = __styles2({
  rootMultiline: {
    Huce71: "f6juhto",
    Bt984gj: "f1s2louj",
    z8tnut: "f1ngh7ph",
    Budl1dq: "f17g0uqy",
    zoa1oz: "f1w7oly7"
  },
  secondaryActionsMultiline: {
    Brf1p80: "f1e8xxv9",
    B6of3ja: "f1gaxbfw",
    jrapky: "fqcjy3b",
    t21cq0: ["fibjyge", "f9yszdx"]
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779"
  }
}, {
  d: [".f6juhto{white-space:normal;}", ".f1s2louj{align-items:start;}", ".f1ngh7ph{padding-top:var(--spacingVerticalMNudge);}", ".f17g0uqy{grid-template-columns:auto 1fr auto;}", '.f1w7oly7{grid-template-areas:"icon body actions" "secondaryActions secondaryActions secondaryActions";}', ".f1e8xxv9{justify-content:end;}", ".f1gaxbfw{margin-top:var(--spacingVerticalMNudge);}", ".fqcjy3b{margin-bottom:var(--spacingVerticalS);}", ".fibjyge{margin-right:0px;}", ".f9yszdx{margin-left:0px;}", [".fokr779{border-radius:0;}", {
    p: -1
  }]]
});
var useIconIntentStyles = __styles2({
  info: {},
  error: {
    sj55zd: "f1ca9wz"
  },
  warning: {
    sj55zd: "f14a4cve"
  },
  success: {
    sj55zd: "f36rra6"
  }
}, {
  d: [".f1ca9wz{color:var(--colorStatusDangerForeground1);}", ".f14a4cve{color:var(--colorStatusWarningForeground3);}", ".f36rra6{color:var(--colorStatusSuccessForeground1);}"]
});
var useRootIntentStyles = __styles2({
  info: {},
  error: {
    De3pzq: "f1eon7jj",
    g2u3we: "f1f8dvr7",
    h3c5rm: ["f1g1ijmo", "f1nxacbt"],
    B9xav0g: "fo25q1j",
    zhjwy3: ["f1nxacbt", "f1g1ijmo"]
  },
  warning: {
    De3pzq: "f13ftzij",
    g2u3we: "frd1ypx",
    h3c5rm: ["f1gyjrma", "f18qd5xz"],
    B9xav0g: "fqyqtrt",
    zhjwy3: ["f18qd5xz", "f1gyjrma"]
  },
  success: {
    De3pzq: "f64thcm",
    g2u3we: "f1b4u7v",
    h3c5rm: ["f1nyd2b1", "f70v3om"],
    B9xav0g: "fk173vo",
    zhjwy3: ["f70v3om", "f1nyd2b1"]
  }
}, {
  d: [".f1eon7jj{background-color:var(--colorStatusDangerBackground1);}", ".f1f8dvr7{border-top-color:var(--colorStatusDangerBorder1);}", ".f1g1ijmo{border-right-color:var(--colorStatusDangerBorder1);}", ".f1nxacbt{border-left-color:var(--colorStatusDangerBorder1);}", ".fo25q1j{border-bottom-color:var(--colorStatusDangerBorder1);}", ".f13ftzij{background-color:var(--colorStatusWarningBackground1);}", ".frd1ypx{border-top-color:var(--colorStatusWarningBorder1);}", ".f1gyjrma{border-right-color:var(--colorStatusWarningBorder1);}", ".f18qd5xz{border-left-color:var(--colorStatusWarningBorder1);}", ".fqyqtrt{border-bottom-color:var(--colorStatusWarningBorder1);}", ".f64thcm{background-color:var(--colorStatusSuccessBackground1);}", ".f1b4u7v{border-top-color:var(--colorStatusSuccessBorder1);}", ".f1nyd2b1{border-right-color:var(--colorStatusSuccessBorder1);}", ".f70v3om{border-left-color:var(--colorStatusSuccessBorder1);}", ".fk173vo{border-bottom-color:var(--colorStatusSuccessBorder1);}"]
});
var useMessageBarStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyles = useRootBaseStyles4();
  const iconBaseStyles = useIconBaseStyles3();
  const iconIntentStyles = useIconIntentStyles();
  const rootIntentStyles = useRootIntentStyles();
  const reflowSpacerStyles = useReflowSpacerBaseStyles();
  const styles = useStyles54();
  state.root.className = mergeClasses(messageBarClassNames.root, rootBaseStyles, state.layout === "multiline" && styles.rootMultiline, state.shape === "square" && styles.square, rootIntentStyles[state.intent], state.transitionClassName, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(messageBarClassNames.icon, iconBaseStyles, iconIntentStyles[state.intent], state.icon.className);
  }
  if (state.bottomReflowSpacer) {
    state.bottomReflowSpacer.className = mergeClasses(messageBarClassNames.bottomReflowSpacer, reflowSpacerStyles);
  }
  return state;
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBarContextValues.js
var React455 = __toESM(require_react());
function useMessageBarContextValue_unstable(state) {
  const { layout, actionsRef, bodyRef, titleId } = state;
  const messageBarContext2 = React455.useMemo(() => ({
    layout,
    actionsRef,
    bodyRef,
    titleId
  }), [
    layout,
    actionsRef,
    bodyRef,
    titleId
  ]);
  return {
    messageBar: messageBarContext2
  };
}

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/MessageBar.js
var MessageBar = React456.forwardRef((props, ref) => {
  const state = useMessageBar_unstable(props, ref);
  useMessageBarStyles_unstable(state);
  useCustomStyleHook("useMessageBarStyles_unstable")(state);
  return renderMessageBar_unstable(state, useMessageBarContextValue_unstable(state));
});
MessageBar.displayName = "MessageBar";

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/MessageBarTitle.js
var React458 = __toESM(require_react());

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/useMessageBarTitle.js
var React457 = __toESM(require_react());
var useMessageBarTitle_unstable = (props, ref) => {
  const { titleId } = useMessageBarContext();
  return {
    components: {
      root: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("span", {
      ref,
      id: titleId,
      ...props
    }), {
      elementType: "span"
    })
  };
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/renderMessageBarTitle.js
var renderMessageBarTitle_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/useMessageBarTitleStyles.styles.js
var messageBarTitleClassNames = {
  root: "fui-MessageBarTitle"
};
var useRootBaseStyles5 = __resetStyles("r168xkm9", null, [".r168xkm9{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase300);}", '.r168xkm9::after{content:" ";}']);
var useMessageBarTitleStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyles = useRootBaseStyles5();
  state.root.className = mergeClasses(messageBarTitleClassNames.root, rootBaseStyles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/MessageBarTitle.js
var MessageBarTitle = React458.forwardRef((props, ref) => {
  const state = useMessageBarTitle_unstable(props, ref);
  useMessageBarTitleStyles_unstable(state);
  useCustomStyleHook("useMessageBarTitleStyles_unstable")(state);
  return renderMessageBarTitle_unstable(state);
});
MessageBarTitle.displayName = "MessageBarTitle";

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/MessageBarActions.js
var React461 = __toESM(require_react());

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/useMessageBarActions.js
var React459 = __toESM(require_react());
var useMessageBarActions_unstable = (props, ref) => {
  const { layout = "singleline", actionsRef } = useMessageBarContext();
  return {
    components: {
      root: "div",
      containerAction: "div"
    },
    containerAction: slot_exports.optional(props.containerAction, {
      renderByDefault: false,
      elementType: "div"
    }),
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, actionsRef),
      ...props
    }), {
      elementType: "div"
    }),
    layout,
    hasActions: !!props.children
  };
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/renderMessageBarActions.js
var renderMessageBarActions_unstable = (state, contexts) => {
  assertSlots(state);
  return jsxs(ButtonContextProvider, {
    value: contexts.button,
    children: [
      state.layout === "multiline" && state.containerAction && jsx(state.containerAction, {}, "containerAction"),
      jsx(state.root, {}),
      state.layout !== "multiline" && state.containerAction && jsx(state.containerAction, {}, "containerAction")
    ]
  });
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/useMessageBarActionsStyles.styles.js
var messageBarActionsClassNames = {
  root: "fui-MessageBarActions",
  containerAction: "fui-MessageBarActions__containerAction"
};
var useRootBaseStyles6 = __resetStyles("r1t4x98y", "r15utzv5", [".r1t4x98y{grid-area:secondaryActions;display:flex;column-gap:var(--spacingHorizontalM);padding-right:var(--spacingHorizontalM);}", ".r15utzv5{grid-area:secondaryActions;display:flex;column-gap:var(--spacingHorizontalM);padding-left:var(--spacingHorizontalM);}"]);
var useContainerActionBaseStyles = __resetStyles("rgzw8nq", "r13ur29z", [".rgzw8nq{grid-area:actions;padding-right:var(--spacingHorizontalM);}", ".r13ur29z{grid-area:actions;padding-left:var(--spacingHorizontalM);}"]);
var useMultilineStyles3 = __styles2({
  root: {
    Brf1p80: "f1e8xxv9",
    B6of3ja: "f1gaxbfw",
    jrapky: "fqcjy3b",
    t21cq0: ["fibjyge", "f9yszdx"],
    z189sj: ["f1p3vkop", "f8cewkv"]
  },
  noActions: {
    mc9l5x: "fjseox"
  }
}, {
  d: [".f1e8xxv9{justify-content:end;}", ".f1gaxbfw{margin-top:var(--spacingVerticalMNudge);}", ".fqcjy3b{margin-bottom:var(--spacingVerticalS);}", ".fibjyge{margin-right:0px;}", ".f9yszdx{margin-left:0px;}", ".f1p3vkop{padding-right:var(--spacingVerticalM);}", ".f8cewkv{padding-left:var(--spacingVerticalM);}", ".fjseox{display:none;}"]
});
var useMessageBarActionsStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyles = useRootBaseStyles6();
  const containerActionBaseStyles = useContainerActionBaseStyles();
  const multilineStyles = useMultilineStyles3();
  state.root.className = mergeClasses(messageBarActionsClassNames.root, rootBaseStyles, state.layout === "multiline" && multilineStyles.root, !state.hasActions && multilineStyles.noActions, state.root.className);
  if (state.containerAction) {
    state.containerAction.className = mergeClasses(messageBarActionsClassNames.containerAction, containerActionBaseStyles, state.containerAction.className);
  }
  return state;
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/useMessageBarActionsContextValues.js
var React460 = __toESM(require_react());
function useMessageBarActionsContextValue_unstable() {
  const buttonContext2 = React460.useMemo(() => ({
    size: "small"
  }), []);
  return {
    button: buttonContext2
  };
}

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/MessageBarActions.js
var MessageBarActions = React461.forwardRef((props, ref) => {
  const state = useMessageBarActions_unstable(props, ref);
  useMessageBarActionsStyles_unstable(state);
  useCustomStyleHook("useMessageBarActionsStyles_unstable")(state);
  return renderMessageBarActions_unstable(state, useMessageBarActionsContextValue_unstable());
});
MessageBarActions.displayName = "MessageBarActions";

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/MessageBarBody.js
var React464 = __toESM(require_react());

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/useMessageBarBody.js
var React462 = __toESM(require_react());
var useMessageBarBody_unstable = (props, ref) => {
  const { bodyRef } = useMessageBarContext();
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, bodyRef),
      ...props
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/renderMessageBarBody.js
var renderMessageBarBody_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(LinkContextProvider, {
    value: contextValues.link,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/useMessageBarBodyStyles.styles.js
var messageBarBodyClassNames = {
  root: "fui-MessageBarBody"
};
var useRootBaseStyles7 = __resetStyles("rtatq2b", "re2rary", [".rtatq2b{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);grid-area:body;padding-right:var(--spacingHorizontalM);}", ".re2rary{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);grid-area:body;padding-left:var(--spacingHorizontalM);}"]);
var useMessageBarBodyStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyles = useRootBaseStyles7();
  state.root.className = mergeClasses(messageBarBodyClassNames.root, rootBaseStyles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/useMessageBarBodyContextValues.js
var React463 = __toESM(require_react());
function useMessageBarBodyContextValues_unstable(state) {
  const link = React463.useMemo(() => ({
    inline: true
  }), []);
  return {
    link
  };
}

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/MessageBarBody.js
var MessageBarBody = React464.forwardRef((props, ref) => {
  const state = useMessageBarBody_unstable(props, ref);
  const ctx = useMessageBarBodyContextValues_unstable(state);
  useMessageBarBodyStyles_unstable(state);
  useCustomStyleHook("useMessageBarBodyStyles_unstable")(state);
  return renderMessageBarBody_unstable(state, ctx);
});
MessageBarBody.displayName = "MessageBarBody";

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/MessageBarGroup.js
var React473 = __toESM(require_react());

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/useMessageBarGroup.js
var React465 = __toESM(require_react());
var useMessageBarGroup_unstable = (props, ref) => {
  if (true) {
    React465.Children.forEach(props.children, (c) => {
      if (!React465.isValidElement(c) || c.type === React465.Fragment) {
        throw new Error("MessageBarGroup: children must be valid MessageBar components. Please ensure you're not using fragments. ");
      }
    });
  }
  var _props_children;
  const children2 = React465.Children.map((_props_children = props.children) !== null && _props_children !== void 0 ? _props_children : [], (c) => React465.isValidElement(c) && c.type !== React465.Fragment ? c : null).filter(Boolean);
  var _props_animate;
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    children: children2,
    animate: (_props_animate = props.animate) !== null && _props_animate !== void 0 ? _props_animate : "exit-only",
    enterStyles: "",
    exitStyles: ""
  };
};

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}

// node_modules/react-transition-group/esm/CSSTransition.js
var import_prop_types3 = __toESM(require_prop_types());

// node_modules/dom-helpers/esm/hasClass.js
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

// node_modules/dom-helpers/esm/addClass.js
function addClass(element, className) {
  if (element.classList) element.classList.add(className);
  else if (!hasClass(element, className)) if (typeof element.className === "string") element.className = element.className + " " + className;
  else element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}

// node_modules/dom-helpers/esm/removeClass.js
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}

// node_modules/react-transition-group/esm/CSSTransition.js
var import_react145 = __toESM(require_react());

// node_modules/react-transition-group/esm/Transition.js
var import_prop_types2 = __toESM(require_prop_types());
var import_react144 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/react-transition-group/esm/config.js
var config_default = {
  disabled: false
};

// node_modules/react-transition-group/esm/utils/PropTypes.js
var import_prop_types = __toESM(require_prop_types());
var timeoutsShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.shape({
  enter: import_prop_types.default.number,
  exit: import_prop_types.default.number,
  appear: import_prop_types.default.number
}).isRequired]) : null;
var classNamesShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.shape({
  enter: import_prop_types.default.string,
  exit: import_prop_types.default.string,
  active: import_prop_types.default.string
}), import_prop_types.default.shape({
  enter: import_prop_types.default.string,
  enterDone: import_prop_types.default.string,
  enterActive: import_prop_types.default.string,
  exit: import_prop_types.default.string,
  exitDone: import_prop_types.default.string,
  exitActive: import_prop_types.default.string
})]) : null;

// node_modules/react-transition-group/esm/TransitionGroupContext.js
var import_react143 = __toESM(require_react());
var TransitionGroupContext_default = import_react143.default.createContext(null);

// node_modules/react-transition-group/esm/utils/reflow.js
var forceReflow = function forceReflow2(node) {
  return node.scrollTop;
};

// node_modules/react-transition-group/esm/Transition.js
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
          if (node) forceReflow(node);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [import_react_dom.default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config_default.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : import_react_dom.default.findDOMNode(this);
    if (!exit || config_default.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children2 = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      import_react144.default.createElement(TransitionGroupContext_default.Provider, {
        value: null
      }, typeof children2 === "function" ? children2(status, childProps) : import_react144.default.cloneElement(import_react144.default.Children.only(children2), childProps))
    );
  };
  return Transition2;
}(import_react144.default.Component);
Transition.contextType = TransitionGroupContext_default;
Transition.propTypes = true ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: import_prop_types2.default.shape({
    current: typeof Element === "undefined" ? import_prop_types2.default.any : function(propValue, key, componentName, location, propFullName, secret) {
      var value = propValue[key];
      return import_prop_types2.default.instanceOf(value && "ownerDocument" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: import_prop_types2.default.oneOfType([import_prop_types2.default.func.isRequired, import_prop_types2.default.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: import_prop_types2.default.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: import_prop_types2.default.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: import_prop_types2.default.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: import_prop_types2.default.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: import_prop_types2.default.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: import_prop_types2.default.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function timeout(props) {
    var pt = timeoutsShape;
    if (!props.addEndListener) pt = pt.isRequired;
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return pt.apply(void 0, [props].concat(args));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: import_prop_types2.default.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: import_prop_types2.default.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: import_prop_types2.default.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: import_prop_types2.default.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: import_prop_types2.default.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: import_prop_types2.default.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: import_prop_types2.default.func
} : {};
function noop12() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop12,
  onEntering: noop12,
  onEntered: noop12,
  onExit: noop12,
  onExiting: noop12,
  onExited: noop12
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition_default = Transition;

// node_modules/react-transition-group/esm/CSSTransition.js
var _addClass = function addClass2(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return addClass(node, c);
  });
};
var removeClass2 = function removeClass3(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return removeClass(node, c);
  });
};
var CSSTransition = function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass3(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      if (node) forceReflow(node);
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass2(node, baseClassName);
    }
    if (activeClassName) {
      removeClass2(node, activeClassName);
    }
    if (doneClassName) {
      removeClass2(node, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, _ = _this$props.classNames, props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return import_react145.default.createElement(Transition_default, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(import_react145.default.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = true ? _extends({}, Transition_default.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: classNamesShape,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: import_prop_types3.default.func
}) : {};

// node_modules/react-transition-group/esm/ReplaceTransition.js
var import_prop_types5 = __toESM(require_prop_types());
var import_react148 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

// node_modules/react-transition-group/esm/TransitionGroup.js
var import_prop_types4 = __toESM(require_prop_types());
var import_react147 = __toESM(require_react());

// node_modules/react-transition-group/esm/utils/ChildMapping.js
var import_react146 = __toESM(require_react());
function getChildMapping2(children2, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && (0, import_react146.isValidElement)(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children2) import_react146.Children.map(children2, function(c) {
    return c;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  });
  return result;
}
function mergeChildMappings2(prev, next) {
  prev = prev || {};
  next = next || {};
  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i;
  var childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping2(props.children, function(child) {
    return (0, import_react146.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping2(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping2(nextProps.children);
  var children2 = mergeChildMappings2(prevChildMapping, nextChildMapping);
  Object.keys(children2).forEach(function(key) {
    var child = children2[key];
    if (!(0, import_react146.isValidElement)(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = (0, import_react146.isValidElement)(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children2[key] = (0, import_react146.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children2[key] = (0, import_react146.cloneElement)(child, {
        in: false
      });
    } else if (hasNext && hasPrev && (0, import_react146.isValidElement)(prevChild)) {
      children2[key] = (0, import_react146.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children2;
}

// node_modules/react-transition-group/esm/TransitionGroup.js
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k) {
    return obj[k];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping2(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping2(this.props.children);
    if (child.key in currentChildMapping) return;
    if (child.props.onExited) {
      child.props.onExited(node);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children2 = _extends({}, state.children);
        delete children2[child.key];
        return {
          children: children2
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component2 = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children2 = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component2 === null) {
      return import_react147.default.createElement(TransitionGroupContext_default.Provider, {
        value: contextValue
      }, children2);
    }
    return import_react147.default.createElement(TransitionGroupContext_default.Provider, {
      value: contextValue
    }, import_react147.default.createElement(Component2, props, children2));
  };
  return TransitionGroup2;
}(import_react147.default.Component);
TransitionGroup.propTypes = true ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: import_prop_types4.default.any,
  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: import_prop_types4.default.node,
  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: import_prop_types4.default.bool,
  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: import_prop_types4.default.bool,
  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: import_prop_types4.default.bool,
  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: import_prop_types4.default.func
} : {};
TransitionGroup.defaultProps = defaultProps;
var TransitionGroup_default = TransitionGroup;

// node_modules/react-transition-group/esm/ReplaceTransition.js
var ReplaceTransition = function(_React$Component) {
  _inheritsLoose(ReplaceTransition2, _React$Component);
  function ReplaceTransition2() {
    var _this;
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
    _this.handleEnter = function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _this.handleLifecycle("onEnter", 0, args);
    };
    _this.handleEntering = function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.handleLifecycle("onEntering", 0, args);
    };
    _this.handleEntered = function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.handleLifecycle("onEntered", 0, args);
    };
    _this.handleExit = function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _this.handleLifecycle("onExit", 1, args);
    };
    _this.handleExiting = function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _this.handleLifecycle("onExiting", 1, args);
    };
    _this.handleExited = function() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return _this.handleLifecycle("onExited", 1, args);
    };
    return _this;
  }
  var _proto = ReplaceTransition2.prototype;
  _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
    var _child$props;
    var children2 = this.props.children;
    var child = import_react148.default.Children.toArray(children2)[idx];
    if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);
    if (this.props[handler]) {
      var maybeNode = child.props.nodeRef ? void 0 : import_react_dom2.default.findDOMNode(this);
      this.props[handler](maybeNode);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, children2 = _this$props.children, inProp = _this$props.in, props = _objectWithoutPropertiesLoose(_this$props, ["children", "in"]);
    var _React$Children$toArr = import_react148.default.Children.toArray(children2), first = _React$Children$toArr[0], second = _React$Children$toArr[1];
    delete props.onEnter;
    delete props.onEntering;
    delete props.onEntered;
    delete props.onExit;
    delete props.onExiting;
    delete props.onExited;
    return import_react148.default.createElement(TransitionGroup_default, props, inProp ? import_react148.default.cloneElement(first, {
      key: "first",
      onEnter: this.handleEnter,
      onEntering: this.handleEntering,
      onEntered: this.handleEntered
    }) : import_react148.default.cloneElement(second, {
      key: "second",
      onEnter: this.handleExit,
      onEntering: this.handleExiting,
      onEntered: this.handleExited
    }));
  };
  return ReplaceTransition2;
}(import_react148.default.Component);
ReplaceTransition.propTypes = true ? {
  in: import_prop_types5.default.bool.isRequired,
  children: function children(props, propName) {
    if (import_react148.default.Children.count(props[propName]) !== 2) return new Error('"' + propName + '" must be exactly two transition components.');
    return null;
  }
} : {};

// node_modules/react-transition-group/esm/SwitchTransition.js
var import_react149 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());
var _leaveRenders;
var _enterRenders;
function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren) return false;
  if (import_react149.default.isValidElement(oldChildren) && import_react149.default.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }
  return true;
}
var modes = {
  out: "out-in",
  in: "in-out"
};
var callHook = function callHook2(element, name, cb) {
  return function() {
    var _element$props;
    element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
    cb();
  };
};
var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(_ref) {
  var current = _ref.current, changeState = _ref.changeState;
  return import_react149.default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(_ref2) {
  var current = _ref2.current, changeState = _ref2.changeState, children2 = _ref2.children;
  return [current, import_react149.default.cloneElement(children2, {
    in: true,
    onEntered: callHook(children2, "onEntered", function() {
      changeState(ENTERING);
    })
  })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(_ref3) {
  var children2 = _ref3.children, changeState = _ref3.changeState;
  return import_react149.default.cloneElement(children2, {
    in: true,
    onEntered: callHook(children2, "onEntered", function() {
      changeState(ENTERED, import_react149.default.cloneElement(children2, {
        in: true
      }));
    })
  });
}, _enterRenders[modes.in] = function(_ref4) {
  var current = _ref4.current, children2 = _ref4.children, changeState = _ref4.changeState;
  return [import_react149.default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERED, import_react149.default.cloneElement(children2, {
        in: true
      }));
    })
  }), import_react149.default.cloneElement(children2, {
    in: true
  })];
}, _enterRenders);
var SwitchTransition = function(_React$Component) {
  _inheritsLoose(SwitchTransition2, _React$Component);
  function SwitchTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      status: ENTERED,
      current: null
    };
    _this.appeared = false;
    _this.changeState = function(status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }
      _this.setState({
        status,
        current
      });
    };
    return _this;
  }
  var _proto = SwitchTransition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
  };
  SwitchTransition2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.children == null) {
      return {
        current: null
      };
    }
    if (state.status === ENTERING && props.mode === modes.in) {
      return {
        status: ENTERING
      };
    }
    if (state.current && areChildrenDifferent(state.current, props.children)) {
      return {
        status: EXITING
      };
    }
    return {
      current: import_react149.default.cloneElement(props.children, {
        in: true
      })
    };
  };
  _proto.render = function render() {
    var _this$props = this.props, children2 = _this$props.children, mode = _this$props.mode, _this$state = this.state, status = _this$state.status, current = _this$state.current;
    var data = {
      children: children2,
      current,
      changeState: this.changeState,
      status
    };
    var component;
    switch (status) {
      case ENTERING:
        component = enterRenders[mode](data);
        break;
      case EXITING:
        component = leaveRenders[mode](data);
        break;
      case ENTERED:
        component = current;
    }
    return import_react149.default.createElement(TransitionGroupContext_default.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, component);
  };
  return SwitchTransition2;
}(import_react149.default.Component);
SwitchTransition.propTypes = true ? {
  /**
   * Transition modes.
   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
   * `in-out`: New element transitions in first, then when complete, the current element transitions out.
   *
   * @type {'out-in'|'in-out'}
   */
  mode: import_prop_types6.default.oneOf([modes.in, modes.out]),
  /**
   * Any `Transition` or `CSSTransition` component.
   */
  children: import_prop_types6.default.oneOfType([import_prop_types6.default.element.isRequired])
} : {};
SwitchTransition.defaultProps = {
  mode: modes.out
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/MessageBarTransition.js
var React472 = __toESM(require_react());
var getClassName = (status, enterClassName, exitClassName, animate) => {
  switch (status) {
    case "entering":
    case "entered":
      return animate === "both" ? enterClassName : "";
    case "exiting":
    case "exited":
      return exitClassName;
    default:
      return "";
  }
};
var MessageBarTransition = ({ children: children2, enterClassName, exitClassName, animate, ...rest }) => {
  const nodeRef = React472.useRef(null);
  return React472.createElement(Transition_default, {
    timeout: 250,
    nodeRef,
    ...rest
  }, (state) => React472.createElement(MessageBarTransitionInner, {
    animate,
    enterClassName,
    exitClassName,
    nodeRef,
    state
  }, children2));
};
var MessageBarTransitionInner = ({ children: children2, state, enterClassName, exitClassName, animate, nodeRef }) => {
  const className = getClassName(state, enterClassName, exitClassName, animate);
  const context = React472.useMemo(() => ({
    className,
    nodeRef
  }), [
    className,
    nodeRef
  ]);
  return React472.createElement(MessageBarTransitionContextProvider, {
    value: context
  }, children2);
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/renderMessageBarGroup.js
var renderMessageBarGroup_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(TransitionGroup_default, {
      component: null,
      children: state.children.map((child) => jsx(MessageBarTransition, {
        animate: state.animate,
        enterClassName: state.enterStyles,
        exitClassName: state.exitStyles,
        children: child
      }, child.key))
    })
  });
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/useMessageBarGroupStyles.styles.js
var messageBarGroupClassNames = {
  root: "fui-MessageBarGroup"
};
var useStyles55 = __styles2({
  base: {
    Bf5fcs: "f4cll0y",
    vin17d: "fy8si0b"
  },
  enter: {
    Bv12yb3: "f1dg9w1v"
  },
  exit: {
    Bv12yb3: "fu80iee"
  }
}, {
  d: [".f4cll0y{animation-fill-mode:forwards;}", ".fy8si0b{animation-duration:var(--durationNormal);}", ".f1dg9w1v{animation-name:fngeioi;}", ".fu80iee{animation-name:fk0lfw7;}"],
  k: ["@keyframes fngeioi{from{opacity:0;transform:translateY(-100%);}to{opacity:1;transform:translateY(0);}}", "@keyframes fk0lfw7{from{opacity:1;}to{opacity:0;}}"]
});
var useMessageBarGroupStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles55();
  state.root.className = mergeClasses(messageBarGroupClassNames.root, state.root.className);
  state.enterStyles = mergeClasses(styles.base, styles.enter);
  state.exitStyles = mergeClasses(styles.base, styles.exit);
  return state;
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/MessageBarGroup.js
var MessageBarGroup = React473.forwardRef((props, ref) => {
  const state = useMessageBarGroup_unstable(props, ref);
  useMessageBarGroupStyles_unstable(state);
  useCustomStyleHook("useMessageBarGroupStyles_unstable")(state);
  return renderMessageBarGroup_unstable(state);
});
MessageBarGroup.displayName = "MessageBarGroup";

// node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/InfoLabel.js
var React477 = __toESM(require_react());

// node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/renderInfoLabel.js
var renderInfoLabel_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.label, {}),
      state.infoButton && jsx(state.infoButton, {})
    ]
  });
};

// node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/useInfoLabel.js
var React476 = __toESM(require_react());

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/InfoButton.js
var React475 = __toESM(require_react());

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/renderInfoButton.js
var renderInfoButton_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.popover, {
    children: [
      jsx(PopoverTrigger, {
        children: jsx(state.root, {})
      }),
      jsx(state.info, {})
    ]
  });
};

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/useInfoButton.js
var React474 = __toESM(require_react());

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/DefaultInfoButtonIcons.js
var DefaultInfoButtonIcon12 = bundleIcon_default(Info12Filled, Info12Regular);
var DefaultInfoButtonIcon16 = bundleIcon_default(Info16Filled, Info16Regular);
var DefaultInfoButtonIcon20 = bundleIcon_default(Info20Filled, Info20Regular);

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/useInfoButton.js
var infoButtonIconMap = {
  small: React474.createElement(DefaultInfoButtonIcon12, null),
  medium: React474.createElement(DefaultInfoButtonIcon16, null),
  large: React474.createElement(DefaultInfoButtonIcon20, null)
};
var popoverSizeMap = {
  small: "small",
  medium: "small",
  large: "medium"
};
var useInfoButton_unstable = (props, ref) => {
  const { size: size3 = "medium", inline: inline2 = true, popover, info, ...rest } = props;
  const rootRef = useMergedRefs(ref);
  const state = {
    inline: inline2,
    size: size3,
    components: {
      root: "button",
      popover: Popover,
      info: PopoverSurface
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      children: infoButtonIconMap[size3],
      type: "button",
      "aria-label": "information",
      ...rest,
      ref: rootRef
    }), {
      elementType: "button"
    }),
    popover: slot_exports.always(popover, {
      defaultProps: {
        inline: inline2,
        positioning: "above-start",
        size: popoverSizeMap[size3],
        withArrow: true
      },
      elementType: Popover
    }),
    info: slot_exports.always(info, {
      defaultProps: {
        role: "note",
        tabIndex: -1
      },
      elementType: PopoverSurface
    })
  };
  const [popoverOpen, setPopoverOpen] = useControllableState({
    state: state.popover.open,
    defaultState: state.popover.defaultOpen,
    initialState: false
  });
  state.popover.open = popoverOpen;
  state.popover.onOpenChange = mergeCallbacks(state.popover.onOpenChange, (e, data) => setPopoverOpen(data.open));
  const infoRef = useMergedRefs(state.info.ref);
  state.info.ref = infoRef;
  const onBlurButtonOrInfo = (e) => {
    const nextFocused = e.relatedTarget;
    if (nextFocused && rootRef.current !== nextFocused && !elementContains(infoRef.current, nextFocused)) {
      setPopoverOpen(false);
    }
  };
  state.root.onBlur = useEventCallback(mergeCallbacks(state.root.onBlur, onBlurButtonOrInfo));
  state.info.onBlurCapture = useEventCallback(mergeCallbacks(state.info.onBlurCapture, onBlurButtonOrInfo));
  return state;
};

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/useInfoButtonStyles.styles.js
var infoButtonClassNames = {
  root: "fui-InfoButton",
  // this className won't be used, but it's needed to satisfy the type checker
  popover: "fui-InfoButton__popover",
  info: "fui-InfoButton__info"
};
var useButtonStyles2 = __styles2({
  base: {
    Bt984gj: "f122n59",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "ftuwxu6",
    Brf1p80: "f4d9j23",
    w71qe1: "f1iuv45f",
    ha4doy: "fmrv4ls",
    qhf8xq: "f10pi13n",
    De3pzq: "f1c21dwh",
    sj55zd: "fkfq4zb",
    icvyot: "f1ern45e",
    vrafjx: ["f1n71otn", "f1deefiw"],
    oivjwe: "f1h8hb77",
    wvpqe5: ["f1deefiw", "f1n71otn"],
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f16d74zd",
    D0sxk3: "f16u1re",
    t6yez3: "f1rw4040",
    Jwef8y: "fjxutwb",
    Bi91k9c: "f139oj5f",
    eoavqd: "f8491dx",
    Bk3fhr4: "f1jpd6y0",
    Bmfj8id: "fuxngvv",
    iro3zm: "fwiml72",
    B2d53fq: "f1fg1p5m"
  },
  selected: {
    De3pzq: "f1q9pm1r",
    sj55zd: "f1qj7y59",
    D0sxk3: "fgzdkf0",
    t6yez3: "f15q0o9g",
    Bsw6fvg: "f1rirnrt",
    Bbusuzp: "f1cg6951"
  },
  highContrast: {
    Bbusuzp: "fn0tkbb",
    Bs6v0vm: "f1rp3av6",
    B46dtvo: "f1u7gwqv",
    gh1jta: "fl6kagl"
  },
  focusIndicator: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Bb7d1vk: "f226i61",
    zhwhgb: ["f13kzufm", "fsx75g8"],
    dhy2o1: "flujwa2",
    Gfyso: ["fsx75g8", "f13kzufm"],
    Bm4h7ae: "f15bsgw9",
    B7ys5i9: "f14e48fq",
    Busjfv9: "f18yb2kv",
    Bhk32uz: "fd6o370",
    f6g5ot: 0,
    Boxcth7: 0,
    Bhdgwq3: 0,
    hgwjuy: 0,
    Bshpdp8: 0,
    Bsom6fd: 0,
    Blkhhs4: 0,
    Bonggc9: 0,
    Ddfuxk: 0,
    i03rao: 0,
    kclons: 0,
    clg4pj: 0,
    Bpqj9nj: 0,
    B6dhp37: 0,
    Bf4ptjt: 0,
    Bqtpl0w: 0,
    i4rwgc: "ffwy5si",
    Dah5zi: 0,
    B1tsrr9: 0,
    qqdqy8: 0,
    Bkh64rk: 0,
    e3fwne: "f3znvyf",
    J0r882: "f57olzd",
    Bule8hv: ["f4stah7", "fs1por5"],
    Bjwuhne: "f480a47",
    Ghsupd: ["fs1por5", "f4stah7"]
  },
  large: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1kx978o"
  }
}, {
  d: [".f122n59{align-items:center;}", ".f1ewtqcl{box-sizing:border-box;}", ".ftuwxu6{display:inline-flex;}", ".f4d9j23{justify-content:center;}", ".f1iuv45f{text-decoration-line:none;}", ".fmrv4ls{vertical-align:middle;}", ".f10pi13n{position:relative;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1h8hb77{border-bottom-style:none;}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f1s184ao{margin:0;}", {
    p: -1
  }], [".f16d74zd{padding:var(--spacingVerticalXS) var(--spacingHorizontalXS);}", {
    p: -1
  }], ".f16u1re .fui-Icon-filled{display:none;}", ".f1rw4040 .fui-Icon-regular{display:inline-flex;}", ".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}", ".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}", ".fgzdkf0 .fui-Icon-filled{display:inline-flex;}", ".f15q0o9g .fui-Icon-regular{display:none;}", ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", '.f15bsgw9[data-fui-focus-visible]::after{content:"";}', ".f14e48fq[data-fui-focus-visible]::after{position:absolute;}", ".f18yb2kv[data-fui-focus-visible]::after{pointer-events:none;}", ".fd6o370[data-fui-focus-visible]::after{z-index:1;}", [".ffwy5si[data-fui-focus-visible]::after{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f3znvyf[data-fui-focus-visible]::after{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f57olzd[data-fui-focus-visible]::after{top:calc(2px * -1);}", ".f4stah7[data-fui-focus-visible]::after{right:calc(2px * -1);}", ".fs1por5[data-fui-focus-visible]::after{left:calc(2px * -1);}", ".f480a47[data-fui-focus-visible]::after{bottom:calc(2px * -1);}", [".f1kx978o{padding:var(--spacingVerticalXXS) var(--spacingVerticalXXS);}", {
    p: -1
  }]],
  h: [".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}", ".f8491dx:hover{cursor:pointer;}", ".f1jpd6y0:hover .fui-Icon-filled{display:inline-flex;}", ".fuxngvv:hover .fui-Icon-regular{display:none;}", ".fwiml72:hover:active{background-color:var(--colorTransparentBackgroundPressed);}", ".f1fg1p5m:hover:active{color:var(--colorNeutralForeground2BrandPressed);}"],
  m: [["@media (forced-colors: active){.f1rirnrt{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1cg6951{color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fn0tkbb{color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1rp3av6:hover,.f1rp3av6:hover:active{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1u7gwqv:hover,.f1u7gwqv:hover:active{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fl6kagl:hover,.fl6kagl:hover:active{color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f226i61[data-fui-focus-visible]::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f13kzufm[data-fui-focus-visible]::after{border-right-color:Highlight;}.fsx75g8[data-fui-focus-visible]::after{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.flujwa2[data-fui-focus-visible]::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"]
});
var usePopoverSurfaceStyles2 = __styles2({
  base: {
    B2u0y6b: "f1qmtlvf"
  },
  smallMedium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  large: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".f1qmtlvf{max-width:264px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});
var useInfoButtonStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3
  } = state;
  const {
    open
  } = state.popover;
  const buttonStyles = useButtonStyles2();
  const popoverSurfaceStyles = usePopoverSurfaceStyles2();
  state.info.className = mergeClasses(infoButtonClassNames.info, popoverSurfaceStyles.base, size3 === "large" ? popoverSurfaceStyles.large : popoverSurfaceStyles.smallMedium, state.info.className);
  state.root.className = mergeClasses(infoButtonClassNames.root, buttonStyles.base, buttonStyles.highContrast, buttonStyles.focusIndicator, open && buttonStyles.selected, size3 === "large" && buttonStyles.large, state.root.className);
  return state;
};

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/InfoButton.js
var InfoButton = React475.forwardRef((props, ref) => {
  const state = useInfoButton_unstable(props, ref);
  useInfoButtonStyles_unstable(state);
  useCustomStyleHook("useInfoButtonStyles_unstable")(state);
  return renderInfoButton_unstable(state);
});
InfoButton.displayName = "InfoButton";

// node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/useInfoLabel.js
var useInfoLabel_unstable = (props, ref) => {
  const { root: rootShorthand, label: labelShorthand, infoButton: infoButtonShorthand, info, size: size3, className, style, ...labelProps } = props;
  const baseId = useId2("infolabel-");
  const [open, setOpen] = React476.useState(false);
  const root = slot_exports.always(rootShorthand, {
    defaultProps: {
      className,
      style
    },
    elementType: "span"
  });
  const label = slot_exports.always(labelShorthand, {
    defaultProps: {
      id: baseId + "__label",
      ref,
      size: size3,
      ...labelProps
    },
    elementType: Label
  });
  const infoButton = slot_exports.optional(infoButtonShorthand, {
    renderByDefault: !!info,
    defaultProps: {
      id: baseId + "__infoButton",
      size: size3,
      info
    },
    elementType: InfoButton
  });
  const infoButtonPopover = slot_exports.always(infoButton === null || infoButton === void 0 ? void 0 : infoButton.popover, {
    elementType: "div"
  });
  infoButtonPopover.onOpenChange = useEventCallback(mergeCallbacks(infoButtonPopover.onOpenChange, (_2, data) => {
    setOpen(data.open);
  }));
  if (infoButton) {
    var _infoButton, _arialabelledby;
    infoButton.popover = infoButtonPopover;
    const infoPopupId = baseId + "__info";
    infoButton.info = slot_exports.optional(infoButton === null || infoButton === void 0 ? void 0 : infoButton.info, {
      defaultProps: {
        id: infoPopupId,
        "aria-labelledby": infoPopupId
      },
      elementType: "div"
    });
    var _;
    (_ = (_infoButton = infoButton)[_arialabelledby = "aria-labelledby"]) !== null && _ !== void 0 ? _ : _infoButton[_arialabelledby] = `${label.id} ${infoButton.id}`;
    if (open) {
      var _infoButton_info;
      var _root, _ariaowns;
      var _1;
      (_1 = (_root = root)[_ariaowns = "aria-owns"]) !== null && _1 !== void 0 ? _1 : _root[_ariaowns] = (_infoButton_info = infoButton.info) === null || _infoButton_info === void 0 ? void 0 : _infoButton_info.id;
    }
  }
  return {
    size: size3,
    components: {
      root: "span",
      label: Label,
      infoButton: InfoButton
    },
    root,
    label,
    infoButton
  };
};

// node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/useInfoLabelStyles.styles.js
var infoLabelClassNames = {
  root: "fui-InfoLabel",
  label: "fui-InfoLabel__label",
  infoButton: "fui-InfoLabel__infoButton"
};
var useLabelStyles6 = __styles2({
  base: {
    ha4doy: "f12kltsn",
    Bceei9c: "fpo1scq",
    sj55zd: "f1ym3bx4"
  }
}, {
  d: [".f12kltsn{vertical-align:top;}", ".fpo1scq{cursor:inherit;}", ".f1ym3bx4{color:inherit;}"]
});
var useInfoButtonStyles = __styles2({
  base: {
    ha4doy: "f12kltsn",
    B6of3ja: "f1bmzb36",
    jrapky: "f1nyzk09"
  },
  large: {
    B6of3ja: "fkrn0sh",
    jrapky: "fmxx68s"
  }
}, {
  d: [".f12kltsn{vertical-align:top;}", ".f1bmzb36{margin-top:calc(0px - var(--spacingVerticalXXS));}", ".f1nyzk09{margin-bottom:calc(0px - var(--spacingVerticalXXS));}", ".fkrn0sh{margin-top:-1px;}", ".fmxx68s{margin-bottom:-1px;}"]
});
var useInfoLabelStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(infoLabelClassNames.root, state.root.className);
  const labelStyles = useLabelStyles6();
  state.label.className = mergeClasses(infoLabelClassNames.label, labelStyles.base, state.label.className);
  const infoButtonStyles = useInfoButtonStyles();
  if (state.infoButton) {
    state.infoButton.className = mergeClasses(infoLabelClassNames.infoButton, infoButtonStyles.base, state.size === "large" && infoButtonStyles.large, state.infoButton.className);
  }
  return state;
};

// node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/InfoLabel.js
var InfoLabel = React477.forwardRef((props, ref) => {
  const state = useInfoLabel_unstable(props, ref);
  useInfoLabelStyles_unstable(state);
  useCustomStyleHook("useInfoLabelStyles_unstable")(state);
  return renderInfoLabel_unstable(state);
});
InfoLabel.displayName = "InfoLabel";

// node_modules/@fluentui/react-drawer/lib/contexts/drawerContext.js
var React478 = __toESM(require_react());
var defaultContextValue4 = {
  scrollState: "none",
  setScrollState: () => ({})
};
var drawerContext = React478.createContext(void 0);
var DrawerProvider = drawerContext.Provider;
var useDrawerContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React478.useContext(drawerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultContextValue4;
};
var useDrawerContextValue = () => {
  const [scrollState, setScrollState] = React478.useState("none");
  return {
    setScrollState,
    scrollState
  };
};

// node_modules/@fluentui/react-drawer/lib/components/Drawer/Drawer.js
var React487 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/Drawer/useDrawer.js
var React486 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/OverlayDrawer.js
var React483 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/useOverlayDrawer.js
var React481 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/shared/useDrawerBaseStyles.styles.js
var drawerCSSVars = {
  drawerSizeVar: "--fui-Drawer--size"
};
var drawerDefaultStyles = {
  overflow: "hidden",
  width: `var(${drawerCSSVars.drawerSizeVar})`,
  maxWidth: "100vw",
  height: "auto",
  maxHeight: "100vh",
  boxSizing: "border-box",
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start",
  justifyContent: "flex-start",
  backgroundColor: tokens.colorNeutralBackground1,
  color: tokens.colorNeutralForeground1
};
var useDrawerStyles = __styles2({
  start: {
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    u1mtju: ["f1xteiwb", "fsqykmd"],
    oyh7mz: ["f1vgc2s3", "f1e31b4d"],
    j35jbq: ["fvfyk4", "frppm18"]
  },
  end: {
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    B4g9neb: ["fsqykmd", "f1xteiwb"],
    j35jbq: ["f1e31b4d", "f1vgc2s3"],
    oyh7mz: ["frppm18", "fvfyk4"]
  },
  bottom: {
    B5kzvoi: "f1yab3r1",
    Bhzewxz: "f198g47y"
  },
  small: {
    Bjr0ffy: "f1exhnwo"
  },
  medium: {
    Bjr0ffy: "fqofjzu"
  },
  large: {
    Bjr0ffy: "fce6y3m"
  },
  full: {
    Bjr0ffy: "fsdmzs6"
  }
}, {
  d: [[".f1xteiwb{border-right:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -1
  }], [".fsqykmd{border-left:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -1
  }], ".f1vgc2s3{left:0;}", ".f1e31b4d{right:0;}", ".fvfyk4{right:auto;}", ".frppm18{left:auto;}", [".fsqykmd{border-left:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -1
  }], [".f1xteiwb{border-right:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -1
  }], ".f1yab3r1{bottom:0;}", ".f198g47y{top:auto;}", ".f1exhnwo{--fui-Drawer--size:320px;}", ".fqofjzu{--fui-Drawer--size:592px;}", ".fce6y3m{--fui-Drawer--size:940px;}", ".fsdmzs6{--fui-Drawer--size:100vw;}"]
});
var useDrawerBottomBaseStyles = __styles2({
  small: {
    Bjr0ffy: "f1exhnwo"
  },
  medium: {
    Bjr0ffy: "fqofjzu"
  },
  large: {
    Bjr0ffy: "fce6y3m"
  },
  full: {
    Bjr0ffy: "f1rat34m"
  }
}, {
  d: [".f1exhnwo{--fui-Drawer--size:320px;}", ".fqofjzu{--fui-Drawer--size:592px;}", ".fce6y3m{--fui-Drawer--size:940px;}", ".f1rat34m{--fui-Drawer--size:100%;}"]
});
var useDrawerBaseClassNames = ({
  position,
  size: size3
}) => {
  const baseStyles3 = useDrawerStyles();
  const bottomBaseStyles = useDrawerBottomBaseStyles();
  return mergeClasses(baseStyles3[position], position === "bottom" && bottomBaseStyles[size3], position !== "bottom" && baseStyles3[size3]);
};

// node_modules/@fluentui/react-drawer/lib/shared/drawerMotions.js
var durations3 = {
  small: motionTokens.durationGentle,
  medium: motionTokens.durationSlow,
  large: motionTokens.durationSlower,
  full: motionTokens.durationUltraSlow
};
function getPositionTransform(position, sizeVar, dir) {
  const leftToRightTransform = `translate3d(var(${sizeVar}), 0, 0)`;
  const rightToLeftTransform = `translate3d(calc(var(${sizeVar}) * -1), 0, 0)`;
  const bottomToTopTransform = `translate3d(0, var(${sizeVar}), 0)`;
  if (position === "start") {
    return dir === "ltr" ? rightToLeftTransform : leftToRightTransform;
  }
  if (position === "end") {
    return dir === "ltr" ? leftToRightTransform : rightToLeftTransform;
  }
  if (position === "bottom") {
    return bottomToTopTransform;
  }
  return "translate3d(0, 0, 0)";
}
var InlineDrawerMotion = createPresenceComponent(({ position, size: size3, dir }) => {
  const keyframes = [
    {
      /**
      * TODO: Once the #31663 lands, we should update the RTL logic to use Motion APIs
      * The work will be done in the #32817
      */
      transform: getPositionTransform(position, drawerCSSVars.drawerSizeVar, dir),
      opacity: 0
    },
    {
      transform: "translate3d(0, 0, 0)",
      opacity: 1
    }
  ];
  const duration = durations3[size3];
  return {
    enter: {
      keyframes,
      duration,
      easing: motionTokens.curveDecelerateMid
    },
    exit: {
      keyframes: [
        ...keyframes
      ].reverse(),
      duration,
      easing: motionTokens.curveAccelerateMin
    }
  };
});
var OverlayDrawerMotion = createPresenceComponent(({ position, size: size3, dir }) => {
  const keyframes = [
    {
      /**
      * TODO: Once the #31663 lands, we should update the RTL logic to use Motion APIs
      * The work will be done in the #32817
      */
      transform: getPositionTransform(position, drawerCSSVars.drawerSizeVar, dir),
      boxShadow: `0px ${tokens.colorTransparentBackground}`,
      opacity: 0
    },
    {
      transform: "translate3d(0, 0, 0)",
      boxShadow: tokens.shadow64,
      opacity: 1
    }
  ];
  const duration = durations3[size3];
  return {
    enter: {
      keyframes,
      duration,
      easing: motionTokens.curveDecelerateMid
    },
    exit: {
      keyframes: [
        ...keyframes
      ].reverse(),
      duration,
      easing: motionTokens.curveAccelerateMin
    }
  };
});
var OverlaySurfaceBackdropMotion = createPresenceComponent(({ size: size3 }) => {
  const keyframes = [
    {
      opacity: 0
    },
    {
      opacity: 1
    }
  ];
  const duration = durations3[size3];
  return {
    enter: {
      keyframes,
      easing: motionTokens.curveLinear,
      duration
    },
    exit: {
      keyframes: [
        ...keyframes
      ].reverse(),
      easing: motionTokens.curveLinear,
      duration
    }
  };
});

// node_modules/@fluentui/react-drawer/lib/shared/useDrawerDefaultProps.js
function useDrawerDefaultProps(props) {
  const { open = false, size: size3 = "small", position = "start" } = props;
  return {
    size: size3,
    position,
    open
  };
}

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/OverlayDrawerSurface/OverlayDrawerSurface.js
var React479 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/OverlayDrawerSurface/useOverlayDrawerSurfaceStyles.styles.js
var useBackdropResetStyles = __resetStyles("rl76ifk", null, [".rl76ifk{inset:0px;position:fixed;background-color:var(--colorBackgroundOverlay);}"]);
var useBackdropStyles = __styles2({
  nested: {
    De3pzq: "f1c21dwh"
  }
}, {
  d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}"]
});
var useOverlayDrawerSurfaceStyles_unstable = (state) => {
  "use no memo";
  const backdropResetStyles = useBackdropResetStyles();
  const backdropStyles = useBackdropStyles();
  if (state.backdrop) {
    state.backdrop.className = mergeClasses(backdropResetStyles, state.isNestedDialog && backdropStyles.nested, state.backdrop.className);
  }
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/OverlayDrawerSurface/OverlayDrawerSurface.js
var OverlayDrawerSurface = React479.forwardRef((props, ref) => {
  const dialogSurfaceState = useDialogSurface_unstable({
    ...props,
    /**
    * Drawer accepts a `div` or `aside` element type, but Dialog only accepts a `div` element type.
    * We need to cast the ref to a `div` element type to not break Dialog's ref type.
    *
    * FIXME: Evaluate the possibility to remove this cast when Dialog is refactored to accept `aside` elements.
    */
    as: props.as
  }, ref);
  const dialogSurfaceContextValues = useDialogSurfaceContextValues_unstable(dialogSurfaceState);
  useOverlayDrawerSurfaceStyles_unstable(dialogSurfaceState);
  useCustomStyleHook("useOverlayDrawerSurfaceStyles_unstable")(dialogSurfaceState);
  return renderDialogSurface_unstable(dialogSurfaceState, dialogSurfaceContextValues);
});
OverlayDrawerSurface.displayName = "OverlayDrawerSurface";

// node_modules/@fluentui/react-drawer/lib/shared/drawerMotionUtils.js
var React480 = __toESM(require_react());
function mergePresenceSlots(inputSlot, Component2, params) {
  if (inputSlot === null) {
    return null;
  }
  return {
    ...inputSlot,
    children: (_, props) => {
      if (inputSlot === null || inputSlot === void 0 ? void 0 : inputSlot.children) {
        return inputSlot.children(Component2, {
          ...props,
          ...params
        });
      }
      return React480.createElement(Component2, {
        ...props,
        ...params
      }, props.children);
    }
  };
}

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/useOverlayDrawer.js
var STATIC_MOTION = {
  active: true,
  canRender: true,
  ref: React481.createRef(),
  type: "idle"
};
var useOverlayDrawer_unstable = (props, ref) => {
  const { open, size: size3, position } = useDrawerDefaultProps(props);
  const { backdropMotion, modalType = "modal", inertTrapFocus, onOpenChange, surfaceMotion, mountNode } = props;
  const { dir, targetDocument } = useFluent();
  const { element: mountNodeElement } = toMountNodeProps(mountNode);
  const hasMountNodeElement = Boolean(mountNodeElement && (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body) !== mountNodeElement);
  const backdropProps = slot_exports.resolveShorthand(props.backdrop);
  const hasCustomBackdrop = modalType !== "non-modal" && backdropProps !== null;
  const root = slot_exports.always({
    ...props,
    ref,
    backdrop: hasCustomBackdrop ? {
      ...backdropProps
    } : null,
    backdropMotion: mergePresenceSlots(backdropMotion, OverlaySurfaceBackdropMotion, {
      size: size3
    })
  }, {
    /**
    * Drawer accepts a `div` or `aside` element type, but Dialog only accepts a `div` element type.
    * We need to cast the ref to a `div` element type to not break Dialog's ref type.
    */
    elementType: OverlayDrawerSurface
  });
  const dialog = slot_exports.always({
    open,
    onOpenChange,
    inertTrapFocus,
    modalType,
    surfaceMotion: mergePresenceSlots(surfaceMotion, OverlayDrawerMotion, {
      position,
      size: size3,
      dir
    }),
    /**
    * children is not needed here because we construct the children in the render function,
    * but it's required by DialogProps
    */
    children: null
  }, {
    elementType: Dialog
  });
  return {
    components: {
      root: OverlayDrawerSurface,
      dialog: Dialog
    },
    root,
    dialog,
    open,
    size: size3,
    position,
    hasMountNodeElement,
    // Deprecated props
    mountNode,
    motion: STATIC_MOTION
  };
};

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/renderOverlayDrawer.js
var renderOverlayDrawer_unstable = (state, contextValue) => {
  assertSlots(state);
  return jsx(DrawerProvider, {
    value: contextValue,
    children: jsx(state.dialog, {
      children: jsx(state.root, {})
    })
  });
};

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/useOverlayDrawerStyles.styles.js
var React482 = __toESM(require_react());
var overlayDrawerClassNames = {
  root: "fui-OverlayDrawer",
  backdrop: "fui-OverlayDrawer__backdrop"
};
var useDrawerResetStyles = __resetStyles("r7dfyj8", "rmx02j7", {
  r: [".r7dfyj8{overflow:hidden;width:var(--fui-Drawer--size);max-width:100vw;height:auto;max-height:100vh;box-sizing:border-box;display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);position:fixed;top:0;bottom:0;}", ".r7dfyj8:focus{outline-style:none;}", ".r7dfyj8:focus-visible{outline-style:none;}", ".r7dfyj8[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r7dfyj8[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".rmx02j7{overflow:hidden;width:var(--fui-Drawer--size);max-width:100vw;height:auto;max-height:100vh;box-sizing:border-box;display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);position:fixed;top:0;bottom:0;}", ".rmx02j7:focus{outline-style:none;}", ".rmx02j7:focus-visible{outline-style:none;}", ".rmx02j7[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.rmx02j7[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.r7dfyj8[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.rmx02j7[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useDrawerRootStyles = __styles2({
  start: {},
  end: {},
  bottom: {
    Bhzewxz: "f198g47y",
    Bqenvij: "fub80nq",
    a9b677: "fr97h3j"
  },
  absolute: {
    qhf8xq: "f1euv43f"
  }
}, {
  d: [".f198g47y{top:auto;}", ".fub80nq{height:var(--fui-Drawer--size);}", ".fr97h3j{width:100vw;}", ".f1euv43f{position:absolute;}"]
});
var useOverlayDrawerStyles_unstable = (state) => {
  "use no memo";
  const baseClassNames = useDrawerBaseClassNames(state);
  const resetStyles = useDrawerResetStyles();
  const rootStyles = useDrawerRootStyles();
  const absoluteStyles = state.hasMountNodeElement && rootStyles.absolute;
  const backdrop = state.root.backdrop;
  state.root.className = mergeClasses(overlayDrawerClassNames.root, baseClassNames, resetStyles, rootStyles[state.position], absoluteStyles, state.root.className);
  if (backdrop) {
    backdrop.className = mergeClasses(overlayDrawerClassNames.backdrop, absoluteStyles, backdrop.className);
  }
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/OverlayDrawer.js
var OverlayDrawer = React483.forwardRef((props, ref) => {
  const state = useOverlayDrawer_unstable(props, ref);
  const contextValue = useDrawerContextValue();
  useOverlayDrawerStyles_unstable(state);
  useCustomStyleHook("useDrawerOverlayStyles_unstable")(state);
  useCustomStyleHook("useOverlayDrawerStyles_unstable")(state);
  return renderOverlayDrawer_unstable(state, contextValue);
});
OverlayDrawer.displayName = "OverlayDrawer";

// node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/InlineDrawer.js
var React485 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/useInlineDrawer.js
var React484 = __toESM(require_react());
var STATIC_MOTION2 = {
  active: true,
  canRender: true,
  ref: React484.createRef(),
  type: "idle"
};
var useInlineDrawer_unstable = (props, ref) => {
  const { size: size3, position, open } = useDrawerDefaultProps(props);
  const { separator = false, surfaceMotion } = props;
  const { dir } = useFluent();
  const state = {
    components: {
      root: "div",
      // casting from internal type that has required properties
      // to external type that only has optional properties
      // converting to unknown first as both Function component signatures are not compatible
      surfaceMotion: InlineDrawerMotion
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ...props,
      ref
    }), {
      elementType: "div"
    }),
    open,
    position,
    size: size3,
    separator,
    surfaceMotion: presenceMotionSlot(surfaceMotion, {
      elementType: InlineDrawerMotion,
      defaultProps: {
        position,
        size: size3,
        dir,
        visible: open,
        unmountOnExit: true
      }
    }),
    // Deprecated props
    motion: STATIC_MOTION2
  };
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/renderInlineDrawer.js
var renderInlineDrawer_unstable = (state, contextValue) => {
  assertSlots(state);
  return jsx(DrawerProvider, {
    value: contextValue,
    children: jsx(state.surfaceMotion, {
      children: jsx(state.root, {})
    })
  });
};

// node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/useInlineDrawerStyles.styles.js
var inlineDrawerClassNames = {
  root: "fui-InlineDrawer"
};
var useDrawerResetStyles2 = __resetStyles("rkjj3x6", null, [".rkjj3x6{overflow:hidden;width:var(--fui-Drawer--size);max-width:100vw;height:auto;max-height:100vh;box-sizing:border-box;display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);position:relative;}"]);
var borderValue = `1px solid ${tokens.colorNeutralBackground3}`;
var useDrawerRootStyles2 = __styles2({
  separatorStart: {
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    u1mtju: ["f1cxmi7i", "f1j970fk"]
  },
  separatorEnd: {
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    B4g9neb: ["f1j970fk", "f1cxmi7i"]
  },
  separatorBottom: {
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    i8vvqc: "f1n3kblk"
  },
  start: {},
  end: {},
  bottom: {
    a9b677: "fly5x3f",
    Bqenvij: "fub80nq"
  }
}, {
  d: [[".f1cxmi7i{border-right:1px solid var(--colorNeutralBackground3);}", {
    p: -1
  }], [".f1j970fk{border-left:1px solid var(--colorNeutralBackground3);}", {
    p: -1
  }], [".f1j970fk{border-left:1px solid var(--colorNeutralBackground3);}", {
    p: -1
  }], [".f1cxmi7i{border-right:1px solid var(--colorNeutralBackground3);}", {
    p: -1
  }], [".f1n3kblk{border-top:1px solid var(--colorNeutralBackground3);}", {
    p: -1
  }], ".fly5x3f{width:100%;}", ".fub80nq{height:var(--fui-Drawer--size);}"]
});
function getSeparatorClass(state, classNames) {
  if (!state.separator) {
    return void 0;
  }
  switch (state.position) {
    case "start":
      return classNames.separatorStart;
    case "end":
      return classNames.separatorEnd;
    case "bottom":
      return classNames.separatorBottom;
    default:
      return void 0;
  }
}
var useInlineDrawerStyles_unstable = (state) => {
  "use no memo";
  const resetStyles = useDrawerResetStyles2();
  const baseClassNames = useDrawerBaseClassNames(state);
  const rootStyles = useDrawerRootStyles2();
  state.root.className = mergeClasses(inlineDrawerClassNames.root, resetStyles, baseClassNames, getSeparatorClass(state, rootStyles), rootStyles[state.position], state.root.className);
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/InlineDrawer.js
var InlineDrawer = React485.forwardRef((props, ref) => {
  const state = useInlineDrawer_unstable(props, ref);
  const contextValue = useDrawerContextValue();
  useInlineDrawerStyles_unstable(state);
  useCustomStyleHook("useDrawerInlineStyles_unstable")(state);
  useCustomStyleHook("useInlineDrawerStyles_unstable")(state);
  return renderInlineDrawer_unstable(state, contextValue);
});
InlineDrawer.displayName = "InlineDrawer";

// node_modules/@fluentui/react-drawer/lib/components/Drawer/useDrawer.js
var useDrawer_unstable = (props, ref) => {
  const elementType = props.type === "inline" ? InlineDrawer : OverlayDrawer;
  const root = slot_exports.always({
    ref,
    ...props
  }, {
    elementType
  });
  return {
    components: {
      root: elementType
    },
    root
  };
};

// node_modules/@fluentui/react-drawer/lib/components/Drawer/renderDrawer.js
var renderDrawer_unstable = (state, contextValue) => {
  assertSlots(state);
  return jsx(DrawerProvider, {
    value: contextValue,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-drawer/lib/components/Drawer/useDrawerStyles.styles.js
var drawerClassNames = {
  root: "fui-Drawer"
};
var useDrawerStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(drawerClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/Drawer/Drawer.js
var Drawer = React487.forwardRef((props, ref) => {
  const state = useDrawer_unstable(props, ref);
  const contextValue = useDrawerContextValue();
  useDrawerStyles_unstable(state);
  useCustomStyleHook("useDrawerStyles_unstable")(state);
  return renderDrawer_unstable(state, contextValue);
});
Drawer.displayName = "Drawer";

// node_modules/@fluentui/react-drawer/lib/components/DrawerBody/DrawerBody.js
var React489 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/DrawerBody/useDrawerBody.js
var React488 = __toESM(require_react());
var getScrollState = ({ scrollTop, scrollHeight, clientHeight }) => {
  if (scrollHeight <= clientHeight) {
    return "none";
  }
  if (scrollTop === 0) {
    return "top";
  }
  if (scrollTop + clientHeight === scrollHeight) {
    return "bottom";
  }
  return "middle";
};
var useDrawerBody_unstable = (props, ref) => {
  const { setScrollState } = useDrawerContext_unstable();
  const scrollRef = React488.useRef(null);
  const [setAnimationFrame, cancelAnimationFrame2] = useAnimationFrame();
  const updateScrollState = React488.useCallback(() => {
    if (!scrollRef.current) {
      return;
    }
    setScrollState(getScrollState(scrollRef.current));
  }, [
    setScrollState
  ]);
  const onScroll = React488.useCallback(() => {
    cancelAnimationFrame2();
    setAnimationFrame(() => updateScrollState());
  }, [
    cancelAnimationFrame2,
    setAnimationFrame,
    updateScrollState
  ]);
  useIsomorphicLayoutEffect(() => {
    cancelAnimationFrame2();
    setAnimationFrame(() => updateScrollState());
    return () => cancelAnimationFrame2();
  }, [
    props.children,
    cancelAnimationFrame2,
    updateScrollState,
    setAnimationFrame
  ]);
  useIsomorphicLayoutEffect(() => {
    cancelAnimationFrame2();
    setAnimationFrame(() => updateScrollState());
    return () => cancelAnimationFrame2();
  }, [
    cancelAnimationFrame2,
    updateScrollState,
    setAnimationFrame
  ]);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, scrollRef),
      ...props,
      onScroll: mergeCallbacks(props.onScroll, onScroll)
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerBody/renderDrawerBody.js
var renderDrawerBody_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerBody/useDrawerBodyStyles.styles.js
var drawerBodyClassNames = {
  root: "fui-DrawerBody"
};
var useStyles56 = __resetStyles("ri6rvx7", null, [".ri6rvx7{padding:0 var(--spacingHorizontalXXL);flex:1;align-self:stretch;position:relative;z-index:1;overflow:auto;}", ".ri6rvx7:last-child{padding-bottom:calc(var(--spacingHorizontalXXL) + 1px);}", ".ri6rvx7:first-child{padding-top:calc(var(--spacingHorizontalXXL) + 1px);}"]);
var useDrawerBodyStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles56();
  state.root.className = mergeClasses(drawerBodyClassNames.root, styles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerBody/DrawerBody.js
var DrawerBody = React489.forwardRef((props, ref) => {
  const state = useDrawerBody_unstable(props, ref);
  useDrawerBodyStyles_unstable(state);
  useCustomStyleHook("useDrawerBodyStyles_unstable")(state);
  return renderDrawerBody_unstable(state);
});
DrawerBody.displayName = "DrawerBody";

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/DrawerHeader.js
var React491 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/useDrawerHeader.js
var React490 = __toESM(require_react());
var useDrawerHeader_unstable = (props, ref) => {
  const { scrollState } = useDrawerContext_unstable();
  return {
    components: {
      root: "header"
    },
    root: slot_exports.always(getIntrinsicElementProps("header", {
      ref,
      role: "none",
      ...props
    }), {
      elementType: "header"
    }),
    scrollState
  };
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/renderDrawerHeader.js
var renderDrawerHeader_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-drawer/lib/shared/drawerSeparatorStyles.js
var drawerSeparatorStyles = {
  height: "1px",
  position: "absolute",
  right: 0,
  left: 0,
  opacity: 0,
  backgroundColor: tokens.colorNeutralStroke1,
  transitionDuration: tokens.durationNormal,
  transitionProperty: "opacity",
  transitionTimingFunction: tokens.curveEasyEase,
  content: '""'
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/useDrawerHeaderStyles.styles.js
var drawerHeaderClassNames = {
  root: "fui-DrawerHeader"
};
var useStyles57 = __resetStyles("r3ovn4i", null, [".r3ovn4i{width:100%;max-width:100%;padding:var(--spacingVerticalXXL) var(--spacingHorizontalXXL) var(--spacingVerticalS);gap:var(--spacingHorizontalS);align-self:stretch;display:flex;flex-direction:column;box-sizing:border-box;position:relative;z-index:2;}"]);
var useDrawerHeaderStyles = __styles2({
  separator: {
    Dlnsje: "fxnjyrl",
    E3zdtr: "f1mdlcz9",
    B1piin3: ["f15yvnhg", "f1n6gb5g"],
    Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
    Bp15pi3: "f1564nw5",
    Bjyk6c5: "fdlpgxj",
    F2fol1: "f15cmg8x",
    Ba2ppi3: "f3f8dgl",
    B1dyfl9: "fjvo4va",
    Bsft5z2: "f13zj6fq",
    By385i5: "fo72kxq"
  },
  separatorVisible: {
    Bp15pi3: "fjsqi2x"
  }
}, {
  d: [".fxnjyrl::after{height:1px;}", ".f1mdlcz9::after{position:absolute;}", ".f15yvnhg::after{right:0;}", ".f1n6gb5g::after{left:0;}", ".f1564nw5::after{opacity:0;}", ".fdlpgxj::after{background-color:var(--colorNeutralStroke1);}", ".f15cmg8x::after{transition-duration:var(--durationNormal);}", ".f3f8dgl::after{transition-property:opacity;}", ".fjvo4va::after{transition-timing-function:var(--curveEasyEase);}", '.f13zj6fq::after{content:"";}', ".fo72kxq::after{bottom:0;}", ".fjsqi2x::after{opacity:1;}"]
});
var useDrawerHeaderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles57();
  const rootStyles = useDrawerHeaderStyles();
  state.root.className = mergeClasses(drawerHeaderClassNames.root, styles, state.scrollState !== "none" && rootStyles.separator, ["middle", "bottom"].includes(state.scrollState) && rootStyles.separatorVisible, state.root.className);
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/DrawerHeader.js
var DrawerHeader = React491.forwardRef((props, ref) => {
  const state = useDrawerHeader_unstable(props, ref);
  useDrawerHeaderStyles_unstable(state);
  useCustomStyleHook("useDrawerHeaderStyles_unstable")(state);
  return renderDrawerHeader_unstable(state);
});
DrawerHeader.displayName = "DrawerHeader";

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/DrawerHeaderTitle.js
var React493 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/useDrawerHeaderTitle.js
var React492 = __toESM(require_react());
var useDrawerHeaderTitle_unstable = (props, ref) => {
  const { children: children2, heading } = props;
  const headingId = useDialogContext_unstable((ctx) => ctx.dialogTitleId);
  return {
    components: {
      root: "div",
      heading: "h2",
      action: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    heading: slot_exports.optional(heading, {
      defaultProps: {
        id: headingId,
        children: children2
      },
      renderByDefault: true,
      elementType: "h2"
    }),
    action: slot_exports.optional(props.action, {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/renderDrawerHeaderTitle.js
var renderDrawerHeaderTitle_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.heading && jsx(state.heading, {}),
      state.action && jsx(state.action, {})
    ]
  });
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/useDrawerHeaderTitleStyles.styles.js
var drawerHeaderTitleClassNames = {
  root: "fui-DrawerHeaderTitle",
  heading: "fui-DrawerHeaderTitle__heading",
  action: "fui-DrawerHeaderTitle__action"
};
var useStyles58 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Brf1p80: "f1869bpl",
    Bt984gj: "f122n59",
    i8kkvl: "fsnqrgy"
  },
  action: {
    t21cq0: ["faqnl2i", "fd75udd"]
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1869bpl{justify-content:space-between;}", ".f122n59{align-items:center;}", ".fsnqrgy{column-gap:var(--spacingHorizontalS);}", ".faqnl2i{margin-right:calc(var(--spacingHorizontalS) * -1);}", ".fd75udd{margin-left:calc(var(--spacingHorizontalS) * -1);}"]
});
var useDrawerHeaderTitleStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles58();
  const {
    heading: root = {},
    action,
    // We should not use components to pass along the base element type of a slot
    // but there's no way to retrieve the element type of a slot from the slot definition
    // right now without using SLOT_ELEMENT_TYPE_SYMBOL
    // TODO: create a method to retrieve the element type of a slot
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    components
  } = state;
  useDialogTitleStyles_unstable({
    components: {
      root: components.heading,
      action: components.action
    },
    root,
    action
  });
  state.root.className = mergeClasses(drawerHeaderTitleClassNames.root, styles.root, state.root.className);
  if (state.heading) {
    state.heading.className = mergeClasses(drawerHeaderTitleClassNames.heading, state.heading.className);
  }
  if (state.action) {
    state.action.className = mergeClasses(drawerHeaderTitleClassNames.action, styles.action, state.action.className);
  }
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/DrawerHeaderTitle.js
var DrawerHeaderTitle = React493.forwardRef((props, ref) => {
  const state = useDrawerHeaderTitle_unstable(props, ref);
  useDrawerHeaderTitleStyles_unstable(state);
  useCustomStyleHook("useDrawerHeaderTitleStyles_unstable")(state);
  return renderDrawerHeaderTitle_unstable(state);
});
DrawerHeaderTitle.displayName = "DrawerHeaderTitle";

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/DrawerHeaderNavigation.js
var React495 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/useDrawerHeaderNavigation.js
var React494 = __toESM(require_react());
var useDrawerHeaderNavigation_unstable = (props, ref) => {
  return {
    components: {
      root: "nav"
    },
    root: slot_exports.always(getIntrinsicElementProps("nav", {
      ref,
      ...props
    }), {
      elementType: "nav"
    })
  };
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/renderDrawerHeaderNavigation.js
var renderDrawerHeaderNavigation_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/useDrawerHeaderNavigationStyles.styles.js
var drawerHeaderNavigationClassNames = {
  root: "fui-DrawerHeaderNavigation"
};
var useStyles59 = __resetStyles("r1ig4pwh", null, [".r1ig4pwh{margin:calc(var(--spacingVerticalS) * -1) calc(var(--spacingHorizontalL) * -1);}"]);
var useDrawerHeaderNavigationStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles59();
  state.root.className = mergeClasses(drawerHeaderNavigationClassNames.root, styles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/DrawerHeaderNavigation.js
var DrawerHeaderNavigation = React495.forwardRef((props, ref) => {
  const state = useDrawerHeaderNavigation_unstable(props, ref);
  useDrawerHeaderNavigationStyles_unstable(state);
  useCustomStyleHook("useDrawerHeaderNavigationStyles_unstable")(state);
  return renderDrawerHeaderNavigation_unstable(state);
});
DrawerHeaderNavigation.displayName = "DrawerHeaderNavigation";

// node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/DrawerFooter.js
var React497 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/useDrawerFooter.js
var React496 = __toESM(require_react());
var useDrawerFooter_unstable = (props, ref) => {
  const { scrollState } = useDrawerContext_unstable();
  return {
    components: {
      root: "footer"
    },
    root: slot_exports.always(getIntrinsicElementProps("footer", {
      ref,
      role: "none",
      ...props
    }), {
      elementType: "footer"
    }),
    scrollState
  };
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/renderDrawerFooter.js
var renderDrawerFooter_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/useDrawerFooterStyles.styles.js
var drawerFooterClassNames = {
  root: "fui-DrawerFooter"
};
var useStyles60 = __resetStyles("r1snvl2j", null, [".r1snvl2j{width:100%;max-width:100%;padding:var(--spacingVerticalL) var(--spacingHorizontalXXL) var(--spacingVerticalXXL);display:flex;justify-content:flex-start;align-items:center;column-gap:var(--spacingHorizontalS);box-sizing:border-box;position:relative;z-index:2;}"]);
var useDrawerFooterStyles = __styles2({
  separator: {
    Baz25je: "f16b62f1",
    Brfgrao: "f1j7ml58",
    mdwyqc: ["f1f351id", "f1fzr1x6"],
    Fbdkly: ["f1fzr1x6", "f1f351id"],
    vz82u: "f1dhznln",
    cmx5o7: "f1p5zmk",
    h7gv66: "f1ljjo4k",
    B8bqphf: "ffd2d9j",
    wjn42g: "ffdt3s5",
    Ftih45: "f1wl9k8s",
    Bciustq: "ffi060y"
  },
  separatorVisible: {
    vz82u: "f1b3qyzu"
  }
}, {
  d: [".f16b62f1::before{height:1px;}", ".f1j7ml58::before{position:absolute;}", ".f1f351id::before{right:0;}", ".f1fzr1x6::before{left:0;}", ".f1dhznln::before{opacity:0;}", ".f1p5zmk::before{background-color:var(--colorNeutralStroke1);}", ".f1ljjo4k::before{transition-duration:var(--durationNormal);}", ".ffd2d9j::before{transition-property:opacity;}", ".ffdt3s5::before{transition-timing-function:var(--curveEasyEase);}", '.f1wl9k8s::before{content:"";}', ".ffi060y::before{top:0;}", ".f1b3qyzu::before{opacity:1;}"]
});
var useDrawerFooterStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles60();
  const rootStyles = useDrawerFooterStyles();
  state.root.className = mergeClasses(drawerFooterClassNames.root, styles, state.scrollState !== "none" && rootStyles.separator, ["middle", "top"].includes(state.scrollState) && rootStyles.separatorVisible, state.root.className);
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/DrawerFooter.js
var DrawerFooter = React497.forwardRef((props, ref) => {
  const state = useDrawerFooter_unstable(props, ref);
  useDrawerFooterStyles_unstable(state);
  useCustomStyleHook("useDrawerFooterStyles_unstable")(state);
  return renderDrawerFooter_unstable(state);
});
DrawerFooter.displayName = "DrawerFooter";

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/Breadcrumb.js
var React501 = __toESM(require_react());

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/useBreadcrumb.js
var React498 = __toESM(require_react());
var useBreadcrumb_unstable = (props, ref) => {
  const { focusMode = "tab", size: size3 = "medium", list, ...rest } = props;
  const focusAttributes = useArrowNavigationGroup({
    circular: true,
    axis: "horizontal",
    memorizeCurrent: true
  });
  var _props_arialabel;
  return {
    components: {
      root: "nav",
      list: "ol"
    },
    root: slot_exports.always(getIntrinsicElementProps("nav", {
      ref,
      "aria-label": (_props_arialabel = props["aria-label"]) !== null && _props_arialabel !== void 0 ? _props_arialabel : "breadcrumb",
      ...focusMode === "arrow" ? focusAttributes : {},
      ...rest
    }), {
      elementType: "nav"
    }),
    list: slot_exports.optional(list, {
      renderByDefault: true,
      defaultProps: {
        role: "list"
      },
      elementType: "ol"
    }),
    size: size3
  };
};

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/BreadcrumbContext.js
var React499 = __toESM(require_react());
var BreadcrumbContext = React499.createContext(void 0);
var breadcrumbDefaultValue = {
  size: "medium"
};
var BreadcrumbProvider = BreadcrumbContext.Provider;
var useBreadcrumbContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React499.useContext(BreadcrumbContext)) !== null && _React_useContext !== void 0 ? _React_useContext : breadcrumbDefaultValue;
};

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/renderBreadcrumb.js
var renderBreadcrumb_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(BreadcrumbProvider, {
      value: contextValues,
      children: state.list && jsx(state.list, {
        children: state.root.children
      })
    })
  });
};

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/useBreadcrumbStyles.styles.js
var breadcrumbClassNames = {
  root: "fui-Breadcrumb",
  list: "fui-Breadcrumb__list"
};
var useListClassName = __resetStyles("rc5rb6b", null, [".rc5rb6b{list-style-type:none;display:flex;align-items:center;margin:0;padding:0;}"]);
var useBreadcrumbStyles_unstable = (state) => {
  "use no memo";
  const listBaseClassName = useListClassName();
  state.root.className = mergeClasses(breadcrumbClassNames.root, state.root.className);
  if (state.list) {
    state.list.className = mergeClasses(listBaseClassName, breadcrumbClassNames.list, state.list.className);
  }
  return state;
};

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/useBreadcrumbContextValue.js
var React500 = __toESM(require_react());
function useBreadcrumbContextValues_unstable(state) {
  const { size: size3 } = state;
  return React500.useMemo(() => ({
    size: size3
  }), [
    size3
  ]);
}

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/Breadcrumb.js
var Breadcrumb = React501.forwardRef((props, ref) => {
  const state = useBreadcrumb_unstable(props, ref);
  const contextValues = useBreadcrumbContextValues_unstable(state);
  useBreadcrumbStyles_unstable(state);
  useCustomStyleHook("useBreadcrumbStyles_unstable")(state);
  return renderBreadcrumb_unstable(state, contextValues);
});
Breadcrumb.displayName = "Breadcrumb";

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/BreadcrumbDivider.js
var React503 = __toESM(require_react());

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/useBreadcrumbDivider.js
var React502 = __toESM(require_react());
var useBreadcrumbDivider_unstable = (props, ref) => {
  const { size: size3 } = useBreadcrumbContext_unstable();
  const { dir } = useFluent();
  const icon = getDividerIcon(dir);
  return {
    components: {
      root: "li"
    },
    root: slot_exports.always(getIntrinsicElementProps("li", {
      ref,
      "aria-hidden": true,
      children: icon,
      ...props
    }), {
      elementType: "li"
    }),
    size: size3
  };
};
function getDividerIcon(dir) {
  return dir === "rtl" ? React502.createElement(ChevronLeftRegular, null) : React502.createElement(ChevronRightRegular, null);
}

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/renderBreadcrumbDivider.js
var renderBreadcrumbDivider_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/useBreadcrumbDividerStyles.styles.js
var breadcrumbDividerClassNames = {
  root: "fui-BreadcrumbDivider"
};
var useStyles61 = __resetStyles("rk008qs", null, [".rk008qs{display:flex;}"]);
var useIconStyles9 = __styles2({
  small: {
    Be2twd7: "f1ugzwwg"
  },
  medium: {
    Be2twd7: "f4ybsrx"
  },
  large: {
    Be2twd7: "fe5j1ua"
  }
}, {
  d: [".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}"]
});
var useBreadcrumbDividerStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles61();
  const iconStyles = useIconStyles9();
  const {
    size: size3 = "medium"
  } = state;
  state.root.className = mergeClasses(breadcrumbDividerClassNames.root, styles, iconStyles[size3], state.root.className);
  return state;
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/BreadcrumbDivider.js
var BreadcrumbDivider = React503.forwardRef((props, ref) => {
  const state = useBreadcrumbDivider_unstable(props, ref);
  useBreadcrumbDividerStyles_unstable(state);
  useCustomStyleHook("useBreadcrumbDividerStyles_unstable")(state);
  return renderBreadcrumbDivider_unstable(state);
});
BreadcrumbDivider.displayName = "BreadcrumbDivider";

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/BreadcrumbItem.js
var React505 = __toESM(require_react());

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/useBreadcrumbItem.js
var React504 = __toESM(require_react());
var useBreadcrumbItem_unstable = (props, ref) => {
  const { size: size3 } = useBreadcrumbContext_unstable();
  return {
    components: {
      root: "li"
    },
    root: slot_exports.always(getIntrinsicElementProps("li", {
      ref,
      ...props
    }), {
      elementType: "li"
    }),
    size: size3
  };
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/renderBreadcrumbItem.js
var renderBreadcrumbItem_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: state.root.children
  });
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/useBreadcrumbItemStyles.styles.js
var breadcrumbItemClassNames = {
  root: "fui-BreadcrumbItem"
};
var useBreadcrumbItemResetStyles = __resetStyles("r1tl60rs", null, [".r1tl60rs{display:flex;align-items:center;color:var(--colorNeutralForeground2);box-sizing:border-box;text-wrap:nowrap;}"]);
var useBreadcrumbItemStyles_unstable = (state) => {
  "use no memo";
  const resetStyles = useBreadcrumbItemResetStyles();
  state.root.className = mergeClasses(breadcrumbItemClassNames.root, resetStyles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/BreadcrumbItem.js
var BreadcrumbItem = React505.forwardRef((props, ref) => {
  const state = useBreadcrumbItem_unstable(props, ref);
  useBreadcrumbItemStyles_unstable(state);
  useCustomStyleHook("useBreadcrumbItemStyles_unstable")(state);
  return renderBreadcrumbItem_unstable(state);
});
BreadcrumbItem.displayName = "BreadcrumbItem";

// node_modules/@fluentui/react-breadcrumb/lib/utils/partitionBreadcrumbItems.js
var DEFAULT_OVERFLOW_INDEX = 1;
var DEFAULT_MAX_DISPLAYED_ITEMS = 6;
var partitionBreadcrumbItems = (options) => {
  let startDisplayedItems;
  let overflowItems;
  let endDisplayedItems;
  const { items = [] } = options;
  const itemsCount = items.length;
  const maxDisplayedItems = getMaxDisplayedItems(options.maxDisplayedItems);
  var _options_overflowIndex;
  let overflowIndex = (_options_overflowIndex = options.overflowIndex) !== null && _options_overflowIndex !== void 0 ? _options_overflowIndex : DEFAULT_OVERFLOW_INDEX;
  startDisplayedItems = items.slice(0, overflowIndex);
  const numberItemsToHide = itemsCount - maxDisplayedItems;
  if (numberItemsToHide > 0) {
    overflowIndex = overflowIndex >= maxDisplayedItems ? maxDisplayedItems - 1 : overflowIndex;
    const menuLastItemIdx = overflowIndex + numberItemsToHide;
    startDisplayedItems = startDisplayedItems.slice(0, overflowIndex);
    overflowItems = items.slice(overflowIndex, menuLastItemIdx);
    if (menuLastItemIdx < itemsCount) {
      endDisplayedItems = items.slice(menuLastItemIdx, itemsCount);
    }
  } else if (overflowIndex < itemsCount) {
    endDisplayedItems = items.slice(overflowIndex, itemsCount);
  }
  return {
    startDisplayedItems,
    overflowItems,
    endDisplayedItems
  };
};
function getMaxDisplayedItems(maxDisplayedItems) {
  return maxDisplayedItems && maxDisplayedItems >= 0 ? maxDisplayedItems : DEFAULT_MAX_DISPLAYED_ITEMS;
}

// node_modules/@fluentui/react-breadcrumb/lib/utils/truncateBreadcrumb.js
var MAX_NAME_LENGTH = 30;
var MAX_TOOLTIP_LENGTH = 80;
var truncateBreadcrumb = (content, maxLength) => {
  return isTruncatableBreadcrumbContent(content, maxLength) ? content.trim().slice(0, maxLength).concat("...") : content;
};
var isTruncatableBreadcrumbContent = (content, maxLength) => {
  return content.length > maxLength;
};
var truncateBreadcrumbLongName = (content, maxLength) => {
  const truncateLength = maxLength || MAX_NAME_LENGTH;
  return truncateBreadcrumb(content, truncateLength);
};
var truncateBreadcrumLongTooltip = (content, maxLength) => {
  const truncateLength = maxLength || MAX_TOOLTIP_LENGTH;
  return truncateBreadcrumb(content, truncateLength);
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/BreadcrumbButton.js
var React507 = __toESM(require_react());

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/useBreadcrumbButton.js
var React506 = __toESM(require_react());
var useBreadcrumbButton_unstable = (props, ref) => {
  const { size: size3 } = useBreadcrumbContext_unstable();
  const { current = false, as, ...rest } = props;
  const controlType = (as !== null && as !== void 0 ? as : props.href) ? "a" : "button";
  var _props_ariacurrent, _props_ariadisabled;
  return {
    ...useButton_unstable({
      appearance: "subtle",
      role: void 0,
      type: void 0,
      as: controlType,
      iconPosition: "before",
      "aria-current": current ? (_props_ariacurrent = props["aria-current"]) !== null && _props_ariacurrent !== void 0 ? _props_ariacurrent : "page" : void 0,
      "aria-disabled": current ? (_props_ariadisabled = props["aria-disabled"]) !== null && _props_ariadisabled !== void 0 ? _props_ariadisabled : true : void 0,
      ...rest
    }, ref),
    current,
    size: size3
  };
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/renderBreadcrumbButton.js
var renderBreadcrumbButton_unstable = (state) => {
  return renderButton_unstable(state);
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/useBreadcrumbButtonStyles.styles.js
var breadcrumbButtonClassNames = {
  root: "fui-BreadcrumbButton",
  icon: "fui-BreadcrumbButton__icon"
};
var useIconStyles10 = __styles2({
  base: {
    Be2twd7: "fsj74e5",
    Bqenvij: "f1qfv4wv",
    Bg96gwp: "f15xapk4",
    a9b677: "f17j33op",
    t21cq0: ["fm0x6gh", "fbyavb5"]
  },
  small: {
    u3h8gg: "f1qfi7kw",
    Biu6dll: "f1876atl"
  },
  medium: {
    u3h8gg: "f1h9446d",
    Biu6dll: "f10xfswh"
  },
  large: {
    u3h8gg: "f5hcofs",
    Biu6dll: "f1a6v6zl"
  }
}, {
  d: [".fsj74e5{font-size:var(--fui-Breadcrumb--icon-size);}", ".f1qfv4wv{height:var(--fui-Breadcrumb--icon-size);}", ".f15xapk4{line-height:var(--fui-Breadcrumb--icon-line-height);}", ".f17j33op{width:var(--fui-Breadcrumb--icon-size);}", ".fm0x6gh{margin-right:var(--spacingHorizontalXS);}", ".fbyavb5{margin-left:var(--spacingHorizontalXS);}", ".f1qfi7kw{--fui-Breadcrumb--icon-size:12px;}", ".f1876atl{--fui-Breadcrumb--icon-line-height:var(--lineHeightBase200);}", ".f1h9446d{--fui-Breadcrumb--icon-size:16px;}", ".f10xfswh{--fui-Breadcrumb--icon-line-height:var(--lineHeightBase400);}", ".f5hcofs{--fui-Breadcrumb--icon-size:20px;}", ".f1a6v6zl{--fui-Breadcrumb--icon-line-height:var(--lineHeightBase600);}"]
});
var defaultButtonStyles = {
  backgroundColor: tokens.colorTransparentBackground,
  color: tokens.colorNeutralForeground2,
  cursor: "auto"
};
var currentIconStyles = {
  ...defaultButtonStyles,
  [`& .${buttonClassNames.icon}`]: {
    color: "unset"
  },
  [`& .${iconFilledClassName}`]: {
    display: "none"
  },
  [`& .${iconRegularClassName}`]: {
    display: "inline"
  }
};
var useStyles62 = __styles2({
  root: {
    Bf4jedk: "f18p0k4z",
    j4b8c3: "fv6wr3j"
  },
  small: {
    Bqenvij: "frvgh55",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1r1wyb6"
  },
  medium: {
    Bqenvij: "f1d2rq10",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1r1wyb6"
  },
  large: {
    Bqenvij: "fbhnoac",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1bnz8pu"
  },
  current: {
    Jwef8y: "f9ql6rf",
    Bi91k9c: "f3p8bqa",
    eoavqd: "f14w7a5u",
    Bbdnnc7: "f1irjp3o",
    Bk3fhr4: "f19vpps7",
    Bmfj8id: "fv5swzo",
    iro3zm: "f3h1zc4",
    B2d53fq: "f1xkgyln",
    c3iz72: "f17wbbfx",
    x3br3k: "fofxw0a",
    em6i61: "f1ol4fw6",
    vm6p8p: "f1q1lw4e",
    Bszkowt: "ff24m",
    Dyrjrp: "ft5r8e9",
    ezr58z: "f1cbpfqp",
    nhk3du: "f1motppv",
    Bfrek18: "fi9vkhg",
    G209fr: "f1fg3nnv"
  },
  currentSmall: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fwrc4pm"
  },
  currentMedium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1i3iumi"
  },
  currentLarge: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  }
}, {
  d: [".f18p0k4z{min-width:unset;}", ".fv6wr3j{text-wrap:nowrap;}", ".frvgh55{height:24px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", [".f1r1wyb6{padding:var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".f1d2rq10{height:32px;}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f1r1wyb6{padding:var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".fbhnoac{height:40px;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f1bnz8pu{padding:var(--spacingHorizontalS);}", {
    p: -1
  }], ".ff24m:disabled{background-color:var(--colorTransparentBackground);}", ".ft5r8e9:disabled{color:var(--colorNeutralForeground2);}", ".f1cbpfqp:disabled{cursor:auto;}", ".f1motppv:disabled .fui-Button__icon{color:unset;}", ".fi9vkhg:disabled .fui-Icon-filled{display:none;}", ".f1fg3nnv:disabled .fui-Icon-regular{display:inline;}", ".fl43uef{font-weight:var(--fontWeightSemibold);}"],
  h: [".f9ql6rf:hover{background-color:var(--colorTransparentBackground);}", ".f3p8bqa:hover{color:var(--colorNeutralForeground2);}", ".f14w7a5u:hover{cursor:auto;}", ".f1irjp3o:hover .fui-Button__icon{color:unset;}", ".f19vpps7:hover .fui-Icon-filled{display:none;}", ".fv5swzo:hover .fui-Icon-regular{display:inline;}", ".f3h1zc4:hover:active{background-color:var(--colorTransparentBackground);}", ".f1xkgyln:hover:active{color:var(--colorNeutralForeground2);}", ".f17wbbfx:hover:active{cursor:auto;}", ".fofxw0a:hover:active .fui-Button__icon{color:unset;}", ".f1ol4fw6:hover:active .fui-Icon-filled{display:none;}", ".f1q1lw4e:hover:active .fui-Icon-regular{display:inline;}"]
});
var useBreadcrumbButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles62();
  const iconStyles = useIconStyles10();
  const currentSizeMap = {
    small: styles.currentSmall,
    medium: styles.currentMedium,
    large: styles.currentLarge
  };
  state.root.className = mergeClasses(breadcrumbButtonClassNames.root, styles[state.size], styles.root, state.current && currentSizeMap[state.size], state.current && styles.current, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(iconStyles.base, iconStyles[state.size], state.icon.className);
  }
  useButtonStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/BreadcrumbButton.js
var BreadcrumbButton = React507.forwardRef((props, ref) => {
  const state = useBreadcrumbButton_unstable(props, ref);
  useBreadcrumbButtonStyles_unstable(state);
  useCustomStyleHook("useBreadcrumbButtonStyles_unstable")(state);
  return renderBreadcrumbButton_unstable(state);
});
BreadcrumbButton.displayName = "BreadcrumbButton";

// node_modules/@fluentui/react-rating/lib/components/Rating/Rating.js
var React513 = __toESM(require_react());

// node_modules/@fluentui/react-rating/lib/components/Rating/useRating.js
var React511 = __toESM(require_react());

// node_modules/@fluentui/react-rating/lib/components/RatingItem/RatingItem.js
var React510 = __toESM(require_react());

// node_modules/@fluentui/react-rating/lib/components/RatingItem/useRatingItem.js
var React509 = __toESM(require_react());

// node_modules/@fluentui/react-rating/lib/contexts/RatingItemContext.js
var React508 = __toESM(require_react());
var RatingItemContext = React508.createContext(void 0);
var ratingItemContextDefaultValue = {
  color: "neutral",
  iconFilled: StarFilled,
  iconOutline: StarRegular,
  step: 1,
  size: "medium"
};
var RatingItemProvider = RatingItemContext.Provider;
var useRatingItemContextValue_unstable = () => React508.useContext(RatingItemContext) || ratingItemContextDefaultValue;

// node_modules/@fluentui/react-rating/lib/components/RatingItem/useRatingItem.js
var defaultItemLabel = (num) => num + "";
var useRatingItem_unstable = (props, ref) => {
  const context = useRatingItemContextValue_unstable();
  const { value = 0 } = props;
  const { itemLabel = defaultItemLabel, iconFilled: IconFilled, iconOutline: IconOutline } = context;
  const ratingValue = Math.round((context.value || 0) * 2) / 2;
  var _context_hoveredValue;
  const displayedRatingValue = (_context_hoveredValue = context.hoveredValue) !== null && _context_hoveredValue !== void 0 ? _context_hoveredValue : ratingValue;
  const appearance = context.interactive ? "outline" : "filled";
  let iconFillWidth;
  if (context.compact || displayedRatingValue >= value) {
    iconFillWidth = 1;
  } else if (displayedRatingValue >= value - 0.5) {
    iconFillWidth = 0.5;
  } else {
    iconFillWidth = 0;
  }
  const root = slot_exports.always(getIntrinsicElementProps("span", {
    ref: useMergedRefs(useFocusWithin(), ref),
    ...props
  }), {
    elementType: "span"
  });
  let unselectedIcon;
  if (iconFillWidth < 1) {
    unselectedIcon = slot_exports.always(props.unselectedIcon, {
      defaultProps: {
        children: appearance === "filled" ? React509.createElement(IconFilled, null) : React509.createElement(IconOutline, null),
        "aria-hidden": true
      },
      elementType: "div"
    });
  }
  let selectedIcon;
  if (iconFillWidth > 0) {
    selectedIcon = slot_exports.always(props.selectedIcon, {
      defaultProps: {
        children: React509.createElement(IconFilled, null),
        "aria-hidden": true
      },
      elementType: "div"
    });
  }
  let halfValueInput;
  if (context.interactive && context.step === 0.5) {
    halfValueInput = slot_exports.always(props.halfValueInput, {
      defaultProps: {
        type: "radio",
        name: context.name,
        value: value - 0.5,
        checked: ratingValue === value - 0.5,
        "aria-label": itemLabel(value - 0.5),
        onChange: () => {
        }
      },
      elementType: "input"
    });
  }
  let fullValueInput;
  if (context.interactive) {
    fullValueInput = slot_exports.always(props.fullValueInput, {
      defaultProps: {
        type: "radio",
        name: context.name,
        value,
        checked: ratingValue === value,
        "aria-label": itemLabel(value),
        onChange: () => {
        }
      },
      elementType: "input"
    });
  }
  const state = {
    appearance,
    color: context.color,
    step: context.step,
    size: context.size,
    iconFillWidth,
    value,
    components: {
      root: "span",
      selectedIcon: "div",
      unselectedIcon: "div",
      halfValueInput: "input",
      fullValueInput: "input"
    },
    root,
    selectedIcon,
    unselectedIcon,
    halfValueInput,
    fullValueInput
  };
  return state;
};

// node_modules/@fluentui/react-rating/lib/components/RatingItem/renderRatingItem.js
var renderRatingItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.halfValueInput && jsx(state.halfValueInput, {}),
      state.fullValueInput && jsx(state.fullValueInput, {}),
      state.unselectedIcon && jsx(state.unselectedIcon, {}),
      state.selectedIcon && jsx(state.selectedIcon, {})
    ]
  });
};

// node_modules/@fluentui/react-rating/lib/components/RatingItem/useRatingItemStyles.styles.js
var ratingItemClassNames = {
  root: "fui-RatingItem",
  selectedIcon: "fui-RatingItem__selectedIcon",
  unselectedIcon: "fui-RatingItem__unselectedIcon",
  halfValueInput: "fui-RatingItem__halfValueInput",
  fullValueInput: "fui-RatingItem__fullValueInput"
};
var useStyles63 = __styles2({
  root: {
    qhf8xq: "f10pi13n",
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    Bssx7fj: "f1b1k54r",
    uh7if5: ["f4ne723", "fqqcjud"],
    clntm0: "fh7aioi",
    Dlk2r6: ["fqqcjud", "f4ne723"],
    Bm3wd5j: "f1k55ka9",
    Bbrhkcr: ["fgclinu", "f16pcs8n"],
    f1oku: "fycbxed",
    aywvf2: ["f16pcs8n", "fgclinu"],
    B2j2mmj: "ffht0p2",
    wigs8: "f1p0ul1q",
    pbfy6t: "f1c901ms",
    B0v4ure: "f1alokd7",
    Byrf0fs: 0,
    Bsiemmq: 0,
    Bwckmig: 0,
    skfxo0: 0,
    Iidy0u: 0,
    B98u21t: 0,
    Bvwlmkc: 0,
    jo1ztg: 0,
    Ba1iezr: 0,
    Blmvk6g: 0,
    B24cy0v: 0,
    Bil7v7r: 0,
    Br3gin4: 0,
    nr063g: 0,
    ghq09: 0,
    Bbgo44z: 0,
    Bseh09z: "fmj8fco",
    az1dzo: 0,
    Ba3ybja: 0,
    B6352mv: 0,
    vppk2z: 0,
    Biaj6j7: "f1iwowo3",
    B2pnrqr: "f1spmvte",
    B29w5g4: ["fgp7k2s", "f13pb23"],
    Bhhzhcn: "f1ihbrwi",
    Bec0n69: ["f13pb23", "fgp7k2s"]
  },
  small: {
    Be2twd7: "f1ugzwwg",
    a9b677: "frx94fk",
    Bqenvij: "fvblgha"
  },
  medium: {
    Be2twd7: "f4ybsrx",
    a9b677: "fjw5fx7",
    Bqenvij: "fd461yt"
  },
  large: {
    Be2twd7: "fe5j1ua",
    a9b677: "f64fuq3",
    Bqenvij: "fjamq6b"
  },
  "extra-large": {
    Be2twd7: "f24l1pt",
    a9b677: "f1w9dchk",
    Bqenvij: "fxldao9"
  }
}, {
  d: [".f10pi13n{position:relative;}", ".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}", ".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}", ".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}", ".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}", '.ffht0p2[data-fui-focus-within]:focus-within::after{content:"";}', ".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}", ".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}", ".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}", [".fmj8fco[data-fui-focus-within]:focus-within::after{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1iwowo3[data-fui-focus-within]:focus-within::after{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1spmvte[data-fui-focus-within]:focus-within::after{top:calc(2px * -1);}", ".fgp7k2s[data-fui-focus-within]:focus-within::after{right:calc(2px * -1);}", ".f13pb23[data-fui-focus-within]:focus-within::after{left:calc(2px * -1);}", ".f1ihbrwi[data-fui-focus-within]:focus-within::after{bottom:calc(2px * -1);}", ".f1ugzwwg{font-size:12px;}", ".frx94fk{width:12px;}", ".fvblgha{height:12px;}", ".f4ybsrx{font-size:16px;}", ".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".fe5j1ua{font-size:20px;}", ".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".f24l1pt{font-size:28px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}"],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"],
  m: [["@media (forced-colors: active){.f1k55ka9[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f16pcs8n[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}.fgclinu[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fycbxed[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useInputBaseClassName4 = __resetStyles("r1qfsv1p", "rh8pzaz", [".r1qfsv1p{position:absolute;left:0;top:0;right:0;bottom:0;box-sizing:border-box;margin:0;opacity:0;cursor:pointer;height:100%;}", ".rh8pzaz{position:absolute;right:0;top:0;left:0;bottom:0;box-sizing:border-box;margin:0;opacity:0;cursor:pointer;height:100%;}"]);
var useInputStyles7 = __styles2({
  lowerHalf: {
    j35jbq: ["ffenbu1", "f1ktbn1t"]
  },
  upperHalf: {
    oyh7mz: ["f1ktbn1t", "ffenbu1"]
  }
}, {
  d: [".ffenbu1{right:50%;}", ".f1ktbn1t{left:50%;}"]
});
var useIndicatorBaseClassName4 = __resetStyles("r1420l2m", "r1yt29v5", [".r1420l2m{display:flex;overflow:hidden;color:var(--colorNeutralForeground1);fill:currentColor;pointer-events:none;position:absolute;left:0;right:0;top:0;bottom:0;}", ".r1yt29v5{display:flex;overflow:hidden;color:var(--colorNeutralForeground1);fill:currentColor;pointer-events:none;position:absolute;right:0;left:0;top:0;bottom:0;}"]);
var useIndicatorStyles3 = __styles2({
  lowerHalf: {
    j35jbq: ["ffenbu1", "f1ktbn1t"],
    l5kjut: 0,
    uoufgc: 0,
    v39lw8: 0,
    Bbwb3tu: "f10jwh99"
  },
  upperHalf: {
    oyh7mz: ["f1ktbn1t", "ffenbu1"],
    Frg6f3: ["fbm7ezh", "f3ev47i"]
  },
  brand: {
    sj55zd: "f16muhyy"
  },
  marigold: {
    sj55zd: "f1whvut0"
  },
  filled: {
    sj55zd: "f1qaymga",
    ojy3ng: "f13qq9og",
    Bbusuzp: "f1cg6951",
    B6jmk37: "f1am6ztc"
  },
  brandFilled: {
    sj55zd: "f1kdv6iu"
  },
  marigoldFilled: {
    sj55zd: "f1ymbmfq"
  }
}, {
  d: [".ffenbu1{right:50%;}", ".f1ktbn1t{left:50%;}", [".f10jwh99>svg{flex:0 0 auto;}", {
    p: -1
  }], ".fbm7ezh{margin-left:-50%;}", ".f3ev47i{margin-right:-50%;}", ".f16muhyy{color:var(--colorBrandForeground1);}", ".f1whvut0{color:var(--colorPaletteMarigoldBorderActive);}", ".f1qaymga{color:var(--colorNeutralBackground6);}", ".f13qq9og{stroke:var(--colorTransparentStroke);}", ".f1kdv6iu{color:var(--colorBrandBackground2);}", ".f1ymbmfq{color:var(--colorPaletteMarigoldBackground2);}"],
  m: [["@media (forced-colors: active){.f1cg6951{color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1am6ztc{stroke:CanvasText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useRatingItemStyles_unstable = (state) => {
  "use no memo";
  const {
    color: color2,
    size: size3,
    iconFillWidth,
    appearance
  } = state;
  const styles = useStyles63();
  const inputBaseClassName = useInputBaseClassName4();
  const inputStyles = useInputStyles7();
  const indicatorBaseClassName = useIndicatorBaseClassName4();
  const indicatorStyles = useIndicatorStyles3();
  state.root.className = mergeClasses(ratingItemClassNames.root, styles.root, styles[size3], state.root.className);
  if (state.halfValueInput) {
    state.halfValueInput.className = mergeClasses(ratingItemClassNames.halfValueInput, inputBaseClassName, inputStyles.lowerHalf, state.halfValueInput.className);
  }
  if (state.fullValueInput) {
    state.fullValueInput.className = mergeClasses(ratingItemClassNames.fullValueInput, inputBaseClassName, state.halfValueInput && inputStyles.upperHalf, state.fullValueInput.className);
  }
  if (state.unselectedIcon) {
    state.unselectedIcon.className = mergeClasses(ratingItemClassNames.unselectedIcon, indicatorBaseClassName, appearance === "filled" && indicatorStyles.filled, color2 === "brand" && (appearance === "filled" ? indicatorStyles.brandFilled : indicatorStyles.brand), color2 === "marigold" && (appearance === "filled" ? indicatorStyles.marigoldFilled : indicatorStyles.marigold), iconFillWidth === 0.5 && indicatorStyles.upperHalf, state.unselectedIcon.className);
  }
  if (state.selectedIcon) {
    state.selectedIcon.className = mergeClasses(ratingItemClassNames.selectedIcon, indicatorBaseClassName, color2 === "brand" && indicatorStyles.brand, color2 === "marigold" && indicatorStyles.marigold, iconFillWidth === 0.5 && indicatorStyles.lowerHalf, state.selectedIcon.className);
  }
  return state;
};

// node_modules/@fluentui/react-rating/lib/components/RatingItem/RatingItem.js
var RatingItem = React510.forwardRef((props, ref) => {
  const state = useRatingItem_unstable(props, ref);
  useRatingItemStyles_unstable(state);
  useCustomStyleHook("useRatingItemStyles_unstable")(state);
  return renderRatingItem_unstable(state);
});
RatingItem.displayName = "RatingItem";

// node_modules/@fluentui/react-rating/lib/components/Rating/useRating.js
var useRating_unstable = (props, ref) => {
  const generatedName = useId2("rating-");
  const { color: color2 = "neutral", iconFilled = StarFilled, iconOutline = StarRegular, max: max2 = 5, name = generatedName, onChange, step = 1, size: size3 = "extra-large", itemLabel } = props;
  const [value, setValue] = useControllableState({
    state: props.value,
    defaultState: props.defaultValue,
    initialState: 0
  });
  const isRatingRadioItem = (target) => isHTMLElement(target, {
    constructorName: "HTMLInputElement"
  }) && target.type === "radio" && target.name === name;
  const [hoveredValue, setHoveredValue] = React511.useState(void 0);
  const rootChildren = React511.useMemo(() => {
    return Array.from(Array(max2), (_, i) => React511.createElement(RatingItem, {
      value: i + 1,
      key: i + 1
    }));
  }, [
    max2
  ]);
  const state = {
    color: color2,
    iconFilled,
    iconOutline,
    name,
    step,
    size: size3,
    itemLabel,
    value,
    hoveredValue,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      children: rootChildren,
      role: "radiogroup",
      ...props
    }, [
      "onChange"
    ]), {
      elementType: "div"
    })
  };
  state.root.onChange = (ev) => {
    if (isRatingRadioItem(ev.target)) {
      const newValue = parseFloat(ev.target.value);
      if (!isNaN(newValue)) {
        setValue(newValue);
        onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
          type: "change",
          event: ev,
          value: newValue
        });
      }
    }
  };
  state.root.onMouseOver = mergeCallbacks(props.onMouseOver, (ev) => {
    if (isRatingRadioItem(ev.target)) {
      const newValue = parseFloat(ev.target.value);
      if (!isNaN(newValue)) {
        setHoveredValue(newValue);
      }
    }
  });
  state.root.onMouseLeave = mergeCallbacks(props.onMouseLeave, (ev) => {
    setHoveredValue(void 0);
  });
  return state;
};

// node_modules/@fluentui/react-rating/lib/components/Rating/renderRating.js
var renderRating_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(RatingItemProvider, {
    value: contextValues.ratingItem,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-rating/lib/components/Rating/useRatingStyles.styles.js
var ratingClassNames = {
  root: "fui-Rating"
};
var useRootClassName7 = __resetStyles("r2imjyh", null, [".r2imjyh{display:flex;flex-wrap:wrap;}"]);
var useRatingStyles_unstable = (state) => {
  "use no memo";
  const rootClassName = useRootClassName7();
  state.root.className = mergeClasses(ratingClassNames.root, rootClassName, state.root.className);
  return state;
};

// node_modules/@fluentui/react-rating/lib/components/Rating/useRatingContextValues.js
var React512 = __toESM(require_react());
var useRatingContextValues = (ratingState) => {
  const { color: color2, hoveredValue, iconFilled, iconOutline, itemLabel, name, step, size: size3, value } = ratingState;
  const ratingItem = React512.useMemo(() => ({
    color: color2,
    hoveredValue,
    iconFilled,
    iconOutline,
    interactive: true,
    itemLabel,
    name,
    step,
    size: size3,
    value
  }), [
    color2,
    hoveredValue,
    iconFilled,
    iconOutline,
    itemLabel,
    name,
    step,
    size3,
    value
  ]);
  return {
    ratingItem
  };
};

// node_modules/@fluentui/react-rating/lib/components/Rating/Rating.js
var Rating = React513.forwardRef((props, ref) => {
  const state = useRating_unstable(props, ref);
  const contextValues = useRatingContextValues(state);
  useRatingStyles_unstable(state);
  useCustomStyleHook("useRatingStyles_unstable")(state);
  return renderRating_unstable(state, contextValues);
});
Rating.displayName = "Rating";

// node_modules/@fluentui/react-rating/lib/components/RatingDisplay/RatingDisplay.js
var React516 = __toESM(require_react());

// node_modules/@fluentui/react-rating/lib/components/RatingDisplay/useRatingDisplay.js
var React514 = __toESM(require_react());
var useRatingDisplay_unstable = (props, ref) => {
  const { color: color2 = "neutral", count, compact = false, icon = StarFilled, max: max2 = 5, size: size3 = "medium", value } = props;
  const valueTextId = useId2("rating-value-");
  const countTextId = useId2("rating-count-");
  const rootChildren = React514.useMemo(() => {
    return compact ? React514.createElement(RatingItem, {
      value: 1,
      key: 1,
      "aria-hidden": true
    }) : Array.from(Array(max2), (_, i) => React514.createElement(RatingItem, {
      value: i + 1,
      key: i + 1,
      "aria-hidden": true
    }));
  }, [
    compact,
    max2
  ]);
  const state = {
    color: color2,
    compact,
    icon,
    max: max2,
    size: size3,
    value,
    components: {
      root: "div",
      valueText: "span",
      countText: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      children: rootChildren,
      role: "img",
      ...props
    }), {
      elementType: "div"
    }),
    valueText: slot_exports.optional(props.valueText, {
      renderByDefault: value !== void 0,
      defaultProps: {
        children: value,
        id: valueTextId,
        "aria-hidden": true
      },
      elementType: "span"
    }),
    countText: slot_exports.optional(props.countText, {
      renderByDefault: count !== void 0,
      defaultProps: {
        children: count === null || count === void 0 ? void 0 : count.toLocaleString(),
        id: countTextId,
        "aria-hidden": true
      },
      elementType: "span"
    })
  };
  if (!state.root["aria-label"] && !state.root["aria-labelledby"]) {
    var _state_valueText, _state_countText;
    state.root["aria-labelledby"] = [
      (_state_valueText = state.valueText) === null || _state_valueText === void 0 ? void 0 : _state_valueText.id,
      (_state_countText = state.countText) === null || _state_countText === void 0 ? void 0 : _state_countText.id
    ].filter(Boolean).join(" ");
  }
  return state;
};

// node_modules/@fluentui/react-rating/lib/components/RatingDisplay/renderRatingDisplay.js
var renderRatingDisplay_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(RatingItemProvider, {
    value: contextValues.ratingItem,
    children: jsxs(state.root, {
      children: [
        state.root.children,
        state.valueText && jsx(state.valueText, {}),
        state.countText && jsx(state.countText, {})
      ]
    })
  });
};

// node_modules/@fluentui/react-rating/lib/components/RatingDisplay/useRatingDisplayStyles.styles.js
var ratingDisplayClassNames = {
  root: "fui-RatingDisplay",
  valueText: "fui-RatingDisplay__valueText",
  countText: "fui-RatingDisplay__countText"
};
var useRootClassName8 = __resetStyles("rxxdqwu", null, [".rxxdqwu{display:flex;flex-wrap:wrap;align-items:center;}"]);
var useLabelClassName = __resetStyles("rkwnos5", "rwei36a", [".rkwnos5{color:var(--colorNeutralForeground1);margin-left:var(--spacingHorizontalXS);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}", ".rwei36a{color:var(--colorNeutralForeground1);margin-right:var(--spacingHorizontalXS);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
var useLabelStyles7 = __styles2({
  large: {
    Be2twd7: "fkhj508",
    Bg96gwp: "f1i3iumi",
    Frg6f3: ["f1t5qyk5", "f1ikr372"]
  },
  extraLarge: {
    Be2twd7: "fod5ikn",
    Bg96gwp: "faaz57k",
    Frg6f3: ["foyynoy", "f1vcna3q"]
  },
  strong: {
    Bhrd7zp: "fl43uef"
  },
  divider: {
    Ftih45: "f169p45e"
  }
}, {
  d: [".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1t5qyk5{margin-left:var(--spacingHorizontalSNudge);}", ".f1ikr372{margin-right:var(--spacingHorizontalSNudge);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".foyynoy{margin-left:var(--spacingHorizontalS);}", ".f1vcna3q{margin-right:var(--spacingHorizontalS);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", '.f169p45e::before{content:"· ";}']
});
var useRatingDisplayStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3
  } = state;
  const rootClassName = useRootClassName8();
  state.root.className = mergeClasses(ratingDisplayClassNames.root, rootClassName, state.root.className);
  const labelClassName = useLabelClassName();
  const labelStyles = useLabelStyles7();
  if (state.valueText) {
    state.valueText.className = mergeClasses(ratingDisplayClassNames.valueText, labelClassName, labelStyles.strong, size3 === "large" && labelStyles.large, size3 === "extra-large" && labelStyles.extraLarge, state.valueText.className);
  }
  if (state.countText) {
    state.countText.className = mergeClasses(ratingDisplayClassNames.countText, labelClassName, size3 === "large" && labelStyles.large, size3 === "extra-large" && labelStyles.extraLarge, state.valueText && labelStyles.divider, state.countText.className);
  }
  return state;
};

// node_modules/@fluentui/react-rating/lib/components/RatingDisplay/useRatingDisplayContextValues.js
var React515 = __toESM(require_react());
var useRatingDisplayContextValues = (state) => {
  const { color: color2, compact, icon, size: size3, value } = state;
  const ratingItem = React515.useMemo(() => ({
    color: color2,
    compact,
    iconFilled: icon,
    iconOutline: icon,
    interactive: false,
    step: 0.5,
    size: size3,
    value
  }), [
    color2,
    compact,
    icon,
    size3,
    value
  ]);
  return {
    ratingItem
  };
};

// node_modules/@fluentui/react-rating/lib/components/RatingDisplay/RatingDisplay.js
var RatingDisplay = React516.forwardRef((props, ref) => {
  const state = useRatingDisplay_unstable(props, ref);
  const contextValues = useRatingDisplayContextValues(state);
  useRatingDisplayStyles_unstable(state);
  useCustomStyleHook("useRatingDisplayStyles_unstable")(state);
  return renderRatingDisplay_unstable(state, contextValues);
});
RatingDisplay.displayName = "RatingDisplay";

// node_modules/@fluentui/react-search/lib/components/SearchBox/SearchBox.js
var React518 = __toESM(require_react());

// node_modules/@fluentui/react-search/lib/components/SearchBox/useSearchBox.js
var React517 = __toESM(require_react());
var useSearchBox_unstable = (props, ref) => {
  const { size: size3 = "medium", disabled = false, root, contentBefore, dismiss, contentAfter, value, defaultValue, ...inputProps } = props;
  const searchBoxRootRef = React517.useRef(null);
  const searchBoxRef = React517.useRef(null);
  const [internalValue, setInternalValue] = useControllableState({
    state: value,
    defaultState: defaultValue,
    initialState: ""
  });
  const [focused, setFocused] = React517.useState(false);
  const onFocus = React517.useCallback(() => {
    setFocused(true);
  }, [
    setFocused
  ]);
  const onBlur = React517.useCallback((ev) => {
    var _searchBoxRootRef_current;
    setFocused(!!((_searchBoxRootRef_current = searchBoxRootRef.current) === null || _searchBoxRootRef_current === void 0 ? void 0 : _searchBoxRootRef_current.contains(ev.relatedTarget)));
  }, [
    setFocused
  ]);
  const rootProps = slot_exports.resolveShorthand(root);
  const handleDismissClick = useEventCallback((event) => {
    var _props_onChange, _searchBoxRef_current;
    if (isResolvedShorthand(dismiss)) {
      var _dismiss_onClick;
      (_dismiss_onClick = dismiss.onClick) === null || _dismiss_onClick === void 0 ? void 0 : _dismiss_onClick.call(dismiss, event);
    }
    const newValue = "";
    setInternalValue(newValue);
    (_props_onChange = props.onChange) === null || _props_onChange === void 0 ? void 0 : _props_onChange.call(props, event, {
      value: newValue
    });
    (_searchBoxRef_current = searchBoxRef.current) === null || _searchBoxRef_current === void 0 ? void 0 : _searchBoxRef_current.focus();
  });
  const inputState = useInput_unstable({
    type: "search",
    disabled,
    size: size3,
    value: internalValue,
    root: slot_exports.always({
      ...rootProps,
      ref: useMergedRefs(rootProps === null || rootProps === void 0 ? void 0 : rootProps.ref, searchBoxRootRef),
      onFocus: mergeCallbacks(rootProps === null || rootProps === void 0 ? void 0 : rootProps.onFocus, onFocus),
      onBlur: mergeCallbacks(rootProps === null || rootProps === void 0 ? void 0 : rootProps.onBlur, onBlur)
    }, {
      elementType: "span"
    }),
    contentBefore: slot_exports.optional(contentBefore, {
      renderByDefault: true,
      defaultProps: {
        children: React517.createElement(SearchRegular, null)
      },
      elementType: "span"
    }),
    contentAfter: slot_exports.optional(contentAfter, {
      renderByDefault: true,
      elementType: "span"
    }),
    ...inputProps,
    onChange: useEventCallback((ev) => {
      var _props_onChange;
      const newValue = ev.target.value;
      (_props_onChange = props.onChange) === null || _props_onChange === void 0 ? void 0 : _props_onChange.call(props, ev, {
        value: newValue
      });
      setInternalValue(newValue);
    })
  }, useMergedRefs(searchBoxRef, ref));
  const state = {
    ...inputState,
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...inputState.components,
      dismiss: "span"
    },
    dismiss: slot_exports.optional(dismiss, {
      defaultProps: {
        children: React517.createElement(DismissRegular, null),
        role: "button",
        "aria-label": "clear",
        tabIndex: -1
      },
      renderByDefault: true,
      elementType: "span"
    }),
    disabled,
    focused,
    size: size3
  };
  if (state.dismiss) {
    state.dismiss.onClick = handleDismissClick;
  }
  return state;
};

// node_modules/@fluentui/react-search/lib/components/SearchBox/renderSearchBox.js
var renderSearchBox_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.contentBefore && jsx(state.contentBefore, {}),
      jsx(state.input, {}),
      state.contentAfter && jsxs(state.contentAfter, {
        children: [
          state.contentAfter.children,
          state.dismiss && jsx(state.dismiss, {})
        ]
      })
    ]
  });
};

// node_modules/@fluentui/react-search/lib/components/SearchBox/useSearchBoxStyles.styles.js
var searchBoxClassNames = {
  root: "fui-SearchBox",
  dismiss: "fui-SearchBox__dismiss",
  contentAfter: "fui-SearchBox__contentAfter",
  contentBefore: "fui-SearchBox__contentBefore",
  input: "fui-SearchBox__input"
};
var useRootStyles25 = __styles2({
  small: {
    i8kkvl: "fjuset5",
    B2u0y6b: "f1xzfw5u",
    uwmqm3: ["fk8j09s", "fdw0yi8"],
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  medium: {
    i8kkvl: "fjuset5",
    B2u0y6b: "f1xzfw5u",
    uwmqm3: ["f1f5gg8d", "f1vdfbxk"],
    z189sj: ["f1vdfbxk", "f1f5gg8d"]
  },
  large: {
    i8kkvl: "fjuset5",
    B2u0y6b: "f1xzfw5u",
    uwmqm3: ["f1ng84yb", "f11gcy0p"],
    z189sj: ["f11gcy0p", "f1ng84yb"]
  },
  input: {
    uwmqm3: ["fk8j09s", "fdw0yi8"],
    z189sj: ["fhxju0i", "f1cnd47f"],
    Boqhc8c: "f18izjht",
    B8uat0v: "fcoa6sg"
  },
  unfocusedNoContentAfter: {
    z189sj: ["fhxju0i", "f1cnd47f"]
  }
}, {
  d: [".fjuset5{column-gap:0;}", ".f1xzfw5u{max-width:468px;}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}", ".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}", ".fhxju0i{padding-right:0;}", ".f1cnd47f{padding-left:0;}", ".f18izjht::-webkit-search-decoration{display:none;}", ".fcoa6sg::-webkit-search-cancel-button{display:none;}"]
});
var useInputStyles8 = __styles2({
  small: {
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  medium: {
    z189sj: ["f1vdfbxk", "f1f5gg8d"]
  },
  large: {
    z189sj: ["f11gcy0p", "f1ng84yb"]
  }
}, {
  d: [".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}", ".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}"]
});
var useContentAfterStyles = __styles2({
  contentAfter: {
    uwmqm3: ["f1uw59to", "fw5db7e"],
    i8kkvl: "f1ufnopg"
  },
  rest: {
    Bqenvij: "fniina8",
    a9b677: "f3tsq5r",
    uwmqm3: ["f1cnd47f", "fhxju0i"],
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp"
  }
}, {
  d: [".f1uw59to{padding-left:var(--spacingHorizontalM);}", ".fw5db7e{padding-right:var(--spacingHorizontalM);}", ".f1ufnopg{column-gap:var(--spacingHorizontalXS);}", ".fniina8{height:0;}", ".f3tsq5r{width:0;}", ".f1cnd47f{padding-left:0;}", ".fhxju0i{padding-right:0;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }]]
});
var useDismissClassName = __resetStyles("r1pvzcuu", null, [".r1pvzcuu{box-sizing:border-box;color:var(--colorNeutralForeground3);display:flex;cursor:pointer;}", ".r1pvzcuu>svg{font-size:20px;}"]);
var useDismissStyles = __styles2({
  disabled: {
    sj55zd: "f1s2aq7o"
  },
  small: {
    Duoase: "f3qv9w"
  },
  medium: {},
  large: {
    Duoase: "f16u2scb"
  }
}, {
  d: [".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f3qv9w>svg{font-size:16px;}", ".f16u2scb>svg{font-size:24px;}"]
});
var useSearchBoxStyles_unstable = (state) => {
  "use no memo";
  const {
    disabled,
    focused,
    size: size3
  } = state;
  const rootStyles = useRootStyles25();
  const inputStyles = useInputStyles8();
  const contentAfterStyles = useContentAfterStyles();
  const dismissClassName = useDismissClassName();
  const dismissStyles = useDismissStyles();
  state.root.className = mergeClasses(searchBoxClassNames.root, rootStyles[size3], !focused && rootStyles.unfocusedNoContentAfter, state.root.className);
  state.input.className = mergeClasses(searchBoxClassNames.input, rootStyles.input, !focused && inputStyles[size3], state.input.className);
  if (state.dismiss) {
    state.dismiss.className = mergeClasses(searchBoxClassNames.dismiss, dismissClassName, disabled && dismissStyles.disabled, dismissStyles[size3], state.dismiss.className);
  }
  if (state.contentBefore) {
    state.contentBefore.className = mergeClasses(searchBoxClassNames.contentBefore, state.contentBefore.className);
  }
  if (state.contentAfter) {
    state.contentAfter.className = mergeClasses(searchBoxClassNames.contentAfter, contentAfterStyles.contentAfter, !focused && contentAfterStyles.rest, state.contentAfter.className);
  } else if (state.dismiss) {
    state.dismiss.className = mergeClasses(state.dismiss.className, contentAfterStyles.contentAfter);
  }
  useInputStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-search/lib/components/SearchBox/SearchBox.js
var SearchBox = React518.forwardRef((props, ref) => {
  const state = useSearchBox_unstable(props, ref);
  useSearchBoxStyles_unstable(state);
  useCustomStyleHook("useSearchBoxStyles_unstable")(state);
  return renderSearchBox_unstable(state);
});
SearchBox.displayName = "SearchBox";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/TeachingPopoverHeader.js
var React520 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/useTeachingPopoverHeader.js
var React519 = __toESM(require_react());
var useTeachingPopoverHeader_unstable = (props, ref) => {
  const { dismissButton, icon } = props;
  const setOpen = usePopoverContext_unstable((context) => context.setOpen);
  const triggerRef = usePopoverContext_unstable((context) => context.triggerRef);
  const appearance = usePopoverContext_unstable((context) => context.appearance);
  const onDismissButtonClick = useEventCallback((ev) => {
    if (!ev.defaultPrevented) {
      setOpen(ev, false);
    }
    if (triggerRef.current) {
      triggerRef.current.focus();
    }
  });
  return {
    appearance,
    components: {
      root: "div",
      dismissButton: "button",
      icon: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    icon: slot_exports.optional(icon, {
      renderByDefault: true,
      defaultProps: {
        children: React519.createElement(Lightbulb16Regular, null),
        "aria-hidden": true
      },
      elementType: "div"
    }),
    dismissButton: slot_exports.optional(dismissButton, {
      renderByDefault: true,
      defaultProps: {
        children: React519.createElement(Dismiss12Regular, null),
        role: "button",
        "aria-label": "dismiss",
        onClick: onDismissButtonClick
      },
      elementType: "button"
    })
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/renderTeachingPopoverHeader.js
var renderTeachingPopoverHeader_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      state.root.children,
      state.dismissButton && jsx(state.dismissButton, {})
    ]
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/useTeachingPopoverHeaderStyles.styles.js
var teachingPopoverHeaderClassNames = {
  root: "fui-TeachingPopoverHeader",
  dismissButton: "fui-TeachingPopoverHeader__dismissButton",
  icon: "fui-TeachingPopoverHeader__icon"
};
var useStyles64 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    sj55zd: "f11d4kpn",
    Bhrd7zp: "fl43uef",
    Be2twd7: "fy9rknc",
    Bg96gwp: "fwrc4pm",
    Byoj8tv: "f14wxoun",
    Bt984gj: "f122n59",
    B6of3ja: "f1jkagg5",
    jrapky: "fi2ljxd"
  },
  rootBrand: {
    sj55zd: "f1phragk"
  },
  dismissButton: {
    sj55zd: "fkfq4zb",
    qhf8xq: "f10pi13n",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: ["f1n71otn", "f1deefiw"],
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Bceei9c: "f1k6fduh",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    De3pzq: "f1c21dwh",
    B7ck84d: "f1ewtqcl",
    B7oj6ja: ["f3fg2lr", "f13av6d4"],
    Bbmb7ep: ["fzi6hpg", "fyowgf4"],
    Jyy4pa: "f1lfeew",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f16d74zd",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f89hs3r",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"]
  },
  dismissBrand: {
    sj55zd: "f1phragk"
  },
  icon: {
    Bqenvij: "fsv12xs",
    a9b677: "f19bqwv",
    Bg96gwp: "fwrc4pm",
    Be2twd7: "fy9rknc",
    Bt984gj: "f122n59",
    B7ck84d: "f1e4lqlz",
    mc9l5x: "ftuwxu6",
    Brf1p80: "f4d9j23",
    w71qe1: "f1iuv45f",
    ha4doy: "fmrv4ls",
    qhf8xq: "f10pi13n",
    De3pzq: "f1c21dwh",
    sj55zd: "fkfq4zb",
    Bokbzmb: "fpvr8q1"
  },
  iconBrand: {
    sj55zd: "f1phragk"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f14wxoun{padding-bottom:var(--spacingVerticalXS);}", ".f122n59{align-items:center;}", ".f1jkagg5{margin-top:var(--spacingHorizontalNone);}", ".fi2ljxd{margin-bottom:var(--spacingHorizontalNone);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f10pi13n{position:relative;}", [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".f1k6fduh{cursor:pointer;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1ewtqcl{box-sizing:border-box;}", ".f3fg2lr{border-top-right-radius:var(--borderRadiusNone);}", ".f13av6d4{border-top-left-radius:var(--borderRadiusNone);}", ".fzi6hpg{border-bottom-right-radius:var(--borderRadiusNone);}", ".fyowgf4{border-bottom-left-radius:var(--borderRadiusNone);}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1lfeew{-webkit-margin-start:auto;margin-inline-start:auto;}", [".f16d74zd{padding:var(--spacingVerticalXS) var(--spacingHorizontalXS);}", {
    p: -1
  }], [".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", ".fsv12xs{height:var(--fontSizeBase200);}", ".f19bqwv{width:var(--fontSizeBase200);}", ".f1e4lqlz{box-sizing:content-box;}", ".ftuwxu6{display:inline-flex;}", ".f4d9j23{justify-content:center;}", ".f1iuv45f{text-decoration-line:none;}", ".fmrv4ls{vertical-align:middle;}", ".fpvr8q1{-webkit-margin-end:var(--spacingHorizontalXS);margin-inline-end:var(--spacingHorizontalXS);}"]
});
var useTeachingPopoverHeaderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles64();
  const {
    appearance
  } = state;
  state.root.className = mergeClasses(teachingPopoverHeaderClassNames.root, styles.root, appearance === "brand" && styles.rootBrand, state.root.className);
  if (state.dismissButton) {
    state.dismissButton.className = mergeClasses(teachingPopoverHeaderClassNames.dismissButton, styles.dismissButton, appearance === "brand" ? styles.dismissBrand : void 0, state.dismissButton.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(teachingPopoverHeaderClassNames.icon, styles.icon, appearance === "brand" ? styles.iconBrand : void 0, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/TeachingPopoverHeader.js
var TeachingPopoverHeader = React520.forwardRef((props, ref) => {
  const state = useTeachingPopoverHeader_unstable(props, ref);
  useTeachingPopoverHeaderStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverHeaderStyles_unstable")(state);
  return renderTeachingPopoverHeader_unstable(state);
});
TeachingPopoverHeader.displayName = "TeachingPopoverHeader";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/TeachingPopoverBody.js
var React522 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/useTeachingPopoverBody.js
var React521 = __toESM(require_react());
var useTeachingPopoverBody_unstable = (props, ref) => {
  const { mediaLength } = props;
  return {
    components: {
      root: "div",
      media: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    media: slot_exports.optional(props.media, {
      elementType: "span"
    }),
    mediaLength: mediaLength !== null && mediaLength !== void 0 ? mediaLength : "short"
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/renderTeachingPopoverBody.js
var renderTeachingPopoverBody_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.media && jsx(state.media, {}),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/useTeachingPopoverBodyStyles.styles.js
var teachingPopoverBodyClassNames = {
  root: "fui-TeachingPopoverBody",
  media: "fui-TeachingPopoverBody__media"
};
var useMediaStyles2 = __styles2({
  base: {
    Bw0ie65: 0,
    Br312pm: 0,
    nk6f5a: 0,
    Ijaq50: 0,
    Bq1tomu: "fujjg13",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    a9b677: "f14z66ap",
    jrapky: "f1jlhsmd",
    ha4doy: "fmrv4ls",
    Brf1p80: "f4d9j23",
    mc9l5x: "f22iagw"
  },
  short: {
    Bubjx69: "f1taewuw",
    Bmuttt3: "fs5pxn9"
  },
  medium: {
    Bubjx69: "f7da563",
    Bmuttt3: "f98prui"
  },
  tall: {
    Bubjx69: "f9ikmtg",
    Bmuttt3: "fqws08j"
  }
}, {
  d: [[".fujjg13{grid-area:media;}", {
    p: -1
  }], [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], ".f14z66ap{width:auto;}", ".f1jlhsmd{margin-bottom:12px;}", ".fmrv4ls{vertical-align:middle;}", ".f4d9j23{justify-content:center;}", ".f22iagw{display:flex;}", ".f1taewuw{aspect-ratio:2.4615384615384617;}", ".f7da563{aspect-ratio:1.6363636363636365;}", ".f9ikmtg{aspect-ratio:1;}"],
  t: ["@supports not (aspect-ratio){.fs5pxn9{height:117px;}}", "@supports not (aspect-ratio){.f98prui{height:176px;}}", "@supports not (aspect-ratio){.fqws08j{height:288px;}}"]
});
var useStyles65 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    Byoj8tv: "fpe6lb7"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".fpe6lb7{padding-bottom:12px;}"]
});
var useTeachingPopoverBodyStyles_unstable = (state) => {
  "use no memo";
  const {
    mediaLength
  } = state;
  const styles = useStyles65();
  const mediaStyles = useMediaStyles2();
  state.root.className = mergeClasses(teachingPopoverBodyClassNames.root, styles.root, state.root.className);
  if (state.media) {
    state.media.className = mergeClasses(teachingPopoverBodyClassNames.media, mediaStyles.base, mediaStyles[mediaLength], state.media.className);
  }
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/TeachingPopoverBody.js
var TeachingPopoverBody = React522.forwardRef((props, ref) => {
  const state = useTeachingPopoverBody_unstable(props, ref);
  useTeachingPopoverBodyStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverBodyStyles_unstable")(state);
  return renderTeachingPopoverBody_unstable(state);
});
TeachingPopoverBody.displayName = "TeachingPopoverBody";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/TeachingPopoverCarouselCard.js
var React527 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/useTeachingPopoverCarouselCard.js
var React526 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselItem/Carouseltem.js
var React525 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselItem/useCarouselItem.js
var React524 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselContext.js
var React523 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/createCarouselStore.js
var createCarouselStore = () => {
  let values2 = [];
  let listeners = [];
  const carouselStore = {
    clear() {
      values2 = [];
      emitChange();
    },
    addValue(value) {
      values2 = [
        ...values2,
        value
      ];
      emitChange();
    },
    insertValue(value, prev) {
      if (!prev) {
        values2 = [
          value,
          ...values2
        ];
      } else {
        const pos = values2.indexOf(prev);
        values2.splice(pos + 1, 0, value);
        values2 = [
          ...values2
        ];
      }
      emitChange();
    },
    removeValue(value) {
      const pos = values2.indexOf(value);
      values2.splice(pos, 1);
      values2 = [
        ...values2
      ];
      emitChange();
    },
    subscribe(listener) {
      listeners = [
        ...listeners,
        listener
      ];
      return () => {
        listeners = listeners.filter((l) => l !== listener);
      };
    },
    getSnapshot() {
      return values2;
    }
  };
  function emitChange() {
    for (const listener of listeners) {
      listener();
    }
  }
  return carouselStore;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselContext.js
var carouselContextDefaultValue = {
  store: createCarouselStore(),
  value: null,
  selectPageByDirection: () => {
  },
  selectPageByValue: () => {
  }
};
var CarouselContext = createContext13(void 0);
var CarouselProvider = CarouselContext.Provider;
var useCarouselContext_unstable = (selector) => useContextSelector(CarouselContext, (ctx = carouselContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/constants.js
var CAROUSEL_ITEM = "data-carousel-item";
var CAROUSEL_ACTIVE_ITEM = "data-carousel-active-item";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselItem/useCarouselItem.js
var useCarouselItem_unstable = (props, ref) => {
  const { value } = props;
  const visible = useCarouselContext_unstable((c) => c.value === value);
  const state = {
    value,
    visible,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      [CAROUSEL_ITEM]: value,
      [CAROUSEL_ACTIVE_ITEM]: visible,
      hidden: !visible,
      ...props
    }), {
      elementType: "div"
    })
  };
  if (!visible) {
    state.root.children = null;
  }
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselItem/renderCarouselItem.js
var renderCarouselItem_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselItem/Carouseltem.js
var CarouselItem = React525.forwardRef((props, ref) => {
  const state = useCarouselItem_unstable(props, ref);
  return renderCarouselItem_unstable(state);
});
CarouselItem.displayName = "CarouselItem";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/useTeachingPopoverCarouselCard.js
var useTeachingPopoverCarouselCard_unstable = (props, ref) => {
  const { value } = props;
  return {
    value,
    components: {
      root: CarouselItem
    },
    root: slot_exports.always({
      ...getIntrinsicElementProps("div", {
        ref,
        ...props
      }),
      value
    }, {
      elementType: CarouselItem
    })
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/renderTeachingPopoverCarouselCard.js
var renderTeachingPopoverCarouselCard_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/useTeachingPopoverCarouselCardStyles.styles.js
var teachingPopoverCarouselCardClassNames = {
  root: "fui-TeachingPopoverCarouselCard"
};
var useStyles66 = __styles2({
  root: {}
}, {});
var useTeachingPopoverCarouselCardStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles66();
  state.root.className = mergeClasses(teachingPopoverCarouselCardClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/TeachingPopoverCarouselCard.js
var TeachingPopoverCarouselCard = React527.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarouselCard_unstable(props, ref);
  useTeachingPopoverCarouselCardStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselCardStyles_unstable")(state);
  return renderTeachingPopoverCarouselCard_unstable(state);
});
TeachingPopoverCarouselCard.displayName = "TeachingPopoverCarouselCard";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/TeachingPopoverCarousel.js
var React531 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/useTeachingPopoverCarousel.js
var React530 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/Carousel.js
var React529 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/useCarouselWalker.js
var React528 = __toESM(require_react());
var useCarouselWalker_unstable = () => {
  const { targetDocument } = useFluent();
  const treeWalkerRef = React528.useRef(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.createTreeWalker(targetDocument.body));
  const htmlRef = React528.useRef(null);
  const ref = React528.useCallback((el) => {
    if (!targetDocument) {
      return;
    }
    if (!el) {
      return;
    }
    htmlRef.current = el;
    treeWalkerRef.current = targetDocument.createTreeWalker(el, NodeFilter.SHOW_ELEMENT, {
      acceptNode(node) {
        if (!isHTMLElement(node)) {
          return NodeFilter.FILTER_SKIP;
        }
        return node.hasAttribute(CAROUSEL_ITEM) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
  }, [
    targetDocument
  ]);
  return {
    ref,
    walker: React528.useMemo(() => ({
      active() {
        if (!htmlRef.current) {
          return null;
        }
        const activeEl = htmlRef.current.querySelector(`[${CAROUSEL_ACTIVE_ITEM}="true"]`);
        if (isHTMLElement(activeEl)) {
          return {
            el: activeEl,
            value: activeEl.getAttribute(CAROUSEL_ITEM)
          };
        }
        return null;
      },
      find(value) {
        var _treeWalkerRef_current;
        if (!((_treeWalkerRef_current = treeWalkerRef.current) === null || _treeWalkerRef_current === void 0 ? void 0 : _treeWalkerRef_current.currentNode) || !htmlRef.current) {
          return null;
        }
        treeWalkerRef.current.currentNode = htmlRef.current;
        let nextNode = null;
        while (nextNode = treeWalkerRef.current.nextNode()) {
          if (!isHTMLElement(nextNode)) {
            continue;
          }
          if (nextNode.getAttribute(CAROUSEL_ITEM) === value) {
            return {
              el: nextNode,
              value: nextNode.getAttribute(CAROUSEL_ITEM)
            };
          }
        }
        return null;
      },
      nextPage(value) {
        var _treeWalkerRef_current;
        const res = this.find(value);
        if (!res || !((_treeWalkerRef_current = treeWalkerRef.current) === null || _treeWalkerRef_current === void 0 ? void 0 : _treeWalkerRef_current.currentNode)) {
          return null;
        }
        treeWalkerRef.current.currentNode = res.el;
        const next = treeWalkerRef.current.nextNode();
        if (isHTMLElement(next)) {
          return {
            el: next,
            value: next.getAttribute(CAROUSEL_ITEM)
          };
        }
        return null;
      },
      prevPage(value) {
        var _treeWalkerRef_current;
        const res = this.find(value);
        if (!res || !((_treeWalkerRef_current = treeWalkerRef.current) === null || _treeWalkerRef_current === void 0 ? void 0 : _treeWalkerRef_current.currentNode)) {
          return null;
        }
        treeWalkerRef.current.currentNode = res.el;
        const next = treeWalkerRef.current.previousNode();
        if (isHTMLElement(next)) {
          return {
            el: next,
            value: next.getAttribute(CAROUSEL_ITEM)
          };
        }
        return null;
      }
    }), [])
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/Carousel.js
function useCarousel_unstable(options) {
  "use no memo";
  const { announcement, onValueChange, onFinish } = options;
  const { targetDocument } = useFluent();
  const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
  const { ref: carouselRef, walker: carouselWalker } = useCarouselWalker_unstable();
  const [store] = React529.useState(() => createCarouselStore());
  const [value, setValue] = useControllableState({
    defaultState: options.defaultValue,
    state: options.value,
    initialState: null
  });
  const rootRef = React529.useRef(null);
  const { announce } = useAnnounce();
  if (true) {
    React529.useEffect(() => {
      if (value === null) {
        console.error("useCarousel: Carousel needs to have a `defaultValue` or `value` prop set. If you want to control the value, use the `value` prop.");
      }
    }, [
      value
    ]);
  }
  React529.useEffect(() => {
    var _rootRef_current;
    const allItems = (_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.querySelectorAll(`[${CAROUSEL_ITEM}]`);
    for (let i = 0; i < allItems.length; i++) {
      store.addValue(allItems.item(i).getAttribute(CAROUSEL_ITEM));
    }
    return () => {
      store.clear();
    };
  }, [
    store
  ]);
  React529.useEffect(() => {
    if (!win) {
      return;
    }
    const config = {
      attributes: true,
      attributeFilter: [
        CAROUSEL_ITEM
      ],
      childList: true,
      subtree: true
    };
    const callback = (mutationList) => {
      for (const mutation of mutationList) {
        for (const addedNode of Array.from(mutation.addedNodes)) {
          if (isHTMLElement(addedNode) && addedNode.hasAttribute(CAROUSEL_ITEM)) {
            const newValue = addedNode.getAttribute(CAROUSEL_ITEM);
            const newNode = carouselWalker.find(newValue);
            if (!(newNode === null || newNode === void 0 ? void 0 : newNode.value)) {
              return;
            }
            const previousNode = carouselWalker.prevPage(newNode === null || newNode === void 0 ? void 0 : newNode.value);
            var _previousNode_value;
            store.insertValue(newValue, (_previousNode_value = previousNode === null || previousNode === void 0 ? void 0 : previousNode.value) !== null && _previousNode_value !== void 0 ? _previousNode_value : null);
          }
        }
        for (const removedNode of Array.from(mutation.removedNodes)) {
          if (isHTMLElement(removedNode) && (removedNode === null || removedNode === void 0 ? void 0 : removedNode.hasAttribute(CAROUSEL_ITEM))) {
            const removedValue = removedNode.getAttribute(CAROUSEL_ITEM);
            store.removeValue(removedValue);
          }
        }
      }
    };
    const observer = new win.MutationObserver(callback);
    observer.observe(rootRef.current, config);
    return () => {
      observer.disconnect();
    };
  }, [
    carouselWalker,
    store,
    win
  ]);
  const updateSlide = useEventCallback((event, newValue) => {
    setValue(newValue);
    onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange(event, {
      event,
      type: "click",
      value: newValue
    });
    const announceText = announcement === null || announcement === void 0 ? void 0 : announcement(newValue);
    if (announceText) {
      announce(announceText, {
        polite: true
      });
    }
  });
  const selectPageByDirection = useEventCallback((event, direction) => {
    const active = carouselWalker.active();
    if (!(active === null || active === void 0 ? void 0 : active.value)) {
      return;
    }
    const newPage = direction === "prev" ? carouselWalker.prevPage(active.value) : carouselWalker.nextPage(active.value);
    if (newPage) {
      updateSlide(event, newPage === null || newPage === void 0 ? void 0 : newPage.value);
    } else {
      onFinish === null || onFinish === void 0 ? void 0 : onFinish(event, {
        event,
        type: "click",
        value: active === null || active === void 0 ? void 0 : active.value
      });
    }
  });
  return {
    carouselRef: useMergedRefs(rootRef, carouselRef),
    carousel: {
      store,
      value,
      selectPageByDirection,
      selectPageByValue: updateSlide
    }
  };
}

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/useTeachingPopoverCarousel.js
var useTeachingPopoverCarousel_unstable = (props, ref) => {
  const toggleOpen = usePopoverContext_unstable((c) => c.toggleOpen);
  const handleFinish = useEventCallback((event, data) => {
    var _props_onFinish;
    (_props_onFinish = props.onFinish) === null || _props_onFinish === void 0 ? void 0 : _props_onFinish.call(props, event, data);
    toggleOpen(event);
  });
  const { carousel, carouselRef } = useCarousel_unstable({
    announcement: props.announcement,
    defaultValue: props.defaultValue,
    value: props.value,
    onValueChange: props.onValueChange,
    onFinish: handleFinish
  });
  const appearance = usePopoverContext_unstable((context) => context.appearance);
  return {
    appearance,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, carouselRef),
      ...props
    }), {
      elementType: "div"
    }),
    ...carousel
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/renderTeachingPopoverCarousel.js
var renderTeachingPopoverCarousel_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(CarouselProvider, {
    value: contextValues.carousel,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/useTeachingPopoverCarouselStyles.styles.js
var teachingPopoverCarouselClassNames = {
  root: "fui-TeachingPopoverCarousel"
};
var useStyles67 = __styles2({
  root: {}
}, {});
var useTeachingPopoverCarouselStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles67();
  state.root.className = mergeClasses(teachingPopoverCarouselClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/useTeachingPopoverCarouselContextValues.js
function useTeachingPopoverCarouselContextValues_unstable(state) {
  const { store, value, selectPageByValue, selectPageByDirection } = state;
  const carousel = {
    store,
    value,
    selectPageByDirection,
    selectPageByValue
  };
  return {
    carousel
  };
}

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/TeachingPopoverCarousel.js
var TeachingPopoverCarousel = React531.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarousel_unstable(props, ref);
  useTeachingPopoverCarouselStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselStyles_unstable")(state);
  const contextValues = useTeachingPopoverCarouselContextValues_unstable(state);
  return renderTeachingPopoverCarousel_unstable(state, contextValues);
});
TeachingPopoverCarousel.displayName = "TeachingPopoverCarousel";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/TeachingPopoverCarouselFooter.js
var React535 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/useTeachingPopoverCarouselFooter.js
var React534 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/TeachingPopoverCarouselFooterButton.js
var React533 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/useTeachingPopoverCarouselFooterButton.js
var React532 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/useCarouselValues.js
var import_shim2 = __toESM(require_shim());
function useCarouselValues_unstable(getSnapshot) {
  const store = useCarouselContext_unstable((c) => c.store);
  return (0, import_shim2.useSyncExternalStore)(store.subscribe, () => getSnapshot(store.getSnapshot()));
}

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/useTeachingPopoverCarouselFooterButton.js
var useTeachingPopoverCarouselFooterButton_unstable = (props, ref) => {
  const { navType, altText } = props;
  const popoverAppearance = usePopoverContext_unstable((context) => context.appearance);
  const selectPageByDirection = useCarouselContext_unstable((c) => c.selectPageByDirection);
  const values2 = useCarouselValues_unstable((snapshot) => snapshot);
  const activeValue = useCarouselContext_unstable((c) => c.value);
  const handleClick = (event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    selectPageByDirection(event, navType);
  };
  const handleButtonClick = useEventCallback(mergeCallbacks(handleClick, props.onClick));
  const isTrailing = React532.useMemo(() => {
    if (!activeValue) {
      return false;
    }
    if (navType === "prev") {
      return values2.indexOf(activeValue) === 0;
    }
    return values2.indexOf(activeValue) === values2.length - 1;
  }, [
    navType,
    activeValue,
    values2
  ]);
  let buttonAppearanceType;
  if (navType === "next") {
    buttonAppearanceType = popoverAppearance === "brand" ? void 0 : "primary";
  } else {
    buttonAppearanceType = popoverAppearance === "brand" ? "outline" : void 0;
  }
  let buttonChild = props.children;
  if (isTrailing) {
    buttonChild = altText;
  }
  return {
    ...useButton_unstable({
      appearance: buttonAppearanceType,
      ...props
    }, ref),
    navType,
    popoverAppearance,
    altText,
    // Override useButton root slot
    root: slot_exports.always(getIntrinsicElementProps("button", {
      ref,
      appearance: buttonAppearanceType,
      ...props,
      onClick: handleButtonClick,
      children: buttonChild
    }), {
      elementType: "button"
    })
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/renderTeachingPopoverCarouselFooterButton.js
var renderTeachingPopoverCarouselFooterButton_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/useTeachingPopoverCarouselFooterButtonStyles.styles.js
var teachingPopoverCarouselFooterButtonClassNames = {
  root: "fui-TeachingPopoverCarouselFooterButton"
};
var useStyles68 = __styles2({
  root: {
    Bf4jedk: "f14es27b"
  },
  brandNext: {
    sj55zd: "f16muhyy",
    De3pzq: "f10s6wn9",
    g2u3we: "f1iimpp0",
    h3c5rm: ["f19uhqvu", "f1nx14hx"],
    B9xav0g: "fnqa90p",
    zhjwy3: ["f1nx14hx", "f19uhqvu"],
    Bi91k9c: "f3ymbdj",
    Jwef8y: "f1rgtb95",
    B2d53fq: "f1pu27ff",
    iro3zm: "f1d5c7in"
  },
  brandPrevious: {
    sj55zd: "f1phragk",
    De3pzq: "ffp7eso",
    g2u3we: "fm1ebug",
    h3c5rm: ["f28omuz", "f1uhflii"],
    B9xav0g: "f1ixw5o4",
    zhjwy3: ["f1uhflii", "f28omuz"],
    Bi91k9c: "f1rq72xc",
    Bgoe8wy: "f1bg5g8r",
    Bwzppfd: ["f1h9bnsk", "f12x9t0k"],
    oetu4i: "f19ervry",
    gg5e9n: ["f12x9t0k", "f1h9bnsk"],
    Jwef8y: "f15wkkf3",
    B2d53fq: "f1d6v5y2",
    b661bw: "f1565b9n",
    Bk6r4ia: ["fm07gvo", "fwlsg72"],
    B9zn80p: "fzw6fmy",
    Bpld233: ["fwlsg72", "fm07gvo"],
    iro3zm: "fnp9lpt"
  }
}, {
  d: [".f14es27b{min-width:96px;}", ".f16muhyy{color:var(--colorBrandForeground1);}", ".f10s6wn9{background-color:var(--colorNeutralForegroundOnBrand);}", ".f1iimpp0{border-top-color:var(--colorTransparentBackground);}", ".f19uhqvu{border-right-color:var(--colorTransparentBackground);}", ".f1nx14hx{border-left-color:var(--colorTransparentBackground);}", ".fnqa90p{border-bottom-color:var(--colorTransparentBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".fm1ebug{border-top-color:var(--colorNeutralForegroundOnBrand);}", ".f28omuz{border-right-color:var(--colorNeutralForegroundOnBrand);}", ".f1uhflii{border-left-color:var(--colorNeutralForegroundOnBrand);}", ".f1ixw5o4{border-bottom-color:var(--colorNeutralForegroundOnBrand);}"],
  h: [".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}", ".f1rgtb95:hover{background-color:var(--colorNeutralForegroundOnBrand);}", ".f1pu27ff:hover:active{color:var(--colorCompoundBrandForeground1Pressed);}", ".f1d5c7in:hover:active{background-color:var(--colorNeutralForegroundOnBrand);}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}", ".f1bg5g8r:hover{border-top-color:var(--colorNeutralForegroundOnBrand);}", ".f1h9bnsk:hover{border-right-color:var(--colorNeutralForegroundOnBrand);}", ".f12x9t0k:hover{border-left-color:var(--colorNeutralForegroundOnBrand);}", ".f19ervry:hover{border-bottom-color:var(--colorNeutralForegroundOnBrand);}", ".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1d6v5y2:hover:active{color:var(--colorNeutralForegroundOnBrand);}", ".f1565b9n:hover:active{border-top-color:var(--colorNeutralForegroundOnBrand);}", ".fm07gvo:hover:active{border-right-color:var(--colorNeutralForegroundOnBrand);}", ".fwlsg72:hover:active{border-left-color:var(--colorNeutralForegroundOnBrand);}", ".fzw6fmy:hover:active{border-bottom-color:var(--colorNeutralForegroundOnBrand);}", ".fnp9lpt:hover:active{background-color:var(--colorBrandBackgroundPressed);}"]
});
var useTeachingPopoverCarouselFooterButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles68();
  const {
    navType,
    popoverAppearance
  } = state;
  state = {
    ...state,
    ...useButtonStyles_unstable(state)
  };
  state.root.className = mergeClasses(teachingPopoverCarouselFooterButtonClassNames.root, styles.root, navType === "prev" && popoverAppearance === "brand" && styles.brandPrevious, navType === "next" && popoverAppearance === "brand" && styles.brandNext, state.root.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/TeachingPopoverCarouselFooterButton.js
var TeachingPopoverCarouselFooterButton = React533.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarouselFooterButton_unstable(props, ref);
  useTeachingPopoverCarouselFooterButtonStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselFooterButtonStyles_unstable")(state);
  return renderTeachingPopoverCarouselFooterButton_unstable(state);
});
TeachingPopoverCarouselFooterButton.displayName = "TeachingPopoverCarouselFooterButton";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/useTeachingPopoverCarouselFooter.js
var useTeachingPopoverCarouselFooter_unstable = (props, ref) => {
  const { layout = "centered", initialStepText, finalStepText } = props;
  const previous = slot_exports.optional(props.previous, {
    defaultProps: {
      navType: "prev",
      altText: initialStepText
    },
    renderByDefault: true,
    elementType: TeachingPopoverCarouselFooterButton
  });
  const next = slot_exports.always(props.next, {
    defaultProps: {
      navType: "next",
      altText: finalStepText
    },
    elementType: TeachingPopoverCarouselFooterButton
  });
  return {
    layout,
    components: {
      root: "div",
      next: TeachingPopoverCarouselFooterButton,
      previous: TeachingPopoverCarouselFooterButton
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    previous,
    next
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/renderTeachingPopoverCarouselFooter.js
var renderTeachingPopoverCarouselFooter_unstable = (state) => {
  assertSlots(state);
  const { layout } = state;
  return jsxs(state.root, {
    children: [
      layout === "centered" && state.previous && jsx(state.previous, {}),
      state.root.children,
      layout === "offset" && state.previous && jsx(state.previous, {}),
      jsx(state.next, {})
    ]
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/useTeachingPopoverCarouselFooterStyles.styles.js
var teachingPopoverCarouselFooterClassNames = {
  root: "fui-TeachingPopoverCarouselFooter",
  previous: "fui-TeachingPopoverCarouselFooter__previous",
  next: "fui-TeachingPopoverCarouselFooter__next"
};
var useStyles69 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq"
  },
  rootCentered: {
    Brf1p80: "f1869bpl",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f19gb1f4"
  },
  rootRightAligned: {
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f19gb1f4",
    Bp34fd5: "f1y65ohq"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f1869bpl{justify-content:space-between;}", [".f19gb1f4{gap:8px;}", {
    p: -1
  }], [".f19gb1f4{gap:8px;}", {
    p: -1
  }], ".f1y65ohq :first-child{-webkit-margin-end:auto;margin-inline-end:auto;}"]
});
var useTeachingPopoverCarouselFooterStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles69();
  const {
    layout
  } = state;
  state.root.className = mergeClasses(teachingPopoverCarouselFooterClassNames.root, styles.root, layout === "centered" ? styles.rootCentered : styles.rootRightAligned, state.root.className);
  if (state.previous) {
    state.previous.className = mergeClasses(teachingPopoverCarouselFooterClassNames.previous, state.previous.className);
  }
  state.next.className = mergeClasses(teachingPopoverCarouselFooterClassNames.next, state.next.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/TeachingPopoverCarouselFooter.js
var TeachingPopoverCarouselFooter = React535.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarouselFooter_unstable(props, ref);
  useTeachingPopoverCarouselFooterStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselFooterStyles_unstable")(state);
  return renderTeachingPopoverCarouselFooter_unstable(state);
});
TeachingPopoverCarouselFooter.displayName = "TeachingPopoverCarouselFooter";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/TeachingPopoverCarouselNav.js
var React538 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/useTeachingPopoverCarouselNav.js
var React536 = __toESM(require_react());
var useTeachingPopoverCarouselNav_unstable = (props, ref) => {
  const focusableGroupAttr = useArrowNavigationGroup({
    circular: false,
    axis: "horizontal",
    memorizeCurrent: false,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_hasDefault: true
  });
  const values2 = useCarouselValues_unstable((snapshot) => snapshot);
  return {
    values: values2,
    renderNavButton: props.children,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      role: "tablist",
      tabIndex: 0,
      ...props,
      ...focusableGroupAttr,
      children: null
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/valueIdContext.js
var React537 = __toESM(require_react());
var valueIdContext = React537.createContext(void 0);
var valueIdContextDefaultValue = "";
var useValueIdContext = () => {
  var _React_useContext;
  return (_React_useContext = React537.useContext(valueIdContext)) !== null && _React_useContext !== void 0 ? _React_useContext : valueIdContextDefaultValue;
};
var ValueIdContextProvider = valueIdContext.Provider;

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/renderTeachingPopoverCarouselNav.js
var renderTeachingPopoverCarouselNav_unstable = (state) => {
  assertSlots(state);
  const { values: values2, renderNavButton } = state;
  return jsx(state.root, {
    children: values2.map((value) => jsx(ValueIdContextProvider, {
      value,
      children: renderNavButton(value)
    }, value))
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/useTeachingPopoverCarouselNavStyles.styles.js
var teachingPopoverCarouselNavClassNames = {
  root: "fui-TeachingPopoverCarouselNav"
};
var useStyles70 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    i8kkvl: "f1ufnopg",
    Bt984gj: "f122n59",
    Brf1p80: "f4d9j23",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f89hs3r",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"]
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f1ufnopg{column-gap:var(--spacingHorizontalXS);}", ".f122n59{align-items:center;}", ".f4d9j23{justify-content:center;}", [".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}"]
});
var useTeachingPopoverCarouselNavStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles70();
  state.root.className = mergeClasses(teachingPopoverCarouselNavClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/TeachingPopoverCarouselNav.js
var TeachingPopoverCarouselNav = React538.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarouselNav_unstable(props, ref);
  useTeachingPopoverCarouselNavStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselNavStyles_unstable")(state);
  return renderTeachingPopoverCarouselNav_unstable(state);
});
TeachingPopoverCarouselNav.displayName = "TeachingPopoverCarouselNav";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/TeachingPopoverCarouselNavButton.js
var React540 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/useTeachingPopoverCarouselNavButton.js
var React539 = __toESM(require_react());
var useTeachingPopoverCarouselNavButton_unstable = (props, ref) => {
  const { onClick, as = "a" } = props;
  const value = useValueIdContext();
  const appearance = usePopoverContext_unstable((context) => context.appearance);
  const selectPageByValue = useCarouselContext_unstable((c) => c.selectPageByValue);
  const isSelected = useCarouselContext_unstable((c) => c.value === value);
  const handleClick = useEventCallback((event) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
    if (!event.defaultPrevented && isHTMLElement(event.target)) {
      selectPageByValue(event, value);
    }
  });
  const defaultTabProps = useTabsterAttributes({
    focusable: {
      isDefault: isSelected
    }
  });
  const _carouselButton = slot_exports.always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
    elementType: "button",
    defaultProps: {
      ref,
      role: "tab",
      type: "button",
      "aria-selected": `${!!isSelected}`,
      ...defaultTabProps
    }
  });
  _carouselButton.onClick = handleClick;
  const state = {
    isSelected,
    appearance,
    components: {
      root: "button"
    },
    root: _carouselButton
  };
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/renderTeachingPopoverCarouselNavButton.js
var renderTeachingPopoverCarouselNavButton_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/useTeachingPopoverCarouselNavButtonStyles.styles.js
var teachingPopoverCarouselNavButtonClassNames = {
  root: "fui-TeachingPopoverCarouselNavButton"
};
var useStyles71 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bceei9c: "f1k6fduh",
    B7ck84d: "f1ewtqcl",
    Bqenvij: "f1x82gua",
    a9b677: "f1o3cbw4",
    De3pzq: "ffp7eso"
  },
  rootUnselected: {
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f5q2cvs",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1c5fvqg",
    Bw0xxkn: 0,
    oeaueh: 0,
    Bpd4iqm: 0,
    Befb4lg: "f71xx7",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f89hs3r",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    De3pzq: "frgiif3",
    Bfclv37: "f14lfud5",
    B372c46: "fngekiq"
  },
  rootSelected: {
    Bw0xxkn: 0,
    oeaueh: 0,
    Bpd4iqm: 0,
    Befb4lg: "f71xx7",
    a9b677: "fjw5fx7",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ff3glw6",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1c5fvqg",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f89hs3r",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Bsw6fvg: "fe2ae1k"
  },
  rootBrand: {
    De3pzq: "f10s6wn9"
  },
  rootBrandUnselected: {
    De3pzq: "frxe7el",
    Bfclv37: "f14lfud5",
    B372c46: "fngekiq"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1k6fduh{cursor:pointer;}", ".f1ewtqcl{box-sizing:border-box;}", ".f1x82gua{height:8px;}", ".f1o3cbw4{width:8px;}", ".ffp7eso{background-color:var(--colorBrandBackground);}", [".f3bhgqh{border:none;}", {
    p: -2
  }], [".f5q2cvs{border-radius:50%;}", {
    p: -1
  }], [".f1c5fvqg{padding:0px;}", {
    p: -1
  }], [".f71xx7{outline:var(--strokeWidthThin) solid transparent;}", {
    p: -1
  }], [".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", ".frgiif3{background-color:color-mix(in srgb, var(--colorBrandBackground) 30%, transparent);}", [".f71xx7{outline:var(--strokeWidthThin) solid transparent;}", {
    p: -1
  }], ".fjw5fx7{width:16px;}", [".f3bhgqh{border:none;}", {
    p: -2
  }], [".ff3glw6{border-radius:4px;}", {
    p: -1
  }], [".f1c5fvqg{padding:0px;}", {
    p: -1
  }], [".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f10s6wn9{background-color:var(--colorNeutralForegroundOnBrand);}", ".frxe7el{background-color:color-mix(in srgb, var(--colorNeutralForegroundOnBrand) 30%, transparent);}"],
  t: ["@supports not (color: color-mix(in lch, white, black)){.f14lfud5{opacity:0.3;}}", "@supports not (color: color-mix(in lch, white, black)){.fngekiq{background-color:var(--colorBrandBackground);}}"],
  m: [["@media (forced-colors: active){.fe2ae1k{background-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useTeachingPopoverCarouselNavButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles71();
  const {
    appearance,
    isSelected
  } = state;
  const brandStyles = isSelected ? styles.rootBrand : styles.rootBrandUnselected;
  state.root.className = mergeClasses(teachingPopoverCarouselNavButtonClassNames.root, styles.root, isSelected ? styles.rootSelected : styles.rootUnselected, appearance === "brand" && brandStyles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/TeachingPopoverCarouselNavButton.js
var TeachingPopoverCarouselNavButton = React540.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarouselNavButton_unstable(props, ref);
  useTeachingPopoverCarouselNavButtonStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselNavButtonStyles_unstable")(state);
  return renderTeachingPopoverCarouselNavButton_unstable(state);
});
TeachingPopoverCarouselNavButton.displayName = "TeachingPopoverCarouselNavButton";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/TeachingPopoverSurface.js
var React542 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/useTeachingPopoverSurface.js
var React541 = __toESM(require_react());
var useTeachingPopoverSurface_unstable = (props, ref) => {
  const state = usePopoverSurface_unstable(props, ref);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/useTeachingPopoverSurfaceStyles.styles.js
var teachingPopoverSurfaceClassNames = {
  root: "fui-TeachingPopoverSurface"
};
var useStyles72 = __styles2({
  root: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f23zza1",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1kijzfu",
    Bf4jedk: "f14hp5dx",
    B7ck84d: "f1ewtqcl"
  }
}, {
  d: [[".f23zza1{padding:var(--spacingVerticalL) var(--spacingVerticalL);}", {
    p: -1
  }], [".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", {
    p: -1
  }], ".f14hp5dx{min-width:320px;}", ".f1ewtqcl{box-sizing:border-box;}"]
});
var useTeachingPopoverSurfaceStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles72();
  state.root.className = mergeClasses(teachingPopoverSurfaceClassNames.root, styles.root, state.root.className);
  const updatedState = usePopoverSurfaceStyles_unstable(state);
  return updatedState;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/renderTeachingPopoverSurface.js
var renderTeachingPopoverSurface_unstable = (state) => {
  assertSlots(state);
  return renderPopoverSurface_unstable(state);
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/TeachingPopoverSurface.js
var TeachingPopoverSurface = React542.forwardRef((props, ref) => {
  const state = useTeachingPopoverSurface_unstable(props, ref);
  useTeachingPopoverSurfaceStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverSurfaceStyles_unstable")(state);
  return renderTeachingPopoverSurface_unstable(state);
});
TeachingPopoverSurface.displayName = "TeachingPopoverSurface";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/TeachingPopoverTitle.js
var React544 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/useTeachingPopoverTitle.js
var React543 = __toESM(require_react());
var DismissIcon = bundleIcon_default(DismissFilled, DismissRegular);
var useTeachingPopoverTitle_unstable = (props, ref) => {
  const { dismissButton } = props;
  const setOpen = usePopoverContext_unstable((context) => context.setOpen);
  const triggerRef = usePopoverContext_unstable((context) => context.triggerRef);
  const appearance = usePopoverContext_unstable((context) => context.appearance);
  const onDismissButtonClick = useEventCallback((ev) => {
    if (!ev.defaultPrevented) {
      setOpen(ev, false);
    }
    if (triggerRef.current) {
      triggerRef.current.focus();
    }
  });
  return {
    appearance,
    components: {
      root: "h2",
      dismissButton: "button"
    },
    root: slot_exports.always(getIntrinsicElementProps("h2", {
      ref,
      ...props
    }), {
      elementType: "h2"
    }),
    dismissButton: slot_exports.optional(dismissButton, {
      renderByDefault: false,
      defaultProps: {
        children: React543.createElement(DismissIcon, null),
        onClick: onDismissButtonClick,
        "aria-label": "dismiss",
        "aria-hidden": true
      },
      elementType: "button"
    })
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/renderTeachingPopoverTitle.js
var renderTeachingPopoverTitle_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.root.children,
      state.dismissButton && jsx(state.dismissButton, {})
    ]
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/useTeachingPopoverTitleStyles.styles.js
var teachingPopoverTitleClassNames = {
  root: "fui-TeachingPopoverTitle",
  dismissButton: "fui-TeachingPopoverTitle__dismissButton"
};
var useStyles73 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    Brf1p80: "f1869bpl",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    sj55zd: "f19n0e5",
    Bg96gwp: "faaz57k",
    Byoj8tv: "f5b47ha",
    B6of3ja: "f1jkagg5",
    jrapky: "fi2ljxd"
  },
  rootBrand: {
    sj55zd: "f1phragk"
  },
  dismissButton: {
    qhf8xq: "f10pi13n",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: ["f1n71otn", "f1deefiw"],
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Bceei9c: "f1k6fduh",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    De3pzq: "f1c21dwh",
    B7ck84d: "f1ewtqcl",
    B7oj6ja: ["f3fg2lr", "f13av6d4"],
    Bbmb7ep: ["fzi6hpg", "fyowgf4"],
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f89hs3r",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Jyy4pa: "f1lfeew"
  },
  dismissBrand: {
    sj55zd: "f1phragk"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f1869bpl{justify-content:space-between;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f5b47ha{padding-bottom:var(--spacingVerticalS);}", ".f1jkagg5{margin-top:var(--spacingHorizontalNone);}", ".fi2ljxd{margin-bottom:var(--spacingHorizontalNone);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".f10pi13n{position:relative;}", [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".f122n59{align-items:center;}", ".f1k6fduh{cursor:pointer;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1ewtqcl{box-sizing:border-box;}", ".f3fg2lr{border-top-right-radius:var(--borderRadiusNone);}", ".f13av6d4{border-top-left-radius:var(--borderRadiusNone);}", ".fzi6hpg{border-bottom-right-radius:var(--borderRadiusNone);}", ".fyowgf4{border-bottom-left-radius:var(--borderRadiusNone);}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", [".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", ".f1lfeew{-webkit-margin-start:auto;margin-inline-start:auto;}"]
});
var useTeachingPopoverTitleStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles73();
  const {
    appearance
  } = state;
  state.root.className = mergeClasses(teachingPopoverTitleClassNames.root, styles.root, appearance === "brand" && styles.rootBrand, state.root.className);
  if (state.dismissButton) {
    state.dismissButton.className = mergeClasses(teachingPopoverTitleClassNames.dismissButton, styles.dismissButton, appearance === "brand" ? styles.dismissBrand : void 0, state.dismissButton.className);
  }
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/TeachingPopoverTitle.js
var TeachingPopoverTitle = React544.forwardRef((props, ref) => {
  const state = useTeachingPopoverTitle_unstable(props, ref);
  useTeachingPopoverTitleStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverTitleStyles_unstable")(state);
  return renderTeachingPopoverTitle_unstable(state);
});
TeachingPopoverTitle.displayName = "TeachingPopoverTitle";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTrigger/TeachingPopoverTrigger.js
var React545 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTrigger/renderTeachingPopoverTrigger.js
var renderTeachingPopoverTrigger_unstable = (state) => {
  return state.children;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTrigger/useTeachingPopoverTrigger.js
var useTeachingPopoverTrigger_unstable = (props) => {
  const state = usePopoverTrigger_unstable(props);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTrigger/TeachingPopoverTrigger.js
var TeachingPopoverTrigger = (props) => {
  const state = useTeachingPopoverTrigger_unstable(props);
  return renderTeachingPopoverTrigger_unstable(state);
};
TeachingPopoverTrigger.displayName = "TeachingPopoverTrigger";
TeachingPopoverTrigger.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopover/TeachingPopover.js
var React546 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopover/useTeachingPopover.js
var useTeachingPopover_unstable = (props) => {
  const popoverState = usePopover_unstable(props);
  var _props_withArrow, _props_trapFocus;
  return {
    ...popoverState,
    withArrow: (_props_withArrow = props.withArrow) !== null && _props_withArrow !== void 0 ? _props_withArrow : true,
    // We trap focus because the default TeachingPopover view has buttons/carousel.
    trapFocus: (_props_trapFocus = props.trapFocus) !== null && _props_trapFocus !== void 0 ? _props_trapFocus : true
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopover/renderTeachingPopover.js
var renderTeachingPopover_unstable = renderPopover_unstable;

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopover/TeachingPopover.js
var TeachingPopover = (props) => {
  const state = useTeachingPopover_unstable(props);
  return renderTeachingPopover_unstable(state);
};
TeachingPopover.displayName = "TeachingPopover";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/TeachingPopoverFooter.js
var React548 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/useTeachingPopoverFooter.js
var React547 = __toESM(require_react());
var useTeachingPopoverFooter_unstable = (props, ref) => {
  const appearance = usePopoverContext_unstable((context) => context.appearance);
  const toggleOpen = usePopoverContext_unstable((context) => context.toggleOpen);
  const handleButtonClick = useEventCallback((event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    toggleOpen(event);
  });
  const secondary = slot_exports.optional(props.secondary, {
    defaultProps: {
      appearance: appearance === "brand" ? "primary" : void 0
    },
    renderByDefault: props.secondary !== void 0,
    elementType: Button
  });
  if (secondary) {
    secondary.onClick = mergeCallbacks(handleButtonClick, secondary === null || secondary === void 0 ? void 0 : secondary.onClick);
  }
  const primary = slot_exports.always(props.primary, {
    defaultProps: {
      appearance: appearance === "brand" ? void 0 : "primary"
    },
    elementType: Button
  });
  if (!secondary) {
    primary.onClick = mergeCallbacks(handleButtonClick, primary === null || primary === void 0 ? void 0 : primary.onClick);
  }
  var _props_footerLayout;
  return {
    footerLayout: (_props_footerLayout = props.footerLayout) !== null && _props_footerLayout !== void 0 ? _props_footerLayout : "horizontal",
    appearance,
    components: {
      root: "div",
      primary: Button,
      secondary: Button
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    secondary,
    primary
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/renderTeachingPopoverFooter.js
var renderTeachingPopoverFooter_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.primary, {}),
      state.secondary && jsx(state.secondary, {})
    ]
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/useTeachingPopoverFooterStyles.styles.js
var teachingPopoverFooterClassNames = {
  root: "fui-TeachingPopoverFooter",
  primary: "fui-TeachingPopoverFooter__primary",
  secondary: "fui-TeachingPopoverFooter__secondary"
};
var useStyles74 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f19gb1f4",
    z8tnut: "f1kcqot9"
  },
  rootVertical: {
    Beiy3e4: "f1vx9l62"
  },
  rootHorizontal: {
    Beiy3e4: "f1063pyq",
    Brf1p80: "f9c4gz4"
  },
  buttonRootVertical: {
    a9b677: "f14z66ap",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ff3glw6"
  },
  buttonRootHorizontal: {
    Bf4jedk: "f14es27b",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ff3glw6"
  },
  brandSecondary: {
    g2u3we: "fm1ebug",
    h3c5rm: ["f28omuz", "f1uhflii"],
    B9xav0g: "f1ixw5o4",
    zhjwy3: ["f1uhflii", "f28omuz"]
  },
  brandPrimary: {
    sj55zd: "f16muhyy",
    De3pzq: "f10s6wn9",
    Bi91k9c: "f3ymbdj",
    Jwef8y: "f1rgtb95",
    B2d53fq: "f1pu27ff",
    iro3zm: "f1d5c7in"
  }
}, {
  d: [".f22iagw{display:flex;}", [".f19gb1f4{gap:8px;}", {
    p: -1
  }], ".f1kcqot9{padding-top:12px;}", ".f1vx9l62{flex-direction:column;}", ".f1063pyq{flex-direction:row;}", ".f9c4gz4{justify-content:flex-end;}", ".f14z66ap{width:auto;}", [".ff3glw6{border-radius:4px;}", {
    p: -1
  }], ".f14es27b{min-width:96px;}", [".ff3glw6{border-radius:4px;}", {
    p: -1
  }], ".fm1ebug{border-top-color:var(--colorNeutralForegroundOnBrand);}", ".f28omuz{border-right-color:var(--colorNeutralForegroundOnBrand);}", ".f1uhflii{border-left-color:var(--colorNeutralForegroundOnBrand);}", ".f1ixw5o4{border-bottom-color:var(--colorNeutralForegroundOnBrand);}", ".f16muhyy{color:var(--colorBrandForeground1);}", ".f10s6wn9{background-color:var(--colorNeutralForegroundOnBrand);}"],
  h: [".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}", ".f1rgtb95:hover{background-color:var(--colorNeutralForegroundOnBrand);}", ".f1pu27ff:hover:active{color:var(--colorCompoundBrandForeground1Pressed);}", ".f1d5c7in:hover:active{background-color:var(--colorNeutralForegroundOnBrand);}"]
});
var useTeachingPopoverFooterStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles74();
  const {
    appearance,
    footerLayout
  } = state;
  state.root.className = mergeClasses(teachingPopoverFooterClassNames.root, styles.root, footerLayout === "horizontal" ? styles.rootHorizontal : styles.rootVertical, state.root.className);
  if (state.secondary) {
    state.secondary.className = mergeClasses(teachingPopoverFooterClassNames.secondary, footerLayout === "horizontal" ? styles.buttonRootHorizontal : styles.buttonRootVertical, appearance === "brand" ? styles.brandSecondary : void 0, state.secondary.className);
  }
  state.primary.className = mergeClasses(teachingPopoverFooterClassNames.primary, footerLayout === "horizontal" ? styles.buttonRootHorizontal : styles.buttonRootVertical, appearance === "brand" ? styles.brandPrimary : void 0, state.primary.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/TeachingPopoverFooter.js
var TeachingPopoverFooter = React548.forwardRef((props, ref) => {
  const state = useTeachingPopoverFooter_unstable(props, ref);
  useTeachingPopoverFooterStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverFooterStyles_unstable")(state);
  return renderTeachingPopoverFooter_unstable(state);
});
TeachingPopoverFooter.displayName = "TeachingPopoverFooter";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/TeachingPopoverCarouselPageCount.js
var React550 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/useTeachingPopoverCarouselPageCount.js
var React549 = __toESM(require_react());
var useTeachingPopoverCarouselPageCount_unstable = (props, ref) => {
  const values2 = useCarouselValues_unstable((snapshot) => snapshot);
  var _useCarouselContext_unstable;
  const selectedValue = (_useCarouselContext_unstable = useCarouselContext_unstable((c) => c.value)) !== null && _useCarouselContext_unstable !== void 0 ? _useCarouselContext_unstable : values2[0];
  const currentIndex = values2.indexOf(selectedValue);
  const totalPages = values2.length;
  return {
    currentIndex,
    totalPages,
    renderPageCount: props.children,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props,
      children: props.children(currentIndex + 1, totalPages)
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/renderTeachingPopoverCarouselPageCount.js
var renderTeachingPopoverCarouselPageCount_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/useTeachingPopoverCarouselPageCountStyles.styles.js
var teachingPopoverCarouselPageCountClassNames = {
  root: "fui-TeachingPopoverCarouselPageCount"
};
var useStyles75 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Brf1p80: "f4d9j23"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}", ".f4d9j23{justify-content:center;}"]
});
var useTeachingPopoverCarouselPageCountStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles75();
  state.root.className = mergeClasses(teachingPopoverCarouselPageCountClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/TeachingPopoverCarouselPageCount.js
var TeachingPopoverCarouselPageCount = React550.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarouselPageCount_unstable(props, ref);
  useTeachingPopoverCarouselPageCountStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselPageCountStyles_unstable")(state);
  return renderTeachingPopoverCarouselPageCount_unstable(state);
});
TeachingPopoverCarouselPageCount.displayName = "TeachingPopoverCarouselPageCount";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/TagPicker.js
var React555 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/useTagPicker.js
var React551 = __toESM(require_react());
var fallbackPositions = [
  "above",
  "after",
  "after-top",
  "before",
  "before-top"
];
var useTagPicker_unstable = (props) => {
  const popoverId = useId2("picker-listbox");
  const triggerInnerRef = React551.useRef(null);
  const secondaryActionRef = React551.useRef(null);
  const tagPickerGroupRef = React551.useRef(null);
  const { positioning, size: size3 = "medium", inline: inline2 = false, noPopover = false } = props;
  const { targetRef, containerRef } = usePositioning({
    position: "below",
    align: "start",
    offset: {
      crossAxis: 0,
      mainAxis: 2
    },
    fallbackPositions,
    matchTargetSize: "width",
    ...resolvePositioningShorthand(positioning)
  });
  const { controller: activeDescendantController, activeParentRef, listboxRef } = useActiveDescendant({
    matchOption: (el) => el.classList.contains(optionClassNames.root)
  });
  const comboboxState = useComboboxBaseState({
    ...props,
    onOptionSelect: useEventCallback((event, data) => {
      var _props_onOptionSelect;
      return (_props_onOptionSelect = props.onOptionSelect) === null || _props_onOptionSelect === void 0 ? void 0 : _props_onOptionSelect.call(props, event, {
        selectedOptions: data.selectedOptions,
        value: data.optionValue,
        type: event.type,
        event
      });
    }),
    onOpenChange: useEventCallback((event, data) => {
      var _props_onOpenChange;
      return (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, event, {
        ...data,
        type: event.type,
        event
      });
    }),
    activeDescendantController,
    editable: true,
    multiselect: true,
    size: "medium"
  });
  const { trigger, popover } = childrenToTriggerAndPopover(props.children, noPopover);
  return {
    activeDescendantController,
    components: {},
    trigger,
    popover: comboboxState.open || comboboxState.hasFocus ? popover : void 0,
    popoverId,
    noPopover,
    disabled: comboboxState.disabled,
    triggerRef: useMergedRefs(triggerInnerRef, activeParentRef),
    popoverRef: useMergedRefs(listboxRef, containerRef),
    secondaryActionRef,
    tagPickerGroupRef,
    targetRef,
    size: size3,
    inline: inline2,
    open: comboboxState.open,
    mountNode: comboboxState.mountNode,
    onOptionClick: useEventCallback((event) => {
      comboboxState.onOptionClick(event);
      comboboxState.setOpen(event, false);
    }),
    appearance: comboboxState.appearance,
    clearSelection: comboboxState.clearSelection,
    getOptionById: comboboxState.getOptionById,
    getOptionsMatchingValue: comboboxState.getOptionsMatchingValue,
    registerOption: comboboxState.registerOption,
    selectedOptions: comboboxState.selectedOptions,
    selectOption: useEventCallback((event, data) => {
      if (comboboxState.selectedOptions.includes(data.value) && !elementContains(tagPickerGroupRef.current, event.target)) {
        var _props_onOptionSelect;
        (_props_onOptionSelect = props.onOptionSelect) === null || _props_onOptionSelect === void 0 ? void 0 : _props_onOptionSelect.call(props, event, {
          selectedOptions: comboboxState.selectedOptions,
          value: data.value,
          type: event.type,
          event
        });
        return;
      }
      comboboxState.selectOption(event, data);
    }),
    setHasFocus: comboboxState.setHasFocus,
    setOpen: comboboxState.setOpen,
    setValue: comboboxState.setValue,
    value: comboboxState.value
  };
};
var childrenToTriggerAndPopover = (children2, noPopover) => {
  const childrenArray = React551.Children.toArray(children2);
  if (true) {
    if (childrenArray.length === 0) {
      console.warn("TagPicker must contain at least one child");
    }
    if (childrenArray.length > 2) {
      console.warn("TagPicker must contain at most two children");
    }
  }
  if (noPopover) {
    return {
      trigger: childrenArray[0]
    };
  }
  let trigger = void 0;
  let popover = void 0;
  if (childrenArray.length === 2) {
    trigger = childrenArray[0];
    popover = childrenArray[1];
  } else if (childrenArray.length === 1) {
    popover = childrenArray[0];
  }
  return {
    trigger,
    popover
  };
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/renderTagPicker.js
var React553 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/contexts/TagPickerContext.js
var React552 = __toESM(require_react());
var tagPickerContextDefaultValue = {
  triggerRef: React552.createRef(),
  popoverRef: React552.createRef(),
  targetRef: React552.createRef(),
  tagPickerGroupRef: React552.createRef(),
  secondaryActionRef: React552.createRef(),
  open: false,
  clearSelection: () => null,
  getOptionById: () => void 0,
  selectedOptions: [],
  selectOption: () => null,
  setHasFocus: () => null,
  setOpen: () => null,
  setValue: () => null,
  value: void 0,
  popoverId: "",
  size: "medium",
  appearance: "outline",
  disabled: false
};
var TagPickerContext = createContext13(void 0);
var TagPickerContextProvider = TagPickerContext.Provider;
var useTagPickerContext_unstable = (selector) => useContextSelector(TagPickerContext, (ctx = tagPickerContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/renderTagPicker.js
var renderTagPicker_unstable = (state, contexts) => {
  assertSlots(state);
  return React553.createElement(TagPickerContextProvider, {
    value: contexts.picker
  }, React553.createElement(ActiveDescendantContextProvider, {
    value: contexts.activeDescendant
  }, React553.createElement(ListboxProvider, {
    value: contexts.listbox
  }, state.trigger, state.inline ? state.popover : React553.createElement(Portal, {
    mountNode: state.mountNode
  }, state.popover))));
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/useTagPickerContextValues.js
var React554 = __toESM(require_react());
function useTagPickerContextValues(state) {
  const { onOptionClick, registerOption, selectedOptions, selectOption, value, triggerRef, secondaryActionRef, tagPickerGroupRef, targetRef, size: size3, setValue, setOpen, setHasFocus, popoverRef, appearance, clearSelection, getOptionById, getOptionsMatchingValue, open, popoverId, disabled, noPopover } = state;
  return {
    activeDescendant: React554.useMemo(() => ({
      controller: state.activeDescendantController
    }), [
      state.activeDescendantController
    ]),
    listbox: {
      onOptionClick,
      registerOption,
      getOptionById,
      getOptionsMatchingValue,
      selectedOptions,
      selectOption,
      focusVisible: false,
      setActiveOption: noop13
    },
    picker: {
      value,
      triggerRef,
      targetRef,
      secondaryActionRef,
      tagPickerGroupRef,
      size: size3,
      setValue,
      setOpen,
      setHasFocus,
      selectOption,
      popoverRef,
      selectedOptions,
      appearance,
      clearSelection,
      getOptionById,
      open,
      popoverId,
      disabled,
      noPopover
    }
  };
}
var noop13 = () => {
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/TagPicker.js
var TagPicker = React555.memo((props) => {
  const state = useTagPicker_unstable(props);
  const contextValues = useTagPickerContextValues(state);
  return renderTagPicker_unstable(state, contextValues);
});
TagPicker.displayName = "TagPicker";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/TagPickerInput.js
var React557 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/useTagPickerInput.js
var React556 = __toESM(require_react());
var ReactDOM6 = __toESM(require_react_dom());

// node_modules/@fluentui/react-tag-picker/lib/utils/tokens.js
var tagPickerInputCSSRules = {
  width: "--fluent-TagPickerInput__width"
};
var tagPickerInputTokens = {
  width: `var(${tagPickerInputCSSRules.width}, 0)`
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/useTagPickerInput.js
var useTagPickerInput_unstable = (propsArg, ref) => {
  const props = useFieldControlProps_unstable(propsArg, {
    supportsLabelFor: true,
    supportsRequired: true,
    supportsSize: true
  });
  const { controller: activeDescendantController } = useActiveDescendantContext();
  const size3 = useTagPickerContext_unstable((ctx) => ctx.size);
  const contextDisabled = useTagPickerContext_unstable((ctx) => ctx.disabled);
  const tagPickerGroupRef = useTagPickerContext_unstable((ctx) => ctx.tagPickerGroupRef);
  const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
  const selectedOptions = useTagPickerContext_unstable((ctx) => ctx.selectedOptions);
  const setValue = useTagPickerContext_unstable((ctx) => ctx.setValue);
  const setOpen = useTagPickerContext_unstable((ctx) => ctx.setOpen);
  const setHasFocus = useTagPickerContext_unstable((ctx) => ctx.setHasFocus);
  const clearSelection = useTagPickerContext_unstable((ctx) => ctx.clearSelection);
  const open = useTagPickerContext_unstable((ctx) => ctx.open);
  const popoverId = useTagPickerContext_unstable((ctx) => ctx.noPopover ? void 0 : ctx.popoverId);
  const selectOption = useTagPickerContext_unstable((ctx) => ctx.selectOption);
  const getOptionById = useTagPickerContext_unstable((ctx) => ctx.getOptionById);
  const contextValue = useTagPickerContext_unstable((ctx) => ctx.value);
  useIsomorphicLayoutEffect(() => {
    if (!triggerRef.current) {
      return;
    }
    setTagPickerInputStretchStyle(triggerRef.current);
  }, [
    selectedOptions,
    triggerRef
  ]);
  useIsomorphicLayoutEffect(() => {
    if (triggerRef.current) {
      const input = triggerRef.current;
      const cb = () => setTagPickerInputStretchStyle(input);
      input.addEventListener("input", cb);
      return () => {
        input.removeEventListener("input", cb);
      };
    }
  }, [
    triggerRef
  ]);
  const { value = contextValue, disabled = contextDisabled } = props;
  const { findLastFocusable } = useFocusFinders();
  const isTypingRef = React556.useRef(false);
  const root = useInputTriggerSlot({
    type: "text",
    value: value !== null && value !== void 0 ? value : "",
    "aria-controls": open ? popoverId : void 0,
    disabled,
    ...getIntrinsicElementProps("input", props),
    onKeyDown: useEventCallback((event) => {
      var _props_onKeyDown;
      (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, event);
      if ((event.key === ArrowLeft || event.key === Backspace) && event.currentTarget.selectionStart === 0 && event.currentTarget.selectionEnd === 0 && tagPickerGroupRef.current) {
        var _findLastFocusable;
        (_findLastFocusable = findLastFocusable(tagPickerGroupRef.current)) === null || _findLastFocusable === void 0 ? void 0 : _findLastFocusable.focus();
      } else if (event.key === Space) {
        if (open && !isTypingRef.current) {
          setOpen(event, false);
        }
      } else if (event.key === Enter) {
        if (open) {
          ReactDOM6.unstable_batchedUpdates(() => {
            setValue(void 0);
            setOpen(event, false);
          });
        } else {
          setOpen(event, true);
        }
      }
      isTypingRef.current = event.key.length === 1 && event.code !== Space && !event.altKey && !event.ctrlKey && !event.metaKey;
    })
  }, useMergedRefs(triggerRef, ref), {
    activeDescendantController,
    freeform: false,
    state: {
      clearSelection,
      getOptionById,
      open,
      selectedOptions,
      selectOption,
      setHasFocus,
      setOpen,
      setValue,
      multiselect: true,
      value: props.value
    }
  });
  const state = {
    components: {
      root: "input"
    },
    root,
    disabled,
    size: size3
  };
  return state;
};
var setTagPickerInputStretchStyle = (input) => {
  input.style.removeProperty(tagPickerInputCSSRules.width);
  if (input.scrollWidth > input.offsetWidth + 1) {
    input.style.setProperty(tagPickerInputCSSRules.width, "100%");
  } else {
    input.style.removeProperty(tagPickerInputCSSRules.width);
  }
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/renderTagPickerInput.js
var renderTagPickerInput_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/useTagPickerInputStyles.styles.js
var tagPickerInputClassNames = {
  root: "fui-TagPickerInput"
};
var useBaseStyle = __resetStyles("r1hdk6fw", null, [".r1hdk6fw{background-color:var(--colorTransparentBackground);color:var(--colorNeutralForeground1);font-family:var(--fontFamilyBase);box-sizing:border-box;border:none;min-width:24px;max-width:100%;width:var(--fluent-TagPickerInput__width, 0);flex-grow:1;}", ".r1hdk6fw:focus{outline-style:none;}", ".r1hdk6fw::-webkit-input-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r1hdk6fw::-moz-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r1hdk6fw::placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r1hdk6fw::after{visibility:hidden;white-space:pre-wrap;}"]);
var useStyles76 = __styles2({
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fa2pw7h"
  },
  large: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "ft37c3"
  },
  "extra-large": {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f3abo53"
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    De3pzq: "f1c21dwh",
    Bceei9c: "fdrzuqr",
    yvdlaj: "fahhnxm"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".fa2pw7h{padding:var(--spacingVerticalSNudge) 0 var(--spacingVerticalSNudge) 0;}", {
    p: -1
  }], [".ft37c3{padding:var(--spacingVerticalMNudge) 0 var(--spacingVerticalMNudge) 0;}", {
    p: -1
  }], [".f3abo53{padding:var(--spacingVerticalM) 0 var(--spacingVerticalM) 0;}", {
    p: -1
  }], ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fdrzuqr{cursor:not-allowed;}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"]
});
var useTagPickerInputStyles_unstable = (state) => {
  "use no memo";
  const baseStyle = useBaseStyle();
  const styles = useStyles76();
  state.root.className = mergeClasses(tagPickerInputClassNames.root, baseStyle, styles[state.size], state.disabled && styles.disabled, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/TagPickerInput.js
var TagPickerInput = React557.forwardRef((props, ref) => {
  const state = useTagPickerInput_unstable(props, ref);
  useTagPickerInputStyles_unstable(state);
  useCustomStyleHook("useTagPickerInputStyles_unstable")(state);
  return renderTagPickerInput_unstable(state);
});
TagPickerInput.displayName = "TagPickerInput";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/TagPickerList.js
var React559 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/useTagPickerList.js
var React558 = __toESM(require_react());
var useTagPickerList_unstable = (props, ref) => {
  const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
  const popoverRef = useTagPickerContext_unstable((ctx) => ctx.popoverRef);
  const popoverId = useTagPickerContext_unstable((ctx) => ctx.popoverId);
  const open = useTagPickerContext_unstable((ctx) => ctx.open);
  return {
    open,
    components: {
      root: Listbox
    },
    root: slot_exports.always({
      ...useListboxSlot(props, useMergedRefs(popoverRef, ref), {
        state: {
          multiselect: true
        },
        triggerRef,
        defaultProps: {
          id: popoverId
        }
      }),
      role: "listbox"
    }, {
      elementType: Listbox
    })
  };
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/renderTagPickerList.js
var renderTagPickerList_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/useTagPickerListStyles.styles.js
var tagPickerListClassNames = {
  root: "fui-TagPickerList"
};
var useStyles77 = __styles2({
  root: {
    E5pizo: "f1hg901r",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bxyxcbc: "fmmk62d",
    B7ck84d: "f1ewtqcl"
  },
  collapsed: {
    mc9l5x: "fjseox"
  }
}, {
  d: [".f1hg901r{box-shadow:var(--shadow16);}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fmmk62d{max-height:80vh;}", ".f1ewtqcl{box-sizing:border-box;}", ".fjseox{display:none;}"]
});
var useTagPickerListStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles77();
  state.root.className = mergeClasses(tagPickerListClassNames.root, styles.root, !state.open && styles.collapsed, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/TagPickerList.js
var TagPickerList = React559.forwardRef((props, ref) => {
  const state = useTagPickerList_unstable(props, ref);
  useTagPickerListStyles_unstable(state);
  useCustomStyleHook("useTagPickerListStyles_unstable")(state);
  return renderTagPickerList_unstable(state);
});
TagPickerList.displayName = "TagPickerList";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/TagPickerButton.js
var React561 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/useTagPickerButton.js
var React560 = __toESM(require_react());
var useTagPickerButton_unstable = (props, ref) => {
  const { controller: activeDescendantController } = useActiveDescendantContext();
  const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
  const open = useTagPickerContext_unstable((ctx) => ctx.open);
  const value = useTagPickerContext_unstable((ctx) => ctx.value);
  const hasSelectedOption = useTagPickerContext_unstable((ctx) => ctx.selectedOptions.length > 0);
  const popoverId = useTagPickerContext_unstable((ctx) => ctx.popoverId);
  const getOptionById = useTagPickerContext_unstable((ctx) => ctx.getOptionById);
  const selectOption = useTagPickerContext_unstable((ctx) => ctx.selectOption);
  const setHasFocus = useTagPickerContext_unstable((ctx) => ctx.setHasFocus);
  const setOpen = useTagPickerContext_unstable((ctx) => ctx.setOpen);
  const root = useButtonTriggerSlot(props, triggerRef, {
    activeDescendantController,
    defaultProps: {
      type: "button",
      tabIndex: 0,
      children: value || // @ts-expect-error - FIXME: TS2339: Property 'placeholder' does not exist on type 'TagPickerButtonProps'
      props.placeholder,
      "aria-controls": open ? popoverId : void 0,
      ref
    },
    state: {
      getOptionById,
      open,
      selectOption,
      setHasFocus,
      setOpen,
      multiselect: true
    }
  });
  const size3 = useTagPickerContext_unstable((ctx) => ctx.size);
  const state = {
    components: {
      root: "button"
    },
    root,
    size: size3,
    hasSelectedOption
  };
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/renderTagPickerButton.js
var renderTagPickerButton_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/useTagPickerButtonStyles.styles.js
var tagPickerButtonClassNames = {
  root: "fui-TagPickerButton"
};
var useStyles78 = __styles2({
  button: {
    Bt984gj: "f122n59",
    sshi5w: "f1nxs5xn",
    De3pzq: "f1c21dwh",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    B7ck84d: "f1ewtqcl",
    sj55zd: "f19n0e5",
    i8kkvl: "f14mj54c",
    Bceei9c: "f1k6fduh",
    Bahqtrf: "fk6fouc",
    fsow6f: ["f1o700av", "fes3tcz"],
    Bh6795r: "fqerorx",
    Brovlpu: "ftqa4ok"
  },
  placeholder: {
    sj55zd: "fxc4j92"
  },
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["fye6m5k", "f3cq2dl"]
  },
  large: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f14ev680", "f58uxzw"]
  },
  "extra-large": {
    i8kkvl: "f1rjii52",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f139mn7i", "f1v3q0m"]
  },
  outline: {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: "f1c1zstj",
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fhz96rm"
  },
  outlineInteractive: {
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "flmw63s",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    B6oc9vd: "fvs00aa",
    ak43y8: ["f1assf6x", "f4ruux4"],
    wmxk5l: "fqhmt4z",
    B50zh58: ["f4ruux4", "f1assf6x"]
  },
  underline: {
    De3pzq: "f1c21dwh",
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f9ez7ne",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fs2rfia"
  },
  "filled-darker": {
    De3pzq: "f16xq7d1",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fs2rfia"
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  },
  invalidUnderline: {
    hhx65j: "f1fgmyf4"
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    Bjwas2f: "fg455y9",
    Bn1d65q: ["f1rvyvqg", "f14g86mu"],
    Bxeuatn: "f1cwzwz",
    n51gp8: ["f14g86mu", "f1rvyvqg"]
  },
  disabledText: {
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr"
  },
  hidden: {
    mc9l5x: "fjseox"
  },
  visuallyHidden: {
    Bh84pgu: "f1ekcaio",
    Bqenvij: "f1mpe4l3",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1jlpb2r",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1c5fvqg",
    a9b677: "frkrog8",
    qhf8xq: "f1euv43f"
  }
}, {
  d: [".f122n59{align-items:center;}", ".f1nxs5xn{min-height:32px;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".f3bhgqh{border:none;}", {
    p: -2
  }], ".f1ewtqcl{box-sizing:border-box;}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f14mj54c{column-gap:var(--spacingHorizontalXXS);}", ".f1k6fduh{cursor:pointer;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".fqerorx{flex-grow:1;}", ".fxc4j92{color:var(--colorNeutralForeground4);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", [".fye6m5k{padding:3px var(--spacingHorizontalSNudge) 3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f3cq2dl{padding:3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS)) 3px var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f14ev680{padding:5px var(--spacingHorizontalMNudge) 5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f58uxzw{padding:5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS)) 5px var(--spacingHorizontalMNudge);}", {
    p: -1
  }], ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f139mn7i{padding:7px var(--spacingHorizontalM) 7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", {
    p: -1
  }], [".f1v3q0m{padding:7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge)) 7px var(--spacingHorizontalM);}", {
    p: -1
  }], ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", {
    p: -2
  }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", [".f9ez7ne{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", {
    p: -1
  }], [".fokr779{border-radius:0;}", {
    p: -1
  }], [".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", [".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", {
    p: -2
  }], ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fjseox{display:none;}", ".f1ekcaio{clip:rect(0px, 0px, 0px, 0px);}", ".f1mpe4l3{height:1px;}", [".f1jlpb2r{margin:-1px;}", {
    p: -1
  }], [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], [".f1c5fvqg{padding:0px;}", {
    p: -1
  }], ".frkrog8{width:1px;}", ".f1euv43f{position:absolute;}"],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".flmw63s:hover{border-bottom-color:var(--colorNeutralStrokeAccessible);}"],
  a: [".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".fqhmt4z:active{border-bottom-color:var(--colorNeutralStrokeAccessible);}"],
  m: [["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useTagPickerButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles78();
  state.root.className = mergeClasses(tagPickerButtonClassNames.root, styles.button, styles[state.size], state.hasSelectedOption && styles.visuallyHidden, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/TagPickerButton.js
var TagPickerButton = React561.forwardRef((props, ref) => {
  const state = useTagPickerButton_unstable(props, ref);
  useTagPickerButtonStyles_unstable(state);
  useCustomStyleHook("useTagPickerButtonStyles_unstable")(state);
  return renderTagPickerButton_unstable(state);
});
TagPickerButton.displayName = "TagPickerButton";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/TagPickerControl.js
var React565 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/useTagPickerControl.js
var React564 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/utils/useResizeObserverRef.js
var React562 = __toESM(require_react());
var useResizeObserverRef = (callback) => {
  const { targetDocument } = useFluent();
  const [observer] = React562.useState(() => {
    var _targetDocument_defaultView;
    const ResizeObserverConstructor = targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.ResizeObserver;
    if (ResizeObserverConstructor) {
      return new ResizeObserverConstructor(callback);
    }
  });
  const ref = React562.useCallback((element) => {
    if (element) {
      observer === null || observer === void 0 ? void 0 : observer.observe(element);
    } else {
      observer === null || observer === void 0 ? void 0 : observer.disconnect();
    }
  }, [
    observer
  ]);
  return ref;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/useTagPickerControlStyles.styles.js
var tagPickerControlClassNames = {
  root: "fui-TagPickerControl",
  expandIcon: "fui-TagPickerControl__expandIcon",
  secondaryAction: "fui-TagPickerControl__secondaryAction",
  aside: "fui-TagPickerControl__aside"
};
var tagPickerControlAsideWidthToken = "--fui-TagPickerControl-aside-width";
var useStyles79 = __styles2({
  root: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    z189sj: ["f1d8q41i", "f8lqu5g"],
    uwmqm3: ["f1uw59to", "fw5db7e"],
    Bt984gj: "f122n59",
    i8kkvl: "f14mj54c",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "f22iagw",
    Bf4jedk: "f1exfvgq",
    qhf8xq: "f10pi13n",
    Eh141a: "fni485r",
    Bbr2w1p: "f14a1fxs",
    Bduesf4: "f3e99gv",
    Bpq79vn: "fhljsf7",
    li1rpt: "f1gw3sf2",
    Bsft5z2: "f13zj6fq",
    E3zdtr: "f1mdlcz9",
    Eqx8gd: ["f1a7op3", "f1cjjd47"],
    By385i5: "f1gboi2j",
    B1piin3: ["f1cjjd47", "f1a7op3"],
    Dlnsje: "f145g4dw",
    d9w3h3: ["f1kp91vd", "f1ibwz09"],
    B3778ie: ["f1ibwz09", "f1kp91vd"],
    B1q35kw: 0,
    Bw17bha: 0,
    Bcgy8vk: 0,
    Bjuhk93: "f1mnjydx",
    Gjdm7m: "f13evtba",
    b1kco5: "f1yk9hq",
    Ba2ppi3: "fhwpy7i",
    F2fol1: "f14ee0xe",
    lck23g: "f1xhbsuh",
    df92cz: "fv8e3ye",
    I188md: "ftb5wc6",
    umuwi5: "fjw5xc1",
    Blcqepd: "f1xdyd5c",
    nplu4u: "fatpbeo",
    Bioka5o: "fb7uyps",
    H713fs: "f1cmft4k",
    B9ooomg: "f1x58t8o",
    Bercvud: "f1ibeo51"
  },
  listbox: {
    E5pizo: "f1hg901r",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bxyxcbc: "fmmk62d",
    B7ck84d: "f1ewtqcl"
  },
  listboxCollapsed: {
    mc9l5x: "fjseox"
  },
  medium: {
    sshi5w: "f1nxs5xn"
  },
  large: {
    sshi5w: "f1w5jphr"
  },
  "extra-large": {
    sshi5w: "f5pgtk9"
  },
  outline: {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: "f1c1zstj",
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fhz96rm"
  },
  outlineInteractive: {
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "f1l4zc64",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    B6oc9vd: "fvs00aa",
    ak43y8: ["f1assf6x", "f4ruux4"],
    wmxk5l: "f1z0osm6",
    B50zh58: ["f4ruux4", "f1assf6x"],
    Bvq3b66: "f1b473iu",
    Brahy3i: ["f381qr8", "ft4skwv"],
    zoxjo1: "f1qzcrsd",
    an54nd: ["ft4skwv", "f381qr8"]
  },
  underline: {
    De3pzq: "f1c21dwh",
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f9ez7ne",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w"
  },
  "filled-darker": {
    De3pzq: "f16xq7d1",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w"
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  },
  invalidUnderline: {
    hhx65j: "f1fgmyf4"
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    Bjwas2f: "fg455y9",
    Bn1d65q: ["f1rvyvqg", "f14g86mu"],
    Bxeuatn: "f1cwzwz",
    n51gp8: ["f14g86mu", "f1rvyvqg"]
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1d8q41i{padding-right:calc(var(--spacingHorizontalM) + var(--fui-TagPickerControl-aside-width, 0px));}", ".f8lqu5g{padding-left:calc(var(--spacingHorizontalM) + var(--fui-TagPickerControl-aside-width, 0px));}", ".f1uw59to{padding-left:var(--spacingHorizontalM);}", ".fw5db7e{padding-right:var(--spacingHorizontalM);}", ".f122n59{align-items:center;}", ".f14mj54c{column-gap:var(--spacingHorizontalXXS);}", ".f1ewtqcl{box-sizing:border-box;}", ".f22iagw{display:flex;}", ".f1exfvgq{min-width:250px;}", ".f10pi13n{position:relative;}", ".fni485r{flex-wrap:wrap;}", ".f1gw3sf2::after{box-sizing:border-box;}", '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1a7op3::after{left:-1px;}", ".f1cjjd47::after{right:-1px;}", ".f1gboi2j::after{bottom:-1px;}", ".f145g4dw::after{height:max(2px, var(--borderRadiusMedium));}", ".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}", [".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", {
    p: -1
  }], ".f13evtba::after{clip-path:inset(calc(100% - 2px) 0 0 0);}", ".f1yk9hq::after{transform:scaleX(0);}", ".fhwpy7i::after{transition-property:transform;}", ".f14ee0xe::after{transition-duration:var(--durationUltraFast);}", ".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}", ".f1hg901r{box-shadow:var(--shadow16);}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fmmk62d{max-height:80vh;}", ".fjseox{display:none;}", ".f1nxs5xn{min-height:32px;}", ".f1w5jphr{min-height:40px;}", ".f5pgtk9{min-height:44px;}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", {
    p: -2
  }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".f9ez7ne{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", {
    p: -1
  }], [".fokr779{border-radius:0;}", {
    p: -1
  }], [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"],
  w: [".f14a1fxs:focus-within{outline-width:2px;}", ".f3e99gv:focus-within{outline-style:solid;}", ".fhljsf7:focus-within{outline-color:transparent;}", ".fjw5xc1:focus-within::after{transform:scaleX(1);}", ".f1xdyd5c:focus-within::after{transition-property:transform;}", ".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}", ".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}", ".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".f1b473iu:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f381qr8:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}", ".ft4skwv:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1qzcrsd:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.fv8e3ye::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.ftb5wc6::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1cmft4k:focus-within::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1x58t8o:focus-within::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"],
  a: [".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"]
});
var useAsideStyles = __styles2({
  root: {
    mc9l5x: "f22iagw",
    qhf8xq: "f1euv43f",
    Bhzewxz: "f15twtuk",
    j35jbq: ["f8b87gs", "fedtrts"],
    Bqenvij: "f1l02sjl",
    Bceei9c: "f113hnb5"
  },
  medium: {
    sshi5w: "f1nxs5xn"
  },
  large: {
    sshi5w: "f1w5jphr"
  },
  "extra-large": {
    sshi5w: "f5pgtk9"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1euv43f{position:absolute;}", ".f15twtuk{top:0;}", ".f8b87gs{right:var(--spacingHorizontalM);}", ".fedtrts{left:var(--spacingHorizontalM);}", ".f1l02sjl{height:100%;}", ".f113hnb5{cursor:text;}", ".f1nxs5xn{min-height:32px;}", ".f1w5jphr{min-height:40px;}", ".f5pgtk9{min-height:44px;}"]
});
var useIconStyles11 = __styles2({
  icon: {
    B7ck84d: "f1ewtqcl",
    sj55zd: "fxkbij4",
    Bceei9c: "f1k6fduh",
    mc9l5x: "f22iagw",
    Brf1p80: "f4d9j23",
    Bt984gj: "f122n59",
    qb2dma: "fjgzulp",
    Be2twd7: "f1pp30po",
    Bo70h7d: "fvc9v3g"
  },
  medium: {
    Be2twd7: "f4ybsrx",
    Frg6f3: ["f1h9en5y", "f1xk557c"],
    sshi5w: "f1nxs5xn"
  },
  large: {
    Be2twd7: "fe5j1ua",
    Frg6f3: ["f1h9en5y", "f1xk557c"],
    sshi5w: "f1w5jphr"
  },
  "extra-large": {
    Be2twd7: "f1rt2boy",
    Frg6f3: ["f1t5qyk5", "f1ikr372"],
    sshi5w: "f5pgtk9"
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr"
  }
}, {
  d: [".f1ewtqcl{box-sizing:border-box;}", ".fxkbij4{color:var(--colorNeutralStrokeAccessible);}", ".f1k6fduh{cursor:pointer;}", ".f22iagw{display:flex;}", ".f4d9j23{justify-content:center;}", ".f122n59{align-items:center;}", ".fjgzulp{align-self:flex-start;}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".fvc9v3g svg{display:block;}", ".f4ybsrx{font-size:16px;}", ".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}", ".f1xk557c{margin-right:var(--spacingHorizontalXXS);}", ".f1nxs5xn{min-height:32px;}", ".fe5j1ua{font-size:20px;}", ".f1w5jphr{min-height:40px;}", ".f1rt2boy{font-size:24px;}", ".f1t5qyk5{margin-left:var(--spacingHorizontalSNudge);}", ".f1ikr372{margin-right:var(--spacingHorizontalSNudge);}", ".f5pgtk9{min-height:44px;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}"]
});
var useSecondaryActionStyles = __styles2({
  root: {
    mc9l5x: "f22iagw"
  }
}, {
  d: [".f22iagw{display:flex;}"]
});
var useTagPickerControlStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles79();
  const iconStyles = useIconStyles11();
  const asideStyles = useAsideStyles();
  const secondaryActionStyles = useSecondaryActionStyles();
  state.root.className = mergeClasses(tagPickerControlClassNames.root, styles.root, styles[state.size], styles[state.appearance], !state.disabled && state.appearance === "outline" && styles.outlineInteractive, state.invalid && state.appearance !== "underline" && styles.invalid, state.invalid && state.appearance === "underline" && styles.invalidUnderline, state.disabled && styles.disabled, state.root.className);
  if (state.aside) {
    state.aside.className = mergeClasses(tagPickerControlClassNames.aside, asideStyles.root, asideStyles[state.size], state.aside.className);
  }
  if (state.expandIcon) {
    state.expandIcon.className = mergeClasses(tagPickerControlClassNames.expandIcon, iconStyles.icon, iconStyles[state.size], state.disabled && iconStyles.disabled, state.expandIcon.className);
  }
  if (state.secondaryAction) {
    state.secondaryAction.className = mergeClasses(tagPickerControlClassNames.secondaryAction, secondaryActionStyles.root, state.secondaryAction.className);
  }
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/utils/useExpandLabel.js
var React563 = __toESM(require_react());
function useExpandLabel(options) {
  const { tagPickerId, state } = options;
  const { targetDocument } = useFluent();
  const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
  const expandIconRef = React563.useRef(null);
  const hasExpandIcon = !!state.expandIcon;
  const { "aria-label": expandIconAriaLabel, "aria-labelledby": expandIconAriaLabelledby, id: expandIconId } = state.expandIcon || {};
  const getExpandLabel = React563.useCallback((ariaLabel, ariaLabelledBy) => {
    let expandAriaLabel = void 0;
    let expandAriaLabelledBy = void 0;
    let expandId = void 0;
    if (hasExpandIcon) {
      const hasExpandLabel = expandIconAriaLabel || expandIconAriaLabelledby;
      const defaultOpenString = "Open";
      if (!hasExpandLabel) {
        if (ariaLabelledBy) {
          expandAriaLabel = defaultOpenString;
          expandId = expandIconId !== null && expandIconId !== void 0 ? expandIconId : `${tagPickerId}-chevron`;
          expandAriaLabelledBy = `${expandId} ${ariaLabelledBy}`;
        } else if (ariaLabel) {
          expandAriaLabel = `${defaultOpenString} ${ariaLabel}`;
        } else {
          expandAriaLabel = defaultOpenString;
        }
      }
    }
    return {
      expandAriaLabel,
      expandAriaLabelledBy,
      expandId
    };
  }, [
    expandIconAriaLabel,
    expandIconAriaLabelledby,
    expandIconId,
    hasExpandIcon,
    tagPickerId
  ]);
  const setExpandLabel = React563.useCallback(() => {
    var _triggerRef_current, _triggerRef_current1;
    const inputAriaLabel = (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.getAttribute("aria-label");
    const inputAriaLabelledBy = (_triggerRef_current1 = triggerRef.current) === null || _triggerRef_current1 === void 0 ? void 0 : _triggerRef_current1.getAttribute("aria-labelledby");
    const { expandAriaLabel, expandAriaLabelledBy, expandId } = getExpandLabel(inputAriaLabel, inputAriaLabelledBy);
    if (expandAriaLabelledBy) {
      var _expandIconRef_current;
      (_expandIconRef_current = expandIconRef.current) === null || _expandIconRef_current === void 0 ? void 0 : _expandIconRef_current.setAttribute("aria-labelledby", expandAriaLabelledBy);
    }
    if (expandAriaLabel) {
      var _expandIconRef_current1;
      (_expandIconRef_current1 = expandIconRef.current) === null || _expandIconRef_current1 === void 0 ? void 0 : _expandIconRef_current1.setAttribute("aria-label", expandAriaLabel);
    }
    if (expandId) {
      var _expandIconRef_current2;
      (_expandIconRef_current2 = expandIconRef.current) === null || _expandIconRef_current2 === void 0 ? void 0 : _expandIconRef_current2.setAttribute("id", expandId);
    }
  }, [
    getExpandLabel,
    triggerRef
  ]);
  React563.useEffect(() => {
    const hasExpandLabel = expandIconAriaLabel || expandIconAriaLabelledby;
    if (!(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) || !triggerRef.current || !hasExpandIcon || hasExpandLabel) {
      return;
    }
    const win = targetDocument.defaultView;
    setExpandLabel();
    const observer = new win.MutationObserver(setExpandLabel);
    observer.observe(triggerRef.current, {
      attributes: true,
      attributeFilter: [
        "aria-label",
        "aria-labelledby"
      ]
    });
    return () => observer.disconnect();
  }, [
    getExpandLabel,
    setExpandLabel,
    expandIconAriaLabel,
    expandIconAriaLabelledby,
    hasExpandIcon,
    tagPickerId,
    triggerRef,
    targetDocument
  ]);
  return expandIconRef;
}

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/useTagPickerControl.js
var useTagPickerControl_unstable = (props, ref) => {
  var _useFieldContext_unstable;
  const targetRef = useTagPickerContext_unstable((ctx) => ctx.targetRef);
  const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
  const tagPickerGroupRef = useTagPickerContext_unstable((ctx) => ctx.tagPickerGroupRef);
  const open = useTagPickerContext_unstable((ctx) => ctx.open);
  const popoverId = useTagPickerContext_unstable((ctx) => ctx.popoverId);
  const setOpen = useTagPickerContext_unstable((ctx) => ctx.setOpen);
  const secondaryInnerActionRef = useTagPickerContext_unstable((ctx) => ctx.secondaryActionRef);
  const size3 = useTagPickerContext_unstable((ctx) => ctx.size);
  const appearance = useTagPickerContext_unstable((ctx) => ctx.appearance);
  const disabled = useTagPickerContext_unstable((ctx) => ctx.disabled);
  const invalid = ((_useFieldContext_unstable = useFieldContext_unstable()) === null || _useFieldContext_unstable === void 0 ? void 0 : _useFieldContext_unstable.validationState) === "error";
  const noPopover = useTagPickerContext_unstable((ctx) => {
    var _ctx_noPopover;
    return (_ctx_noPopover = ctx.noPopover) !== null && _ctx_noPopover !== void 0 ? _ctx_noPopover : false;
  });
  const { targetDocument } = useFluent();
  const tagPickerId = useId2("tagPicker-");
  const rafIdRef = React564.useRef(null);
  const innerRef = React564.useRef(null);
  const expandIconRef = React564.useRef(null);
  const asideRef = React564.useRef(null);
  const secondaryAction = slot_exports.optional(props.secondaryAction, {
    elementType: "span"
  });
  const secondaryActionRef = useMergedRefs(secondaryInnerActionRef, secondaryAction === null || secondaryAction === void 0 ? void 0 : secondaryAction.ref);
  if (secondaryAction) {
    secondaryAction.ref = secondaryActionRef;
  }
  const expandIcon = slot_exports.optional(props.expandIcon, {
    renderByDefault: !noPopover,
    defaultProps: {
      "aria-expanded": open,
      "aria-disabled": disabled ? "true" : void 0,
      children: React564.createElement(ChevronDownRegular, null),
      role: "button"
    },
    elementType: "span"
  });
  const expandIconMergeRef = useMergedRefs(expandIcon === null || expandIcon === void 0 ? void 0 : expandIcon.ref, expandIconRef);
  if (expandIcon) {
    expandIcon.ref = expandIconMergeRef;
  }
  const observerRef = useResizeObserverRef(([entry]) => {
    const targetWindow = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
    if (targetWindow) {
      rafIdRef.current = targetWindow.requestAnimationFrame(() => {
        var _innerRef_current;
        (_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.style.setProperty(tagPickerControlAsideWidthToken, `${entry.contentRect.width}px`);
      });
    }
  });
  const aside = slot_exports.optional(void 0, {
    elementType: "span",
    renderByDefault: Boolean(secondaryAction || expandIcon),
    defaultProps: {
      ref: observerRef
    }
  });
  const mergedAsideRefs = useMergedRefs(asideRef, aside === null || aside === void 0 ? void 0 : aside.ref);
  if (aside) {
    aside.ref = mergedAsideRefs;
  }
  const handleMouseDown = useEventCallback((event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (elementContains(expandIconRef.current, event.target) || event.target === innerRef.current || event.target === tagPickerGroupRef.current || event.target === asideRef.current) {
      var _triggerRef_current;
      event.preventDefault();
      setOpen(event, !open);
      (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
    }
  });
  const state = {
    components: {
      root: "div",
      expandIcon: "span",
      secondaryAction: "span",
      aside: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, targetRef, innerRef),
      "aria-owns": open && !noPopover ? popoverId : void 0,
      ...props,
      onMouseDown: handleMouseDown
    }), {
      elementType: "div"
    }),
    aside,
    expandIcon,
    secondaryAction,
    size: size3,
    appearance,
    disabled,
    invalid
  };
  const expandIconLabelRef = useExpandLabel({
    tagPickerId,
    state
  });
  const expandIconLabelMergeRef = useMergedRefs(expandIcon === null || expandIcon === void 0 ? void 0 : expandIcon.ref, expandIconLabelRef);
  if (state.expandIcon) {
    state.expandIcon.ref = expandIconLabelMergeRef;
  }
  React564.useEffect(() => {
    if (rafIdRef.current && (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView)) {
      targetDocument.defaultView.cancelAnimationFrame(rafIdRef.current);
    }
  }, [
    targetDocument
  ]);
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/renderTagPickerControl.js
var renderTagPickerControl_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.root.children,
      state.aside && jsxs(state.aside, {
        children: [
          state.secondaryAction && jsx(state.secondaryAction, {}),
          state.expandIcon && jsx(state.expandIcon, {})
        ]
      })
    ]
  });
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/TagPickerControl.js
var TagPickerControl = React565.forwardRef((props, ref) => {
  const state = useTagPickerControl_unstable(props, ref);
  useTagPickerControlStyles_unstable(state);
  useCustomStyleHook("useTagPickerControlStyles_unstable")(state);
  return renderTagPickerControl_unstable(state);
});
TagPickerControl.displayName = "TagPickerControl";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/TagPickerOption.js
var React567 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/useTagPickerOption.js
var React566 = __toESM(require_react());
var useTagPickerOption_unstable = (props, ref) => {
  const optionState = useOption_unstable(props, ref);
  const state = {
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...optionState.components,
      media: "div",
      secondaryContent: "span"
    },
    media: slot_exports.optional(props.media, {
      elementType: "div"
    }),
    secondaryContent: slot_exports.optional(props.secondaryContent, {
      elementType: "span"
    }),
    root: slot_exports.always({
      ...optionState.root,
      role: "option",
      "aria-checked": props["aria-checked"]
    }, {
      elementType: "div"
    })
  };
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/renderTagPickerOption.js
var renderTagPickerOption_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.media && jsx(state.media, {}),
      state.root.children,
      state.secondaryContent && jsx(state.secondaryContent, {})
    ]
  });
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/useTagPickerOptionStyles.styles.js
var tagPickerOptionClassNames = {
  root: "fui-TagPickerOption",
  media: "fui-TagPickerOption__media",
  secondaryContent: "fui-TagPickerOption__secondaryContent"
};
var useRootBaseStyle2 = __resetStyles("r70qvj9", null, [".r70qvj9{display:flex;align-items:center;}"]);
var useRootStyles26 = __styles2({
  secondaryContent: {
    mc9l5x: "f13qh94s",
    Budl1dq: "fjxzuw"
  }
}, {
  d: [".f13qh94s{display:grid;}", ".fjxzuw{grid-template-columns:auto 1fr;}"]
});
var useSecondaryContentBaseStyle = __resetStyles("r131qrbm", null, [".r131qrbm{grid-column-start:2;grid-row-start:2;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
var useMediaBaseStyle = __resetStyles("rrip69g", null, [".rrip69g{grid-row-start:span 2;}"]);
var useTagPickerOptionStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyle = useRootBaseStyle2();
  const rootStyles = useRootStyles26();
  const secondaryContentBaseStyle = useSecondaryContentBaseStyle();
  const mediaBaseStyle = useMediaBaseStyle();
  state.root.className = mergeClasses(tagPickerOptionClassNames.root, rootBaseStyle, state.secondaryContent && rootStyles.secondaryContent, state.root.className);
  useOptionStyles_unstable({
    ...state,
    active: false,
    disabled: false,
    focusVisible: false,
    checkIcon: void 0,
    selected: false
  });
  if (state.media) {
    state.media.className = mergeClasses(tagPickerOptionClassNames.media, mediaBaseStyle, state.media.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(tagPickerOptionClassNames.secondaryContent, secondaryContentBaseStyle, state.secondaryContent.className);
  }
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/TagPickerOption.js
var TagPickerOption = React567.forwardRef((props, ref) => {
  const state = useTagPickerOption_unstable(props, ref);
  useTagPickerOptionStyles_unstable(state);
  useCustomStyleHook("useTagPickerOptionStyles_unstable")(state);
  return renderTagPickerOption_unstable(state);
});
TagPickerOption.displayName = "TagPickerOption";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/TagPickerGroup.js
var React569 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/useTagPickerGroup.js
var React568 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/utils/tagPicker2Tag.js
function tagPickerSizeToTagSize(size3) {
  switch (size3) {
    case "medium":
      return "extra-small";
    case "large":
      return "small";
    case "extra-large":
      return "medium";
    default:
      return "extra-small";
  }
}
function tagSizeToTagPickerSize(size3) {
  switch (size3) {
    case "extra-small":
      return "medium";
    case "small":
      return "large";
    case "medium":
      return "extra-large";
    default:
      return "medium";
  }
}
function tagPickerAppearanceToTagAppearance(appearance) {
  switch (appearance) {
    case "filled-darker":
      return "outline";
    default:
      return "filled";
  }
}

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/useTagPickerGroup.js
var useTagPickerGroup_unstable = (props, ref) => {
  const hasSelectedOptions = useTagPickerContext_unstable((ctx) => ctx.selectedOptions.length > 0);
  const hasOneSelectedOption = useTagPickerContext_unstable((ctx) => ctx.selectedOptions.length === 1);
  const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
  const tagPickerGroupRef = useTagPickerContext_unstable((ctx) => ctx.tagPickerGroupRef);
  const selectOption = useTagPickerContext_unstable((ctx) => ctx.selectOption);
  const size3 = useTagPickerContext_unstable((ctx) => tagPickerSizeToTagSize(ctx.size));
  const appearance = useTagPickerContext_unstable((ctx) => ctx.appearance);
  const disabled = useTagPickerContext_unstable((ctx) => ctx.disabled);
  const arrowNavigationProps = useArrowNavigationGroup({
    circular: false,
    axis: "both",
    memorizeCurrent: true
  });
  const state = useTagGroup_unstable({
    role: "listbox",
    disabled,
    ...props,
    ...arrowNavigationProps,
    size: size3,
    appearance: tagPickerAppearanceToTagAppearance(appearance),
    dismissible: true,
    onKeyDown: useEventCallback((event) => {
      var _props_onKeyDown;
      (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, event);
      if (isHTMLElement(event.target) && event.key === ArrowRight) {
        var _triggerRef_current;
        (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
      }
    }),
    onDismiss: useEventCallback((event, data) => {
      selectOption(event, {
        value: data.value,
        // These values no longer exist because the option has unregistered itself
        // for the purposes of selection - these values aren't actually used
        id: "ERROR_DO_NOT_USE",
        text: "ERROR_DO_NOT_USE"
      });
      if (hasOneSelectedOption && !event.isDefaultPrevented()) {
        var _triggerRef_current;
        (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
      }
    })
  }, useMergedRefs(ref, tagPickerGroupRef));
  return {
    ...state,
    hasSelectedOptions
  };
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/renderTagPickerGroup.js
function renderTagPickerGroup_unstable(state, contexts) {
  if (!state.hasSelectedOptions) {
    return null;
  }
  return renderTagGroup_unstable(state, contexts);
}

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/useTagPickerGroupStyles.styles.js
var tagPickerGroupClassNames = {
  root: "fui-TagPickerGroup"
};
var useStyles80 = __styles2({
  root: {
    Eh141a: "fni485r",
    B7ck84d: "f1ewtqcl",
    Bceei9c: "f113hnb5"
  },
  medium: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fa2pw7h",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "fkln5zr"
  },
  large: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fc0zr7g",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1eyhf9v"
  },
  "extra-large": {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fc0zr7g",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1eyhf9v"
  }
}, {
  d: [".fni485r{flex-wrap:wrap;}", ".f1ewtqcl{box-sizing:border-box;}", ".f113hnb5{cursor:text;}", [".fa2pw7h{padding:var(--spacingVerticalSNudge) 0 var(--spacingVerticalSNudge) 0;}", {
    p: -1
  }], [".fkln5zr{gap:var(--spacingHorizontalXS);}", {
    p: -1
  }], [".fc0zr7g{padding:var(--spacingVerticalS) 0 var(--spacingVerticalS) 0;}", {
    p: -1
  }], [".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", {
    p: -1
  }], [".fc0zr7g{padding:var(--spacingVerticalS) 0 var(--spacingVerticalS) 0;}", {
    p: -1
  }], [".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", {
    p: -1
  }]]
});
var useTagPickerGroupStyles_unstable = (state) => {
  "use no memo";
  useTagGroupStyles_unstable(state);
  const styles = useStyles80();
  state.root.className = mergeClasses(tagPickerGroupClassNames.root, styles[tagSizeToTagPickerSize(state.size)], styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/TagPickerGroup.js
var TagPickerGroup = React569.forwardRef((props, ref) => {
  const state = useTagPickerGroup_unstable(props, ref);
  useTagPickerGroupStyles_unstable(state);
  useCustomStyleHook("useTagPickerGroupStyles_unstable")(state);
  return renderTagPickerGroup_unstable(state, useTagGroupContextValues_unstable(state));
});
TagPickerGroup.displayName = "TagPickerGroup";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/TagPickerOptionGroup.js
var React571 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/useTagPickerOptionGroup.js
var React570 = __toESM(require_react());
var useTagPickerOptionGroup = useOptionGroup_unstable;

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/renderTagPickerOptionGroup.js
var renderTagPickerOptionGroup = renderOptionGroup_unstable;

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/useTagPickerOptionGroupStyles.styles.js
var tagPickerOptionGroupClassNames = {
  root: "fui-TagPickerOptionGroup",
  label: "fui-TagPickerOptionGroup__label"
};
var useTagPickerOptionGroupStyles = (state) => {
  "use no memo";
  useOptionGroupStyles_unstable(state);
  state.root.className = mergeClasses(tagPickerOptionGroupClassNames.root, state.root.className);
  if (state.label) {
    state.label.className = mergeClasses(tagPickerOptionGroupClassNames.label, state.label.className);
  }
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/TagPickerOptionGroup.js
var TagPickerOptionGroup = React571.forwardRef((props, ref) => {
  const state = useTagPickerOptionGroup(props, ref);
  useTagPickerOptionGroupStyles(state);
  useCustomStyleHook("useTagPickerOptionGroupStyles_unstable")(state);
  return renderTagPickerOptionGroup(state);
});
TagPickerOptionGroup.displayName = "TagPickerOptionGroup";

// node_modules/@fluentui/react-tag-picker/lib/utils/useTagPickerFilter.js
var React572 = __toESM(require_react());
function defaultRenderOption(option) {
  return React572.createElement(TagPickerOption, {
    value: option,
    key: option
  }, option);
}
function useTagPickerFilter({ filter: filterOverride, noOptionsElement, renderOption = defaultRenderOption, query, options }) {
  const defaultFilter2 = React572.useCallback((option) => {
    const trimmedQuery = query.trim();
    if (trimmedQuery === "") {
      return true;
    }
    return option.toLowerCase().includes(trimmedQuery.toLowerCase());
  }, [
    query
  ]);
  const filter = filterOverride !== null && filterOverride !== void 0 ? filterOverride : defaultFilter2;
  const filteredOptions = React572.useMemo(() => options.reduce((accumulator, option, index) => {
    if (filter(option, index)) {
      accumulator.push(renderOption(option));
    }
    return accumulator;
  }, []), [
    options,
    renderOption,
    filter
  ]);
  return filteredOptions.length === 0 ? [
    noOptionsElement.key ? noOptionsElement : React572.cloneElement(noOptionsElement, {
      key: "no-options"
    })
  ] : filteredOptions;
}

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/SwatchPicker.js
var React575 = __toESM(require_react());

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/useSwatchPicker.js
var React573 = __toESM(require_react());
var useSwatchPicker_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props);
  const { layout, onSelectionChange, size: size3 = "medium", shape, spacing = "medium", style, ...rest } = props;
  const isGrid = layout === "grid";
  const focusAttributes = useArrowNavigationGroup({
    circular: true,
    axis: isGrid ? "grid-linear" : "both",
    memorizeCurrent: true
  });
  const role = isGrid ? "grid" : "radiogroup";
  const [selectedValue, setSelectedValue] = useControllableState({
    state: props.selectedValue,
    defaultState: props.defaultSelectedValue,
    initialState: ""
  });
  const requestSelectionChange = useEventCallback((event, data) => {
    onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(event, {
      type: "click",
      event,
      selectedValue: data.selectedValue,
      selectedSwatch: data.selectedSwatch
    });
    setSelectedValue(data.selectedValue);
  });
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      role,
      ...focusAttributes,
      ...rest
    }), {
      elementType: "div"
    }),
    isGrid,
    requestSelectionChange,
    selectedValue,
    size: size3,
    shape,
    spacing
  };
};

// node_modules/@fluentui/react-swatch-picker/lib/contexts/swatchPicker.js
var React574 = __toESM(require_react());
var useSwatchPickerContextValues = (state) => {
  const { isGrid, size: size3, shape, spacing, requestSelectionChange, selectedValue } = state;
  const swatchPicker = {
    isGrid,
    size: size3,
    shape,
    spacing,
    selectedValue,
    requestSelectionChange
  };
  return {
    swatchPicker
  };
};
var swatchPickerContextDefaultValue = {
  requestSelectionChange: () => {
  },
  isGrid: false,
  size: "medium",
  shape: "square",
  spacing: "medium",
  selectedValue: void 0
};
var SwatchPickerContext = createContext13(void 0);
var SwatchPickerProvider = SwatchPickerContext.Provider;
var useSwatchPickerContextValue_unstable = (selector) => useContextSelector(SwatchPickerContext, (ctx = swatchPickerContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/renderSwatchPicker.js
var renderSwatchPicker_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(SwatchPickerProvider, {
    value: contextValues.swatchPicker,
    children: jsx(state.root, {
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/useSwatchPickerStyles.styles.js
var swatchPickerClassNames = {
  root: "fui-SwatchPicker"
};
var useStyles81 = __styles2({
  root: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f14ufcw5",
    mc9l5x: "f22iagw"
  },
  row: {
    Beiy3e4: "f1063pyq"
  },
  grid: {
    Beiy3e4: "f1vx9l62"
  },
  spacingSmall: {
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1t6b6ee"
  },
  spacingMedium: {
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f4xv25i"
  }
}, {
  d: [[".f14ufcw5{padding:var(--spacingHorizontalNone) var(--spacingVerticalNone);}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f1vx9l62{flex-direction:column;}", [".f1t6b6ee{gap:2px;}", {
    p: -1
  }], [".f4xv25i{gap:4px;}", {
    p: -1
  }]]
});
var useSwatchPickerStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles81();
  const layoutStyle = state.isGrid ? styles.grid : styles.row;
  const spacingStyle = state.spacing === "small" ? styles.spacingSmall : styles.spacingMedium;
  state.root.className = mergeClasses(swatchPickerClassNames.root, styles.root, layoutStyle, spacingStyle, state.root.className);
  return state;
};

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/SwatchPicker.js
var SwatchPicker = React575.forwardRef((props, ref) => {
  const state = useSwatchPicker_unstable(props, ref);
  const contextValues = useSwatchPickerContextValues(state);
  useSwatchPickerStyles_unstable(state);
  useCustomStyleHook("useSwatchPickerStyles_unstable")(state);
  return renderSwatchPicker_unstable(state, contextValues);
});
SwatchPicker.displayName = "SwatchPicker";

// node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/ColorSwatch.js
var React577 = __toESM(require_react());

// node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/useColorSwatch.js
var React576 = __toESM(require_react());

// node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/useColorSwatchStyles.styles.js
var colorSwatchClassNames = {
  root: "fui-ColorSwatch",
  icon: "fui-ColorSwatch__icon",
  disabledIcon: "fui-ColorSwatch__disabledIcon"
};
var swatchCSSVars = {
  color: `--fui-SwatchPicker--color`,
  borderColor: `--fui-SwatchPicker--borderColor`
};
var {
  color,
  borderColor
} = swatchCSSVars;
var useResetStyles4 = __resetStyles("ryw27oi", null, {
  r: [".ryw27oi{display:inline-flex;flex-shrink:0;align-items:center;justify-content:center;box-sizing:border-box;border:1px solid var(--fui-SwatchPicker--borderColor);background:var(--fui-SwatchPicker--color);overflow:hidden;padding:0;}", ".ryw27oi:hover{cursor:pointer;border:none;box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke1),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}", ".ryw27oi:hover:active{border:none;box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorCompoundBrandStrokePressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}", ".ryw27oi:focus{outline:none;}", ".ryw27oi:focus-visible{outline:none;}", ".ryw27oi[data-fui-focus-visible]{border:none;outline:none;box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}"],
  s: ["@media (forced-colors: active){.ryw27oi{forced-color-adjust:none;}.ryw27oi:hover{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke2Hover),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}.ryw27oi:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke2Pressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}}"]
});
var useStyles82 = __styles2({
  disabled: {
    eoavqd: "fphbwmw",
    Bvxd0ez: "f1q3txrk",
    Bs5ihcz: "f1hjbkfk"
  },
  selected: {
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    E5pizo: "f8ps3yo",
    Bvxd0ez: "f106r15f",
    vajtyg: "ft0nc49",
    j6ew2k: "f16jq8vy",
    Bspt33j: "f18nq7tj"
  },
  selectedSmall: {
    E5pizo: "fxflcoq",
    Bvxd0ez: "fha7ylp",
    vajtyg: "fb3iqi"
  }
}, {
  h: [".fphbwmw:hover{cursor:not-allowed;}", ".f1q3txrk:hover{box-shadow:none;}", ".f106r15f:hover{box-shadow:inset 0 0 0 var(--strokeWidthThickest) var(--colorCompoundBrandStrokeHover),inset 0 0 0 6px var(--colorStrokeFocus1);}", ".ft0nc49:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThickest) var(--colorCompoundBrandStrokePressed),inset 0 0 0 7px var(--colorStrokeFocus1);}", ".fha7ylp:hover{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorCompoundBrandStrokeHover),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}", ".fb3iqi:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorCompoundBrandStrokePressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}"],
  m: [["@media (forced-colors: active){.f1hjbkfk:hover{box-shadow:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f18nq7tj{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke2Pressed),inset 0 0 0 5px var(--colorStrokeFocus1);}}", {
    m: "(forced-colors: active)"
  }]],
  d: [[".f3bhgqh{border:none;}", {
    p: -2
  }], ".f8ps3yo{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke1),inset 0 0 0 5px var(--colorStrokeFocus1);}", ".f16jq8vy[data-fui-focus-visible]{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus2),inset 0 0 0 5px var(--colorStrokeFocus1);}", ".fxflcoq{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke1),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}"]
});
var useSizeStyles3 = __styles2({
  "extra-small": {
    a9b677: "f64fuq3",
    Bqenvij: "fjamq6b",
    Bvxd0ez: "fnzblak",
    Bfsrqk8: 0,
    B9zn80p: 0,
    libdba: 0,
    qi15n7: 0,
    G6mxvm: 0,
    Bpld233: 0,
    B2v0cj4: 0,
    qv9p00: 0,
    Bg6oviu: 0,
    Bk6r4ia: 0,
    Bckajt6: 0,
    Bone85h: 0,
    hkxzgu: 0,
    b661bw: 0,
    kpb45w: 0,
    uiygdg: 0,
    rljib7: "f18wa7jm",
    vajtyg: "faswyoo"
  },
  small: {
    a9b677: "fq4mcun",
    Bqenvij: "frvgh55",
    Bfsrqk8: 0,
    B9zn80p: 0,
    libdba: 0,
    qi15n7: 0,
    G6mxvm: 0,
    Bpld233: 0,
    B2v0cj4: 0,
    qv9p00: 0,
    Bg6oviu: 0,
    Bk6r4ia: 0,
    Bckajt6: 0,
    Bone85h: 0,
    hkxzgu: 0,
    b661bw: 0,
    kpb45w: 0,
    uiygdg: 0,
    rljib7: "f18wa7jm",
    vajtyg: "faswyoo"
  },
  medium: {
    a9b677: "f1w9dchk",
    Bqenvij: "fxldao9"
  },
  large: {
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10"
  }
}, {
  d: [".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}"],
  h: [".fnzblak:hover{box-shadow:inset 0 0 0 var(--strokeWidthThin) var(--colorBrandStroke1),inset 0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus1);}", [".f18wa7jm:hover:active{border:none;}", {
    p: -2
  }], ".faswyoo:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorCompoundBrandStrokePressed),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}", [".f18wa7jm:hover:active{border:none;}", {
    p: -2
  }]]
});
var useShapeStyles = __styles2({
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w"
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f1062rbf"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "fj0ryk1"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], [".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }]]
});
var useIconStyles12 = __styles2({
  disabledIcon: {
    sj55zd: "fqpbvvt",
    Bhu2qc9: "f14y0k3d"
  },
  icon: {
    qhf8xq: "f1euv43f",
    mc9l5x: "f22iagw",
    qb2dma: "f7nlbp4"
  },
  "extra-small": {
    Be2twd7: "f4ybsrx"
  },
  small: {
    Be2twd7: "f4ybsrx"
  },
  medium: {
    Be2twd7: "fe5j1ua"
  },
  large: {
    Be2twd7: "f1rt2boy"
  }
}, {
  d: [".fqpbvvt{color:var(--colorNeutralForegroundInverted);}", ".f14y0k3d{filter:drop-shadow(0 1px 1px rgb(0 0 0 / 1));}", ".f1euv43f{position:absolute;}", ".f22iagw{display:flex;}", ".f7nlbp4{align-self:center;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}"]
});
var useColorSwatchStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3 = "medium",
    shape = "square"
  } = state;
  const resetStyles = useResetStyles4();
  const styles = useStyles82();
  const sizeStyles = useSizeStyles3();
  const shapeStyles = useShapeStyles();
  const iconStyles = useIconStyles12();
  const smallerSelectedStyles = size3 === "small" || size3 === "extra-small" ? styles.selectedSmall : "";
  state.root.className = mergeClasses(colorSwatchClassNames.root, resetStyles, sizeStyles[size3], shapeStyles[shape], state.selected && styles.selected, state.selected && smallerSelectedStyles, state.disabled && styles.disabled, state.root.className);
  if (state.disabled && state.disabledIcon) {
    state.disabledIcon.className = mergeClasses(iconStyles.icon, iconStyles[size3], iconStyles.disabledIcon, state.disabledIcon.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(iconStyles.icon, iconStyles[size3], state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/useColorSwatch.js
var useColorSwatch_unstable = (props, ref) => {
  const { borderColor: borderColor2, color: color2, disabled, disabledIcon, icon, value, onClick, size: size3, shape, style, ...rest } = props;
  const _size = useSwatchPickerContextValue_unstable((ctx) => ctx.size);
  const _shape = useSwatchPickerContextValue_unstable((ctx) => ctx.shape);
  const isGrid = useSwatchPickerContextValue_unstable((ctx) => ctx.isGrid);
  const requestSelectionChange = useSwatchPickerContextValue_unstable((ctx) => ctx.requestSelectionChange);
  const selected = useSwatchPickerContextValue_unstable((ctx) => ctx.selectedValue === value);
  const onColorSwatchClick = useEventCallback(mergeCallbacks(onClick, (event) => requestSelectionChange(event, {
    selectedValue: value,
    selectedSwatch: color2
  })));
  const rootVariables = {
    [swatchCSSVars.color]: color2,
    [swatchCSSVars.borderColor]: borderColor2 !== null && borderColor2 !== void 0 ? borderColor2 : tokens.colorTransparentStroke
  };
  const role = isGrid ? "gridcell" : "radio";
  const ariaSelected = isGrid ? {
    "aria-selected": selected
  } : {
    "aria-checked": selected
  };
  const iconShorthand = slot_exports.optional(icon, {
    elementType: "span"
  });
  const disabledIconShorthand = slot_exports.optional(disabledIcon, {
    defaultProps: {
      children: React576.createElement(ProhibitedFilled, null)
    },
    renderByDefault: true,
    elementType: "span"
  });
  return {
    components: {
      root: "button",
      icon: "span",
      disabledIcon: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      ref,
      role,
      ...ariaSelected,
      onClick: onColorSwatchClick,
      type: "button",
      disabled,
      ...rest,
      style: {
        ...rootVariables,
        ...style
      }
    }), {
      elementType: "button"
    }),
    icon: iconShorthand,
    disabledIcon: disabledIconShorthand,
    disabled,
    size: size3 !== null && size3 !== void 0 ? size3 : _size,
    shape: shape !== null && shape !== void 0 ? shape : _shape,
    selected,
    color: color2,
    value
  };
};

// node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/renderColorSwatch.js
var renderColorSwatch_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.root.children,
      state.icon && jsx(state.icon, {}),
      state.disabled && state.disabledIcon && jsx(state.disabledIcon, {})
    ]
  });
};

// node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/ColorSwatch.js
var ColorSwatch = React577.forwardRef((props, ref) => {
  const state = useColorSwatch_unstable(props, ref);
  useColorSwatchStyles_unstable(state);
  useCustomStyleHook("useColorSwatchStyles_unstable")(state);
  return renderColorSwatch_unstable(state);
});
ColorSwatch.displayName = "ColorSwatch";

// node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/ImageSwatch.js
var React579 = __toESM(require_react());

// node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/useImageSwatch.js
var React578 = __toESM(require_react());
var useImageSwatch_unstable = (props, ref) => {
  const { src, value, onClick, style, ...rest } = props;
  const size3 = useSwatchPickerContextValue_unstable((ctx) => ctx.size);
  const shape = useSwatchPickerContextValue_unstable((ctx) => ctx.shape);
  const isGrid = useSwatchPickerContextValue_unstable((ctx) => ctx.isGrid);
  const requestSelectionChange = useSwatchPickerContextValue_unstable((ctx) => ctx.requestSelectionChange);
  const selected = useSwatchPickerContextValue_unstable((ctx) => ctx.selectedValue === value);
  const role = isGrid ? "gridcell" : "radio";
  const ariaSelected = isGrid ? {
    "aria-selected": selected
  } : {
    "aria-checked": selected
  };
  const onImageSwatchClick = useEventCallback(mergeCallbacks(onClick, (event) => requestSelectionChange(event, {
    selectedValue: value,
    selectedSwatch: src
  })));
  return {
    components: {
      root: "button"
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      ref,
      role,
      ...ariaSelected,
      onClick: onImageSwatchClick,
      ...rest,
      style: {
        backgroundImage: `url(${src})`,
        ...style
      }
    }), {
      elementType: "button"
    }),
    value,
    selected,
    size: size3,
    shape
  };
};

// node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/renderImageSwatch.js
var renderImageSwatch_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/useImageSwatchStyles.styles.js
var imageSwatchClassNames = {
  root: "fui-ImageSwatch"
};
var useStyles83 = __resetStyles("r18b5q7m", null, {
  r: [".r18b5q7m{display:inline-flex;box-sizing:border-box;border:1px solid var(--colorTransparentStroke);background-size:cover;background-repeat:no-repeat;padding:0;}", ".r18b5q7m:hover{cursor:pointer;border:none;box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke1),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}", ".r18b5q7m:hover:active{border:none;box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorCompoundBrandStrokePressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}", ".r18b5q7m:focus{outline:none;}", ".r18b5q7m:focus-visible{outline:none;}", ".r18b5q7m[data-fui-focus-visible]{border:none;outline:none;box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}"],
  s: ["@media (forced-colors: active){.r18b5q7m{forced-color-adjust:none;}.r18b5q7m:hover{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke2Hover),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}.r18b5q7m:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke2Pressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}}"]
});
var useStylesSelected = __styles2({
  selected: {
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    E5pizo: "f8ps3yo",
    Bvxd0ez: "f106r15f",
    vajtyg: "ft0nc49",
    j6ew2k: "f16jq8vy",
    Bspt33j: "f18nq7tj"
  }
}, {
  d: [[".f3bhgqh{border:none;}", {
    p: -2
  }], ".f8ps3yo{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke1),inset 0 0 0 5px var(--colorStrokeFocus1);}", ".f16jq8vy[data-fui-focus-visible]{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus2),inset 0 0 0 5px var(--colorStrokeFocus1);}"],
  h: [".f106r15f:hover{box-shadow:inset 0 0 0 var(--strokeWidthThickest) var(--colorCompoundBrandStrokeHover),inset 0 0 0 6px var(--colorStrokeFocus1);}", ".ft0nc49:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThickest) var(--colorCompoundBrandStrokePressed),inset 0 0 0 7px var(--colorStrokeFocus1);}"],
  m: [["@media (forced-colors: active){.f18nq7tj{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke2Pressed),inset 0 0 0 5px var(--colorStrokeFocus1);}}", {
    m: "(forced-colors: active)"
  }]]
});
var useSizeStyles4 = __styles2({
  "extra-small": {
    a9b677: "f64fuq3",
    Bqenvij: "fjamq6b"
  },
  small: {
    a9b677: "fq4mcun",
    Bqenvij: "frvgh55"
  },
  medium: {
    a9b677: "f1w9dchk",
    Bqenvij: "fxldao9"
  },
  large: {
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10"
  }
}, {
  d: [".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}"]
});
var useShapeStyles2 = __styles2({
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w"
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f1062rbf"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "fj0ryk1"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], [".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }]]
});
var useImageSwatchStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles83();
  const selectedStyles = useStylesSelected();
  const sizeStyles = useSizeStyles4();
  const shapeStyles = useShapeStyles2();
  const {
    size: size3 = "medium",
    shape = "square"
  } = state;
  state.root.className = mergeClasses(imageSwatchClassNames.root, styles, sizeStyles[size3], shapeStyles[shape], state.selected && selectedStyles.selected, state.root.className);
  return state;
};

// node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/ImageSwatch.js
var ImageSwatch = React579.forwardRef((props, ref) => {
  const state = useImageSwatch_unstable(props, ref);
  useImageSwatchStyles_unstable(state);
  useCustomStyleHook("useImageSwatchStyles_unstable")(state);
  return renderImageSwatch_unstable(state);
});
ImageSwatch.displayName = "ImageSwatch";

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/SwatchPickerRow.js
var React581 = __toESM(require_react());

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/useSwatchPickerRow.js
var React580 = __toESM(require_react());
var useSwatchPickerRow_unstable = (props, ref) => {
  const { style, ...rest } = props;
  const spacing = useSwatchPickerContextValue_unstable((ctx) => ctx.spacing);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      role: "row",
      ...rest
    }), {
      elementType: "div"
    }),
    spacing
  };
};

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/renderSwatchPickerRow.js
var renderSwatchPickerRow_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/useSwatchPickerRowStyles.styles.js
var swatchPickerRowClassNames = {
  root: "fui-SwatchPickerRow"
};
var useResetStyles5 = __resetStyles("r1xhj18k", null, [".r1xhj18k{display:flex;flex-direction:row;}"]);
var useStyles84 = __styles2({
  spacingSmall: {
    i8kkvl: "f16mnhsx"
  },
  spacingMedium: {
    i8kkvl: "f1q8lukm"
  }
}, {
  d: [".f16mnhsx{column-gap:2px;}", ".f1q8lukm{column-gap:4px;}"]
});
var useSwatchPickerRowStyles_unstable = (state) => {
  "use no memo";
  const resetStyles = useResetStyles5();
  const styles = useStyles84();
  const spacingStyle = state.spacing === "small" ? styles.spacingSmall : styles.spacingMedium;
  state.root.className = mergeClasses(swatchPickerRowClassNames.root, resetStyles, spacingStyle, state.root.className);
  return state;
};

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/SwatchPickerRow.js
var SwatchPickerRow = React581.forwardRef((props, ref) => {
  const state = useSwatchPickerRow_unstable(props, ref);
  useSwatchPickerRowStyles_unstable(state);
  useCustomStyleHook("useSwatchPickerRowStyles_unstable")(state);
  return renderSwatchPickerRow_unstable(state);
});
SwatchPickerRow.displayName = "SwatchPickerRow";

// node_modules/@fluentui/react-swatch-picker/lib/utils/renderUtils.js
var React582 = __toESM(require_react());
var renderSwatchPickerGrid = (props) => {
  const { items, columnCount, renderRow, renderSwatch } = props;
  const _renderRow = renderRow || (({ children: children2, rowId }) => React582.createElement(SwatchPickerRow, {
    key: rowId
  }, children2));
  const _renderSwatch = renderSwatch || ((item) => {
    var _item_src;
    return item.src ? React582.createElement(ImageSwatch, {
      key: item.value,
      src: (_item_src = item.src) !== null && _item_src !== void 0 ? _item_src : "",
      ...item
    }) : React582.createElement(ColorSwatch, {
      key: item.value,
      color: item.color || "",
      ...item
    });
  });
  const rowCount = Math.ceil(items.length / columnCount);
  const rows = Array.from({
    length: rowCount
  }, (_, i) => {
    const start = i * columnCount;
    const end = start + columnCount;
    return items.slice(start, end);
  });
  return rows.map((row, index) => _renderRow({
    children: row.map(_renderSwatch),
    rowId: index
  }));
};

// node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/EmptySwatch.js
var React584 = __toESM(require_react());

// node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/useEmptySwatch.js
var React583 = __toESM(require_react());
var useEmptySwatch_unstable = (props, ref) => {
  const { size: size3, shape, ...rest } = props;
  const _size = useSwatchPickerContextValue_unstable((ctx) => ctx.size);
  const _shape = useSwatchPickerContextValue_unstable((ctx) => ctx.shape);
  const isGrid = useSwatchPickerContextValue_unstable((ctx) => ctx.isGrid);
  const role = isGrid ? "gridcell" : "radio";
  const a11yProps = isGrid ? {} : {
    "aria-checked": false
  };
  return {
    components: {
      root: "button"
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      ref,
      role,
      ...a11yProps,
      ...rest
    }), {
      elementType: "button"
    }),
    size: size3 !== null && size3 !== void 0 ? size3 : _size,
    shape: shape !== null && shape !== void 0 ? shape : _shape
  };
};

// node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/renderEmptySwatch.js
var renderEmptySwatch_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/useEmptySwatchStyles.styles.js
var emptySwatchClassNames = {
  root: "fui-EmptySwatch"
};
var useStyles85 = __resetStyles("r1top892", null, [".r1top892{background-color:var(--colorTransparentBackground);border:1px dashed var(--colorNeutralForeground4);}"]);
var useSizeStyles5 = __styles2({
  "extra-small": {
    a9b677: "f64fuq3",
    Bqenvij: "fjamq6b"
  },
  small: {
    a9b677: "fq4mcun",
    Bqenvij: "frvgh55"
  },
  medium: {
    a9b677: "f1w9dchk",
    Bqenvij: "fxldao9"
  },
  large: {
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10"
  }
}, {
  d: [".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}"]
});
var useShapeStyles3 = __styles2({
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w"
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f1062rbf"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "fj0ryk1"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], [".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }]]
});
var useEmptySwatchStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles85();
  const sizeStyles = useSizeStyles5();
  const shapeStyles = useShapeStyles3();
  var _state_size;
  const size3 = (_state_size = state.size) !== null && _state_size !== void 0 ? _state_size : "medium";
  var _state_shape;
  state.root.className = mergeClasses(emptySwatchClassNames.root, styles, sizeStyles[size3], shapeStyles[(_state_shape = state.shape) !== null && _state_shape !== void 0 ? _state_shape : "square"], state.root.className);
  return state;
};

// node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/EmptySwatch.js
var EmptySwatch = React584.forwardRef((props, ref) => {
  const state = useEmptySwatch_unstable(props, ref);
  useEmptySwatchStyles_unstable(state);
  useCustomStyleHook("useEmptySwatchStyles_unstable")(state);
  return renderEmptySwatch_unstable(state);
});
EmptySwatch.displayName = "EmptySwatch";

// node_modules/@fluentui/react-carousel/lib/components/CarouselButton/CarouselButton.js
var React586 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselButton/useCarouselButton.js
var React585 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselContext.js
var carouselContextDefaultValue2 = {
  activeIndex: 0,
  selectPageByElement: () => {
    return 0;
  },
  selectPageByDirection: () => {
    return 0;
  },
  selectPageByIndex: () => {
  },
  subscribeForValues: () => () => {
  },
  enableAutoplay: () => {
  },
  resetAutoplay: () => {
  },
  circular: false,
  containerRef: void 0,
  viewportRef: void 0
};
var CarouselContext2 = createContext13(void 0);
var CarouselProvider2 = CarouselContext2.Provider;
var useCarouselContext_unstable2 = (selector) => useContextSelector(CarouselContext2, (ctx = carouselContextDefaultValue2) => selector(ctx));

// node_modules/@fluentui/react-carousel/lib/components/CarouselButton/useCarouselButtonStyles.styles.js
var carouselButtonClassNames = {
  root: "fui-CarouselButton",
  icon: "fui-CarouselButton__icon"
};
var useStyles86 = __styles2({
  root: {
    B6of3ja: "fgr6219",
    jrapky: "f10jk5vf",
    sj55zd: "fkfq4zb",
    De3pzq: "fkfdr9r",
    Bkecrkj: "fc5wo7j",
    eoavqd: "f8491dx"
  }
}, {
  d: [".fgr6219{margin-top:auto;}", ".f10jk5vf{margin-bottom:auto;}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".fkfdr9r{background-color:var(--colorNeutralBackgroundAlpha);}", ".fc5wo7j{pointer-events:all;}"],
  h: [".f8491dx:hover{cursor:pointer;}"]
});
var useCarouselButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles86();
  state = {
    ...state,
    ...useButtonStyles_unstable(state)
  };
  state.root.className = mergeClasses(carouselButtonClassNames.root, styles.root, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(carouselButtonClassNames.icon, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselButton/useCarouselButton.js
var useCarouselButton_unstable = (props, ref) => {
  const { navType = "next" } = props;
  const [totalSlides, setTotalSlides] = React585.useState(0);
  const { dir } = useFluent();
  const buttonRef = React585.useRef(void 0);
  const circular = useCarouselContext_unstable2((ctx) => ctx.circular);
  const [canLoop, setCanLoop] = React585.useState(circular);
  const containerRef = useCarouselContext_unstable2((ctx) => ctx.containerRef);
  const selectPageByDirection = useCarouselContext_unstable2((ctx) => ctx.selectPageByDirection);
  const subscribeForValues = useCarouselContext_unstable2((ctx) => ctx.subscribeForValues);
  const resetAutoplay = useCarouselContext_unstable2((ctx) => ctx.resetAutoplay);
  const isTrailing = useCarouselContext_unstable2((ctx) => {
    if (circular && canLoop) {
      return false;
    }
    if (navType === "prev") {
      return ctx.activeIndex === 0;
    }
    return ctx.activeIndex === totalSlides - 1;
  });
  const handleClick = (event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    const nextIndex = selectPageByDirection(event, navType);
    let _trailing = false;
    if (navType === "prev") {
      _trailing = nextIndex === 0;
    } else {
      _trailing = nextIndex === totalSlides - 1;
    }
    if (!circular && _trailing && (containerRef === null || containerRef === void 0 ? void 0 : containerRef.current)) {
      const buttonRefs = containerRef.current.querySelectorAll(`.${carouselButtonClassNames.root}`);
      buttonRefs.forEach((_buttonRef) => {
        if (_buttonRef !== buttonRef.current) {
          _buttonRef.focus();
        }
      });
    }
    resetAutoplay();
  };
  useIsomorphicLayoutEffect(() => {
    return subscribeForValues((data) => {
      if (data.canLoop !== void 0) {
        setCanLoop(data.canLoop);
      }
      setTotalSlides(data.navItemsCount);
    });
  }, [
    subscribeForValues
  ]);
  const nextArrowIcon = dir === "ltr" ? React585.createElement(ChevronRightRegular, null) : React585.createElement(ChevronLeftRegular, null);
  const prevArrowIcon = dir === "ltr" ? React585.createElement(ChevronLeftRegular, null) : React585.createElement(ChevronRightRegular, null);
  return {
    navType,
    // We lean on react-button class to handle styling and icon enhancements
    ...useButton_unstable({
      icon: slot_exports.optional(props.icon, {
        defaultProps: {
          children: navType === "next" ? nextArrowIcon : prevArrowIcon
        },
        renderByDefault: true,
        elementType: "span"
      }),
      disabled: isTrailing,
      tabIndex: isTrailing ? -1 : 0,
      "aria-disabled": isTrailing,
      appearance: "subtle",
      ...props,
      onClick: useEventCallback(mergeCallbacks(handleClick, props.onClick))
    }, useMergedRefs(ref, buttonRef))
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselButton/renderCarouselButton.js
var renderCarouselButton_unstable = (state) => {
  assertSlots(state);
  return renderButton_unstable(state);
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselButton/CarouselButton.js
var CarouselButton = React586.forwardRef((props, ref) => {
  const state = useCarouselButton_unstable(props, ref);
  useCarouselButtonStyles_unstable(state);
  useCustomStyleHook("useCarouselButtonStyles_unstable")(state);
  return renderCarouselButton_unstable(state);
});
CarouselButton.displayName = "CarouselButton";

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/CarouselNav.js
var React590 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/CarouselNavContext.js
var React587 = __toESM(require_react());
var carouselNavContext = React587.createContext(void 0);
var carouselNavContextDefaultValue = {
  appearance: void 0
};
var useCarouselNavContext = () => {
  var _React_useContext;
  return (_React_useContext = React587.useContext(carouselNavContext)) !== null && _React_useContext !== void 0 ? _React_useContext : carouselNavContextDefaultValue;
};
var CarouselNavContextProvider = carouselNavContext.Provider;
function useCarouselNavContextValues_unstable(state) {
  const { appearance } = state;
  const carouselNav = React587.useMemo(() => ({
    appearance
  }), [
    appearance
  ]);
  return {
    carouselNav
  };
}

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/CarouselNavIndexContext.js
var React588 = __toESM(require_react());
var carouselNavIndexContext = React588.createContext(void 0);
var carouselNavIndexContextDefaultValue = 0;
var useCarouselNavIndexContext = () => {
  var _React_useContext;
  return (_React_useContext = React588.useContext(carouselNavIndexContext)) !== null && _React_useContext !== void 0 ? _React_useContext : carouselNavIndexContextDefaultValue;
};
var CarouselNavIndexContextProvider = carouselNavIndexContext.Provider;

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/renderCarouselNav.js
var renderCarouselNav_unstable = (state, contextValues) => {
  assertSlots(state);
  const { totalSlides, renderNavButton } = state;
  return jsx(state.root, {
    children: jsx(CarouselNavContextProvider, {
      value: contextValues.carouselNav,
      children: new Array(totalSlides).fill(null).map((_, index) => jsx(CarouselNavIndexContextProvider, {
        value: index,
        children: renderNavButton(index)
      }, index))
    })
  });
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/useCarouselNav.js
var React589 = __toESM(require_react());
var useCarouselNav_unstable = (props, ref) => {
  const { appearance } = props;
  const focusableGroupAttr = useArrowNavigationGroup({
    circular: false,
    axis: "horizontal",
    memorizeCurrent: false,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_hasDefault: true
  });
  const [totalSlides, setTotalSlides] = useControllableState({
    state: props.totalSlides,
    initialState: 0
  });
  const subscribeForValues = useCarouselContext_unstable2((ctx) => ctx.subscribeForValues);
  useIsomorphicLayoutEffect(() => {
    return subscribeForValues((data) => {
      setTotalSlides(data.navItemsCount);
    });
  }, [
    subscribeForValues,
    setTotalSlides
  ]);
  return {
    totalSlides,
    appearance,
    renderNavButton: props.children,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      role: "tablist",
      ...props,
      ...focusableGroupAttr,
      children: null
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/useCarouselNavStyles.styles.js
var carouselNavClassNames = {
  root: "fui-CarouselNav"
};
var useStyles87 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    Bt984gj: "f122n59",
    Brf1p80: "f4d9j23",
    Bkecrkj: "fc5wo7j",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f89hs3r",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1kijzfu",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "fkb7v5e",
    De3pzq: "fkfdr9r"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f122n59{align-items:center;}", ".f4d9j23{justify-content:center;}", ".fc5wo7j{pointer-events:all;}", [".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", [".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", {
    p: -1
  }], [".fkb7v5e{margin:auto var(--spacingHorizontalS);}", {
    p: -1
  }], ".fkfdr9r{background-color:var(--colorNeutralBackgroundAlpha);}"]
});
var useCarouselNavStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles87();
  state.root.className = mergeClasses(carouselNavClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/CarouselNav.js
var CarouselNav = React590.forwardRef((props, ref) => {
  const state = useCarouselNav_unstable(props, ref);
  const contextValues = useCarouselNavContextValues_unstable(state);
  useCarouselNavStyles_unstable(state);
  useCustomStyleHook("useCarouselNavStyles_unstable")(state);
  return renderCarouselNav_unstable(state, contextValues);
});
CarouselNav.displayName = "CarouselNav";

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/CarouselNavButton.js
var React592 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/useCarouselNavButton.js
var React591 = __toESM(require_react());
var useCarouselNavButton_unstable = (props, ref) => {
  const { onClick, as = "button" } = props;
  const { appearance } = useCarouselNavContext();
  const index = useCarouselNavIndexContext();
  const selectPageByIndex = useCarouselContext_unstable2((ctx) => ctx.selectPageByIndex);
  const selected = useCarouselContext_unstable2((ctx) => ctx.activeIndex === index);
  const subscribeForValues = useCarouselContext_unstable2((ctx) => ctx.subscribeForValues);
  const resetAutoplay = useCarouselContext_unstable2((ctx) => ctx.resetAutoplay);
  const handleClick = useEventCallback((event) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
    if (!event.defaultPrevented && isHTMLElement(event.target)) {
      selectPageByIndex(event, index);
    }
    resetAutoplay();
  });
  const defaultTabProps = useTabsterAttributes({
    focusable: {
      isDefault: selected
    }
  });
  const buttonRef = React591.useRef(void 0);
  const _carouselButton = slot_exports.always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
    elementType: "button",
    defaultProps: {
      ref: useMergedRefs(ref, buttonRef),
      role: "tab",
      type: "button",
      "aria-selected": selected,
      ...defaultTabProps
    }
  });
  useIsomorphicLayoutEffect(() => {
    return subscribeForValues((data) => {
      var _data_groupIndexList;
      var _data_groupIndexList_index;
      const controlList = (_data_groupIndexList_index = (_data_groupIndexList = data.groupIndexList) === null || _data_groupIndexList === void 0 ? void 0 : _data_groupIndexList[index]) !== null && _data_groupIndexList_index !== void 0 ? _data_groupIndexList_index : [];
      const _controlledSlideIds = controlList.map((slideIndex) => {
        return data.slideNodes[slideIndex].id;
      }).join(" ");
      if (buttonRef.current) {
        buttonRef.current.setAttribute("aria-controls", _controlledSlideIds);
      }
    });
  }, [
    index,
    subscribeForValues
  ]);
  _carouselButton.onClick = handleClick;
  const state = {
    selected,
    appearance,
    components: {
      root: "button"
    },
    root: _carouselButton
  };
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/renderCarouselNavButton.js
var renderCarouselNavButton_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/useCarouselNavButtonStyles.styles.js
var carouselNavButtonClassNames = {
  root: "fui-CarouselNavButton"
};
var useStyles88 = __styles2({
  root: {
    Bceei9c: "f1k6fduh",
    Bkecrkj: "fc5wo7j",
    a9b677: "f1van5z7",
    Bqenvij: "f1fkmctz",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1f5q0n8",
    B7ck84d: "f1e4lqlz",
    De3pzq: "f1c21dwh",
    B4j52fo: "fre7gi1",
    Bekrc4i: ["f1358rze", "f1rvrf73"],
    Bn0qgzm: "fqdk4by",
    ibv6hh: ["f1rvrf73", "f1358rze"],
    Bsft5z2: "f13zj6fq",
    ap17g6: "f2gz7yw",
    li1rpt: "f1gw3sf2",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "f1x820d0",
    Bjuhk93: 0,
    B1q35kw: 0,
    Bw17bha: 0,
    Bcgy8vk: 0,
    Du69r6: 0,
    Gp14am: 0,
    vfts7: 0,
    Bhxzhr1: 0,
    G63luc: 0,
    s924m2: 0,
    Barhvk9: 0,
    Ihftqj: 0,
    wywymt: 0,
    B0n5ga8: 0,
    Bm2nyyq: 0,
    xrcqlc: 0,
    e1d83w: "fnwf5yv",
    Dlnsje: "foue38v",
    a2br6o: "fi4ui2s",
    Bjyk6c5: "f1w4p7kh",
    go7t6h: "fo5b2b9",
    qx5q1e: "f1dpauah",
    f7digc: "f1agqfpv",
    Bfz3el7: "f6pnf7h"
  },
  rootUnselected: {
    Bw0xxkn: 0,
    oeaueh: 0,
    Bpd4iqm: 0,
    Befb4lg: "f71xx7",
    Byu6kyc: 0,
    n8qw10: 0,
    Bbjhlyh: 0,
    i2cumq: 0,
    Bunx835: 0,
    Bdrgwmp: 0,
    mqozju: 0,
    lbo84a: 0,
    Bksnhdo: 0,
    Bci5o5g: 0,
    u5e7qz: 0,
    Bn40d3w: 0,
    B7b6zxw: 0,
    B8q5s1w: 0,
    B5gfjzb: 0,
    Bbcte9g: 0,
    Bqz3imu: "f1j9b7x8",
    Bj9ihqo: 0,
    Bl51kww: 0,
    B3bvztg: 0,
    Btyt4dx: 0,
    Brhw1f9: "f1tdm9ui",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    Bp15pi3: "f7x02et",
    Bay5ve9: "f1ry2q4s",
    Bni0232: "f1e9f9ku"
  },
  rootSelected: {
    a9b677: "f1eh74fx",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fwku66v",
    Bw0xxkn: 0,
    oeaueh: 0,
    Bpd4iqm: 0,
    Befb4lg: "f71xx7",
    Byu6kyc: 0,
    n8qw10: 0,
    Bbjhlyh: 0,
    i2cumq: 0,
    Bunx835: 0,
    Bdrgwmp: 0,
    mqozju: 0,
    lbo84a: 0,
    Bksnhdo: 0,
    Bci5o5g: 0,
    u5e7qz: 0,
    Bn40d3w: 0,
    B7b6zxw: 0,
    B8q5s1w: 0,
    B5gfjzb: 0,
    Bbcte9g: 0,
    Bqz3imu: "f1j9b7x8",
    Bj9ihqo: 0,
    Bl51kww: 0,
    B3bvztg: 0,
    Btyt4dx: 0,
    Brhw1f9: "f1tdm9ui",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    a2br6o: "f1v6lwa2",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "fgm6wgx",
    Bay5ve9: "f1ry2q4s",
    Bni0232: "f1gxfet"
  },
  brand: {
    Bjyk6c5: "fnrv5e1",
    Bp15pi3: "fjsqi2x",
    Glksuk: "frrwqtn",
    Bay5ve9: "f9atwx8",
    Blzl0y7: "fmmpig5",
    Bni0232: "f1e9f9ku"
  },
  unselectedBrand: {
    Bp15pi3: "f7x02et",
    Bjyk6c5: "f1w4p7kh",
    Bay5ve9: "f1ry2q4s",
    Bni0232: "f1e9f9ku"
  }
}, {
  d: [".f1k6fduh{cursor:pointer;}", ".fc5wo7j{pointer-events:all;}", ".f1van5z7{width:var(--spacingHorizontalS);}", ".f1fkmctz{height:var(--spacingVerticalS);}", [".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], ".f1e4lqlz{box-sizing:content-box;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fre7gi1{border-top-width:0;}", ".f1358rze{border-right-width:0;}", ".f1rvrf73{border-left-width:0;}", ".fqdk4by{border-bottom-width:0;}", '.f13zj6fq::after{content:"";}', ".f2gz7yw::after{display:block;}", ".f1gw3sf2::after{box-sizing:border-box;}", [".f1x820d0::after{border-radius:50%;}", {
    p: -1
  }], [".fnwf5yv::after{border:none;}", {
    p: -2
  }], ".foue38v::after{height:var(--spacingVerticalS);}", ".fi4ui2s::after{width:var(--spacingHorizontalS);}", ".f1w4p7kh::after{background-color:var(--colorNeutralForeground1);}", ".fo5b2b9::after{color:var(--colorNeutralForeground1);}", [".f71xx7{outline:var(--strokeWidthThin) solid transparent;}", {
    p: -1
  }], [".f1j9b7x8[data-fui-focus-visible]{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1tdm9ui[data-fui-focus-visible]{margin:calc(-1 * var(--strokeWidthThick));}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f7x02et::after{opacity:0.6;}", ".f1eh74fx{width:var(--spacingHorizontalL);}", [".fwku66v{padding:var(--spacingVerticalS) var(--spacingHorizontalXS);}", {
    p: -1
  }], [".f71xx7{outline:var(--strokeWidthThin) solid transparent;}", {
    p: -1
  }], [".f1j9b7x8[data-fui-focus-visible]{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1tdm9ui[data-fui-focus-visible]{margin:calc(-1 * var(--strokeWidthThick));}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1v6lwa2::after{width:var(--spacingHorizontalL);}", [".fgm6wgx::after{border-radius:4px;}", {
    p: -1
  }], ".fnrv5e1::after{background-color:var(--colorCompoundBrandBackground);}", ".fjsqi2x::after{opacity:1;}"],
  m: [["@media (forced-colors: active){.f1dpauah::after{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1agqfpv::after{background-color:white;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f6pnf7h::after{mix-blend-mode:difference;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".f1ry2q4s:hover::after{opacity:0.75;}", ".frrwqtn:hover::after{background-color:var(--colorCompoundBrandBackgroundHover);}", ".f9atwx8:hover::after{opacity:1;}"],
  a: [".f1e9f9ku:active::after{opacity:1;}", ".f1gxfet:active::after{opacity:0.65;}", ".fmmpig5:active::after{background-color:var(--colorCompoundBrandBackgroundPressed);}"]
});
var useCarouselNavButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles88();
  const {
    selected,
    appearance
  } = state;
  state.root.className = mergeClasses(carouselNavButtonClassNames.root, styles.root, selected ? styles.rootSelected : styles.rootUnselected, appearance === "brand" && styles.brand, !selected && appearance === "brand" && styles.unselectedBrand, state.root.className);
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/CarouselNavButton.js
var CarouselNavButton = React592.forwardRef((props, ref) => {
  const state = useCarouselNavButton_unstable(props, ref);
  useCarouselNavButtonStyles_unstable(state);
  useCustomStyleHook("useCarouselNavButtonStyles_unstable")(state);
  return renderCarouselNavButton_unstable(state);
});
CarouselNavButton.displayName = "CarouselNavButton";

// node_modules/@fluentui/react-carousel/lib/components/Carousel/Carousel.js
var React596 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/Carousel/useCarousel.js
var React594 = __toESM(require_react());

// node_modules/embla-carousel/esm/embla-carousel.esm.js
function isNumber(subject) {
  return typeof subject === "number";
}
function isString(subject) {
  return typeof subject === "string";
}
function isBoolean(subject) {
  return typeof subject === "boolean";
}
function isObject(subject) {
  return Object.prototype.toString.call(subject) === "[object Object]";
}
function mathAbs(n) {
  return Math.abs(n);
}
function mathSign(n) {
  return Math.sign(n);
}
function deltaAbs(valueB, valueA) {
  return mathAbs(valueB - valueA);
}
function factorAbs(valueB, valueA) {
  if (valueB === 0 || valueA === 0) return 0;
  if (mathAbs(valueB) <= mathAbs(valueA)) return 0;
  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));
  return mathAbs(diff / valueB);
}
function roundToTwoDecimals(num) {
  return Math.round(num * 100) / 100;
}
function arrayKeys(array) {
  return objectKeys(array).map(Number);
}
function arrayLast(array) {
  return array[arrayLastIndex(array)];
}
function arrayLastIndex(array) {
  return Math.max(0, array.length - 1);
}
function arrayIsLastIndex(array, index) {
  return index === arrayLastIndex(array);
}
function arrayFromNumber(n, startAt = 0) {
  return Array.from(Array(n), (_, i) => startAt + i);
}
function objectKeys(object) {
  return Object.keys(object);
}
function objectsMergeDeep(objectA, objectB) {
  return [objectA, objectB].reduce((mergedObjects, currentObject) => {
    objectKeys(currentObject).forEach((key) => {
      const valueA = mergedObjects[key];
      const valueB = currentObject[key];
      const areObjects = isObject(valueA) && isObject(valueB);
      mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;
    });
    return mergedObjects;
  }, {});
}
function isMouseEvent2(evt, ownerWindow) {
  return typeof ownerWindow.MouseEvent !== "undefined" && evt instanceof ownerWindow.MouseEvent;
}
function Alignment(align, viewSize) {
  const predefined = {
    start,
    center,
    end
  };
  function start() {
    return 0;
  }
  function center(n) {
    return end(n) / 2;
  }
  function end(n) {
    return viewSize - n;
  }
  function measure(n, index) {
    if (isString(align)) return predefined[align](n);
    return align(viewSize, n, index);
  }
  const self = {
    measure
  };
  return self;
}
function EventStore() {
  let listeners = [];
  function add(node, type, handler, options = {
    passive: true
  }) {
    let removeListener;
    if ("addEventListener" in node) {
      node.addEventListener(type, handler, options);
      removeListener = () => node.removeEventListener(type, handler, options);
    } else {
      const legacyMediaQueryList = node;
      legacyMediaQueryList.addListener(handler);
      removeListener = () => legacyMediaQueryList.removeListener(handler);
    }
    listeners.push(removeListener);
    return self;
  }
  function clear() {
    listeners = listeners.filter((remove) => remove());
  }
  const self = {
    add,
    clear
  };
  return self;
}
function Animations(ownerDocument, ownerWindow, update, render) {
  const documentVisibleHandler = EventStore();
  const fixedTimeStep = 1e3 / 60;
  let lastTimeStamp = null;
  let accumulatedTime = 0;
  let animationId = 0;
  function init() {
    documentVisibleHandler.add(ownerDocument, "visibilitychange", () => {
      if (ownerDocument.hidden) reset();
    });
  }
  function destroy() {
    stop();
    documentVisibleHandler.clear();
  }
  function animate(timeStamp) {
    if (!animationId) return;
    if (!lastTimeStamp) {
      lastTimeStamp = timeStamp;
      update();
      update();
    }
    const timeElapsed = timeStamp - lastTimeStamp;
    lastTimeStamp = timeStamp;
    accumulatedTime += timeElapsed;
    while (accumulatedTime >= fixedTimeStep) {
      update();
      accumulatedTime -= fixedTimeStep;
    }
    const alpha = accumulatedTime / fixedTimeStep;
    render(alpha);
    if (animationId) {
      animationId = ownerWindow.requestAnimationFrame(animate);
    }
  }
  function start() {
    if (animationId) return;
    animationId = ownerWindow.requestAnimationFrame(animate);
  }
  function stop() {
    ownerWindow.cancelAnimationFrame(animationId);
    lastTimeStamp = null;
    accumulatedTime = 0;
    animationId = 0;
  }
  function reset() {
    lastTimeStamp = null;
    accumulatedTime = 0;
  }
  const self = {
    init,
    destroy,
    start,
    stop,
    update,
    render
  };
  return self;
}
function Axis(axis, contentDirection) {
  const isRightToLeft = contentDirection === "rtl";
  const isVertical = axis === "y";
  const scroll = isVertical ? "y" : "x";
  const cross = isVertical ? "x" : "y";
  const sign = !isVertical && isRightToLeft ? -1 : 1;
  const startEdge = getStartEdge();
  const endEdge = getEndEdge();
  function measureSize(nodeRect) {
    const {
      height,
      width
    } = nodeRect;
    return isVertical ? height : width;
  }
  function getStartEdge() {
    if (isVertical) return "top";
    return isRightToLeft ? "right" : "left";
  }
  function getEndEdge() {
    if (isVertical) return "bottom";
    return isRightToLeft ? "left" : "right";
  }
  function direction(n) {
    return n * sign;
  }
  const self = {
    scroll,
    cross,
    startEdge,
    endEdge,
    measureSize,
    direction
  };
  return self;
}
function Limit(min2 = 0, max2 = 0) {
  const length = mathAbs(min2 - max2);
  function reachedMin(n) {
    return n < min2;
  }
  function reachedMax(n) {
    return n > max2;
  }
  function reachedAny(n) {
    return reachedMin(n) || reachedMax(n);
  }
  function constrain(n) {
    if (!reachedAny(n)) return n;
    return reachedMin(n) ? min2 : max2;
  }
  function removeOffset(n) {
    if (!length) return n;
    return n - length * Math.ceil((n - max2) / length);
  }
  const self = {
    length,
    max: max2,
    min: min2,
    constrain,
    reachedAny,
    reachedMax,
    reachedMin,
    removeOffset
  };
  return self;
}
function Counter(max2, start, loop) {
  const {
    constrain
  } = Limit(0, max2);
  const loopEnd = max2 + 1;
  let counter4 = withinLimit(start);
  function withinLimit(n) {
    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);
  }
  function get() {
    return counter4;
  }
  function set(n) {
    counter4 = withinLimit(n);
    return self;
  }
  function add(n) {
    return clone().set(get() + n);
  }
  function clone() {
    return Counter(max2, get(), loop);
  }
  const self = {
    get,
    set,
    add,
    clone
  };
  return self;
}
function DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {
  const {
    cross: crossAxis,
    direction
  } = axis;
  const focusNodes = ["INPUT", "SELECT", "TEXTAREA"];
  const nonPassiveEvent = {
    passive: false
  };
  const initEvents = EventStore();
  const dragEvents = EventStore();
  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));
  const snapForceBoost = {
    mouse: 300,
    touch: 400
  };
  const freeForceBoost = {
    mouse: 500,
    touch: 600
  };
  const baseSpeed = dragFree ? 43 : 25;
  let isMoving = false;
  let startScroll = 0;
  let startCross = 0;
  let pointerIsDown = false;
  let preventScroll = false;
  let preventClick = false;
  let isMouse = false;
  function init(emblaApi) {
    if (!watchDrag) return;
    function downIfAllowed(evt) {
      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);
    }
    const node = rootNode;
    initEvents.add(node, "dragstart", (evt) => evt.preventDefault(), nonPassiveEvent).add(node, "touchmove", () => void 0, nonPassiveEvent).add(node, "touchend", () => void 0).add(node, "touchstart", downIfAllowed).add(node, "mousedown", downIfAllowed).add(node, "touchcancel", up).add(node, "contextmenu", up).add(node, "click", click, true);
  }
  function destroy() {
    initEvents.clear();
    dragEvents.clear();
  }
  function addDragEvents() {
    const node = isMouse ? ownerDocument : rootNode;
    dragEvents.add(node, "touchmove", move, nonPassiveEvent).add(node, "touchend", up).add(node, "mousemove", move, nonPassiveEvent).add(node, "mouseup", up);
  }
  function isFocusNode(node) {
    const nodeName = node.nodeName || "";
    return focusNodes.includes(nodeName);
  }
  function forceBoost() {
    const boost = dragFree ? freeForceBoost : snapForceBoost;
    const type = isMouse ? "mouse" : "touch";
    return boost[type];
  }
  function allowedForce(force, targetChanged) {
    const next = index.add(mathSign(force) * -1);
    const baseForce = scrollTarget.byDistance(force, !dragFree).distance;
    if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;
    if (skipSnaps && targetChanged) return baseForce * 0.5;
    return scrollTarget.byIndex(next.get(), 0).distance;
  }
  function down(evt) {
    const isMouseEvt = isMouseEvent2(evt, ownerWindow);
    isMouse = isMouseEvt;
    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;
    isMoving = deltaAbs(target.get(), location.get()) >= 2;
    if (isMouseEvt && evt.button !== 0) return;
    if (isFocusNode(evt.target)) return;
    pointerIsDown = true;
    dragTracker.pointerDown(evt);
    scrollBody.useFriction(0).useDuration(0);
    target.set(location);
    addDragEvents();
    startScroll = dragTracker.readPoint(evt);
    startCross = dragTracker.readPoint(evt, crossAxis);
    eventHandler.emit("pointerDown");
  }
  function move(evt) {
    const isTouchEvt = !isMouseEvent2(evt, ownerWindow);
    if (isTouchEvt && evt.touches.length >= 2) return up(evt);
    const lastScroll = dragTracker.readPoint(evt);
    const lastCross = dragTracker.readPoint(evt, crossAxis);
    const diffScroll = deltaAbs(lastScroll, startScroll);
    const diffCross = deltaAbs(lastCross, startCross);
    if (!preventScroll && !isMouse) {
      if (!evt.cancelable) return up(evt);
      preventScroll = diffScroll > diffCross;
      if (!preventScroll) return up(evt);
    }
    const diff = dragTracker.pointerMove(evt);
    if (diffScroll > dragThreshold) preventClick = true;
    scrollBody.useFriction(0.3).useDuration(0.75);
    animation.start();
    target.add(direction(diff));
    evt.preventDefault();
  }
  function up(evt) {
    const currentLocation = scrollTarget.byDistance(0, false);
    const targetChanged = currentLocation.index !== index.get();
    const rawForce = dragTracker.pointerUp(evt) * forceBoost();
    const force = allowedForce(direction(rawForce), targetChanged);
    const forceFactor = factorAbs(rawForce, force);
    const speed = baseSpeed - 10 * forceFactor;
    const friction = baseFriction + forceFactor / 50;
    preventScroll = false;
    pointerIsDown = false;
    dragEvents.clear();
    scrollBody.useDuration(speed).useFriction(friction);
    scrollTo.distance(force, !dragFree);
    isMouse = false;
    eventHandler.emit("pointerUp");
  }
  function click(evt) {
    if (preventClick) {
      evt.stopPropagation();
      evt.preventDefault();
      preventClick = false;
    }
  }
  function pointerDown() {
    return pointerIsDown;
  }
  const self = {
    init,
    destroy,
    pointerDown
  };
  return self;
}
function DragTracker(axis, ownerWindow) {
  const logInterval = 170;
  let startEvent;
  let lastEvent;
  function readTime(evt) {
    return evt.timeStamp;
  }
  function readPoint(evt, evtAxis) {
    const property = evtAxis || axis.scroll;
    const coord = `client${property === "x" ? "X" : "Y"}`;
    return (isMouseEvent2(evt, ownerWindow) ? evt : evt.touches[0])[coord];
  }
  function pointerDown(evt) {
    startEvent = evt;
    lastEvent = evt;
    return readPoint(evt);
  }
  function pointerMove(evt) {
    const diff = readPoint(evt) - readPoint(lastEvent);
    const expired = readTime(evt) - readTime(startEvent) > logInterval;
    lastEvent = evt;
    if (expired) startEvent = evt;
    return diff;
  }
  function pointerUp(evt) {
    if (!startEvent || !lastEvent) return 0;
    const diffDrag = readPoint(lastEvent) - readPoint(startEvent);
    const diffTime = readTime(evt) - readTime(startEvent);
    const expired = readTime(evt) - readTime(lastEvent) > logInterval;
    const force = diffDrag / diffTime;
    const isFlick = diffTime && !expired && mathAbs(force) > 0.1;
    return isFlick ? force : 0;
  }
  const self = {
    pointerDown,
    pointerMove,
    pointerUp,
    readPoint
  };
  return self;
}
function NodeRects() {
  function measure(node) {
    const {
      offsetTop,
      offsetLeft,
      offsetWidth,
      offsetHeight
    } = node;
    const offset4 = {
      top: offsetTop,
      right: offsetLeft + offsetWidth,
      bottom: offsetTop + offsetHeight,
      left: offsetLeft,
      width: offsetWidth,
      height: offsetHeight
    };
    return offset4;
  }
  const self = {
    measure
  };
  return self;
}
function PercentOfView(viewSize) {
  function measure(n) {
    return viewSize * (n / 100);
  }
  const self = {
    measure
  };
  return self;
}
function ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {
  const observeNodes = [container].concat(slides);
  let resizeObserver;
  let containerSize;
  let slideSizes = [];
  let destroyed = false;
  function readSize(node) {
    return axis.measureSize(nodeRects.measure(node));
  }
  function init(emblaApi) {
    if (!watchResize) return;
    containerSize = readSize(container);
    slideSizes = slides.map(readSize);
    function defaultCallback(entries) {
      for (const entry of entries) {
        if (destroyed) return;
        const isContainer = entry.target === container;
        const slideIndex = slides.indexOf(entry.target);
        const lastSize = isContainer ? containerSize : slideSizes[slideIndex];
        const newSize = readSize(isContainer ? container : slides[slideIndex]);
        const diffSize = mathAbs(newSize - lastSize);
        if (diffSize >= 0.5) {
          emblaApi.reInit();
          eventHandler.emit("resize");
          break;
        }
      }
    }
    resizeObserver = new ResizeObserver((entries) => {
      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {
        defaultCallback(entries);
      }
    });
    ownerWindow.requestAnimationFrame(() => {
      observeNodes.forEach((node) => resizeObserver.observe(node));
    });
  }
  function destroy() {
    destroyed = true;
    if (resizeObserver) resizeObserver.disconnect();
  }
  const self = {
    init,
    destroy
  };
  return self;
}
function ScrollBody(location, offsetLocation, previousLocation, target, baseDuration, baseFriction) {
  let scrollVelocity = 0;
  let scrollDirection = 0;
  let scrollDuration = baseDuration;
  let scrollFriction = baseFriction;
  let rawLocation = location.get();
  let rawLocationPrevious = 0;
  function seek() {
    const displacement = target.get() - location.get();
    const isInstant = !scrollDuration;
    let scrollDistance = 0;
    if (isInstant) {
      scrollVelocity = 0;
      previousLocation.set(target);
      location.set(target);
      scrollDistance = displacement;
    } else {
      previousLocation.set(location);
      scrollVelocity += displacement / scrollDuration;
      scrollVelocity *= scrollFriction;
      rawLocation += scrollVelocity;
      location.add(scrollVelocity);
      scrollDistance = rawLocation - rawLocationPrevious;
    }
    scrollDirection = mathSign(scrollDistance);
    rawLocationPrevious = rawLocation;
    return self;
  }
  function settled() {
    const diff = target.get() - offsetLocation.get();
    return mathAbs(diff) < 1e-3;
  }
  function duration() {
    return scrollDuration;
  }
  function direction() {
    return scrollDirection;
  }
  function velocity() {
    return scrollVelocity;
  }
  function useBaseDuration() {
    return useDuration(baseDuration);
  }
  function useBaseFriction() {
    return useFriction(baseFriction);
  }
  function useDuration(n) {
    scrollDuration = n;
    return self;
  }
  function useFriction(n) {
    scrollFriction = n;
    return self;
  }
  const self = {
    direction,
    duration,
    velocity,
    seek,
    settled,
    useBaseFriction,
    useBaseDuration,
    useFriction,
    useDuration
  };
  return self;
}
function ScrollBounds(limit, location, target, scrollBody, percentOfView) {
  const pullBackThreshold = percentOfView.measure(10);
  const edgeOffsetTolerance = percentOfView.measure(50);
  const frictionLimit = Limit(0.1, 0.99);
  let disabled = false;
  function shouldConstrain() {
    if (disabled) return false;
    if (!limit.reachedAny(target.get())) return false;
    if (!limit.reachedAny(location.get())) return false;
    return true;
  }
  function constrain(pointerDown) {
    if (!shouldConstrain()) return;
    const edge = limit.reachedMin(location.get()) ? "min" : "max";
    const diffToEdge = mathAbs(limit[edge] - location.get());
    const diffToTarget = target.get() - location.get();
    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);
    target.subtract(diffToTarget * friction);
    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {
      target.set(limit.constrain(target.get()));
      scrollBody.useDuration(25).useBaseFriction();
    }
  }
  function toggleActive(active) {
    disabled = !active;
  }
  const self = {
    shouldConstrain,
    constrain,
    toggleActive
  };
  return self;
}
function ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {
  const scrollBounds = Limit(-contentSize + viewSize, 0);
  const snapsBounded = measureBounded();
  const scrollContainLimit = findScrollContainLimit();
  const snapsContained = measureContained();
  function usePixelTolerance(bound, snap) {
    return deltaAbs(bound, snap) <= 1;
  }
  function findScrollContainLimit() {
    const startSnap = snapsBounded[0];
    const endSnap = arrayLast(snapsBounded);
    const min2 = snapsBounded.lastIndexOf(startSnap);
    const max2 = snapsBounded.indexOf(endSnap) + 1;
    return Limit(min2, max2);
  }
  function measureBounded() {
    return snapsAligned.map((snapAligned, index) => {
      const {
        min: min2,
        max: max2
      } = scrollBounds;
      const snap = scrollBounds.constrain(snapAligned);
      const isFirst = !index;
      const isLast = arrayIsLastIndex(snapsAligned, index);
      if (isFirst) return max2;
      if (isLast) return min2;
      if (usePixelTolerance(min2, snap)) return min2;
      if (usePixelTolerance(max2, snap)) return max2;
      return snap;
    }).map((scrollBound) => parseFloat(scrollBound.toFixed(3)));
  }
  function measureContained() {
    if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max];
    if (containScroll === "keepSnaps") return snapsBounded;
    const {
      min: min2,
      max: max2
    } = scrollContainLimit;
    return snapsBounded.slice(min2, max2);
  }
  const self = {
    snapsContained,
    scrollContainLimit
  };
  return self;
}
function ScrollLimit(contentSize, scrollSnaps, loop) {
  const max2 = scrollSnaps[0];
  const min2 = loop ? max2 - contentSize : arrayLast(scrollSnaps);
  const limit = Limit(min2, max2);
  const self = {
    limit
  };
  return self;
}
function ScrollLooper(contentSize, limit, location, vectors) {
  const jointSafety = 0.1;
  const min2 = limit.min + jointSafety;
  const max2 = limit.max + jointSafety;
  const {
    reachedMin,
    reachedMax
  } = Limit(min2, max2);
  function shouldLoop(direction) {
    if (direction === 1) return reachedMax(location.get());
    if (direction === -1) return reachedMin(location.get());
    return false;
  }
  function loop(direction) {
    if (!shouldLoop(direction)) return;
    const loopDistance = contentSize * (direction * -1);
    vectors.forEach((v) => v.add(loopDistance));
  }
  const self = {
    loop
  };
  return self;
}
function ScrollProgress(limit) {
  const {
    max: max2,
    length
  } = limit;
  function get(n) {
    const currentLocation = n - max2;
    return length ? currentLocation / -length : 0;
  }
  const self = {
    get
  };
  return self;
}
function ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {
  const {
    startEdge,
    endEdge
  } = axis;
  const {
    groupSlides
  } = slidesToScroll;
  const alignments2 = measureSizes().map(alignment.measure);
  const snaps = measureUnaligned();
  const snapsAligned = measureAligned();
  function measureSizes() {
    return groupSlides(slideRects).map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);
  }
  function measureUnaligned() {
    return slideRects.map((rect) => containerRect[startEdge] - rect[startEdge]).map((snap) => -mathAbs(snap));
  }
  function measureAligned() {
    return groupSlides(snaps).map((g) => g[0]).map((snap, index) => snap + alignments2[index]);
  }
  const self = {
    snaps,
    snapsAligned
  };
  return self;
}
function SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {
  const {
    groupSlides
  } = slidesToScroll;
  const {
    min: min2,
    max: max2
  } = scrollContainLimit;
  const slideRegistry = createSlideRegistry();
  function createSlideRegistry() {
    const groupedSlideIndexes = groupSlides(slideIndexes);
    const doNotContain = !containSnaps || containScroll === "keepSnaps";
    if (scrollSnaps.length === 1) return [slideIndexes];
    if (doNotContain) return groupedSlideIndexes;
    return groupedSlideIndexes.slice(min2, max2).map((group, index, groups) => {
      const isFirst = !index;
      const isLast = arrayIsLastIndex(groups, index);
      if (isFirst) {
        const range = arrayLast(groups[0]) + 1;
        return arrayFromNumber(range);
      }
      if (isLast) {
        const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;
        return arrayFromNumber(range, arrayLast(groups)[0]);
      }
      return group;
    });
  }
  const self = {
    slideRegistry
  };
  return self;
}
function ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {
  const {
    reachedAny,
    removeOffset,
    constrain
  } = limit;
  function minDistance(distances) {
    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0];
  }
  function findTargetSnap(target) {
    const distance = loop ? removeOffset(target) : constrain(target);
    const ascDiffsToSnaps = scrollSnaps.map((snap, index2) => ({
      diff: shortcut(snap - distance, 0),
      index: index2
    })).sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff));
    const {
      index
    } = ascDiffsToSnaps[0];
    return {
      index,
      distance
    };
  }
  function shortcut(target, direction) {
    const targets = [target, target + contentSize, target - contentSize];
    if (!loop) return target;
    if (!direction) return minDistance(targets);
    const matchingTargets = targets.filter((t) => mathSign(t) === direction);
    if (matchingTargets.length) return minDistance(matchingTargets);
    return arrayLast(targets) - contentSize;
  }
  function byIndex(index, direction) {
    const diffToSnap = scrollSnaps[index] - targetVector.get();
    const distance = shortcut(diffToSnap, direction);
    return {
      index,
      distance
    };
  }
  function byDistance(distance, snap) {
    const target = targetVector.get() + distance;
    const {
      index,
      distance: targetSnapDistance
    } = findTargetSnap(target);
    const reachedBound = !loop && reachedAny(target);
    if (!snap || reachedBound) return {
      index,
      distance
    };
    const diffToSnap = scrollSnaps[index] - targetSnapDistance;
    const snapDistance = distance + shortcut(diffToSnap, 0);
    return {
      index,
      distance: snapDistance
    };
  }
  const self = {
    byDistance,
    byIndex,
    shortcut
  };
  return self;
}
function ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {
  function scrollTo(target) {
    const distanceDiff = target.distance;
    const indexDiff = target.index !== indexCurrent.get();
    targetVector.add(distanceDiff);
    if (distanceDiff) {
      if (scrollBody.duration()) {
        animation.start();
      } else {
        animation.update();
        animation.render(1);
        animation.update();
      }
    }
    if (indexDiff) {
      indexPrevious.set(indexCurrent.get());
      indexCurrent.set(target.index);
      eventHandler.emit("select");
    }
  }
  function distance(n, snap) {
    const target = scrollTarget.byDistance(n, snap);
    scrollTo(target);
  }
  function index(n, direction) {
    const targetIndex = indexCurrent.clone().set(n);
    const target = scrollTarget.byIndex(targetIndex.get(), direction);
    scrollTo(target);
  }
  const self = {
    distance,
    index
  };
  return self;
}
function SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {
  const focusListenerOptions = {
    passive: true,
    capture: true
  };
  let lastTabPressTime = 0;
  function init(emblaApi) {
    if (!watchFocus) return;
    function defaultCallback(index) {
      const nowTime = (/* @__PURE__ */ new Date()).getTime();
      const diffTime = nowTime - lastTabPressTime;
      if (diffTime > 10) return;
      eventHandler.emit("slideFocusStart");
      root.scrollLeft = 0;
      const group = slideRegistry.findIndex((group2) => group2.includes(index));
      if (!isNumber(group)) return;
      scrollBody.useDuration(0);
      scrollTo.index(group, 0);
      eventHandler.emit("slideFocus");
    }
    eventStore.add(document, "keydown", registerTabPress, false);
    slides.forEach((slide, slideIndex) => {
      eventStore.add(slide, "focus", (evt) => {
        if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {
          defaultCallback(slideIndex);
        }
      }, focusListenerOptions);
    });
  }
  function registerTabPress(event) {
    if (event.code === "Tab") lastTabPressTime = (/* @__PURE__ */ new Date()).getTime();
  }
  const self = {
    init
  };
  return self;
}
function Vector1D(initialValue) {
  let value = initialValue;
  function get() {
    return value;
  }
  function set(n) {
    value = normalizeInput(n);
  }
  function add(n) {
    value += normalizeInput(n);
  }
  function subtract(n) {
    value -= normalizeInput(n);
  }
  function normalizeInput(n) {
    return isNumber(n) ? n : n.get();
  }
  const self = {
    get,
    set,
    add,
    subtract
  };
  return self;
}
function Translate(axis, container) {
  const translate = axis.scroll === "x" ? x : y;
  const containerStyle = container.style;
  let previousTarget = null;
  let disabled = false;
  function x(n) {
    return `translate3d(${n}px,0px,0px)`;
  }
  function y(n) {
    return `translate3d(0px,${n}px,0px)`;
  }
  function to(target) {
    if (disabled) return;
    const newTarget = roundToTwoDecimals(axis.direction(target));
    if (newTarget === previousTarget) return;
    containerStyle.transform = translate(newTarget);
    previousTarget = newTarget;
  }
  function toggleActive(active) {
    disabled = !active;
  }
  function clear() {
    if (disabled) return;
    containerStyle.transform = "";
    if (!container.getAttribute("style")) container.removeAttribute("style");
  }
  const self = {
    clear,
    to,
    toggleActive
  };
  return self;
}
function SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location, slides) {
  const roundingSafety = 0.5;
  const ascItems = arrayKeys(slideSizesWithGaps);
  const descItems = arrayKeys(slideSizesWithGaps).reverse();
  const loopPoints = startPoints().concat(endPoints());
  function removeSlideSizes(indexes, from) {
    return indexes.reduce((a, i) => {
      return a - slideSizesWithGaps[i];
    }, from);
  }
  function slidesInGap(indexes, gap) {
    return indexes.reduce((a, i) => {
      const remainingGap = removeSlideSizes(a, gap);
      return remainingGap > 0 ? a.concat([i]) : a;
    }, []);
  }
  function findSlideBounds(offset4) {
    return snaps.map((snap, index) => ({
      start: snap - slideSizes[index] + roundingSafety + offset4,
      end: snap + viewSize - roundingSafety + offset4
    }));
  }
  function findLoopPoints(indexes, offset4, isEndEdge) {
    const slideBounds = findSlideBounds(offset4);
    return indexes.map((index) => {
      const initial = isEndEdge ? 0 : -contentSize;
      const altered = isEndEdge ? contentSize : 0;
      const boundEdge = isEndEdge ? "end" : "start";
      const loopPoint = slideBounds[index][boundEdge];
      return {
        index,
        loopPoint,
        slideLocation: Vector1D(-1),
        translate: Translate(axis, slides[index]),
        target: () => location.get() > loopPoint ? initial : altered
      };
    });
  }
  function startPoints() {
    const gap = scrollSnaps[0];
    const indexes = slidesInGap(descItems, gap);
    return findLoopPoints(indexes, contentSize, false);
  }
  function endPoints() {
    const gap = viewSize - scrollSnaps[0] - 1;
    const indexes = slidesInGap(ascItems, gap);
    return findLoopPoints(indexes, -contentSize, true);
  }
  function canLoop() {
    return loopPoints.every(({
      index
    }) => {
      const otherIndexes = ascItems.filter((i) => i !== index);
      return removeSlideSizes(otherIndexes, viewSize) <= 0.1;
    });
  }
  function loop() {
    loopPoints.forEach((loopPoint) => {
      const {
        target,
        translate,
        slideLocation
      } = loopPoint;
      const shiftLocation = target();
      if (shiftLocation === slideLocation.get()) return;
      translate.to(shiftLocation);
      slideLocation.set(shiftLocation);
    });
  }
  function clear() {
    loopPoints.forEach((loopPoint) => loopPoint.translate.clear());
  }
  const self = {
    canLoop,
    clear,
    loop,
    loopPoints
  };
  return self;
}
function SlidesHandler(container, eventHandler, watchSlides) {
  let mutationObserver;
  let destroyed = false;
  function init(emblaApi) {
    if (!watchSlides) return;
    function defaultCallback(mutations) {
      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          emblaApi.reInit();
          eventHandler.emit("slidesChanged");
          break;
        }
      }
    }
    mutationObserver = new MutationObserver((mutations) => {
      if (destroyed) return;
      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {
        defaultCallback(mutations);
      }
    });
    mutationObserver.observe(container, {
      childList: true
    });
  }
  function destroy() {
    if (mutationObserver) mutationObserver.disconnect();
    destroyed = true;
  }
  const self = {
    init,
    destroy
  };
  return self;
}
function SlidesInView(container, slides, eventHandler, threshold) {
  const intersectionEntryMap = {};
  let inViewCache = null;
  let notInViewCache = null;
  let intersectionObserver;
  let destroyed = false;
  function init() {
    intersectionObserver = new IntersectionObserver((entries) => {
      if (destroyed) return;
      entries.forEach((entry) => {
        const index = slides.indexOf(entry.target);
        intersectionEntryMap[index] = entry;
      });
      inViewCache = null;
      notInViewCache = null;
      eventHandler.emit("slidesInView");
    }, {
      root: container.parentElement,
      threshold
    });
    slides.forEach((slide) => intersectionObserver.observe(slide));
  }
  function destroy() {
    if (intersectionObserver) intersectionObserver.disconnect();
    destroyed = true;
  }
  function createInViewList(inView) {
    return objectKeys(intersectionEntryMap).reduce((list, slideIndex) => {
      const index = parseInt(slideIndex);
      const {
        isIntersecting
      } = intersectionEntryMap[index];
      const inViewMatch = inView && isIntersecting;
      const notInViewMatch = !inView && !isIntersecting;
      if (inViewMatch || notInViewMatch) list.push(index);
      return list;
    }, []);
  }
  function get(inView = true) {
    if (inView && inViewCache) return inViewCache;
    if (!inView && notInViewCache) return notInViewCache;
    const slideIndexes = createInViewList(inView);
    if (inView) inViewCache = slideIndexes;
    if (!inView) notInViewCache = slideIndexes;
    return slideIndexes;
  }
  const self = {
    init,
    destroy,
    get
  };
  return self;
}
function SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {
  const {
    measureSize,
    startEdge,
    endEdge
  } = axis;
  const withEdgeGap = slideRects[0] && readEdgeGap;
  const startGap = measureStartGap();
  const endGap = measureEndGap();
  const slideSizes = slideRects.map(measureSize);
  const slideSizesWithGaps = measureWithGaps();
  function measureStartGap() {
    if (!withEdgeGap) return 0;
    const slideRect = slideRects[0];
    return mathAbs(containerRect[startEdge] - slideRect[startEdge]);
  }
  function measureEndGap() {
    if (!withEdgeGap) return 0;
    const style = ownerWindow.getComputedStyle(arrayLast(slides));
    return parseFloat(style.getPropertyValue(`margin-${endEdge}`));
  }
  function measureWithGaps() {
    return slideRects.map((rect, index, rects) => {
      const isFirst = !index;
      const isLast = arrayIsLastIndex(rects, index);
      if (isFirst) return slideSizes[index] + startGap;
      if (isLast) return slideSizes[index] + endGap;
      return rects[index + 1][startEdge] - rect[startEdge];
    }).map(mathAbs);
  }
  const self = {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  };
  return self;
}
function SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {
  const {
    startEdge,
    endEdge,
    direction
  } = axis;
  const groupByNumber = isNumber(slidesToScroll);
  function byNumber(array, groupSize) {
    return arrayKeys(array).filter((i) => i % groupSize === 0).map((i) => array.slice(i, i + groupSize));
  }
  function bySize(array) {
    if (!array.length) return [];
    return arrayKeys(array).reduce((groups, rectB, index) => {
      const rectA = arrayLast(groups) || 0;
      const isFirst = rectA === 0;
      const isLast = rectB === arrayLastIndex(array);
      const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];
      const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];
      const gapA = !loop && isFirst ? direction(startGap) : 0;
      const gapB = !loop && isLast ? direction(endGap) : 0;
      const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));
      if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB);
      if (isLast) groups.push(array.length);
      return groups;
    }, []).map((currentSize, index, groups) => {
      const previousSize = Math.max(groups[index - 1] || 0);
      return array.slice(previousSize, currentSize);
    });
  }
  function groupSlides(array) {
    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);
  }
  const self = {
    groupSlides
  };
  return self;
}
function Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {
  const {
    align,
    axis: scrollAxis,
    direction,
    startIndex,
    loop,
    duration,
    dragFree,
    dragThreshold,
    inViewThreshold,
    slidesToScroll: groupSlides,
    skipSnaps,
    containScroll,
    watchResize,
    watchSlides,
    watchDrag,
    watchFocus
  } = options;
  const pixelTolerance = 2;
  const nodeRects = NodeRects();
  const containerRect = nodeRects.measure(container);
  const slideRects = slides.map(nodeRects.measure);
  const axis = Axis(scrollAxis, direction);
  const viewSize = axis.measureSize(containerRect);
  const percentOfView = PercentOfView(viewSize);
  const alignment = Alignment(align, viewSize);
  const containSnaps = !loop && !!containScroll;
  const readEdgeGap = loop || !!containScroll;
  const {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);
  const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);
  const {
    snaps,
    snapsAligned
  } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);
  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);
  const {
    snapsContained,
    scrollContainLimit
  } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);
  const scrollSnaps = containSnaps ? snapsContained : snapsAligned;
  const {
    limit
  } = ScrollLimit(contentSize, scrollSnaps, loop);
  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);
  const indexPrevious = index.clone();
  const slideIndexes = arrayKeys(slides);
  const update = ({
    dragHandler,
    scrollBody: scrollBody2,
    scrollBounds,
    options: {
      loop: loop2
    }
  }) => {
    if (!loop2) scrollBounds.constrain(dragHandler.pointerDown());
    scrollBody2.seek();
  };
  const render = ({
    scrollBody: scrollBody2,
    translate,
    location: location2,
    offsetLocation: offsetLocation2,
    previousLocation: previousLocation2,
    scrollLooper,
    slideLooper,
    dragHandler,
    animation: animation2,
    eventHandler: eventHandler2,
    scrollBounds,
    options: {
      loop: loop2
    }
  }, alpha) => {
    const shouldSettle = scrollBody2.settled();
    const withinBounds = !scrollBounds.shouldConstrain();
    const hasSettled = loop2 ? shouldSettle : shouldSettle && withinBounds;
    const hasSettledAndIdle = hasSettled && !dragHandler.pointerDown();
    if (hasSettledAndIdle) animation2.stop();
    const interpolatedLocation = location2.get() * alpha + previousLocation2.get() * (1 - alpha);
    offsetLocation2.set(interpolatedLocation);
    if (loop2) {
      scrollLooper.loop(scrollBody2.direction());
      slideLooper.loop();
    }
    translate.to(offsetLocation2.get());
    if (hasSettledAndIdle) eventHandler2.emit("settle");
    if (!hasSettled) eventHandler2.emit("scroll");
  };
  const animation = Animations(ownerDocument, ownerWindow, () => update(engine), (alpha) => render(engine, alpha));
  const friction = 0.68;
  const startLocation = scrollSnaps[index.get()];
  const location = Vector1D(startLocation);
  const previousLocation = Vector1D(startLocation);
  const offsetLocation = Vector1D(startLocation);
  const target = Vector1D(startLocation);
  const scrollBody = ScrollBody(location, offsetLocation, previousLocation, target, duration, friction);
  const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);
  const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);
  const scrollProgress = ScrollProgress(limit);
  const eventStore = EventStore();
  const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);
  const {
    slideRegistry
  } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);
  const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);
  const engine = {
    ownerDocument,
    ownerWindow,
    eventHandler,
    containerRect,
    slideRects,
    animation,
    axis,
    dragHandler: DragHandler(axis, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),
    eventStore,
    percentOfView,
    index,
    indexPrevious,
    limit,
    location,
    offsetLocation,
    previousLocation,
    options,
    resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),
    scrollBody,
    scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),
    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [location, offsetLocation, previousLocation, target]),
    scrollProgress,
    scrollSnapList: scrollSnaps.map(scrollProgress.get),
    scrollSnaps,
    scrollTarget,
    scrollTo,
    slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),
    slideFocus,
    slidesHandler: SlidesHandler(container, eventHandler, watchSlides),
    slidesInView,
    slideIndexes,
    slideRegistry,
    slidesToScroll,
    target,
    translate: Translate(axis, container)
  };
  return engine;
}
function EventHandler() {
  let listeners = {};
  let api;
  function init(emblaApi) {
    api = emblaApi;
  }
  function getListeners(evt) {
    return listeners[evt] || [];
  }
  function emit(evt) {
    getListeners(evt).forEach((e) => e(api, evt));
    return self;
  }
  function on(evt, cb) {
    listeners[evt] = getListeners(evt).concat([cb]);
    return self;
  }
  function off(evt, cb) {
    listeners[evt] = getListeners(evt).filter((e) => e !== cb);
    return self;
  }
  function clear() {
    listeners = {};
  }
  const self = {
    init,
    emit,
    off,
    on,
    clear
  };
  return self;
}
var defaultOptions2 = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: false,
  dragThreshold: 10,
  loop: false,
  skipSnaps: false,
  duration: 25,
  startIndex: 0,
  active: true,
  watchDrag: true,
  watchResize: true,
  watchSlides: true,
  watchFocus: true
};
function OptionsHandler(ownerWindow) {
  function mergeOptions(optionsA, optionsB) {
    return objectsMergeDeep(optionsA, optionsB || {});
  }
  function optionsAtMedia(options) {
    const optionsAtMedia2 = options.breakpoints || {};
    const matchedMediaOptions = objectKeys(optionsAtMedia2).filter((media) => ownerWindow.matchMedia(media).matches).map((media) => optionsAtMedia2[media]).reduce((a, mediaOption) => mergeOptions(a, mediaOption), {});
    return mergeOptions(options, matchedMediaOptions);
  }
  function optionsMediaQueries(optionsList) {
    return optionsList.map((options) => objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries) => acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);
  }
  const self = {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  };
  return self;
}
function PluginsHandler(optionsHandler) {
  let activePlugins = [];
  function init(emblaApi, plugins) {
    activePlugins = plugins.filter(({
      options
    }) => optionsHandler.optionsAtMedia(options).active !== false);
    activePlugins.forEach((plugin) => plugin.init(emblaApi, optionsHandler));
    return plugins.reduce((map, plugin) => Object.assign(map, {
      [plugin.name]: plugin
    }), {});
  }
  function destroy() {
    activePlugins = activePlugins.filter((plugin) => plugin.destroy());
  }
  const self = {
    init,
    destroy
  };
  return self;
}
function EmblaCarousel(root, userOptions, userPlugins) {
  const ownerDocument = root.ownerDocument;
  const ownerWindow = ownerDocument.defaultView;
  const optionsHandler = OptionsHandler(ownerWindow);
  const pluginsHandler = PluginsHandler(optionsHandler);
  const mediaHandlers = EventStore();
  const eventHandler = EventHandler();
  const {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  } = optionsHandler;
  const {
    on,
    off,
    emit
  } = eventHandler;
  const reInit = reActivate;
  let destroyed = false;
  let engine;
  let optionsBase = mergeOptions(defaultOptions2, EmblaCarousel.globalOptions);
  let options = mergeOptions(optionsBase);
  let pluginList = [];
  let pluginApis;
  let container;
  let slides;
  function storeElements() {
    const {
      container: userContainer,
      slides: userSlides
    } = options;
    const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;
    container = customContainer || root.children[0];
    const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;
    slides = [].slice.call(customSlides || container.children);
  }
  function createEngine(options2) {
    const engine2 = Engine(root, container, slides, ownerDocument, ownerWindow, options2, eventHandler);
    if (options2.loop && !engine2.slideLooper.canLoop()) {
      const optionsWithoutLoop = Object.assign({}, options2, {
        loop: false
      });
      return createEngine(optionsWithoutLoop);
    }
    return engine2;
  }
  function activate(withOptions, withPlugins) {
    if (destroyed) return;
    optionsBase = mergeOptions(optionsBase, withOptions);
    options = optionsAtMedia(optionsBase);
    pluginList = withPlugins || pluginList;
    storeElements();
    engine = createEngine(options);
    optionsMediaQueries([optionsBase, ...pluginList.map(({
      options: options2
    }) => options2)]).forEach((query) => mediaHandlers.add(query, "change", reActivate));
    if (!options.active) return;
    engine.translate.to(engine.location.get());
    engine.animation.init();
    engine.slidesInView.init();
    engine.slideFocus.init(self);
    engine.eventHandler.init(self);
    engine.resizeHandler.init(self);
    engine.slidesHandler.init(self);
    if (engine.options.loop) engine.slideLooper.loop();
    if (container.offsetParent && slides.length) engine.dragHandler.init(self);
    pluginApis = pluginsHandler.init(self, pluginList);
  }
  function reActivate(withOptions, withPlugins) {
    const startIndex = selectedScrollSnap();
    deActivate();
    activate(mergeOptions({
      startIndex
    }, withOptions), withPlugins);
    eventHandler.emit("reInit");
  }
  function deActivate() {
    engine.dragHandler.destroy();
    engine.eventStore.clear();
    engine.translate.clear();
    engine.slideLooper.clear();
    engine.resizeHandler.destroy();
    engine.slidesHandler.destroy();
    engine.slidesInView.destroy();
    engine.animation.destroy();
    pluginsHandler.destroy();
    mediaHandlers.clear();
  }
  function destroy() {
    if (destroyed) return;
    destroyed = true;
    mediaHandlers.clear();
    deActivate();
    eventHandler.emit("destroy");
    eventHandler.clear();
  }
  function scrollTo(index, jump, direction) {
    if (!options.active || destroyed) return;
    engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);
    engine.scrollTo.index(index, direction || 0);
  }
  function scrollNext(jump) {
    const next = engine.index.add(1).get();
    scrollTo(next, jump, -1);
  }
  function scrollPrev(jump) {
    const prev = engine.index.add(-1).get();
    scrollTo(prev, jump, 1);
  }
  function canScrollNext() {
    const next = engine.index.add(1).get();
    return next !== selectedScrollSnap();
  }
  function canScrollPrev() {
    const prev = engine.index.add(-1).get();
    return prev !== selectedScrollSnap();
  }
  function scrollSnapList() {
    return engine.scrollSnapList;
  }
  function scrollProgress() {
    return engine.scrollProgress.get(engine.offsetLocation.get());
  }
  function selectedScrollSnap() {
    return engine.index.get();
  }
  function previousScrollSnap() {
    return engine.indexPrevious.get();
  }
  function slidesInView() {
    return engine.slidesInView.get();
  }
  function slidesNotInView() {
    return engine.slidesInView.get(false);
  }
  function plugins() {
    return pluginApis;
  }
  function internalEngine() {
    return engine;
  }
  function rootNode() {
    return root;
  }
  function containerNode() {
    return container;
  }
  function slideNodes() {
    return slides;
  }
  const self = {
    canScrollNext,
    canScrollPrev,
    containerNode,
    internalEngine,
    destroy,
    off,
    on,
    emit,
    plugins,
    previousScrollSnap,
    reInit,
    rootNode,
    scrollNext,
    scrollPrev,
    scrollProgress,
    scrollSnapList,
    scrollTo,
    selectedScrollSnap,
    slideNodes,
    slidesInView,
    slidesNotInView
  };
  activate(userOptions, userPlugins);
  setTimeout(() => eventHandler.emit("init"), 0);
  return self;
}
EmblaCarousel.globalOptions = void 0;

// node_modules/@fluentui/react-carousel/lib/components/useEmblaCarousel.js
var React593 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselCard/useCarouselCardStyles.styles.js
var carouselCardClassNames = {
  root: "fui-CarouselCard"
};
var useStyles89 = __styles2({
  root: {
    xawz: 0,
    Bh6795r: 0,
    Bnnss6s: 0,
    fkmc3a: "fg68ejw",
    B2u0y6b: "f6dzj5z"
  },
  autoSize: {
    xawz: 0,
    Bh6795r: 0,
    Bnnss6s: 0,
    fkmc3a: "fd9q35j",
    Bf4jedk: "fy77jfu",
    a9b677: "f14z66ap",
    B2u0y6b: "f6dzj5z"
  }
}, {
  d: [[".fg68ejw{flex:0 0 100%;}", {
    p: -1
  }], ".f6dzj5z{max-width:100%;}", [".fd9q35j{flex:0 0 auto;}", {
    p: -1
  }], ".fy77jfu{min-width:0;}", ".f14z66ap{width:auto;}"]
});
var useCarouselCardStyles_unstable = (state) => {
  "use no memo";
  const {
    autoSize
  } = state;
  const styles = useStyles89();
  state.root.className = mergeClasses(carouselCardClassNames.root, styles.root, autoSize && styles.autoSize, state.root.className);
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/useCarouselSliderStyles.styles.js
var carouselSliderClassNames = {
  root: "fui-CarouselSlider"
};
var useStyles90 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Eiaeu8: "f1115ve7"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1115ve7{overflow-anchor:none;}"]
});
var useCarouselSliderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles90();
  state.root.className = mergeClasses(carouselSliderClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/embla-carousel-autoplay/esm/embla-carousel-autoplay.esm.js
var defaultOptions3 = {
  active: true,
  breakpoints: {},
  delay: 4e3,
  jump: false,
  playOnInit: true,
  stopOnFocusIn: true,
  stopOnInteraction: true,
  stopOnMouseEnter: false,
  stopOnLastSnap: false,
  rootNode: null
};
function normalizeDelay(emblaApi, delay) {
  const scrollSnaps = emblaApi.scrollSnapList();
  if (typeof delay === "number") {
    return scrollSnaps.map(() => delay);
  }
  return delay(scrollSnaps, emblaApi);
}
function getAutoplayRootNode(emblaApi, rootNode) {
  const emblaRootNode = emblaApi.rootNode();
  return rootNode && rootNode(emblaRootNode) || emblaRootNode;
}
function Autoplay(userOptions = {}) {
  let options;
  let emblaApi;
  let destroyed;
  let delay;
  let timerStartTime = null;
  let timerId = 0;
  let autoplayActive = false;
  let mouseIsOver = false;
  let playOnDocumentVisible = false;
  let jump = false;
  function init(emblaApiInstance, optionsHandler) {
    emblaApi = emblaApiInstance;
    const {
      mergeOptions,
      optionsAtMedia
    } = optionsHandler;
    const optionsBase = mergeOptions(defaultOptions3, Autoplay.globalOptions);
    const allOptions = mergeOptions(optionsBase, userOptions);
    options = optionsAtMedia(allOptions);
    if (emblaApi.scrollSnapList().length <= 1) return;
    jump = options.jump;
    destroyed = false;
    delay = normalizeDelay(emblaApi, options.delay);
    const {
      eventStore,
      ownerDocument
    } = emblaApi.internalEngine();
    const isDraggable = !!emblaApi.internalEngine().options.watchDrag;
    const root = getAutoplayRootNode(emblaApi, options.rootNode);
    eventStore.add(ownerDocument, "visibilitychange", visibilityChange);
    if (isDraggable) {
      emblaApi.on("pointerDown", pointerDown);
    }
    if (isDraggable && !options.stopOnInteraction) {
      emblaApi.on("pointerUp", pointerUp);
    }
    if (options.stopOnMouseEnter) {
      eventStore.add(root, "mouseenter", mouseEnter);
    }
    if (options.stopOnMouseEnter && !options.stopOnInteraction) {
      eventStore.add(root, "mouseleave", mouseLeave);
    }
    if (options.stopOnFocusIn) {
      emblaApi.on("slideFocusStart", stopAutoplay);
    }
    if (options.stopOnFocusIn && !options.stopOnInteraction) {
      eventStore.add(emblaApi.containerNode(), "focusout", startAutoplay);
    }
    if (options.playOnInit) startAutoplay();
  }
  function destroy() {
    emblaApi.off("pointerDown", pointerDown).off("pointerUp", pointerUp).off("slideFocusStart", stopAutoplay);
    stopAutoplay();
    destroyed = true;
    autoplayActive = false;
  }
  function setTimer() {
    const {
      ownerWindow
    } = emblaApi.internalEngine();
    ownerWindow.clearTimeout(timerId);
    timerId = ownerWindow.setTimeout(next, delay[emblaApi.selectedScrollSnap()]);
    timerStartTime = (/* @__PURE__ */ new Date()).getTime();
    emblaApi.emit("autoplay:timerset");
  }
  function clearTimer() {
    const {
      ownerWindow
    } = emblaApi.internalEngine();
    ownerWindow.clearTimeout(timerId);
    timerId = 0;
    timerStartTime = null;
    emblaApi.emit("autoplay:timerstopped");
  }
  function startAutoplay() {
    if (destroyed) return;
    if (documentIsHidden()) {
      playOnDocumentVisible = true;
      return;
    }
    if (!autoplayActive) emblaApi.emit("autoplay:play");
    setTimer();
    autoplayActive = true;
  }
  function stopAutoplay() {
    if (destroyed) return;
    if (autoplayActive) emblaApi.emit("autoplay:stop");
    clearTimer();
    autoplayActive = false;
  }
  function visibilityChange() {
    if (documentIsHidden()) {
      playOnDocumentVisible = autoplayActive;
      return stopAutoplay();
    }
    if (playOnDocumentVisible) startAutoplay();
  }
  function documentIsHidden() {
    const {
      ownerDocument
    } = emblaApi.internalEngine();
    return ownerDocument.visibilityState === "hidden";
  }
  function pointerDown() {
    if (!mouseIsOver) stopAutoplay();
  }
  function pointerUp() {
    if (!mouseIsOver) startAutoplay();
  }
  function mouseEnter() {
    mouseIsOver = true;
    stopAutoplay();
  }
  function mouseLeave() {
    mouseIsOver = false;
    startAutoplay();
  }
  function play(jumpOverride) {
    if (typeof jumpOverride !== "undefined") jump = jumpOverride;
    startAutoplay();
  }
  function stop() {
    if (autoplayActive) stopAutoplay();
  }
  function reset() {
    if (autoplayActive) startAutoplay();
  }
  function isPlaying() {
    return autoplayActive;
  }
  function next() {
    const {
      index
    } = emblaApi.internalEngine();
    const nextIndex = index.clone().add(1).get();
    const lastIndex = emblaApi.scrollSnapList().length - 1;
    const kill = options.stopOnLastSnap && nextIndex === lastIndex;
    if (emblaApi.canScrollNext()) {
      emblaApi.scrollNext(jump);
    } else {
      emblaApi.scrollTo(0, jump);
    }
    emblaApi.emit("autoplay:select");
    if (kill) return stopAutoplay();
    startAutoplay();
  }
  function timeUntilNext() {
    if (!timerStartTime) return null;
    const currentDelay = delay[emblaApi.selectedScrollSnap()];
    const timePastSinceStart = (/* @__PURE__ */ new Date()).getTime() - timerStartTime;
    return currentDelay - timePastSinceStart;
  }
  const self = {
    name: "autoplay",
    options: userOptions,
    init,
    destroy,
    play,
    stop,
    reset,
    isPlaying,
    timeUntilNext
  };
  return self;
}
Autoplay.globalOptions = void 0;

// node_modules/embla-carousel-fade/esm/embla-carousel-fade.esm.js
function clampNumber(number, min2, max2) {
  return Math.min(Math.max(number, min2), max2);
}
function isNumber2(value) {
  return typeof value === "number" && !isNaN(value);
}
function Fade2(userOptions = {}) {
  const fullOpacity = 1;
  const noOpacity = 0;
  const fadeFriction = 0.68;
  let emblaApi;
  let opacities = [];
  let fadeToNextDistance;
  let distanceFromPointerDown = 0;
  let fadeVelocity = 0;
  let progress = 0;
  let shouldFadePair = false;
  let defaultSettledBehaviour;
  let defaultProgressBehaviour;
  function init(emblaApiInstance) {
    emblaApi = emblaApiInstance;
    const selectedSnap = emblaApi.selectedScrollSnap();
    const {
      scrollBody,
      containerRect,
      axis
    } = emblaApi.internalEngine();
    const containerSize = axis.measureSize(containerRect);
    fadeToNextDistance = clampNumber(containerSize * 0.75, 200, 500);
    shouldFadePair = false;
    opacities = emblaApi.scrollSnapList().map((_, index) => index === selectedSnap ? fullOpacity : noOpacity);
    defaultSettledBehaviour = scrollBody.settled;
    defaultProgressBehaviour = emblaApi.scrollProgress;
    scrollBody.settled = settled;
    emblaApi.scrollProgress = scrollProgress;
    emblaApi.on("select", select).on("slideFocus", fadeToSelectedSnapInstantly).on("pointerDown", pointerDown).on("pointerUp", pointerUp);
    disableScroll();
    fadeToSelectedSnapInstantly();
  }
  function destroy() {
    const {
      scrollBody
    } = emblaApi.internalEngine();
    scrollBody.settled = defaultSettledBehaviour;
    emblaApi.scrollProgress = defaultProgressBehaviour;
    emblaApi.off("select", select).off("slideFocus", fadeToSelectedSnapInstantly).off("pointerDown", pointerDown).off("pointerUp", pointerUp);
    emblaApi.slideNodes().forEach((slideNode) => {
      const slideStyle = slideNode.style;
      slideStyle.opacity = "";
      slideStyle.transform = "";
      slideStyle.pointerEvents = "";
      if (!slideNode.getAttribute("style")) slideNode.removeAttribute("style");
    });
  }
  function fadeToSelectedSnapInstantly() {
    const selectedSnap = emblaApi.selectedScrollSnap();
    setOpacities(selectedSnap, fullOpacity);
  }
  function pointerUp() {
    shouldFadePair = false;
  }
  function pointerDown() {
    shouldFadePair = false;
    distanceFromPointerDown = 0;
    fadeVelocity = 0;
  }
  function select() {
    const duration = emblaApi.internalEngine().scrollBody.duration();
    fadeVelocity = duration ? 0 : fullOpacity;
    shouldFadePair = true;
    if (!duration) fadeToSelectedSnapInstantly();
  }
  function getSlideTransform(position) {
    const {
      axis
    } = emblaApi.internalEngine();
    const translateAxis = axis.scroll.toUpperCase();
    return `translate${translateAxis}(${axis.direction(position)}px)`;
  }
  function disableScroll() {
    const {
      translate,
      slideLooper
    } = emblaApi.internalEngine();
    translate.clear();
    translate.toggleActive(false);
    slideLooper.loopPoints.forEach(({
      translate: translate2
    }) => {
      translate2.clear();
      translate2.toggleActive(false);
    });
  }
  function lockExcessiveScroll(fadeIndex) {
    const {
      scrollSnaps,
      location,
      target
    } = emblaApi.internalEngine();
    if (!isNumber2(fadeIndex) || opacities[fadeIndex] < 0.5) return;
    location.set(scrollSnaps[fadeIndex]);
    target.set(location);
  }
  function setOpacities(fadeIndex, velocity) {
    const scrollSnaps = emblaApi.scrollSnapList();
    scrollSnaps.forEach((_, indexA) => {
      const absVelocity = Math.abs(velocity);
      const currentOpacity = opacities[indexA];
      const isFadeIndex = indexA === fadeIndex;
      const nextOpacity = isFadeIndex ? currentOpacity + absVelocity : currentOpacity - absVelocity;
      const clampedOpacity = clampNumber(nextOpacity, noOpacity, fullOpacity);
      opacities[indexA] = clampedOpacity;
      const fadePair = isFadeIndex && shouldFadePair;
      const indexB = emblaApi.previousScrollSnap();
      if (fadePair) opacities[indexB] = 1 - clampedOpacity;
      if (isFadeIndex) setProgress(fadeIndex, clampedOpacity);
      setOpacity(indexA);
    });
  }
  function setOpacity(index) {
    const slidesInSnap = emblaApi.internalEngine().slideRegistry[index];
    const {
      scrollSnaps,
      containerRect
    } = emblaApi.internalEngine();
    const opacity = opacities[index];
    slidesInSnap.forEach((slideIndex) => {
      const slideStyle = emblaApi.slideNodes()[slideIndex].style;
      const roundedOpacity = parseFloat(opacity.toFixed(2));
      const hasOpacity = roundedOpacity > noOpacity;
      const position = hasOpacity ? scrollSnaps[index] : containerRect.width + 2;
      const transform = getSlideTransform(position);
      if (hasOpacity) slideStyle.transform = transform;
      slideStyle.opacity = roundedOpacity.toString();
      slideStyle.pointerEvents = opacity > 0.5 ? "auto" : "none";
      if (!hasOpacity) slideStyle.transform = transform;
    });
  }
  function setProgress(fadeIndex, opacity) {
    const {
      index,
      dragHandler,
      scrollSnaps
    } = emblaApi.internalEngine();
    const pointerDown2 = dragHandler.pointerDown();
    const snapFraction = 1 / (scrollSnaps.length - 1);
    let indexA = fadeIndex;
    let indexB = pointerDown2 ? emblaApi.selectedScrollSnap() : emblaApi.previousScrollSnap();
    if (pointerDown2 && indexA === indexB) {
      const reverseSign = Math.sign(distanceFromPointerDown) * -1;
      indexA = indexB;
      indexB = index.clone().set(indexB).add(reverseSign).get();
    }
    const currentPosition = indexB * snapFraction;
    const diffPosition = (indexA - indexB) * snapFraction;
    progress = currentPosition + diffPosition * opacity;
  }
  function getFadeIndex() {
    const {
      dragHandler,
      index,
      scrollBody
    } = emblaApi.internalEngine();
    const selectedSnap = emblaApi.selectedScrollSnap();
    if (!dragHandler.pointerDown()) return selectedSnap;
    const directionSign = Math.sign(scrollBody.velocity());
    const distanceSign = Math.sign(distanceFromPointerDown);
    const nextSnap = index.clone().set(selectedSnap).add(directionSign * -1).get();
    if (!directionSign || !distanceSign) return null;
    return distanceSign === directionSign ? nextSnap : selectedSnap;
  }
  function fade(emblaApi2) {
    const {
      dragHandler,
      scrollBody
    } = emblaApi2.internalEngine();
    const pointerDown2 = dragHandler.pointerDown();
    const velocity = scrollBody.velocity();
    const duration = scrollBody.duration();
    const fadeIndex = getFadeIndex();
    const noFadeIndex = !isNumber2(fadeIndex);
    if (pointerDown2) {
      if (!velocity) return;
      distanceFromPointerDown += velocity;
      fadeVelocity = Math.abs(velocity / fadeToNextDistance);
      lockExcessiveScroll(fadeIndex);
    }
    if (!pointerDown2) {
      if (!duration || noFadeIndex) return;
      fadeVelocity += (fullOpacity - opacities[fadeIndex]) / duration;
      fadeVelocity *= fadeFriction;
    }
    if (noFadeIndex) return;
    setOpacities(fadeIndex, fadeVelocity);
  }
  function settled() {
    const {
      target,
      location
    } = emblaApi.internalEngine();
    const diffToTarget = target.get() - location.get();
    const notReachedTarget = Math.abs(diffToTarget) >= 1;
    const fadeIndex = getFadeIndex();
    const noFadeIndex = !isNumber2(fadeIndex);
    fade(emblaApi);
    if (noFadeIndex || notReachedTarget) return false;
    return opacities[fadeIndex] > 0.999;
  }
  function scrollProgress() {
    return progress;
  }
  const self = {
    name: "fade",
    options: userOptions,
    init,
    destroy
  };
  return self;
}
Fade2.globalOptions = void 0;

// node_modules/@fluentui/react-carousel/lib/components/pointerEvents.js
function pointerEventPlugin(options) {
  let emblaApi;
  let pointerEvent;
  let carouselListenerTarget;
  function documentDownListener(event) {
    if (event.target) {
      const targetNode = event.target;
      if (targetNode.classList.contains(carouselClassNames.root) || (carouselListenerTarget === null || carouselListenerTarget === void 0 ? void 0 : carouselListenerTarget.contains(targetNode))) {
        pointerEvent = event;
      }
    }
    if (carouselListenerTarget) {
      carouselListenerTarget.removeEventListener("mousedown", documentDownListener);
      carouselListenerTarget.removeEventListener("pointerdown", documentDownListener);
    }
  }
  function pointerUpListener() {
    if (carouselListenerTarget) {
      carouselListenerTarget.addEventListener("mousedown", documentDownListener);
      carouselListenerTarget.addEventListener("pointerdown", documentDownListener);
    }
  }
  function clearPointerEvent() {
    pointerEvent = void 0;
    pointerUpListener();
  }
  function selectListener() {
    if (pointerEvent) {
      var _emblaApi_selectedScrollSnap;
      const newIndex = (_emblaApi_selectedScrollSnap = emblaApi.selectedScrollSnap()) !== null && _emblaApi_selectedScrollSnap !== void 0 ? _emblaApi_selectedScrollSnap : 0;
      options.onSelectViaDrag(pointerEvent, newIndex);
    }
  }
  function init(emblaApiInstance, optionsHandler) {
    emblaApi = emblaApiInstance;
    carouselListenerTarget = emblaApi.containerNode();
    carouselListenerTarget.addEventListener("mousedown", documentDownListener);
    carouselListenerTarget.addEventListener("pointerdown", documentDownListener);
    emblaApi.on("pointerUp", pointerUpListener);
    emblaApi.on("select", selectListener);
    emblaApi.on("settle", clearPointerEvent);
  }
  function destroy() {
    if (carouselListenerTarget) {
      carouselListenerTarget.removeEventListener("mousedown", documentDownListener);
      carouselListenerTarget.removeEventListener("pointerdown", documentDownListener);
    }
    carouselListenerTarget = void 0;
    emblaApi.off("pointerUp", pointerUpListener);
    emblaApi.off("select", selectListener);
    emblaApi.off("settle", clearPointerEvent);
  }
  return {
    name: "pointerEvent",
    options,
    init,
    destroy
  };
}

// node_modules/@fluentui/react-carousel/lib/components/useEmblaCarousel.js
var sliderClassname = `.${carouselSliderClassNames.root}`;
var DEFAULT_EMBLA_OPTIONS = {
  containScroll: "trimSnaps",
  inViewThreshold: 0.99,
  watchDrag: false,
  skipSnaps: true,
  container: sliderClassname,
  slides: `.${carouselCardClassNames.root}`
};
var EMBLA_VISIBILITY_EVENT = "embla:visibilitychange";
function setTabsterDefault(element, isDefault) {
  const tabsterAttr = element.getAttribute("data-tabster");
  if (tabsterAttr) {
    const tabsterAttributes = JSON.parse(tabsterAttr);
    if (tabsterAttributes.focusable) {
      tabsterAttributes.focusable.isDefault = isDefault;
      element.setAttribute("data-tabster", JSON.stringify(tabsterAttributes));
    }
  }
}
function useEmblaCarousel(options) {
  const { align, autoplayInterval, direction, loop, slidesToScroll, watchDrag, containScroll, motion, onDragIndexChange, onAutoplayIndexChange } = options;
  var _motion_kind;
  const motionType = typeof motion === "string" ? motion : (_motion_kind = motion === null || motion === void 0 ? void 0 : motion.kind) !== null && _motion_kind !== void 0 ? _motion_kind : "slide";
  var _motion_duration;
  const motionDuration = typeof motion === "string" ? 25 : (_motion_duration = motion === null || motion === void 0 ? void 0 : motion.duration) !== null && _motion_duration !== void 0 ? _motion_duration : 25;
  const [activeIndex, setActiveIndex] = useControllableState({
    defaultState: options.defaultActiveIndex,
    state: options.activeIndex,
    initialState: 0
  });
  const onDragEvent = useEventCallback((event, index) => {
    onDragIndexChange === null || onDragIndexChange === void 0 ? void 0 : onDragIndexChange(event, {
      event,
      type: "drag",
      index
    });
  });
  const emblaOptions = React593.useRef({
    align,
    direction,
    loop,
    slidesToScroll,
    startIndex: activeIndex,
    watchDrag,
    containScroll,
    duration: motionDuration
  });
  const emblaApi = React593.useRef(null);
  const autoplayRef = React593.useRef(false);
  const resetAutoplay = React593.useCallback(() => {
    var _emblaApi_current_plugins_autoplay, _emblaApi_current;
    (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : (_emblaApi_current_plugins_autoplay = _emblaApi_current.plugins().autoplay) === null || _emblaApi_current_plugins_autoplay === void 0 ? void 0 : _emblaApi_current_plugins_autoplay.reset();
  }, []);
  const getPlugins = React593.useCallback(() => {
    const plugins = [];
    plugins.push(Autoplay({
      playOnInit: autoplayRef.current,
      delay: autoplayInterval,
      /* stopOnInteraction: false causes autoplay to restart on interaction end*/
      /* we'll handle this logic to ensure autoplay state is respected */
      stopOnInteraction: true,
      stopOnFocusIn: false,
      stopOnMouseEnter: false
    }));
    if (motionType === "fade") {
      plugins.push(Fade2());
    }
    if (watchDrag) {
      plugins.push(pointerEventPlugin({
        onSelectViaDrag: onDragEvent
      }));
    }
    return plugins;
  }, [
    motionType,
    onDragEvent,
    watchDrag,
    autoplayInterval
  ]);
  const enableAutoplay = React593.useCallback((autoplay, temporary) => {
    if (!temporary) {
      autoplayRef.current = autoplay;
    }
    if (autoplay && autoplayRef.current) {
      var _emblaApi_current_plugins_autoplay, _emblaApi_current;
      (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : (_emblaApi_current_plugins_autoplay = _emblaApi_current.plugins().autoplay) === null || _emblaApi_current_plugins_autoplay === void 0 ? void 0 : _emblaApi_current_plugins_autoplay.play();
      resetAutoplay();
    } else if (!autoplay) {
      var _emblaApi_current_plugins_autoplay1, _emblaApi_current1;
      (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : (_emblaApi_current_plugins_autoplay1 = _emblaApi_current1.plugins().autoplay) === null || _emblaApi_current_plugins_autoplay1 === void 0 ? void 0 : _emblaApi_current_plugins_autoplay1.stop();
    }
  }, [
    resetAutoplay
  ]);
  const listeners = React593.useRef(/* @__PURE__ */ new Set());
  const subscribeForValues = React593.useCallback((listener) => {
    listeners.current.add(listener);
    return () => {
      listeners.current.delete(listener);
    };
  }, []);
  const updateIndex = () => {
    var _emblaApi_current, _emblaApi_current1, _emblaApi_current2, _slideRegistry_newIndex;
    var _emblaApi_current_selectedScrollSnap;
    const newIndex = (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
    const slides = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.slideNodes();
    const slideRegistry = (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.internalEngine().slideRegistry;
    var _slideRegistry_newIndex_;
    const actualIndex = (_slideRegistry_newIndex_ = slideRegistry === null || slideRegistry === void 0 ? void 0 : (_slideRegistry_newIndex = slideRegistry[newIndex]) === null || _slideRegistry_newIndex === void 0 ? void 0 : _slideRegistry_newIndex[0]) !== null && _slideRegistry_newIndex_ !== void 0 ? _slideRegistry_newIndex_ : 0;
    slides === null || slides === void 0 ? void 0 : slides.forEach((slide, slideIndex) => {
      setTabsterDefault(slide, slideIndex === actualIndex);
    });
    setActiveIndex(newIndex);
  };
  const handleReinit = useEventCallback(() => {
    var _emblaApi_current, _emblaApi_current1, _emblaApi_current2, _emblaApi_current3, _emblaApi_current4;
    var _emblaApi_current_slideNodes;
    const nodes = (_emblaApi_current_slideNodes = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.slideNodes()) !== null && _emblaApi_current_slideNodes !== void 0 ? _emblaApi_current_slideNodes : [];
    var _emblaApi_current_internalEngine_slideRegistry;
    const groupIndexList = (_emblaApi_current_internalEngine_slideRegistry = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.internalEngine().slideRegistry) !== null && _emblaApi_current_internalEngine_slideRegistry !== void 0 ? _emblaApi_current_internalEngine_slideRegistry : [];
    const navItemsCount = groupIndexList.length > 0 ? groupIndexList.length : nodes.length;
    const canLoop = (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.internalEngine().slideLooper.canLoop();
    var _emblaApi_current_selectedScrollSnap;
    const data = {
      navItemsCount,
      activeIndex: (_emblaApi_current_selectedScrollSnap = (_emblaApi_current3 = emblaApi.current) === null || _emblaApi_current3 === void 0 ? void 0 : _emblaApi_current3.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0,
      groupIndexList,
      slideNodes: nodes,
      canLoop
    };
    updateIndex();
    (_emblaApi_current4 = emblaApi.current) === null || _emblaApi_current4 === void 0 ? void 0 : _emblaApi_current4.scrollTo(activeIndex, false);
    for (const listener of listeners.current) {
      listener(data);
    }
  });
  const handleIndexChange = useEventCallback((_, eventType) => {
    var _emblaApi_current;
    var _emblaApi_current_selectedScrollSnap;
    const newIndex = (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
    updateIndex();
    if (eventType === "autoplay:select") {
      const noopEvent = new Event("autoplay");
      onAutoplayIndexChange === null || onAutoplayIndexChange === void 0 ? void 0 : onAutoplayIndexChange(noopEvent, {
        event: noopEvent,
        type: "autoplay",
        index: newIndex
      });
    }
  });
  const viewportRef = React593.useRef(null);
  const containerRef = React593.useMemo(() => {
    const handleVisibilityChange = () => {
      var _emblaApi_current, _emblaApi_current1;
      const cardElements = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.slideNodes();
      var _emblaApi_current_slidesInView;
      const visibleIndexes = (_emblaApi_current_slidesInView = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.slidesInView()) !== null && _emblaApi_current_slidesInView !== void 0 ? _emblaApi_current_slidesInView : [];
      cardElements === null || cardElements === void 0 ? void 0 : cardElements.forEach((cardElement, index) => {
        cardElement.dispatchEvent(new CustomEvent(EMBLA_VISIBILITY_EVENT, {
          bubbles: false,
          detail: {
            isVisible: visibleIndexes.includes(index)
          }
        }));
      });
    };
    const plugins = getPlugins();
    return {
      set current(newElement) {
        if (emblaApi.current) {
          var _emblaApi_current_plugins_autoplay, _emblaApi_current_plugins, _emblaApi_current;
          (_emblaApi_current_plugins = (_emblaApi_current = emblaApi.current).plugins) === null || _emblaApi_current_plugins === void 0 ? void 0 : (_emblaApi_current_plugins_autoplay = _emblaApi_current_plugins.call(_emblaApi_current).autoplay) === null || _emblaApi_current_plugins_autoplay === void 0 ? void 0 : _emblaApi_current_plugins_autoplay.stop();
          emblaApi.current.off("slidesInView", handleVisibilityChange);
          emblaApi.current.off("select", handleIndexChange);
          emblaApi.current.off("reInit", handleReinit);
          emblaApi.current.off("autoplay:select", handleIndexChange);
          emblaApi.current.destroy();
          emblaApi.current = null;
        }
        if (newElement) {
          var _viewportRef_current;
          const newEmblaApi = EmblaCarousel((_viewportRef_current = viewportRef.current) !== null && _viewportRef_current !== void 0 ? _viewportRef_current : newElement, {
            ...DEFAULT_EMBLA_OPTIONS,
            ...emblaOptions.current
          }, plugins);
          newEmblaApi.on("reInit", handleReinit);
          newEmblaApi.on("slidesInView", handleVisibilityChange);
          newEmblaApi.on("select", handleIndexChange);
          newEmblaApi.on("autoplay:select", handleIndexChange);
          emblaApi.current = newEmblaApi;
        }
      }
    };
  }, [
    getPlugins,
    handleIndexChange,
    handleReinit
  ]);
  const carouselApi = React593.useMemo(() => ({
    scrollToElement: (element, jump) => {
      var _emblaApi_current, _emblaApi_current1, _emblaApi_current2;
      const cardElements = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.slideNodes();
      var _emblaApi_current_internalEngine_slideRegistry;
      const groupIndexList = (_emblaApi_current_internalEngine_slideRegistry = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.internalEngine().slideRegistry) !== null && _emblaApi_current_internalEngine_slideRegistry !== void 0 ? _emblaApi_current_internalEngine_slideRegistry : [];
      var _cardElements_indexOf;
      const cardIndex = (_cardElements_indexOf = cardElements === null || cardElements === void 0 ? void 0 : cardElements.indexOf(element)) !== null && _cardElements_indexOf !== void 0 ? _cardElements_indexOf : 0;
      const groupIndex = groupIndexList.findIndex((group) => {
        return group.includes(cardIndex);
      });
      const indexFocus = groupIndex !== null && groupIndex !== void 0 ? groupIndex : cardIndex;
      (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.scrollTo(indexFocus, jump);
      return indexFocus;
    },
    scrollToIndex: (index, jump) => {
      var _emblaApi_current;
      (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.scrollTo(index, jump);
    },
    scrollInDirection: (dir) => {
      var _emblaApi_current;
      if (dir === "prev") {
        var _emblaApi_current1;
        (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.scrollPrev();
      } else {
        var _emblaApi_current2;
        (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.scrollNext();
      }
      var _emblaApi_current_selectedScrollSnap;
      return (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
    }
  }), []);
  React593.useEffect(() => {
    var _emblaApi_current_plugins_autoplay, _emblaApi_current_plugins, _emblaApi_current, _emblaApi_current1;
    const plugins = getPlugins();
    emblaOptions.current = {
      startIndex: emblaOptions.current.startIndex,
      align,
      direction,
      loop,
      slidesToScroll,
      watchDrag,
      containScroll,
      duration: motionDuration
    };
    (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : (_emblaApi_current_plugins = _emblaApi_current.plugins) === null || _emblaApi_current_plugins === void 0 ? void 0 : (_emblaApi_current_plugins_autoplay = _emblaApi_current_plugins.call(_emblaApi_current).autoplay) === null || _emblaApi_current_plugins_autoplay === void 0 ? void 0 : _emblaApi_current_plugins_autoplay.stop();
    (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.reInit({
      ...DEFAULT_EMBLA_OPTIONS,
      ...emblaOptions.current
    }, plugins);
  }, [
    align,
    containScroll,
    direction,
    getPlugins,
    loop,
    slidesToScroll,
    watchDrag,
    motionDuration
  ]);
  React593.useEffect(() => {
    var _emblaApi_current, _emblaApi_current_slideNodes, _emblaApi_current1;
    var _emblaApi_current_selectedScrollSnap;
    const currentActiveIndex = (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
    var _emblaApi_current_slideNodes_length;
    const slideLength = (_emblaApi_current_slideNodes_length = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : (_emblaApi_current_slideNodes = _emblaApi_current1.slideNodes()) === null || _emblaApi_current_slideNodes === void 0 ? void 0 : _emblaApi_current_slideNodes.length) !== null && _emblaApi_current_slideNodes_length !== void 0 ? _emblaApi_current_slideNodes_length : 0;
    emblaOptions.current.startIndex = activeIndex;
    if (activeIndex < slideLength && activeIndex !== currentActiveIndex) {
      var _emblaApi_current2;
      (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.scrollTo(activeIndex);
    }
  }, [
    activeIndex
  ]);
  return {
    activeIndex,
    carouselApi,
    viewportRef,
    containerRef,
    subscribeForValues,
    enableAutoplay,
    resetAutoplay
  };
}

// node_modules/@fluentui/react-carousel/lib/components/Carousel/useCarousel.js
function useCarousel_unstable2(props, ref) {
  "use no memo";
  const { align = "center", circular = false, onActiveIndexChange, groupSize = "auto", draggable = false, whitespace = false, announcement, motion = "slide", autoplayInterval = 4e3 } = props;
  const { dir } = useFluent();
  const { activeIndex, carouselApi, containerRef, viewportRef, subscribeForValues, enableAutoplay, resetAutoplay } = useEmblaCarousel({
    align,
    direction: dir,
    loop: circular,
    slidesToScroll: groupSize,
    defaultActiveIndex: props.defaultActiveIndex,
    activeIndex: props.activeIndex,
    watchDrag: draggable,
    containScroll: whitespace ? false : "keepSnaps",
    motion,
    onDragIndexChange: onActiveIndexChange,
    onAutoplayIndexChange: onActiveIndexChange,
    autoplayInterval
  });
  const selectPageByElement = useEventCallback((event, element, jump) => {
    const foundIndex = carouselApi.scrollToElement(element, jump);
    onActiveIndexChange === null || onActiveIndexChange === void 0 ? void 0 : onActiveIndexChange(event, {
      event,
      type: "focus",
      index: foundIndex
    });
    return foundIndex;
  });
  const selectPageByIndex = useEventCallback((event, index, jump) => {
    carouselApi.scrollToIndex(index, jump);
    onActiveIndexChange === null || onActiveIndexChange === void 0 ? void 0 : onActiveIndexChange(event, {
      event,
      type: "click",
      index
    });
  });
  const selectPageByDirection = useEventCallback((event, direction) => {
    const nextPageIndex = carouselApi.scrollInDirection(direction);
    onActiveIndexChange === null || onActiveIndexChange === void 0 ? void 0 : onActiveIndexChange(event, {
      event,
      type: "click",
      index: nextPageIndex
    });
    return nextPageIndex;
  });
  const mergedContainerRef = useMergedRefs(ref, containerRef);
  const announcementTextRef = React594.useRef("");
  const totalNavLength = React594.useRef(0);
  const navGroupRef = React594.useRef([]);
  const { announce } = useAnnounce();
  const updateAnnouncement = useEventCallback(() => {
    if (totalNavLength.current <= 0 || !announcement) {
      return;
    }
    const announcementText = announcement(activeIndex, totalNavLength.current, navGroupRef.current);
    if (announcementText !== announcementTextRef.current) {
      announcementTextRef.current = announcementText;
      announce(announcementText, {
        polite: true
      });
    }
  });
  useIsomorphicLayoutEffect(() => {
    return subscribeForValues((data) => {
      if (totalNavLength.current <= 0 && data.navItemsCount > 0 && announcement) {
        const announcementText = announcement(data.activeIndex, data.navItemsCount, data.groupIndexList);
        announcementTextRef.current = announcementText;
      }
      totalNavLength.current = data.navItemsCount;
      navGroupRef.current = data.groupIndexList;
      updateAnnouncement();
    });
  }, [
    subscribeForValues,
    updateAnnouncement,
    announcement
  ]);
  useIsomorphicLayoutEffect(() => {
    updateAnnouncement();
  }, [
    activeIndex,
    updateAnnouncement
  ]);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: mergedContainerRef,
      role: "region",
      ...props
    }), {
      elementType: "div"
    }),
    activeIndex,
    circular,
    containerRef: mergedContainerRef,
    viewportRef,
    selectPageByElement,
    selectPageByDirection,
    selectPageByIndex,
    subscribeForValues,
    enableAutoplay,
    resetAutoplay
  };
}

// node_modules/@fluentui/react-carousel/lib/components/Carousel/renderCarousel.js
var renderCarousel_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(CarouselProvider2, {
    value: contextValues.carousel,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-carousel/lib/components/Carousel/useCarouselStyles.styles.js
var carouselClassNames = {
  root: "fui-Carousel"
};
var useStyles91 = __styles2({
  root: {
    B68tc82: "f1p9o1ba",
    Eiaeu8: "f1115ve7",
    qhf8xq: "f10pi13n"
  }
}, {
  d: [".f1p9o1ba{overflow-x:hidden;}", ".f1115ve7{overflow-anchor:none;}", ".f10pi13n{position:relative;}"]
});
var useCarouselStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles91();
  state.root.className = mergeClasses(carouselClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/Carousel/useCarouselContextValues.js
var React595 = __toESM(require_react());
function useCarouselContextValues_unstable(state) {
  const { activeIndex, selectPageByElement, selectPageByDirection, selectPageByIndex, subscribeForValues, enableAutoplay, resetAutoplay, circular, containerRef, viewportRef } = state;
  const carousel = React595.useMemo(() => ({
    activeIndex,
    selectPageByElement,
    selectPageByDirection,
    selectPageByIndex,
    subscribeForValues,
    enableAutoplay,
    resetAutoplay,
    circular,
    containerRef,
    viewportRef
  }), [
    activeIndex,
    selectPageByElement,
    selectPageByDirection,
    selectPageByIndex,
    subscribeForValues,
    enableAutoplay,
    resetAutoplay,
    circular,
    containerRef,
    viewportRef
  ]);
  return {
    carousel
  };
}

// node_modules/@fluentui/react-carousel/lib/components/Carousel/Carousel.js
var Carousel = React596.forwardRef((props, ref) => {
  const state = useCarousel_unstable2(props, ref);
  useCarouselStyles_unstable(state);
  useCustomStyleHook("useCarouselStyles_unstable")(state);
  const contextValues = useCarouselContextValues_unstable(state);
  return renderCarousel_unstable(state, contextValues);
});
Carousel.displayName = "Carousel";

// node_modules/@fluentui/react-carousel/lib/components/CarouselCard/CarouselCard.js
var React599 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselCard/useCarouselCard.js
var React598 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/CarouselSliderContext.js
var React597 = __toESM(require_react());
var carouselSliderContext = React597.createContext(void 0);
var carouselSliderContextDefaultValue = {
  cardFocus: false
};
var useCarouselSliderContext = () => {
  var _React_useContext;
  return (_React_useContext = React597.useContext(carouselSliderContext)) !== null && _React_useContext !== void 0 ? _React_useContext : carouselSliderContextDefaultValue;
};
var CarouselSliderContextProvider = carouselSliderContext.Provider;
function useCarouselSliderContextValues_unstable(state) {
  const { cardFocus } = state;
  const carouselSlider = React597.useMemo(() => ({
    cardFocus
  }), [
    cardFocus
  ]);
  return {
    carouselSlider
  };
}

// node_modules/@fluentui/react-carousel/lib/components/CarouselCard/useCarouselCard.js
var useCarouselCard_unstable = (props, ref) => {
  const { autoSize } = props;
  const elementRef = React598.useRef(null);
  const isMouseEvent3 = React598.useRef(false);
  const selectPageByElement = useCarouselContext_unstable2((ctx) => ctx.selectPageByElement);
  const containerRef = useCarouselContext_unstable2((ctx) => ctx.containerRef);
  const { cardFocus } = useCarouselSliderContext();
  const focusAttr = useFocusableGroup({
    tabBehavior: "limited"
  });
  const focusAttrProps = cardFocus ? {
    ...focusAttr,
    tabIndex: 0
  } : {};
  const id = useId2(carouselCardClassNames.root, props.id);
  React598.useEffect(() => {
    const element = elementRef.current;
    if (element) {
      const listener = (_e) => {
        const event = _e;
        if (!cardFocus) {
          const hidden = !event.detail.isVisible;
          element.ariaHidden = hidden.toString();
          element.inert = hidden;
        }
      };
      element.addEventListener(EMBLA_VISIBILITY_EVENT, listener);
      return () => {
        element.removeEventListener(EMBLA_VISIBILITY_EVENT, listener);
      };
    }
  }, [
    cardFocus
  ]);
  const handleFocus = React598.useCallback((e) => {
    if (!e.defaultPrevented && isHTMLElement(e.currentTarget) && !isMouseEvent3.current) {
      var _containerRef_current;
      containerRef === null || containerRef === void 0 ? void 0 : (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.scrollTo(0, 0);
      selectPageByElement(e, e.currentTarget, false);
    }
    isMouseEvent3.current = false;
  }, [
    selectPageByElement,
    containerRef
  ]);
  const handlePointerDown = (e) => {
    if (!e.defaultPrevented) {
      isMouseEvent3.current = true;
    }
  };
  const handlePointerUp = (e) => {
    if (!e.defaultPrevented) {
      isMouseEvent3.current = false;
    }
  };
  const onFocusCapture = mergeCallbacks(props.onFocusCapture, handleFocus);
  const onPointerUp = mergeCallbacks(props.onPointerUp, handlePointerUp);
  const onPointerDown = mergeCallbacks(props.onPointerDown, handlePointerDown);
  const state = {
    autoSize,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(elementRef, ref),
      role: "tabpanel",
      tabIndex: cardFocus ? 0 : void 0,
      ...props,
      id,
      onFocusCapture,
      onPointerUp,
      onPointerDown,
      ...focusAttrProps
    }), {
      elementType: "div"
    })
  };
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselCard/renderCarouselCard.js
var renderCarouselCard_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselCard/CarouselCard.js
var CarouselCard = React599.forwardRef((props, ref) => {
  const state = useCarouselCard_unstable(props, ref);
  useCarouselCardStyles_unstable(state);
  useCustomStyleHook("useCarouselCardStyles_unstable")(state);
  return renderCarouselCard_unstable(state);
});
CarouselCard.displayName = "CarouselCard";

// node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/CarouselAutoplayButton.js
var React601 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/useCarouselAutoplayButton.js
var React600 = __toESM(require_react());
var useCarouselAutoplayButton_unstable = (props, ref) => {
  const { onCheckedChange, checked, defaultChecked } = props;
  const [autoplay, setAutoplay] = useControllableState({
    state: checked,
    defaultState: defaultChecked,
    initialState: false
  });
  const enableAutoplay = useCarouselContext_unstable2((ctx) => ctx.enableAutoplay);
  React600.useEffect(() => {
    enableAutoplay(autoplay);
    return () => {
      enableAutoplay(false);
    };
  }, [
    autoplay,
    enableAutoplay
  ]);
  const handleClick = (event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    const newValue = !autoplay;
    setAutoplay(newValue);
    onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(event, {
      event,
      type: "click",
      checked: newValue
    });
  };
  return {
    // We lean on react-button class to handle styling and icon enhancements
    ...useToggleButton_unstable({
      icon: slot_exports.optional(props.icon, {
        defaultProps: {
          children: autoplay ? React600.createElement(PauseCircleRegular, null) : React600.createElement(PlayCircleRegular, null)
        },
        renderByDefault: true,
        elementType: "span"
      }),
      ...props,
      checked: autoplay,
      onClick: useEventCallback(mergeCallbacks(handleClick, props.onClick))
    }, ref)
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/renderCarouselAutoplayButton.js
var renderCarouselAutoplayButton_unstable = (state) => {
  assertSlots(state);
  return renderButton_unstable(state);
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/useCarouselAutoplayButtonStyles.styles.js
var carouselAutoplayButtonClassNames = {
  root: "fui-CarouselAutoplayButton",
  icon: "fui-CarouselAutoplayButton__icon"
};
var useStyles92 = __styles2({
  root: {
    Bkecrkj: "fc5wo7j",
    B6of3ja: "fgr6219",
    jrapky: "f10jk5vf",
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"],
    sj55zd: "fkfq4zb",
    De3pzq: "fkfdr9r",
    eoavqd: "f8491dx"
  }
}, {
  d: [".fc5wo7j{pointer-events:all;}", ".fgr6219{margin-top:auto;}", ".f10jk5vf{margin-bottom:auto;}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".fkfdr9r{background-color:var(--colorNeutralBackgroundAlpha);}"],
  h: [".f8491dx:hover{cursor:pointer;}"]
});
var useCarouselAutoplayButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles92();
  useToggleButtonStyles_unstable(state);
  state.root.className = mergeClasses(carouselAutoplayButtonClassNames.root, styles.root, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(carouselAutoplayButtonClassNames.icon, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/CarouselAutoplayButton.js
var CarouselAutoplayButton = React601.forwardRef((props, ref) => {
  const state = useCarouselAutoplayButton_unstable(props, ref);
  useCarouselAutoplayButtonStyles_unstable(state);
  useCustomStyleHook("useCarouselAutoplayButtonStyles_unstable")(state);
  return renderCarouselAutoplayButton_unstable(state);
});
CarouselAutoplayButton.displayName = "CarouselAutoplayButton";

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/CarouselNavImageButton.js
var React603 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/useCarouselNavImageButton.js
var React602 = __toESM(require_react());
var useCarouselNavImageButton_unstable = (props, ref) => {
  const { onClick, as = "button" } = props;
  const index = useCarouselNavIndexContext();
  const selectPageByIndex = useCarouselContext_unstable2((ctx) => ctx.selectPageByIndex);
  const selected = useCarouselContext_unstable2((ctx) => ctx.activeIndex === index);
  const subscribeForValues = useCarouselContext_unstable2((ctx) => ctx.subscribeForValues);
  const handleClick = useEventCallback((event) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
    if (!event.defaultPrevented && isHTMLElement(event.target)) {
      selectPageByIndex(event, index);
    }
  });
  const defaultTabProps = useTabsterAttributes({
    focusable: {
      isDefault: selected
    }
  });
  const buttonRef = React602.useRef(void 0);
  const _carouselButton = slot_exports.always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
    elementType: "button",
    defaultProps: {
      ref: useMergedRefs(ref, buttonRef),
      role: "tab",
      type: "button",
      "aria-selected": selected,
      ...defaultTabProps
    }
  });
  useIsomorphicLayoutEffect(() => {
    return subscribeForValues((data) => {
      var _data_groupIndexList;
      var _data_groupIndexList_index;
      const controlList = (_data_groupIndexList_index = (_data_groupIndexList = data.groupIndexList) === null || _data_groupIndexList === void 0 ? void 0 : _data_groupIndexList[index]) !== null && _data_groupIndexList_index !== void 0 ? _data_groupIndexList_index : [];
      const _controlledSlideIds = controlList.map((slideIndex) => {
        return data.slideNodes[slideIndex].id;
      }).join(" ");
      if (buttonRef.current) {
        buttonRef.current.setAttribute("aria-controls", _controlledSlideIds);
      }
    });
  }, [
    subscribeForValues,
    index
  ]);
  _carouselButton.onClick = handleClick;
  const image = slot_exports.always(getIntrinsicElementProps("img", {
    "aria-hidden": true,
    alt: "",
    role: "presentation",
    ...props.image
  }), {
    elementType: "img"
  });
  return {
    components: {
      root: "button",
      image: "img"
    },
    root: _carouselButton,
    image,
    selected
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/renderCarouselNavImageButton.js
var renderCarouselNavImageButton_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(state.image, {})
  });
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/useCarouselNavImageButtonStyles.styles.js
var carouselNavImageButtonClassNames = {
  root: "fui-CarouselNavImageButton",
  image: "fui-CarouselNavImageButton__image"
};
var useStyles93 = __styles2({
  root: {
    B7ck84d: "f1e4lqlz",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1c5fvqg",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f186qr3g",
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"],
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fq9zq91",
    a9b677: "feqmc2u",
    Bqenvij: "fbhnoac",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    eoavqd: "f8491dx"
  },
  image: {
    a9b677: "feqmc2u",
    Bqenvij: "fbhnoac",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fq9zq91"
  },
  selected: {
    a9b677: "f124akge",
    Bqenvij: "ff2sm71"
  }
}, {
  d: [".f1e4lqlz{box-sizing:content-box;}", [".f1c5fvqg{padding:0px;}", {
    p: -1
  }], [".f186qr3g{margin:0 var(--spacingHorizontalXS);}", {
    p: -1
  }], ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
    p: -1
  }], ".feqmc2u{width:40px;}", ".fbhnoac{height:40px;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
    p: -1
  }], ".f124akge{width:48px;}", ".ff2sm71{height:48px;}"],
  h: [".f8491dx:hover{cursor:pointer;}"]
});
var useCarouselNavImageButtonStyles_unstable = (state) => {
  "use no memo";
  const {
    selected
  } = state;
  const styles = useStyles93();
  state.root.className = mergeClasses(carouselNavImageButtonClassNames.root, styles.root, selected && styles.selected, state.root.className);
  if (state.image) {
    var _state_image;
    state.image.className = mergeClasses(carouselNavImageButtonClassNames.image, styles.image, selected && styles.selected, (_state_image = state.image) === null || _state_image === void 0 ? void 0 : _state_image.className);
  }
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/CarouselNavImageButton.js
var CarouselNavImageButton = React603.forwardRef((props, ref) => {
  const state = useCarouselNavImageButton_unstable(props, ref);
  useCarouselNavImageButtonStyles_unstable(state);
  useCustomStyleHook("useCarouselNavImageButtonStyles_unstable")(state);
  return renderCarouselNavImageButton_unstable(state);
});
CarouselNavImageButton.displayName = "CarouselNavImageButton";

// node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/CarouselSlider.js
var React605 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/useCarouselSlider.js
var React604 = __toESM(require_react());
var useCarouselSlider_unstable = (props, ref) => {
  const { cardFocus = false } = props;
  const circular = useCarouselContext_unstable2((ctx) => ctx.circular);
  const focusableGroupAttr = useArrowNavigationGroup({
    circular,
    axis: "horizontal",
    memorizeCurrent: false,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_hasDefault: true
  });
  const focusProps = cardFocus ? focusableGroupAttr : {};
  return {
    cardFocus,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      role: "group",
      ...props,
      ...focusProps
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/renderCarouselSlider.js
var renderCarouselSlider_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(CarouselSliderContextProvider, {
    value: contextValues.carouselSlider,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/CarouselSlider.js
var CarouselSlider = React605.forwardRef((props, ref) => {
  const state = useCarouselSlider_unstable(props, ref);
  useCarouselSliderStyles_unstable(state);
  useCustomStyleHook("useCarouselSliderStyles_unstable")(state);
  const context = useCarouselSliderContextValues_unstable(state);
  return renderCarouselSlider_unstable(state, context);
});
CarouselSlider.displayName = "CarouselSlider";

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/CarouselNavContainer.js
var React607 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/useCarouselNavContainer.js
var React606 = __toESM(require_react());
var useCarouselNavContainer_unstable = (props, ref) => {
  const { layout } = props;
  const next = slot_exports.optional(props.next, {
    defaultProps: {
      navType: "next"
    },
    elementType: CarouselButton,
    renderByDefault: true
  });
  const prev = slot_exports.optional(props.prev, {
    defaultProps: {
      navType: "prev"
    },
    elementType: CarouselButton,
    renderByDefault: true
  });
  const autoplay = slot_exports.optional(props.autoplay, {
    elementType: CarouselAutoplayButton,
    renderByDefault: !!props.autoplay || !!props.autoplayTooltip
  });
  const nextTooltip = slot_exports.optional(props.nextTooltip, {
    defaultProps: {},
    elementType: Tooltip,
    renderByDefault: false
  });
  const prevTooltip = slot_exports.optional(props.prevTooltip, {
    defaultProps: {},
    elementType: Tooltip,
    renderByDefault: false
  });
  const autoplayTooltip = slot_exports.optional(props.autoplayTooltip, {
    defaultProps: {},
    elementType: Tooltip,
    renderByDefault: false
  });
  return {
    layout,
    components: {
      root: "div",
      next: CarouselButton,
      prev: CarouselButton,
      autoplay: CarouselAutoplayButton,
      nextTooltip: Tooltip,
      prevTooltip: Tooltip,
      autoplayTooltip: Tooltip
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    next,
    prev,
    autoplay,
    nextTooltip,
    prevTooltip,
    autoplayTooltip
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/renderCarouselNavContainer.js
var renderCarouselNavContainer_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      !state.autoplayTooltip && state.autoplay && jsx(state.autoplay, {}),
      state.autoplayTooltip && state.autoplay && jsx(state.autoplayTooltip, {
        children: jsx(state.autoplay, {})
      }),
      !state.prevTooltip && state.prev && jsx(state.prev, {}),
      state.prevTooltip && state.prev && jsx(state.prevTooltip, {
        children: jsx(state.prev, {})
      }),
      state.root.children,
      !state.nextTooltip && state.next && jsx(state.next, {}),
      state.nextTooltip && state.next && jsx(state.nextTooltip, {
        children: jsx(state.next, {})
      })
    ]
  });
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/useCarouselNavContainerStyles.styles.js
var carouselNavContainerClassNames = {
  root: "fui-CarouselNavContainer",
  next: "fui-CarouselNavContainer__next",
  prev: "fui-CarouselNavContainer__prev",
  autoplay: "fui-CarouselNavContainer__autoplay",
  /* Tooltip classNames are listed for type compatibility only (cannot assign root className to portal)
  * Use 'content' slot to style Tooltip content instead
  */
  nextTooltip: "fui-CarouselNavContainer__nextTooltip",
  prevTooltip: "fui-CarouselNavContainer__prevTooltip",
  autoplayTooltip: "fui-CarouselNavContainer__autoplayTooltip"
};
var useStyles94 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    Brf1p80: "f4d9j23",
    a9b677: "fly5x3f",
    Bkecrkj: "f1aehjj5"
  },
  next: {},
  prev: {},
  autoplay: {},
  inline: {
    B6of3ja: "f1mevb6"
  },
  overlay: {
    qhf8xq: "f1euv43f",
    B5kzvoi: "f1bu4tuc",
    B7ck84d: "f1ewtqcl"
  },
  overlayWide: {
    B5kzvoi: "f1bu4tuc"
  },
  nextWide: {
    Frg6f3: ["fcgxt0o", "f1ujusj6"]
  },
  prevWide: {
    t21cq0: ["f1ujusj6", "fcgxt0o"]
  },
  nextOverlayWide: {
    t21cq0: ["fkujibs", "f199hnxi"]
  },
  prevOverlayWide: {
    Frg6f3: ["f199hnxi", "fkujibs"]
  },
  autoplayOverlayWide: {
    Frg6f3: ["f199hnxi", "fkujibs"]
  },
  expanded: {
    a9b677: "fly5x3f",
    Bqenvij: "f1l02sjl",
    Bt984gj: "fgs5rwf",
    Brf1p80: "f4d9j23",
    B5kzvoi: "f1yab3r1",
    c7y7m3: "f1ok8cdc",
    yx0ijg: "fcq6x80",
    v4amzz: "f1gy9d85"
  },
  nextOverlayExpanded: {
    qhf8xq: "f1euv43f",
    j35jbq: ["f8b87gs", "fedtrts"],
    Bhzewxz: "f1i1t8d1",
    Bz10aip: "f188r07x"
  },
  prevOverlayExpanded: {
    qhf8xq: "f1euv43f",
    oyh7mz: ["fedtrts", "f8b87gs"],
    Bhzewxz: "f1i1t8d1",
    Bz10aip: "f188r07x"
  },
  autoplayExpanded: {
    qhf8xq: "f1euv43f",
    B5kzvoi: "f49tsn4",
    oyh7mz: ["fedtrts", "f8b87gs"],
    jrapky: "f18zxyen"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f4d9j23{justify-content:center;}", ".fly5x3f{width:100%;}", ".f1aehjj5{pointer-events:none;}", ".f1mevb6{margin-top:var(--spacingVerticalM);}", ".f1euv43f{position:absolute;}", ".f1bu4tuc{bottom:var(--spacingVerticalM);}", ".f1ewtqcl{box-sizing:border-box;}", ".fcgxt0o{margin-left:auto;}", ".f1ujusj6{margin-right:auto;}", ".fkujibs{margin-right:var(--spacingHorizontalM);}", ".f199hnxi{margin-left:var(--spacingHorizontalM);}", ".f1l02sjl{height:100%;}", ".fgs5rwf{align-items:flex-end;}", ".f1yab3r1{bottom:0;}", ".f1ok8cdc>div{position:relative;}", ".fcq6x80>div{bottom:var(--spacingVerticalL);}", ".f1gy9d85>div{margin-bottom:0;}", ".f8b87gs{right:var(--spacingHorizontalM);}", ".fedtrts{left:var(--spacingHorizontalM);}", ".f1i1t8d1{top:50%;}", ".f188r07x{transform:translateY(-50%);}", ".f49tsn4{bottom:-var(--spacingHorizontalXS);}", ".f18zxyen{margin-bottom:var(--spacingVerticalM);}"]
});
var useCarouselNavContainerStyles_unstable = (state) => {
  "use no memo";
  const {
    layout
  } = state;
  const isOverlay = layout === "overlay" || layout === "overlay-wide" || layout === "overlay-expanded";
  const isWide = layout === "inline-wide" || layout === "overlay-wide";
  const styles = useStyles94();
  state.root.className = mergeClasses(carouselNavContainerClassNames.root, styles.root, isOverlay ? styles.overlay : styles.inline, isOverlay && isWide && styles.overlayWide, layout === "overlay-expanded" && styles.expanded, state.root.className);
  if (state.next) {
    state.next.className = mergeClasses(carouselNavContainerClassNames.next, styles.next, isWide && styles.nextWide, isWide && isOverlay && styles.nextOverlayWide, layout === "overlay-expanded" && styles.nextOverlayExpanded, state.next.className);
  }
  if (state.prev) {
    state.prev.className = mergeClasses(carouselNavContainerClassNames.prev, styles.prev, isWide && styles.prevWide, !state.autoplay && isWide && isOverlay && styles.prevOverlayWide, layout === "overlay-expanded" && styles.prevOverlayExpanded, state.prev.className);
  }
  if (state.autoplay) {
    state.autoplay.className = mergeClasses(carouselNavContainerClassNames.autoplay, styles.autoplay, layout === "overlay-expanded" && styles.autoplayExpanded, isWide && isOverlay && styles.autoplayOverlayWide, state.autoplay.className);
  }
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/CarouselNavContainer.js
var CarouselNavContainer = React607.forwardRef((props, ref) => {
  const state = useCarouselNavContainer_unstable(props, ref);
  useCarouselNavContainerStyles_unstable(state);
  useCustomStyleHook("useCarouselNavContainerStyles_unstable")(state);
  return renderCarouselNavContainer_unstable(state);
});
CarouselNavContainer.displayName = "CarouselNavContainer";

// node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/CarouselViewport.js
var React609 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/useCarouselViewport.js
var React608 = __toESM(require_react());
var useCarouselViewport_unstable = (props, ref) => {
  const hasFocus = React608.useRef(false);
  const hasMouse = React608.useRef(false);
  const viewportRef = useCarouselContext_unstable2((ctx) => ctx.viewportRef);
  const enableAutoplay = useCarouselContext_unstable2((ctx) => ctx.enableAutoplay);
  const handleFocusCapture = React608.useCallback(() => {
    hasFocus.current = true;
    enableAutoplay(false, true);
  }, [
    enableAutoplay
  ]);
  const handleBlurCapture = React608.useCallback((e) => {
    if (!e.currentTarget.contains(e.relatedTarget)) {
      hasFocus.current = false;
      if (!hasMouse.current) {
        enableAutoplay(true, true);
      }
    }
  }, [
    enableAutoplay
  ]);
  const handleMouseEnter = React608.useCallback(() => {
    hasMouse.current = true;
    enableAutoplay(false, true);
  }, [
    enableAutoplay
  ]);
  const handleMouseLeave = React608.useCallback(() => {
    hasMouse.current = false;
    if (!hasFocus.current) {
      enableAutoplay(true, true);
    }
  }, [
    enableAutoplay
  ]);
  const onFocusCapture = mergeCallbacks(props.onFocusCapture, handleFocusCapture);
  const onBlurCapture = mergeCallbacks(props.onBlurCapture, handleBlurCapture);
  const onMouseEnter = mergeCallbacks(props.onMouseEnter, handleMouseEnter);
  const onMouseLeave = mergeCallbacks(props.onMouseLeave, handleMouseLeave);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, viewportRef),
      role: "presentation",
      // Draggable ensures dragging is supported (even if not enabled)
      draggable: true,
      ...props,
      onFocusCapture,
      onBlurCapture,
      onMouseEnter,
      onMouseLeave
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/renderCarouselViewport.js
var renderCarouselViewport_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(CarouselSliderContextProvider, {
    value: contextValues.carouselSlider,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/useCarouselViewportStyles.styles.js
var carouselViewportClassNames = {
  root: "fui-CarouselViewport"
};
var useStyles95 = __styles2({
  root: {
    B2u0y6b: "f6dzj5z",
    a9b677: "f14z66ap"
  }
}, {
  d: [".f6dzj5z{max-width:100%;}", ".f14z66ap{width:auto;}"]
});
var useCarouselViewportStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles95();
  state.root.className = mergeClasses(carouselViewportClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/CarouselViewport.js
var CarouselViewport = React609.forwardRef((props, ref) => {
  const state = useCarouselViewport_unstable(props, ref);
  useCarouselViewportStyles_unstable(state);
  useCustomStyleHook("useCarouselViewportStyles_unstable")(state);
  const context = useCarouselSliderContextValues_unstable(state);
  return renderCarouselViewport_unstable(state, context);
});
CarouselViewport.displayName = "CarouselViewport";

// node_modules/@fluentui/react-list/lib/components/List/List.js
var React614 = __toESM(require_react());

// node_modules/@fluentui/react-list/lib/components/List/useList.js
var React611 = __toESM(require_react());

// node_modules/@fluentui/react-list/lib/hooks/useListSelection.js
var React610 = __toESM(require_react());
function useListSelection(options = {
  selectionMode: "multiselect"
}) {
  const { selectionMode, defaultSelectedItems, onSelectionChange } = options;
  const [selectedItems, setSelectedItems] = useControllableState({
    state: options.selectedItems,
    defaultState: defaultSelectedItems,
    initialState: []
  });
  const [selected, selectionMethods] = useSelection({
    selectionMode,
    defaultSelectedItems,
    selectedItems,
    onSelectionChange: (e, data) => {
      setSelectedItems(data.selectedItems);
      onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(e, data);
    }
  });
  const toggleItem = useEventCallback((e, itemId) => selectionMethods.toggleItem(e, itemId));
  const toggleAllItems = useEventCallback((e, itemIds) => {
    selectionMethods.toggleAllItems(e, itemIds);
  });
  const deselectItem = useEventCallback((e, itemId) => selectionMethods.deselectItem(e, itemId));
  const selectItem = useEventCallback((e, itemId) => selectionMethods.selectItem(e, itemId));
  const clearSelection = useEventCallback((e) => selectionMethods.clearItems(e));
  const selectedArray = React610.useMemo(() => Array.from(selected), [
    selected
  ]);
  return {
    selectedItems: selectedArray,
    toggleItem,
    toggleAllItems,
    deselectItem,
    selectItem,
    setSelectedItems,
    isSelected: (id) => selectionMethods.isSelected(id),
    clearSelection
  };
}

// node_modules/@fluentui/react-list/lib/utils/calculateListRole.js
var calculateListRole = (navigationMode, selectable) => {
  if (navigationMode === "composite") {
    return "grid";
  } else if (selectable) {
    return "listbox";
  } else {
    return "list";
  }
};

// node_modules/@fluentui/react-list/lib/utils/validateProperElementTypes.js
function validateProperElementTypes(listRenderedAs, listItemRenderedAs) {
  if (listItemRenderedAs === "div" && listRenderedAs !== "div") {
    throw new Error("ListItem cannot be rendered as a div when its parent is not a div.");
  }
  if (listItemRenderedAs === "li" && listRenderedAs === "div") {
    throw new Error("ListItem cannot be rendered as a li when its parent is a div.");
  }
}

// node_modules/@fluentui/react-list/lib/utils/validateProperRolesAreUsed.js
var validateProperRolesAreUsed = (role, listItemRole, hasSelection, hasFocusableChildren) => {
  if (role === "list" && listItemRole !== "listitem") {
    throw new Error('When the List role is "list", ListItem role must be "listitem".');
  }
  if (role === "listbox" && listItemRole !== "option") {
    throw new Error('When the List role is "listbox", ListItem role must be "option".');
  }
  if (role === "grid" && listItemRole !== "row") {
    throw new Error('When the List role is "grid", ListItem role must be "row".');
  }
  const expectedRole = (() => {
    if (hasFocusableChildren) {
      return "grid";
    } else {
      if (hasSelection) {
        return "listbox";
      } else {
        return "list";
      }
    }
  })();
  if (role !== expectedRole) {
    console.warn(`@fluentui/react-list [useList]:
The role "${role}" does not match the expected role "${expectedRole}".
Please use the "navigationMode" property for automatic role assignment and keyboard navigation.
If you are using this role intentionally, make sure to verify screen reader support.
    `);
  }
};

// node_modules/@fluentui/react-list/lib/utils/calculateListItemRoleForListRole.js
var calculateListItemRoleForListRole = (listRole) => {
  switch (listRole) {
    case "list":
      return "listitem";
    case "listbox":
      return "option";
    case "grid":
      return "row";
    default:
      return "listitem";
  }
};

// node_modules/@fluentui/react-list/lib/utils/validateGridCellsArePresent.js
var validateGridCellsArePresent = (listRole, listItemEl) => {
  if (listRole !== "grid") {
    return;
  }
  const gridCells = listItemEl.querySelectorAll(':scope > [role="gridcell"]');
  if (gridCells.length === 0) {
    console.warn(`@fluentui/react-list [useList]:
List items in List with "grid" role (which is automatically assigned when navigationMode is set to "composite") must contain at least one "gridcell" as direct child of <ListItem /> for proper screen reader support.`, `Ideally, each focus target should be in it's own "gridcell", which is a direct child of <ListItem />.
`);
  }
};

// node_modules/@fluentui/react-list/lib/components/List/useList.js
var DEFAULT_ROOT_EL_TYPE = "ul";
var useList_unstable = (props, ref) => {
  const { navigationMode, selectionMode, selectedItems, defaultSelectedItems, onSelectionChange } = props;
  const as = props.as || navigationMode === "composite" ? "div" : DEFAULT_ROOT_EL_TYPE;
  const arrowNavigationAttributes = useArrowNavigationGroup({
    axis: "vertical",
    memorizeCurrent: true
  });
  const [selectionState, setSelectionState] = useControllableState({
    state: selectedItems,
    defaultState: defaultSelectedItems,
    initialState: []
  });
  const onChange = useEventCallback((e, data) => {
    const selectedItemsAsArray = Array.from(data.selectedItems);
    setSelectionState(selectedItemsAsArray);
    onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(e, {
      event: e,
      type: "change",
      selectedItems: selectedItemsAsArray
    });
  });
  const selection = useListSelection({
    onSelectionChange: onChange,
    selectionMode: selectionMode || "multiselect",
    selectedItems: selectionState
  });
  const listRole = props.role || calculateListRole(navigationMode, !!selectionMode);
  const listItemRole = calculateListItemRoleForListRole(listRole);
  const { findAllFocusable } = useFocusFinders();
  const validateListItem = useEventCallback((listItemEl) => {
    if (false) {
      return;
    }
    const itemRole = listItemEl.getAttribute("role") || "";
    const focusable = findAllFocusable(listItemEl);
    validateProperElementTypes(as, listItemEl.tagName.toLocaleLowerCase());
    validateProperRolesAreUsed(listRole, itemRole, !!selectionMode, focusable.length > 0);
    validateGridCellsArePresent(listRole, listItemEl);
  });
  return {
    components: {
      root: as
    },
    root: slot_exports.always(getIntrinsicElementProps(as, {
      ref,
      role: listRole,
      ...selectionMode && {
        "aria-multiselectable": selectionMode === "multiselect" ? true : void 0
      },
      ...arrowNavigationAttributes,
      ...props
    }), {
      elementType: as
    }),
    listItemRole,
    validateListItem,
    navigationMode,
    // only pass down selection state if its handled internally, otherwise just report the events
    selection: selectionMode ? selection : void 0
  };
};

// node_modules/@fluentui/react-list/lib/components/List/listContext.js
var React612 = __toESM(require_react());
var listContextDefaultValue = {
  selection: void 0,
  validateListItem: () => {
  }
};
var listContext = createContext13(void 0);
var ListContextProvider = listContext.Provider;
var useListContext_unstable = (selector) => useContextSelector(listContext, (ctx = listContextDefaultValue) => selector(ctx));
var ListSynchronousContext = React612.createContext(void 0);
var ListSynchronousContextProvider = ListSynchronousContext.Provider;
var useListSynchronousContext = () => React612.useContext(ListSynchronousContext) || {
  navigationMode: void 0,
  listItemRole: "listitem"
};

// node_modules/@fluentui/react-list/lib/components/List/renderList.js
var renderList_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(ListContextProvider, {
    value: contextValues.listContext,
    children: jsx(ListSynchronousContextProvider, {
      value: contextValues.synchronousContext,
      children: jsx(state.root, {})
    })
  });
};

// node_modules/@fluentui/react-list/lib/components/List/useListStyles.styles.js
var listClassNames = {
  root: "fui-List"
};
var useRootBaseStyles8 = __resetStyles("r1m6yby2", null, [".r1m6yby2{padding:0;margin:0;text-indent:0;list-style-type:none;}"]);
var useListStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootBaseStyles8();
  state.root.className = mergeClasses(listClassNames.root, rootStyles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-list/lib/components/List/useListContextValues.js
var React613 = __toESM(require_react());
function useListContextValues_unstable(state) {
  const { selection, navigationMode, listItemRole, validateListItem } = state;
  const listContext2 = {
    selection,
    navigationMode,
    validateListItem
  };
  const synchronousContext = React613.useMemo(() => ({
    listItemRole,
    navigationMode
  }), [
    listItemRole,
    navigationMode
  ]);
  return {
    listContext: listContext2,
    synchronousContext
  };
}

// node_modules/@fluentui/react-list/lib/components/List/List.js
var List = React614.forwardRef((props, ref) => {
  const state = useList_unstable(props, ref);
  const contextValues = useListContextValues_unstable(state);
  useListStyles_unstable(state);
  useCustomStyleHook("useListStyles_unstable")(state);
  return renderList_unstable(state, contextValues);
});
List.displayName = "List";

// node_modules/@fluentui/react-list/lib/components/ListItem/ListItem.js
var React617 = __toESM(require_react());

// node_modules/@fluentui/react-list/lib/components/ListItem/useListItem.js
var React616 = __toESM(require_react());

// node_modules/@fluentui/react-list/lib/events/ListItemActionEvent.js
var React615 = __toESM(require_react());
var ListItemActionEventName = "ListItemAction";
var createListItemActionEvent = (originalEvent) => new CustomEvent(ListItemActionEventName, {
  cancelable: true,
  bubbles: true,
  detail: {
    originalEvent
  }
});

// node_modules/@fluentui/react-list/lib/components/ListItem/useListItem.js
var DEFAULT_ROOT_EL_TYPE2 = "li";
var useListItem_unstable = (props, ref) => {
  const id = useId2("listItem");
  const { value = id, onKeyDown, onClick, tabIndex, role, onAction, disabledSelection } = props;
  const toggleItem = useListContext_unstable((ctx) => {
    var _ctx_selection;
    return (_ctx_selection = ctx.selection) === null || _ctx_selection === void 0 ? void 0 : _ctx_selection.toggleItem;
  });
  const { navigationMode, listItemRole } = useListSynchronousContext();
  const isSelectionModeEnabled = useListContext_unstable((ctx) => !!ctx.selection);
  const isSelected = useListContext_unstable((ctx) => {
    var _ctx_selection;
    return (_ctx_selection = ctx.selection) === null || _ctx_selection === void 0 ? void 0 : _ctx_selection.isSelected(value);
  });
  const validateListItem = useListContext_unstable((ctx) => ctx.validateListItem);
  const as = props.as || navigationMode === "composite" ? "div" : DEFAULT_ROOT_EL_TYPE2;
  const finalListItemRole = role || listItemRole;
  const focusableItems = Boolean(isSelectionModeEnabled || navigationMode || tabIndex === 0);
  const rootRef = React616.useRef(null);
  const checkmarkRef = React616.useRef(null);
  const handleAction = useEventCallback((event) => {
    onAction === null || onAction === void 0 ? void 0 : onAction(event, {
      event,
      value,
      type: ListItemActionEventName
    });
    if (event.defaultPrevented) {
      return;
    }
    if (isSelectionModeEnabled && !disabledSelection) {
      toggleItem === null || toggleItem === void 0 ? void 0 : toggleItem(event.detail.originalEvent, value);
    }
  });
  React616.useEffect(() => {
    if (rootRef.current) {
      validateListItem(rootRef.current);
    }
  }, [
    validateListItem
  ]);
  const triggerAction = (e) => {
    const actionEvent = createListItemActionEvent(e);
    handleAction(actionEvent);
    e.target.dispatchEvent(actionEvent);
  };
  const focusableGroupAttrs = useFocusableGroup({
    ignoreDefaultKeydown: {
      Enter: true
    },
    tabBehavior: "limited-trap-focus"
  });
  const handleClick = useEventCallback((e) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(e);
    if (e.defaultPrevented) {
      return;
    }
    const isFromCheckbox = elementContains(checkmarkRef.current, e.target);
    if (isFromCheckbox) {
      return;
    }
    triggerAction(e);
  });
  const handleKeyDown = useEventCallback((e) => {
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e);
    if (e.defaultPrevented) {
      return;
    }
    if (e.target !== e.currentTarget) {
      if (focusableItems) {
        switch (e.key) {
          case ArrowLeft:
            e.target.dispatchEvent(new GroupperMoveFocusEvent({
              action: GroupperMoveFocusActions.Escape
            }));
            break;
          case ArrowDown:
          case ArrowUp:
            e.preventDefault();
            e.target.dispatchEvent(new GroupperMoveFocusEvent({
              action: GroupperMoveFocusActions.Escape
            }));
            e.currentTarget.dispatchEvent(new MoverMoveFocusEvent({
              key: MoverKeys[e.key]
            }));
        }
        return;
      }
      return;
    }
    switch (e.key) {
      case Space:
        e.preventDefault();
        if (isSelectionModeEnabled) {
          if (!disabledSelection) {
            toggleItem === null || toggleItem === void 0 ? void 0 : toggleItem(e, value);
          }
        } else {
          triggerAction(e);
        }
        break;
      case Enter:
        triggerAction(e);
        break;
      case ArrowRight:
        if (navigationMode === "composite") {
          e.target.dispatchEvent(new GroupperMoveFocusEvent({
            action: GroupperMoveFocusActions.Enter
          }));
        }
        break;
    }
  });
  const onCheckboxChange = useEventCallback((e, data) => {
    if (!isSelectionModeEnabled || e.defaultPrevented) {
      return;
    }
    toggleItem === null || toggleItem === void 0 ? void 0 : toggleItem(e, value);
  });
  const arrowNavigationAttributes = useArrowNavigationGroup({
    axis: "horizontal"
  });
  const tabsterAttributes = useMergedTabsterAttributes_unstable(focusableItems ? arrowNavigationAttributes : {}, focusableGroupAttrs, props);
  const root = slot_exports.always(getIntrinsicElementProps(as, {
    ref: useMergedRefs(rootRef, ref),
    tabIndex: focusableItems ? 0 : void 0,
    role: finalListItemRole,
    id: String(value),
    ...isSelectionModeEnabled && {
      "aria-selected": isSelected,
      "aria-disabled": disabledSelection && !onAction || void 0
    },
    ...props,
    ...tabsterAttributes,
    onKeyDown: handleKeyDown,
    onClick: isSelectionModeEnabled || onClick || onAction ? handleClick : void 0
  }), {
    elementType: as
  });
  const checkmark = slot_exports.optional(props.checkmark, {
    defaultProps: {
      checked: isSelected,
      tabIndex: -1,
      disabled: disabledSelection
    },
    renderByDefault: isSelectionModeEnabled,
    elementType: Checkbox
  });
  const mergedCheckmarkRef = useMergedRefs(checkmark === null || checkmark === void 0 ? void 0 : checkmark.ref, checkmarkRef);
  if (checkmark) {
    checkmark.onChange = mergeCallbacks(checkmark.onChange, onCheckboxChange);
    checkmark.ref = mergedCheckmarkRef;
  }
  const state = {
    components: {
      root: as,
      checkmark: Checkbox
    },
    root,
    checkmark,
    disabled: disabledSelection && !onAction,
    selectable: isSelectionModeEnabled,
    navigable: focusableItems
  };
  return state;
};

// node_modules/@fluentui/react-list/lib/components/ListItem/renderListItem.js
var renderListItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.checkmark && jsx(state.checkmark, {}),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-list/lib/components/ListItem/useListItemStyles.styles.js
var listItemClassNames = {
  root: "fui-ListItem",
  checkmark: "fui-ListItem__checkmark"
};
var useRootBaseStyles9 = __resetStyles("rikgcmv", null, [".rikgcmv{padding:0;margin:0;text-indent:0;list-style-type:none;}", ".rikgcmv[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);}"]);
var useCheckmarkBaseStyles = __styles2({
  root: {
    qb2dma: "f7nlbp4",
    Bpb5tq4: 0,
    Biccaaf: 0,
    Gaeyjg: 0,
    ldoezw: 0,
    B6gmeee: "f1bgo3o3"
  }
}, {
  d: [".f7nlbp4{align-self:center;}", [".f1bgo3o3 .fui-Checkbox__indicator{margin:4px;}", {
    p: -1
  }]]
});
var useStyles96 = __styles2({
  rootClickableOrSelectable: {
    mc9l5x: "f22iagw",
    Bceei9c: "f1k6fduh"
  },
  disabled: {
    Bceei9c: "f158kwzp"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1k6fduh{cursor:pointer;}", ".f158kwzp{cursor:default;}"]
});
var useListItemStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyles = useRootBaseStyles9();
  const checkmarkBaseStyles = useCheckmarkBaseStyles();
  const styles = useStyles96();
  state.root.className = mergeClasses(listItemClassNames.root, rootBaseStyles, (state.selectable || state.navigable) && styles.rootClickableOrSelectable, state.disabled && styles.disabled, state.root.className);
  if (state.checkmark) {
    state.checkmark.className = mergeClasses(listItemClassNames.checkmark, checkmarkBaseStyles.root, state.checkmark.className);
  }
  return state;
};

// node_modules/@fluentui/react-list/lib/components/ListItem/ListItem.js
var ListItem = React617.forwardRef((props, ref) => {
  const state = useListItem_unstable(props, ref);
  useListItemStyles_unstable(state);
  useCustomStyleHook("useListItemStyles_unstable")(state);
  return renderListItem_unstable(state);
});
ListItem.displayName = "ListItem";

// node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/ColorSlider.js
var React620 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/useColorSlider.js
var React619 = __toESM(require_react());

// node_modules/@ctrl/tinycolor/dist/module/util.js
function bound01(n, max2) {
  if (isOnePointZero(n)) {
    n = "100%";
  }
  var isPercent = isPercentage(n);
  n = max2 === 360 ? n : Math.min(max2, Math.max(0, parseFloat(n)));
  if (isPercent) {
    n = parseInt(String(n * max2), 10) / 100;
  }
  if (Math.abs(n - max2) < 1e-6) {
    return 1;
  }
  if (max2 === 360) {
    n = (n < 0 ? n % max2 + max2 : n % max2) / parseFloat(String(max2));
  } else {
    n = n % max2 / parseFloat(String(max2));
  }
  return n;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n) {
  return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") !== -1;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function convertToPercentage(n) {
  if (n <= 1) {
    return "".concat(Number(n) * 100, "%");
  }
  return n;
}
function pad2(c) {
  return c.length === 1 ? "0" + c : String(c);
}

// node_modules/@ctrl/tinycolor/dist/module/conversion.js
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max2 = Math.max(r, g, b);
  var min2 = Math.min(r, g, b);
  var h = 0;
  var s = 0;
  var l = (max2 + min2) / 2;
  if (max2 === min2) {
    s = 0;
    h = 0;
  } else {
    var d = max2 - min2;
    s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
    switch (max2) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
      default:
        break;
    }
    h /= 6;
  }
  return { h, s, l };
}
function hue2rgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * (6 * t);
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslToRgb(h, s, l) {
  var r;
  var g;
  var b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  if (s === 0) {
    g = l;
    b = l;
    r = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max2 = Math.max(r, g, b);
  var min2 = Math.min(r, g, b);
  var h = 0;
  var v = max2;
  var d = max2 - min2;
  var s = max2 === 0 ? 0 : d / max2;
  if (max2 === min2) {
    h = 0;
  } else {
    switch (max2) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
      default:
        break;
    }
    h /= 6;
  }
  return { h, s, v };
}
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h);
  var f = h - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);
  var mod = i % 6;
  var r = [v, q, p, p, t, v][mod];
  var g = [t, v, v, q, p, p][mod];
  var b = [p, p, t, v, v, q][mod];
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHex(r, g, b, allow3Char) {
  var hex = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16))
  ];
  if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16)),
    pad2(convertDecimalToHex(a))
  ];
  if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color2) {
  return {
    r: color2 >> 16,
    g: (color2 & 65280) >> 8,
    b: color2 & 255
  };
}

// node_modules/@ctrl/tinycolor/dist/module/css-color-names.js
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};

// node_modules/@ctrl/tinycolor/dist/module/format-input.js
function inputToRGB(color2) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;
  if (typeof color2 === "string") {
    color2 = stringInputToObject(color2);
  }
  if (typeof color2 === "object") {
    if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
      rgb = rgbToRgb(color2.r, color2.g, color2.b);
      ok = true;
      format = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
      s = convertToPercentage(color2.s);
      v = convertToPercentage(color2.v);
      rgb = hsvToRgb(color2.h, s, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
      s = convertToPercentage(color2.s);
      l = convertToPercentage(color2.l);
      rgb = hslToRgb(color2.h, s, l);
      ok = true;
      format = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color2, "a")) {
      a = color2.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color2.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color2) {
  color2 = color2.trim().toLowerCase();
  if (color2.length === 0) {
    return false;
  }
  var named = false;
  if (names[color2]) {
    color2 = names[color2];
    named = true;
  } else if (color2 === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match = matchers.rgb.exec(color2);
  if (match) {
    return { r: match[1], g: match[2], b: match[3] };
  }
  match = matchers.rgba.exec(color2);
  if (match) {
    return { r: match[1], g: match[2], b: match[3], a: match[4] };
  }
  match = matchers.hsl.exec(color2);
  if (match) {
    return { h: match[1], s: match[2], l: match[3] };
  }
  match = matchers.hsla.exec(color2);
  if (match) {
    return { h: match[1], s: match[2], l: match[3], a: match[4] };
  }
  match = matchers.hsv.exec(color2);
  if (match) {
    return { h: match[1], s: match[2], v: match[3] };
  }
  match = matchers.hsva.exec(color2);
  if (match) {
    return { h: match[1], s: match[2], v: match[3], a: match[4] };
  }
  match = matchers.hex8.exec(color2);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex6.exec(color2);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  match = matchers.hex4.exec(color2);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex3.exec(color2);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color2) {
  return Boolean(matchers.CSS_UNIT.exec(String(color2)));
}

// node_modules/@ctrl/tinycolor/dist/module/index.js
var TinyColor = (
  /** @class */
  function() {
    function TinyColor2(color2, opts) {
      if (color2 === void 0) {
        color2 = "";
      }
      if (opts === void 0) {
        opts = {};
      }
      var _a;
      if (color2 instanceof TinyColor2) {
        return color2;
      }
      if (typeof color2 === "number") {
        color2 = numberInputToObject(color2);
      }
      this.originalInput = color2;
      var rgb = inputToRGB(color2);
      this.originalInput = color2;
      this.r = rgb.r;
      this.g = rgb.g;
      this.b = rgb.b;
      this.a = rgb.a;
      this.roundA = Math.round(100 * this.a) / 100;
      this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
      this.gradientType = opts.gradientType;
      if (this.r < 1) {
        this.r = Math.round(this.r);
      }
      if (this.g < 1) {
        this.g = Math.round(this.g);
      }
      if (this.b < 1) {
        this.b = Math.round(this.b);
      }
      this.isValid = rgb.ok;
    }
    TinyColor2.prototype.isDark = function() {
      return this.getBrightness() < 128;
    };
    TinyColor2.prototype.isLight = function() {
      return !this.isDark();
    };
    TinyColor2.prototype.getBrightness = function() {
      var rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
    };
    TinyColor2.prototype.getLuminance = function() {
      var rgb = this.toRgb();
      var R;
      var G;
      var B;
      var RsRGB = rgb.r / 255;
      var GsRGB = rgb.g / 255;
      var BsRGB = rgb.b / 255;
      if (RsRGB <= 0.03928) {
        R = RsRGB / 12.92;
      } else {
        R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      }
      if (GsRGB <= 0.03928) {
        G = GsRGB / 12.92;
      } else {
        G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      }
      if (BsRGB <= 0.03928) {
        B = BsRGB / 12.92;
      } else {
        B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    };
    TinyColor2.prototype.getAlpha = function() {
      return this.a;
    };
    TinyColor2.prototype.setAlpha = function(alpha) {
      this.a = boundAlpha(alpha);
      this.roundA = Math.round(100 * this.a) / 100;
      return this;
    };
    TinyColor2.prototype.isMonochrome = function() {
      var s = this.toHsl().s;
      return s === 0;
    };
    TinyColor2.prototype.toHsv = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
    };
    TinyColor2.prototype.toHsvString = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      var h = Math.round(hsv.h * 360);
      var s = Math.round(hsv.s * 100);
      var v = Math.round(hsv.v * 100);
      return this.a === 1 ? "hsv(".concat(h, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHsl = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
    };
    TinyColor2.prototype.toHslString = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      var h = Math.round(hsl.h * 360);
      var s = Math.round(hsl.s * 100);
      var l = Math.round(hsl.l * 100);
      return this.a === 1 ? "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHex = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return rgbToHex(this.r, this.g, this.b, allow3Char);
    };
    TinyColor2.prototype.toHexString = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return "#" + this.toHex(allow3Char);
    };
    TinyColor2.prototype.toHex8 = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
    };
    TinyColor2.prototype.toHex8String = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return "#" + this.toHex8(allow4Char);
    };
    TinyColor2.prototype.toHexShortString = function(allowShortChar) {
      if (allowShortChar === void 0) {
        allowShortChar = false;
      }
      return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
    };
    TinyColor2.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toRgbString = function() {
      var r = Math.round(this.r);
      var g = Math.round(this.g);
      var b = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toPercentageRgb = function() {
      var fmt = function(x) {
        return "".concat(Math.round(bound01(x, 255) * 100), "%");
      };
      return {
        r: fmt(this.r),
        g: fmt(this.g),
        b: fmt(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toPercentageRgbString = function() {
      var rnd = function(x) {
        return Math.round(bound01(x, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toName = function() {
      if (this.a === 0) {
        return "transparent";
      }
      if (this.a < 1) {
        return false;
      }
      var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
      for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        if (hex === value) {
          return key;
        }
      }
      return false;
    };
    TinyColor2.prototype.toString = function(format) {
      var formatSet = Boolean(format);
      format = format !== null && format !== void 0 ? format : this.format;
      var formattedString = false;
      var hasAlpha = this.a < 1 && this.a >= 0;
      var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
      if (needsAlphaFormat) {
        if (format === "name" && this.a === 0) {
          return this.toName();
        }
        return this.toRgbString();
      }
      if (format === "rgb") {
        formattedString = this.toRgbString();
      }
      if (format === "prgb") {
        formattedString = this.toPercentageRgbString();
      }
      if (format === "hex" || format === "hex6") {
        formattedString = this.toHexString();
      }
      if (format === "hex3") {
        formattedString = this.toHexString(true);
      }
      if (format === "hex4") {
        formattedString = this.toHex8String(true);
      }
      if (format === "hex8") {
        formattedString = this.toHex8String();
      }
      if (format === "name") {
        formattedString = this.toName();
      }
      if (format === "hsl") {
        formattedString = this.toHslString();
      }
      if (format === "hsv") {
        formattedString = this.toHsvString();
      }
      return formattedString || this.toHexString();
    };
    TinyColor2.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    };
    TinyColor2.prototype.clone = function() {
      return new TinyColor2(this.toString());
    };
    TinyColor2.prototype.lighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.brighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var rgb = this.toRgb();
      rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
      rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
      rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
      return new TinyColor2(rgb);
    };
    TinyColor2.prototype.darken = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.tint = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("white", amount);
    };
    TinyColor2.prototype.shade = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("black", amount);
    };
    TinyColor2.prototype.desaturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.saturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.greyscale = function() {
      return this.desaturate(100);
    };
    TinyColor2.prototype.spin = function(amount) {
      var hsl = this.toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.mix = function(color2, amount) {
      if (amount === void 0) {
        amount = 50;
      }
      var rgb1 = this.toRgb();
      var rgb2 = new TinyColor2(color2).toRgb();
      var p = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p + rgb1.r,
        g: (rgb2.g - rgb1.g) * p + rgb1.g,
        b: (rgb2.b - rgb1.b) * p + rgb1.b,
        a: (rgb2.a - rgb1.a) * p + rgb1.a
      };
      return new TinyColor2(rgba);
    };
    TinyColor2.prototype.analogous = function(results, slices) {
      if (results === void 0) {
        results = 6;
      }
      if (slices === void 0) {
        slices = 30;
      }
      var hsl = this.toHsl();
      var part = 360 / slices;
      var ret = [this];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(new TinyColor2(hsl));
      }
      return ret;
    };
    TinyColor2.prototype.complement = function() {
      var hsl = this.toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.monochromatic = function(results) {
      if (results === void 0) {
        results = 6;
      }
      var hsv = this.toHsv();
      var h = hsv.h;
      var s = hsv.s;
      var v = hsv.v;
      var res = [];
      var modification = 1 / results;
      while (results--) {
        res.push(new TinyColor2({ h, s, v }));
        v = (v + modification) % 1;
      }
      return res;
    };
    TinyColor2.prototype.splitcomplement = function() {
      var hsl = this.toHsl();
      var h = hsl.h;
      return [
        this,
        new TinyColor2({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
        new TinyColor2({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    };
    TinyColor2.prototype.onBackground = function(background) {
      var fg = this.toRgb();
      var bg = new TinyColor2(background).toRgb();
      var alpha = fg.a + bg.a * (1 - fg.a);
      return new TinyColor2({
        r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
        g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
        b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
        a: alpha
      });
    };
    TinyColor2.prototype.triad = function() {
      return this.polyad(3);
    };
    TinyColor2.prototype.tetrad = function() {
      return this.polyad(4);
    };
    TinyColor2.prototype.polyad = function(n) {
      var hsl = this.toHsl();
      var h = hsl.h;
      var result = [this];
      var increment = 360 / n;
      for (var i = 1; i < n; i++) {
        result.push(new TinyColor2({ h: (h + i * increment) % 360, s: hsl.s, l: hsl.l }));
      }
      return result;
    };
    TinyColor2.prototype.equals = function(color2) {
      return this.toRgbString() === new TinyColor2(color2).toRgbString();
    };
    return TinyColor2;
  }()
);
function tinycolor(color2, opts) {
  if (color2 === void 0) {
    color2 = "";
  }
  if (opts === void 0) {
    opts = {};
  }
  return new TinyColor(color2, opts);
}

// node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/useColorSliderStyles.styles.js
var colorSliderClassNames = {
  root: "fui-ColorSlider",
  rail: "fui-ColorSlider__rail",
  thumb: "fui-ColorSlider__thumb",
  input: "fui-ColorSlider__input"
};
var colorSliderCSSVars = {
  sliderDirectionVar: `--fui-Slider--direction`,
  sliderProgressVar: `--fui-Slider--progress`,
  thumbColorVar: `--fui-Slider__thumb--color`,
  railColorVar: `--fui-Slider__rail--color`,
  thumbSizeVar: `--fui-Slider__thumb--size`,
  railSizeVar: `--fui-Slider__rail--size`
};
var hueBackground = `linear-gradient(${[`var(${colorSliderCSSVars.sliderDirectionVar})`, "red", "fuchsia", "blue", "aqua", "lime", "yellow", "red"].join(",")})`;
var useRootStyles27 = __resetStyles("r1j9hj9j", null, [".r1j9hj9j{position:relative;display:inline-grid;touch-action:none;align-items:center;justify-items:center;--fui-Slider__thumb--size:20px;--fui-Slider__rail--size:20px;min-height:32px;}"]);
var useStyles97 = __styles2({
  horizontal: {
    Bf4jedk: "f93ek0f",
    wkccdc: "fgfd48t",
    Budl1dq: "f11e9psi"
  },
  vertical: {
    sshi5w: "fwwq4i4",
    wkccdc: "fqcvrs3",
    Budl1dq: "fiadc6h"
  }
}, {
  d: [".f93ek0f{min-width:200px;}", ".fgfd48t{grid-template-rows:1fr var(--fui-Slider__thumb--size) 1fr;}", ".f11e9psi{grid-template-columns:1fr 100% 1fr;}", ".fwwq4i4{min-height:280px;}", ".fqcvrs3{grid-template-rows:1fr 100% 1fr;}", ".fiadc6h{grid-template-columns:1fr var(--fui-Slider__thumb--size) 1fr;}"]
});
var useChannelStyles = __styles2({
  hue: {
    Bcmaq0h: "f1curpo1"
  },
  saturation: {
    Bcmaq0h: ["fdhcg5e", "f1onqon0"]
  },
  value: {
    Bcmaq0h: ["f1r1ueul", "fbtriqu"]
  }
}, {
  d: [".f1curpo1{background-image:linear-gradient(var(--fui-Slider--direction),red,fuchsia,blue,aqua,lime,yellow,red);}", ".fdhcg5e{background-image:linear-gradient(to right, #808080, var(--fui-Slider__rail--color));}", ".f1onqon0{background-image:linear-gradient(to left, #808080, var(--fui-Slider__rail--color));}", ".f1r1ueul{background-image:linear-gradient(to right, #000, var(--fui-Slider__rail--color));}", ".fbtriqu{background-image:linear-gradient(to left, #000, var(--fui-Slider__rail--color));}"]
});
var useRailStyles2 = __styles2({
  rail: {
    Bkecrkj: "f1aehjj5",
    Ijaq50: "faunodf",
    nk6f5a: "f88nxoq",
    Br312pm: "fd46tj4",
    Bw0ie65: "f1e2fz10",
    qhf8xq: "f10pi13n",
    Bvjb7m6: "fdgv6k0",
    Bpd4iqm: "fpvhumw",
    oeaueh: "f1yog68k",
    Bw0xxkn: "f13sgyd8",
    Ftih45: "fzhtfnv",
    Brfgrao: "f1j7ml58"
  },
  horizontal: {
    a9b677: "fly5x3f",
    Bqenvij: "f1cy86ho",
    Fbdkly: ["f1heqfse", "fkh49vu"],
    mdwyqc: ["fkh49vu", "f1heqfse"],
    Baz25je: "f16tdq4e"
  },
  vertical: {
    a9b677: "fqxfnkd",
    Bqenvij: "f1l02sjl",
    Ccq8qp: "f1rik0od",
    Bciustq: "f14xwovp",
    lawp4y: "febq2dz"
  }
}, {
  d: [".f1aehjj5{pointer-events:none;}", ".faunodf{grid-row-start:2;}", ".f88nxoq{grid-row-end:2;}", ".fd46tj4{grid-column-start:2;}", ".f1e2fz10{grid-column-end:2;}", ".f10pi13n{position:relative;}", ".fdgv6k0{forced-color-adjust:none;}", ".fpvhumw{outline-width:1px;}", ".f1yog68k{outline-style:solid;}", ".f13sgyd8{outline-color:var(--colorTransparentStroke);}", ".fzhtfnv::before{content:'';}", ".f1j7ml58::before{position:absolute;}", ".fly5x3f{width:100%;}", ".f1cy86ho{height:var(--fui-Slider__rail--size);}", ".f1heqfse::before{left:-1px;}", ".fkh49vu::before{right:-1px;}", ".f16tdq4e::before{height:var(--fui-Slider__rail--size);}", ".fqxfnkd{width:var(--fui-Slider__rail--size);}", ".f1l02sjl{height:100%;}", ".f1rik0od::before{width:var(--fui-Slider__rail--size);}", ".f14xwovp::before{top:-1px;}", ".febq2dz::before{bottom:1px;}"]
});
var useThumbStyles2 = __styles2({
  thumb: {
    Ijaq50: "faunodf",
    nk6f5a: "f88nxoq",
    Br312pm: "fd46tj4",
    Bw0ie65: "f1e2fz10",
    qhf8xq: "f1euv43f",
    a9b677: "f174ca62",
    Bqenvij: "f1yfdkfd",
    Bkecrkj: "f1aehjj5",
    oeaueh: "f1s6fcnf",
    Bvjb7m6: "fdgv6k0",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f1lvq45z",
    E5pizo: "f1whvlc6",
    De3pzq: "foksa45",
    Brfgrao: "f1j7ml58",
    lawp4y: 0,
    Fbdkly: 0,
    mdwyqc: 0,
    Bciustq: 0,
    gc50h5: "f1abv9ik",
    r59vdv: 0,
    Budzafs: 0,
    ck0cow: 0,
    n07z76: 0,
    Gng75u: "fielpny",
    Bcvre1j: "fyl8oag",
    Ftih45: "fzhtfnv",
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f3i7wkk"
  },
  horizontal: {
    Bz10aip: ["f13gfj74", "f1nfknbn"],
    oyh7mz: ["f1fj3zth", "fcf9u6w"]
  },
  vertical: {
    Bz10aip: "f5cv5a3",
    B5kzvoi: "feeniun"
  }
}, {
  d: [".faunodf{grid-row-start:2;}", ".f88nxoq{grid-row-end:2;}", ".fd46tj4{grid-column-start:2;}", ".f1e2fz10{grid-column-end:2;}", ".f1euv43f{position:absolute;}", ".f174ca62{width:var(--fui-Slider__thumb--size);}", ".f1yfdkfd{height:var(--fui-Slider__thumb--size);}", ".f1aehjj5{pointer-events:none;}", ".f1s6fcnf{outline-style:none;}", ".fdgv6k0{forced-color-adjust:none;}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1lvq45z{border:var(--strokeWidthThin) solid var(--colorNeutralForeground4);}", {
    p: -2
  }], ".f1whvlc6{box-shadow:var(--shadow4);}", ".foksa45{background-color:var(--fui-Slider__thumb--color);}", ".f1j7ml58::before{position:absolute;}", [".f1abv9ik::before{inset:0px;}", {
    p: -1
  }], [".fielpny::before{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".fyl8oag::before{box-sizing:border-box;}", ".fzhtfnv::before{content:'';}", [".f3i7wkk::before{border:var(--strokeWidthThick) solid var(--colorNeutralBackground1);}", {
    p: -2
  }], ".f13gfj74{transform:translateX(-50%);}", ".f1nfknbn{transform:translateX(50%);}", ".f1fj3zth{left:var(--fui-Slider--progress);}", ".fcf9u6w{right:var(--fui-Slider--progress);}", ".f5cv5a3{transform:translateY(50%);}", ".feeniun{bottom:var(--fui-Slider--progress);}"]
});
var useShapeStyles4 = __styles2({
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }]]
});
var useInputStyles9 = __styles2({
  input: {
    Bceei9c: "f1k6fduh",
    abs64n: "fk73vx1",
    Ijaq50: "f16hsg94",
    nk6f5a: "f1nzqi2z",
    Br312pm: "fwpfdsa",
    Bw0ie65: "fuur7zz",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    jo39rj: 0,
    C5zqim: 0,
    Bdlbwnu: 0,
    B8rk77i: 0,
    Bbzx7hc: 0,
    Hwkvcz: 0,
    B0nnt1c: 0,
    Brwsv5j: 0,
    B2b7vog: 0,
    B4hmq5e: 0,
    B8jxwem: 0,
    B18nadz: 0,
    Ddg5ig: 0,
    Byj09el: 0,
    Dac2s3: 0,
    Dd2y6r: 0,
    Bk0t58e: "f1nq8t98",
    Ewenww: 0,
    Brqi8qb: 0,
    zz3kca: 0,
    low6xx: "fjt56wq",
    d0s10n: 0,
    wea7l5: 0,
    olu5tv: 0,
    g5nsvh: 0,
    Bqvnfwh: "f1n9m442"
  },
  horizontal: {
    Bqenvij: "f1yfdkfd",
    a9b677: "fly5x3f"
  },
  vertical: {
    Bqenvij: "f1l02sjl",
    a9b677: "f174ca62",
    Biqzhck: "f1r7j8g6",
    kgocjf: ["f1va4sj6", "f1r2v9sp"]
  }
}, {
  d: [".f1k6fduh{cursor:pointer;}", ".fk73vx1{opacity:0;}", ".f16hsg94{grid-row-start:1;}", ".f1nzqi2z{grid-row-end:-1;}", ".fwpfdsa{grid-column-start:1;}", ".fuur7zz{grid-column-end:-1;}", [".f1mk8lai{padding:0;}", {
    p: -1
  }], [".f1s184ao{margin:0;}", {
    p: -1
  }], ".f1yfdkfd{height:var(--fui-Slider__thumb--size);}", ".fly5x3f{width:100%;}", ".f1l02sjl{height:100%;}", ".f174ca62{width:var(--fui-Slider__thumb--size);}", ".f1r7j8g6{writing-mode:vertical-lr;}", ".f1va4sj6{direction:rtl;}", ".f1r2v9sp{direction:ltr;}"],
  i: [[".f1nq8t98:focus-visible~.fui-ColorSlider__thumb{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".fjt56wq:focus-visible~.fui-ColorSlider__thumb{outline:var(--strokeWidthThick) solid var(--colorTransparentStroke);}", {
    p: -1
  }], [".f1n9m442:focus-visible~.fui-ColorSlider__thumb{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }]]
});
var useColorSliderStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles27();
  const styles = useStyles97();
  const railStyles = useRailStyles2();
  const thumbStyles = useThumbStyles2();
  const inputStyles = useInputStyles9();
  const shapeStyles = useShapeStyles4();
  const channelStyles = useChannelStyles();
  const isVertical = state.vertical;
  state.root.className = mergeClasses(colorSliderClassNames.root, rootStyles, isVertical ? styles.vertical : styles.horizontal, state.root.className);
  state.rail.className = mergeClasses(colorSliderClassNames.rail, railStyles.rail, channelStyles[state.channel || "hue"], shapeStyles[state.shape || "rounded"], isVertical ? railStyles.vertical : railStyles.horizontal, state.rail.className);
  state.thumb.className = mergeClasses(colorSliderClassNames.thumb, thumbStyles.thumb, isVertical ? thumbStyles.vertical : thumbStyles.horizontal, state.thumb.className);
  state.input.className = mergeClasses(colorSliderClassNames.input, inputStyles.input, isVertical ? inputStyles.vertical : inputStyles.horizontal, state.input.className);
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/contexts/colorPicker.js
var React618 = __toESM(require_react());
var useColorPickerContextValues = (state) => {
  const { color: color2, shape, requestChange } = state;
  const colorPicker = {
    requestChange,
    color: color2,
    shape
  };
  return {
    colorPicker
  };
};
var colorPickerContextDefaultValue = {
  requestChange: () => {
  },
  color: void 0,
  shape: "rounded"
};
var colorPickerContext = createContext13(void 0);
var ColorPickerProvider = colorPickerContext.Provider;
var useColorPickerContextValue_unstable = (selector) => useContextSelector(colorPickerContext, (ctx = colorPickerContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-color-picker/lib/utils/constants.js
var MIN = 0;
var MAX = 100;
var HUE_MAX = 360;
var INITIAL_COLOR = "#FFF";
var INITIAL_COLOR_HSV = tinycolor(INITIAL_COLOR).toHsv();

// node_modules/@fluentui/react-color-picker/lib/utils/getPercent.js
var getPercent2 = (value, min2, max2) => {
  return max2 === min2 ? 0 : (value - min2) / (max2 - min2) * 100;
};

// node_modules/@fluentui/react-color-picker/lib/utils/createHsvColor.js
function createHsvColor({ h = 0, s = 0, v = 0, a = 1 }) {
  return {
    h,
    s,
    v,
    a
  };
}

// node_modules/@fluentui/react-color-picker/lib/utils/adjustChannel.js
function clampValue2(value, channel = "hue") {
  const MAX2 = channel === "hue" ? HUE_MAX : MAX;
  return clamp(value, MIN, MAX2);
}
function adjustChannel(channel, actions) {
  return actions[channel] || actions.hue;
}

// node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/useColorSlider.js
var useColorSlider_unstable = (props, ref) => {
  "use no memo";
  const { dir } = useFluent();
  const onChangeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.requestChange);
  const colorFromContext = useColorPickerContextValue_unstable((ctx) => ctx.color);
  const shapeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.shape);
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "onChange",
      "color"
    ]
  });
  const {
    color: color2,
    channel = "hue",
    onChange = onChangeFromContext,
    shape = shapeFromContext,
    vertical,
    // Slots
    root,
    input,
    rail,
    thumb
  } = props;
  const hsvColor = color2 || colorFromContext;
  const hslColor = tinycolor(hsvColor).toHsl();
  const [currentColor, setCurrentColor] = useControllableState({
    defaultState: props.defaultColor,
    state: hsvColor,
    initialState: INITIAL_COLOR_HSV
  });
  const MAX2 = channel === "hue" ? HUE_MAX : MAX;
  const valueChannelActions = {
    hue: clampValue2(currentColor.h),
    saturation: clampValue2(currentColor.s * 100),
    value: clampValue2(currentColor.v * 100)
  };
  const clampedValue = adjustChannel(channel, valueChannelActions);
  const valuePercent = getPercent2(clampedValue, MIN, MAX2);
  const inputOnChange = input === null || input === void 0 ? void 0 : input.onChange;
  const _onChange = useEventCallback((event) => {
    const newValue = Number(event.target.value);
    const colorActions = {
      hue: () => createHsvColor({
        ...hsvColor,
        h: newValue
      }),
      saturation: () => createHsvColor({
        ...hsvColor,
        s: newValue / 100
      }),
      value: () => createHsvColor({
        ...hsvColor,
        v: newValue / 100
      })
    };
    const newColor = adjustChannel(channel, colorActions)();
    setCurrentColor(newColor);
    inputOnChange === null || inputOnChange === void 0 ? void 0 : inputOnChange(event);
    onChange === null || onChange === void 0 ? void 0 : onChange(event, {
      type: "change",
      event,
      color: newColor
    });
  });
  const rootVariables = {
    [colorSliderCSSVars.sliderDirectionVar]: vertical ? "180deg" : dir === "ltr" ? "-90deg" : "90deg",
    [colorSliderCSSVars.sliderProgressVar]: `${valuePercent}%`,
    [colorSliderCSSVars.thumbColorVar]: channel === "hue" ? `hsl(${clampedValue}, 100%, 50%)` : tinycolor(hsvColor).toRgbString(),
    [colorSliderCSSVars.railColorVar]: channel === "hue" ? `hsl(${hslColor.h} ${hslColor.s * 100}%, ${hslColor.l * 100}%)` : `hsl(${hslColor.h} 100%, 50%)`
  };
  const state = {
    shape,
    vertical,
    channel,
    components: {
      input: "input",
      rail: "div",
      root: "div",
      thumb: "div"
    },
    root: slot_exports.always(root, {
      defaultProps: {
        role: "group",
        ...nativeProps.root
      },
      elementType: "div"
    }),
    input: slot_exports.always(input, {
      defaultProps: {
        id: useId2("slider-", props.id),
        ref,
        min: MIN,
        max: MAX2,
        tabIndex: 0,
        ["aria-orientation"]: vertical ? "vertical" : "horizontal",
        ...nativeProps.primary,
        type: "range"
      },
      elementType: "input"
    }),
    rail: slot_exports.always(rail, {
      elementType: "div"
    }),
    thumb: slot_exports.always(thumb, {
      elementType: "div"
    })
  };
  state.root.style = {
    ...rootVariables,
    ...state.root.style
  };
  state.input.value = clampedValue;
  state.input.onChange = _onChange;
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/renderColorSlider.js
var renderColorSlider_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      jsx(state.rail, {}),
      jsx(state.thumb, {})
    ]
  });
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/ColorSlider.js
var ColorSlider = React620.forwardRef((props, ref) => {
  const state = useColorSlider_unstable(props, ref);
  useColorSliderStyles_unstable(state);
  useCustomStyleHook("useColorSliderStyles_unstable")(state);
  return renderColorSlider_unstable(state);
});
ColorSlider.displayName = "ColorSlider";

// node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/ColorPicker.js
var React622 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/useColorPicker.js
var React621 = __toESM(require_react());
var useColorPicker_unstable = (props, ref) => {
  const { color: color2, onColorChange, shape, ...rest } = props;
  const requestChange = useEventCallback((event, data) => {
    onColorChange === null || onColorChange === void 0 ? void 0 : onColorChange(event, {
      type: "change",
      event,
      color: data.color
    });
  });
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...rest
    }), {
      elementType: "div"
    }),
    color: color2,
    requestChange,
    shape
  };
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/renderColorPicker.js
var renderColorPicker_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(ColorPickerProvider, {
    value: contextValues.colorPicker,
    children: jsx(state.root, {
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/useColorPickerStyles.styles.js
var colorPickerClassNames = {
  root: "fui-ColorPicker"
};
var useStyles98 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f7e3wsx"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", [".f7e3wsx{gap:var(--spacingVerticalXS);}", {
    p: -1
  }]]
});
var useColorPickerStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles98();
  state.root.className = mergeClasses(colorPickerClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/ColorPicker.js
var ColorPicker = React622.forwardRef((props, ref) => {
  const state = useColorPicker_unstable(props, ref);
  const contextValues = useColorPickerContextValues(state);
  useColorPickerStyles_unstable(state);
  useCustomStyleHook("useColorPickerStyles_unstable")(state);
  return renderColorPicker_unstable(state, contextValues);
});
ColorPicker.displayName = "ColorPicker";

// node_modules/@fluentui/react-color-picker/lib/components/ColorArea/ColorArea.js
var React624 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/ColorArea/useColorArea.js
var React623 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/ColorArea/useColorAreaStyles.styles.js
var colorAreaClassNames = {
  root: "fui-ColorArea",
  thumb: "fui-ColorArea__thumb",
  inputX: "fui-ColorArea__inputX",
  inputY: "fui-ColorArea__inputY"
};
var colorAreaCSSVars = {
  areaXProgressVar: `--fui-AreaX--progress`,
  areaYProgressVar: `--fui-AreaY--progress`,
  thumbColorVar: `--fui-Area__thumb--color`,
  mainColorVar: `--fui-Area--main-color`
};
var useRootStyles28 = __resetStyles("r77w3t7", "r9og4es", [".r77w3t7{position:relative;border:1px solid var(--colorNeutralStroke1);background:linear-gradient(to bottom, transparent, #000),linear-gradient(to right, #fff, transparent),var(--fui-Area--main-color);forced-color-adjust:none;display:inline-grid;touch-action:none;align-items:start;justify-items:start;--fui-Slider__thumb--size:20px;min-width:300px;min-height:300px;box-sizing:border-box;margin-bottom:var(--spacingVerticalSNudge);}", ".r9og4es{position:relative;border:1px solid var(--colorNeutralStroke1);background:linear-gradient(to bottom, transparent, #000),linear-gradient(to left, #fff, transparent),var(--fui-Area--main-color);forced-color-adjust:none;display:inline-grid;touch-action:none;align-items:start;justify-items:start;--fui-Slider__thumb--size:20px;min-width:300px;min-height:300px;box-sizing:border-box;margin-bottom:var(--spacingVerticalSNudge);}"]);
var useThumbStyles3 = __styles2({
  thumb: {
    qhf8xq: "f1euv43f",
    a9b677: "f174ca62",
    Bqenvij: "f1yfdkfd",
    Bkecrkj: "f1aehjj5",
    oeaueh: "f1s6fcnf",
    Bvjb7m6: "fdgv6k0",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f1lvq45z",
    E5pizo: "f1whvlc6",
    De3pzq: "fqogvx2",
    Bz10aip: ["f1g1iug4", "f11okln6"],
    oyh7mz: ["f1r4bsg1", "fwsk87b"],
    B5kzvoi: "f1rtkqdg",
    Brfgrao: "f1j7ml58",
    lawp4y: 0,
    Fbdkly: 0,
    mdwyqc: 0,
    Bciustq: 0,
    gc50h5: "f1abv9ik",
    r59vdv: 0,
    Budzafs: 0,
    ck0cow: 0,
    n07z76: 0,
    Gng75u: "fielpny",
    Bcvre1j: "fyl8oag",
    Ftih45: "fzhtfnv",
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f3i7wkk"
  },
  focusIndicator: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    Bssx7fj: "f1b1k54r",
    uh7if5: ["f4ne723", "fqqcjud"],
    clntm0: "fh7aioi",
    Dlk2r6: ["fqqcjud", "f4ne723"],
    Bm3wd5j: "f1k55ka9",
    Bbrhkcr: ["fgclinu", "f16pcs8n"],
    f1oku: "fycbxed",
    aywvf2: ["f16pcs8n", "fgclinu"],
    B2j2mmj: "ffht0p2",
    wigs8: "f1p0ul1q",
    pbfy6t: "f1c901ms",
    B0v4ure: "f1alokd7",
    Byrf0fs: 0,
    Bsiemmq: 0,
    Bwckmig: 0,
    skfxo0: 0,
    Iidy0u: 0,
    B98u21t: 0,
    Bvwlmkc: 0,
    jo1ztg: 0,
    Ba1iezr: 0,
    Blmvk6g: 0,
    B24cy0v: 0,
    Bil7v7r: 0,
    Br3gin4: 0,
    nr063g: 0,
    ghq09: 0,
    Bbgo44z: 0,
    Bseh09z: "f1i978nd",
    az1dzo: 0,
    Ba3ybja: 0,
    B6352mv: 0,
    vppk2z: 0,
    Biaj6j7: "f16hcqkr",
    B2pnrqr: "f1tye2sp",
    B29w5g4: ["flw7qy0", "f1t01kh7"],
    Bhhzhcn: "frujvlw",
    Bec0n69: ["f1t01kh7", "flw7qy0"]
  }
}, {
  d: [".f1euv43f{position:absolute;}", ".f174ca62{width:var(--fui-Slider__thumb--size);}", ".f1yfdkfd{height:var(--fui-Slider__thumb--size);}", ".f1aehjj5{pointer-events:none;}", ".f1s6fcnf{outline-style:none;}", ".fdgv6k0{forced-color-adjust:none;}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1lvq45z{border:var(--strokeWidthThin) solid var(--colorNeutralForeground4);}", {
    p: -2
  }], ".f1whvlc6{box-shadow:var(--shadow4);}", ".fqogvx2{background-color:var(--fui-Area__thumb--color);}", ".f1g1iug4{transform:translate(-50%, 50%);}", ".f11okln6{transform:translate(50%, 50%);}", ".f1r4bsg1{left:var(--fui-AreaX--progress);}", ".fwsk87b{right:var(--fui-AreaX--progress);}", ".f1rtkqdg{bottom:var(--fui-AreaY--progress);}", ".f1j7ml58::before{position:absolute;}", [".f1abv9ik::before{inset:0px;}", {
    p: -1
  }], [".fielpny::before{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".fyl8oag::before{box-sizing:border-box;}", ".fzhtfnv::before{content:'';}", [".f3i7wkk::before{border:var(--strokeWidthThick) solid var(--colorNeutralBackground1);}", {
    p: -2
  }], ".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}", ".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}", ".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}", ".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}", '.ffht0p2[data-fui-focus-within]:focus-within::after{content:"";}', ".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}", ".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}", ".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}", [".f1i978nd[data-fui-focus-within]:focus-within::after{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f16hcqkr[data-fui-focus-within]:focus-within::after{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".f1tye2sp[data-fui-focus-within]:focus-within::after{top:calc(var(--strokeWidthThick) * -1);}", ".flw7qy0[data-fui-focus-within]:focus-within::after{right:calc(var(--strokeWidthThick) * -1);}", ".f1t01kh7[data-fui-focus-within]:focus-within::after{left:calc(var(--strokeWidthThick) * -1);}", ".frujvlw[data-fui-focus-within]:focus-within::after{bottom:calc(var(--strokeWidthThick) * -1);}"],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"],
  m: [["@media (forced-colors: active){.f1k55ka9[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f16pcs8n[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}.fgclinu[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fycbxed[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useInputStyles10 = __styles2({
  input: {
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    qhf8xq: "f1euv43f",
    Bkecrkj: "f1aehjj5",
    Bhzewxz: "f15twtuk",
    oyh7mz: ["f1vgc2s3", "f1e31b4d"],
    abs64n: "fk73vx1",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    a9b677: "fly5x3f",
    Bqenvij: "f1l02sjl"
  }
}, {
  d: [[".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], ".f1euv43f{position:absolute;}", ".f1aehjj5{pointer-events:none;}", ".f15twtuk{top:0;}", ".f1vgc2s3{left:0;}", ".f1e31b4d{right:0;}", ".fk73vx1{opacity:0;}", [".f1mk8lai{padding:0;}", {
    p: -1
  }], [".f1s184ao{margin:0;}", {
    p: -1
  }], ".fly5x3f{width:100%;}", ".f1l02sjl{height:100%;}"]
});
var useShapeStyles5 = __styles2({
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }]]
});
var useColorAreaStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles28();
  const thumbStyles = useThumbStyles3();
  const inputStyles = useInputStyles10();
  const shapeStyles = useShapeStyles5();
  state.root.className = mergeClasses(colorAreaClassNames.root, rootStyles, shapeStyles[state.shape || "rounded"], state.root.className);
  state.thumb.className = mergeClasses(colorAreaClassNames.thumb, thumbStyles.thumb, thumbStyles.focusIndicator, state.thumb.className);
  state.inputX.className = mergeClasses(colorAreaClassNames.inputX, inputStyles.input, state.inputX.className);
  state.inputY.className = mergeClasses(colorAreaClassNames.inputY, inputStyles.input, state.inputY.className);
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/utils/getCoordinates.js
function getCoordinates(element, event) {
  const rect = element.getBoundingClientRect();
  const newX = roundTwoDecimal((event.clientX - rect.left) / rect.width);
  const newY = roundTwoDecimal(1 - (event.clientY - rect.top) / rect.height);
  return {
    x: clamp(newX, 0, 1),
    y: clamp(newY, 0, 1)
  };
}
function roundTwoDecimal(num) {
  return Math.round(num * 100) / 100;
}

// node_modules/@fluentui/react-color-picker/lib/components/ColorArea/useColorArea.js
var useColorArea_unstable = (props, ref) => {
  const { targetDocument } = useFluent();
  const rootRef = React623.useRef(null);
  const xRef = React623.useRef(null);
  const yRef = React623.useRef(null);
  const focusWithinRef = useFocusWithin();
  const onChangeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.requestChange);
  const colorFromContext = useColorPickerContextValue_unstable((ctx) => ctx.color);
  const shapeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.shape);
  const {
    onChange = onChangeFromContext,
    shape = shapeFromContext,
    // Slots
    inputX,
    inputY,
    thumb,
    color: color2,
    ...rest
  } = props;
  const [hsvColor, setColor] = useControllableState({
    defaultState: props.defaultColor,
    state: color2 || colorFromContext,
    initialState: INITIAL_COLOR_HSV
  });
  const saturation = Math.round(hsvColor.s * 100);
  const value = Math.round(hsvColor.v * 100);
  const [activeAxis, setActiveAxis] = React623.useState(null);
  const requestColorChange = useEventCallback((event) => {
    if (!rootRef.current) {
      return;
    }
    const coordinates = getCoordinates(rootRef.current, event);
    const newColor = {
      ...hsvColor,
      s: coordinates.x,
      v: coordinates.y
    };
    setColor(newColor);
    onChange === null || onChange === void 0 ? void 0 : onChange(event, {
      type: "change",
      event,
      color: newColor
    });
  });
  const handleDocumentPointerMove = React623.useCallback((event) => {
    requestColorChange(event);
  }, [
    requestColorChange
  ]);
  const handleDocumentPointerUp = useEventCallback(() => {
    targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("pointermove", handleDocumentPointerMove);
  });
  const handleRootOnPointerDown = useEventCallback((event) => {
    event.stopPropagation();
    event.preventDefault();
    requestColorChange(event.nativeEvent);
    targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("pointermove", handleDocumentPointerMove);
    targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("pointerup", handleDocumentPointerUp, {
      once: true
    });
  });
  const handleInputOnChange = useEventCallback((event) => {
    const targetValue = Number(event.target.value) / 100;
    const newColor = {
      ...hsvColor,
      ...event.target === xRef.current && {
        s: targetValue
      },
      ...event.target === yRef.current && {
        v: targetValue
      }
    };
    setColor(newColor);
    onChange === null || onChange === void 0 ? void 0 : onChange(event, {
      type: "change",
      event,
      color: newColor
    });
  });
  const handleRootOnKeyDown = useEventCallback((event) => {
    let deltaX = 0;
    let deltaY = 0;
    let axis = "x";
    switch (event.key) {
      case "ArrowUp":
        event.preventDefault();
        axis = "y";
        deltaY = 1;
        break;
      case "ArrowDown":
        event.preventDefault();
        axis = "y";
        deltaY = -1;
        break;
      case "ArrowLeft":
        event.preventDefault();
        axis = "x";
        deltaX = -1;
        break;
      case "ArrowRight":
        event.preventDefault();
        axis = "x";
        deltaX = 1;
        break;
    }
    if (deltaX === 0 && deltaY === 0) {
      return;
    }
    const newColor = {
      ...hsvColor,
      s: Math.min(Math.max(hsvColor.s + deltaX / 100, 0), 1),
      v: Math.min(Math.max(hsvColor.v + deltaY / 100, 0), 1)
    };
    setColor(newColor);
    setActiveAxis(axis);
    onChange === null || onChange === void 0 ? void 0 : onChange(event, {
      type: "change",
      event,
      color: newColor
    });
  });
  const rootVariables = {
    [colorAreaCSSVars.areaXProgressVar]: `${saturation}%`,
    [colorAreaCSSVars.areaYProgressVar]: `${value}%`,
    [colorAreaCSSVars.thumbColorVar]: tinycolor(hsvColor).toRgbString(),
    [colorAreaCSSVars.mainColorVar]: `hsl(${hsvColor.h}, 100%, 50%)`
  };
  const state = {
    shape,
    components: {
      inputX: "input",
      inputY: "input",
      root: "div",
      thumb: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...rest
    }), {
      elementType: "div"
    }),
    inputX: slot_exports.always(inputX, {
      defaultProps: {
        id: useId2("sliderX-"),
        type: "range",
        ...activeAxis && {
          tabIndex: activeAxis === "x" ? 0 : -1
        }
      },
      elementType: "input"
    }),
    inputY: slot_exports.always(inputY, {
      defaultProps: {
        id: useId2("sliderY-"),
        type: "range",
        tabIndex: activeAxis && activeAxis === "y" ? 0 : -1
      },
      elementType: "input"
    }),
    thumb: slot_exports.always(thumb, {
      elementType: "div"
    })
  };
  state.root.ref = useMergedRefs(state.root.ref, rootRef);
  state.thumb.ref = useMergedRefs(state.thumb.ref, focusWithinRef);
  state.inputX.ref = useMergedRefs(state.inputX.ref, xRef);
  state.inputY.ref = useMergedRefs(state.inputY.ref, yRef);
  state.root.style = {
    ...state.root.style,
    ...rootVariables
  };
  state.root.onPointerDown = useEventCallback(mergeCallbacks(state.root.onPointerDown, handleRootOnPointerDown));
  state.root.onKeyDown = useEventCallback(mergeCallbacks(state.root.onKeyDown, handleRootOnKeyDown));
  state.inputX.onChange = useEventCallback(mergeCallbacks(state.inputX.onChange, handleInputOnChange));
  state.inputY.onChange = useEventCallback(mergeCallbacks(state.inputY.onChange, handleInputOnChange));
  state.inputX.value = saturation;
  state.inputY.value = value;
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorArea/renderColorArea.js
var renderColorArea_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsxs(state.thumb, {
      children: [
        jsx(state.inputX, {}),
        jsx(state.inputY, {})
      ]
    })
  });
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorArea/ColorArea.js
var ColorArea = React624.forwardRef((props, ref) => {
  const state = useColorArea_unstable(props, ref);
  useColorAreaStyles_unstable(state);
  useCustomStyleHook("useColorAreaStyles_unstable")(state);
  return renderColorArea_unstable(state);
});
ColorArea.displayName = "ColorArea";

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/AlphaSlider.js
var React627 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/useAlphaSlider.js
var React626 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/useAlphaSliderState.js
var React625 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/useAlphaSliderStyles.styles.js
var alphaSliderClassNames = {
  root: "fui-AlphaSlider",
  rail: "fui-AlphaSlider__rail",
  thumb: "fui-AlphaSlider__thumb",
  input: "fui-AlphaSlider__input"
};
var alphaSliderCSSVars = {
  sliderDirectionVar: `--fui-AlphaSlider--direction`,
  sliderProgressVar: `--fui-AlphaSlider--progress`,
  thumbColorVar: `--fui-AlphaSlider__thumb--color`,
  railColorVar: `--fui-AlphaSlider__rail--color`
};
var useStyles99 = __styles2({
  rail: {
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fm9niy",
    Bcmaq0h: "f183gti0"
  }
}, {
  d: [[".fm9niy{border:1px solid var(--colorNeutralStroke1);}", {
    p: -2
  }], `.f183gti0{background-image:linear-gradient(var(--fui-AlphaSlider--direction), transparent, var(--fui-AlphaSlider__rail--color)),url(https://fabricweb.azureedge.net/fabric-website/assets/images/transparent-pattern.png);}`]
});
var useThumbStyles4 = __styles2({
  thumb: {
    De3pzq: "fxugw4r",
    cmx5o7: "f5vbyc6"
  },
  horizontal: {
    Bz10aip: ["f13gfj74", "f1nfknbn"],
    oyh7mz: ["fsmxtey", "fh8h8tc"]
  },
  vertical: {
    Bz10aip: "f5cv5a3",
    B5kzvoi: "falo4kr"
  }
}, {
  d: [".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f5vbyc6::before{background-color:var(--fui-AlphaSlider__thumb--color);}", ".f13gfj74{transform:translateX(-50%);}", ".f1nfknbn{transform:translateX(50%);}", ".fsmxtey{left:var(--fui-AlphaSlider--progress);}", ".fh8h8tc{right:var(--fui-AlphaSlider--progress);}", ".f5cv5a3{transform:translateY(50%);}", ".falo4kr{bottom:var(--fui-AlphaSlider--progress);}"]
});
var useAlphaSliderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles99();
  const thumbStyles = useThumbStyles4();
  state.root.className = mergeClasses(alphaSliderClassNames.root, state.root.className);
  state.input.className = mergeClasses(alphaSliderClassNames.input, state.input.className);
  state.rail.className = mergeClasses(alphaSliderClassNames.rail, styles.rail, state.rail.className);
  state.thumb.className = mergeClasses(alphaSliderClassNames.thumb, thumbStyles.thumb, state.vertical ? thumbStyles.vertical : thumbStyles.horizontal, state.thumb.className);
  state.thumb.className = mergeClasses(alphaSliderClassNames.thumb, thumbStyles.thumb, state.vertical ? thumbStyles.vertical : thumbStyles.horizontal, state.thumb.className);
  useColorSliderStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/alphaSliderUtils.js
function adjustToTransparency(value, transparency) {
  return transparency ? 100 - value : value;
}
function calculateTransparencyValue(transparency, value) {
  return value !== void 0 ? adjustToTransparency(value * 100, transparency) : void 0;
}
function getSliderDirection(dir, vertical, transparency) {
  if (vertical) {
    return transparency ? "180deg" : "0deg";
  }
  return dir === "ltr" && !transparency ? "90deg" : "-90deg";
}

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/useAlphaSliderState.js
var useAlphaSliderState_unstable = (state, props) => {
  "use no memo";
  var _props_defaultColor;
  const { dir } = useFluent();
  const onChangeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.requestChange);
  const colorFromContext = useColorPickerContextValue_unstable((ctx) => ctx.color);
  const { color: color2, onChange = onChangeFromContext, transparency = false, vertical = false } = props;
  const hsvColor = color2 || colorFromContext;
  const hslColor = tinycolor(hsvColor).toHsl();
  const [currentValue, setCurrentValue] = useControllableState({
    defaultState: calculateTransparencyValue(transparency, (_props_defaultColor = props.defaultColor) === null || _props_defaultColor === void 0 ? void 0 : _props_defaultColor.a),
    state: calculateTransparencyValue(transparency, hsvColor === null || hsvColor === void 0 ? void 0 : hsvColor.a),
    initialState: adjustToTransparency(100, transparency)
  });
  const clampedValue = clamp(currentValue, MIN, MAX);
  const valuePercent = getPercent2(clampedValue, MIN, MAX);
  const inputOnChange = state.input.onChange;
  const _onChange = useEventCallback((event) => {
    const newValue = adjustToTransparency(Number(event.target.value), transparency);
    const newColor = createHsvColor({
      ...hsvColor,
      a: newValue / 100
    });
    setCurrentValue(newValue);
    inputOnChange === null || inputOnChange === void 0 ? void 0 : inputOnChange(event);
    onChange === null || onChange === void 0 ? void 0 : onChange(event, {
      type: "change",
      event,
      color: newColor
    });
  });
  const sliderDirection = getSliderDirection(dir, vertical, transparency);
  const rootVariables = {
    [alphaSliderCSSVars.sliderDirectionVar]: sliderDirection,
    [alphaSliderCSSVars.sliderProgressVar]: `${valuePercent}%`,
    [alphaSliderCSSVars.thumbColorVar]: `hsla(${hslColor.h} ${hslColor.s * 100}%, ${hslColor.l * 100}%, ${hslColor.a})`,
    [alphaSliderCSSVars.railColorVar]: `hsl(${hslColor.h} ${hslColor.s * 100}%, ${hslColor.l * 100}%)`
  };
  state.root.style = {
    ...rootVariables,
    ...state.root.style
  };
  state.input.value = clampedValue;
  state.input.onChange = _onChange;
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/useAlphaSlider.js
var useAlphaSlider_unstable = (props, ref) => {
  const shapeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.shape);
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "onChange",
      "color"
    ]
  });
  const {
    shape = shapeFromContext,
    vertical,
    // Slots
    root,
    input,
    rail,
    thumb
  } = props;
  const state = {
    shape,
    vertical,
    components: {
      input: "input",
      rail: "div",
      root: "div",
      thumb: "div"
    },
    root: slot_exports.always(root, {
      defaultProps: nativeProps.root,
      elementType: "div"
    }),
    input: slot_exports.always(input, {
      defaultProps: {
        id: useId2("slider-", props.id),
        ref,
        ...nativeProps.primary,
        type: "range"
      },
      elementType: "input"
    }),
    rail: slot_exports.always(rail, {
      elementType: "div"
    }),
    thumb: slot_exports.always(thumb, {
      elementType: "div"
    })
  };
  useAlphaSliderState_unstable(state, props);
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/renderAlphaSlider.js
var renderAlphaSlider_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      jsx(state.rail, {}),
      jsx(state.thumb, {})
    ]
  });
};

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/AlphaSlider.js
var AlphaSlider = React627.forwardRef((props, ref) => {
  const state = useAlphaSlider_unstable(props, ref);
  useAlphaSliderStyles_unstable(state);
  useCustomStyleHook("useAlphaSliderStyles_unstable")(state);
  return renderAlphaSlider_unstable(state);
});
AlphaSlider.displayName = "AlphaSlider";

// node_modules/@fluentui/react-nav/lib/components/Nav/Nav.js
var React631 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/Nav/useNav.js
var React628 = __toESM(require_react());
function initializeUncontrolledOpenCategories({ defaultOpenCategories, multiple }) {
  if (defaultOpenCategories !== void 0) {
    if (Array.isArray(defaultOpenCategories)) {
      return multiple ? defaultOpenCategories : [
        defaultOpenCategories[0]
      ];
    }
    return [
      defaultOpenCategories
    ];
  }
  return void 0;
}
var updateOpenCategories = (value, previousOpenItems, multiple) => {
  if (multiple) {
    if (previousOpenItems.includes(value)) {
      return previousOpenItems.filter((i) => i !== value);
    } else {
      return [
        ...previousOpenItems,
        value
      ];
    }
  }
  return previousOpenItems[0] === value ? [] : [
    value
  ];
};
var useNav_unstable = (props, ref) => {
  const { onNavItemSelect, onNavCategoryItemToggle, multiple = true, density = "medium", openCategories: controlledOpenCategoryItems, selectedCategoryValue: controlledSelectedCategoryValue, selectedValue: controlledSelectedValue, defaultOpenCategories, defaultSelectedValue, defaultSelectedCategoryValue } = props;
  const innerRef = React628.useRef(null);
  const [openCategories, setOpenCategories] = useControllableState({
    state: controlledOpenCategoryItems,
    defaultState: initializeUncontrolledOpenCategories({
      defaultOpenCategories,
      multiple
    }),
    initialState: []
  });
  const [selectedCategoryValue, setSelectedCategoryValue] = useControllableState({
    state: controlledSelectedCategoryValue,
    defaultState: defaultSelectedCategoryValue,
    initialState: void 0
  });
  const [selectedValue, setSelectedValue] = useControllableState({
    state: controlledSelectedValue,
    defaultState: defaultSelectedValue,
    initialState: void 0
  });
  const currentSelectedValue = React628.useRef(void 0);
  const previousSelectedValue = React628.useRef(void 0);
  const currentSelectedCategoryValue = React628.useRef(void 0);
  const previousSelectedCategoryValue = React628.useRef(void 0);
  if (currentSelectedValue.current !== selectedValue) {
    previousSelectedValue.current = currentSelectedValue.current;
    currentSelectedValue.current = selectedValue;
  }
  if (currentSelectedCategoryValue.current !== selectedCategoryValue) {
    previousSelectedCategoryValue.current = currentSelectedCategoryValue.current;
    currentSelectedCategoryValue.current = selectedCategoryValue;
  }
  const onSelect = useEventCallback((event, data) => {
    setSelectedValue(data.value);
    setSelectedCategoryValue(data.categoryValue ? data.categoryValue : "");
    onNavItemSelect === null || onNavItemSelect === void 0 ? void 0 : onNavItemSelect(event, data);
  });
  const onRequestNavCategoryItemToggle = useEventCallback((event, data) => {
    if (data.categoryValue !== void 0) {
      const nextOpenCategories = updateOpenCategories(data.categoryValue, openCategories !== null && openCategories !== void 0 ? openCategories : [], multiple);
      onNavCategoryItemToggle === null || onNavCategoryItemToggle === void 0 ? void 0 : onNavCategoryItemToggle(event, data);
      setOpenCategories(nextOpenCategories);
    }
  });
  const registeredNavItems = React628.useRef({});
  const onRegister = React628.useCallback((data) => {
    registeredNavItems.current[JSON.stringify(data.value)] = data;
  }, []);
  const onUnregister = React628.useCallback((data) => {
    delete registeredNavItems.current[JSON.stringify(data.value)];
  }, []);
  const getRegisteredNavItems = React628.useCallback(() => {
    return {
      selectedValue: currentSelectedValue.current,
      previousSelectedValue: previousSelectedValue.current,
      selectedCategoryValue: currentSelectedCategoryValue.current,
      previousSelectedCategoryValue: previousSelectedCategoryValue.current,
      registeredNavItems: registeredNavItems.current
    };
  }, []);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, innerRef),
      ...props
    }), {
      elementType: "div"
    }),
    openCategories,
    selectedValue,
    selectedCategoryValue,
    onRegister,
    onUnregister,
    onSelect,
    getRegisteredNavItems,
    onRequestNavCategoryItemToggle,
    multiple,
    density
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavContext.js
var React629 = __toESM(require_react());
var navContextDefaultValue = {
  selectedValue: void 0,
  selectedCategoryValue: void 0,
  onRegister: () => {
  },
  onUnregister: () => {
  },
  onSelect: () => {
  },
  getRegisteredNavItems: () => {
    return {
      registeredNavItems: {}
    };
  },
  onRequestNavCategoryItemToggle() {
  },
  /**
  * The list of opened panels by index
  */
  openCategories: [],
  /**
  * Indicates if Nav supports multiple open Categories at the same time.
  */
  multiple: true,
  /**
  * Indicates the vertical density and density of the Nav.
  */
  density: "medium"
};
var NavContext = React629.createContext(void 0);
var NavProvider = NavContext.Provider;
var useNavContext_unstable = () => React629.useContext(NavContext) || navContextDefaultValue;

// node_modules/@fluentui/react-nav/lib/components/Nav/renderNav.js
var renderNav_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(NavProvider, {
    value: contextValues.nav,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-nav/lib/components/Nav/useNavStyles.styles.js
var navClassNames = {
  root: "fui-Nav"
};
var useStyles100 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}"]
});
var useNavStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles100();
  state.root.className = mergeClasses(navClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/useNavContextValues.js
var React630 = __toESM(require_react());
function useNavContextValues_unstable(state) {
  const { selectedValue, selectedCategoryValue, onRegister, onUnregister, onSelect, getRegisteredNavItems, onRequestNavCategoryItemToggle, openCategories, multiple, density, onNavItemSelect } = state;
  const navContext = React630.useMemo(() => ({
    selectedValue,
    selectedCategoryValue,
    onSelect,
    onRegister,
    onUnregister,
    getRegisteredNavItems,
    onRequestNavCategoryItemToggle,
    openCategories,
    multiple,
    density,
    onNavItemSelect
  }), [
    selectedValue,
    selectedCategoryValue,
    onSelect,
    onRegister,
    onUnregister,
    getRegisteredNavItems,
    onRequestNavCategoryItemToggle,
    openCategories,
    multiple,
    density,
    onNavItemSelect
  ]);
  return {
    nav: navContext
  };
}

// node_modules/@fluentui/react-nav/lib/components/Nav/Nav.js
var Nav = React631.forwardRef((props, ref) => {
  const state = useNav_unstable(props, ref);
  const contextValues = useNavContextValues_unstable(state);
  useNavStyles_unstable(state);
  useCustomStyleHook("useHamburgerStyles_unstable")(state);
  return renderNav_unstable(state, contextValues);
});
Nav.displayName = "Nav";

// node_modules/@fluentui/react-nav/lib/components/NavCategory/NavCategory.js
var React636 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavCategory/useNavCategory.js
var React632 = __toESM(require_react());
var useNavCategory_unstable = (props, ref) => {
  const { value, children: children2 } = props;
  const { openCategories } = useNavContext_unstable();
  const open = openCategories === null || openCategories === void 0 ? void 0 : openCategories.includes(value);
  return {
    open,
    value,
    children: children2 !== null && children2 !== void 0 ? children2 : null
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavCategory/renderNavCategory.js
var React634 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavCategoryContext.js
var React633 = __toESM(require_react());
var NavCategoryContext = React633.createContext(void 0);
var navCategoryContextDefaultValue = {
  open: false,
  value: ""
};
var { Provider: NavCategoryProvider } = NavCategoryContext;
var useNavCategoryContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React633.useContext(NavCategoryContext)) !== null && _React_useContext !== void 0 ? _React_useContext : navCategoryContextDefaultValue;
};

// node_modules/@fluentui/react-nav/lib/components/NavCategory/renderNavCategory.js
var renderNavCategory_unstable = (state, contextValues) => {
  return React634.createElement(NavCategoryProvider, {
    value: contextValues.categoryValue
  }, state.children);
};

// node_modules/@fluentui/react-nav/lib/components/useNavCategoryContextValues_unstable.js
var React635 = __toESM(require_react());
function useNavCategoryContextValues_unstable(state) {
  const { open, value } = state;
  const navCategory = React635.useMemo(() => ({
    open,
    value
  }), [
    open,
    value
  ]);
  return {
    categoryValue: navCategory
  };
}

// node_modules/@fluentui/react-nav/lib/components/NavCategory/NavCategory.js
var NavCategory = React636.forwardRef((props, ref) => {
  const state = useNavCategory_unstable(props, ref);
  const contextValues = useNavCategoryContextValues_unstable(state);
  return renderNavCategory_unstable(state, contextValues);
});
NavCategory.displayName = "NavCategory";

// node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/NavCategoryItem.js
var React640 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/useNavCategoryItem.js
var React637 = __toESM(require_react());
var ExpandIconMotion = createPresenceComponent(() => {
  const keyframes = [
    {
      transform: "rotate(0deg) translate3D(0, 0, 0)"
    },
    {
      transform: "rotate(180deg) translate3D(0, 0, 0)"
    }
  ];
  const duration = motionTokens.durationFast;
  const easing = motionTokens.curveEasyEase;
  return {
    enter: {
      keyframes,
      duration,
      easing
    },
    exit: {
      keyframes: [
        ...keyframes
      ].reverse(),
      duration,
      easing
    }
  };
});
var useNavCategoryItem_unstable = (props, ref) => {
  const { onClick, expandIcon, icon } = props;
  const { open, value } = useNavCategoryContext_unstable();
  const { onRequestNavCategoryItemToggle, selectedCategoryValue, density = "medium" } = useNavContext_unstable();
  const onNavCategoryItemClick = useEventCallback(mergeCallbacks(onClick, (event) => onRequestNavCategoryItemToggle(event, {
    type: "click",
    event,
    value: "",
    categoryValue: value
  })));
  const selected = selectedCategoryValue === value && !open;
  const validAriaCurrent = selected && !open ? "page" : "false";
  return {
    open,
    value,
    selected,
    components: {
      root: "button",
      icon: "span",
      expandIcon: "span",
      expandIconMotion: ExpandIconMotion
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      ref,
      "aria-current": validAriaCurrent,
      "aria-expanded": open,
      ...props,
      onClick: onNavCategoryItemClick
    }), {
      elementType: "button"
    }),
    expandIcon: slot_exports.always(expandIcon, {
      defaultProps: {
        children: React637.createElement(ChevronDown20Regular, null),
        "aria-hidden": true
      },
      elementType: "span"
    }),
    expandIconMotion: presenceMotionSlot(props.expandIconMotion, {
      elementType: ExpandIconMotion,
      defaultProps: {
        visible: open
      }
    }),
    icon: slot_exports.optional(icon, {
      elementType: "span"
    }),
    density
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavCategoryItemContext.js
var React638 = __toESM(require_react());
var NavCategoryItemContext = React638.createContext(void 0);
var NavCategoryItemContextDefaultValues = {
  open: false
};
var { Provider: NavCategoryItemProvider } = NavCategoryItemContext;
var useNavCategoryItemContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React638.useContext(NavCategoryItemContext)) !== null && _React_useContext !== void 0 ? _React_useContext : NavCategoryItemContextDefaultValues;
};

// node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/renderNavCategoryItem.js
var getExpandIcon = (state) => {
  assertSlots(state);
  if (!state.expandIcon) {
    return null;
  }
  if (!state.expandIconMotion) {
    return jsx(state.expandIcon, {});
  }
  return jsx(state.expandIconMotion, {
    children: jsx(state.expandIcon, {})
  });
};
var renderNavCategoryItem_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(NavCategoryItemProvider, {
    value: contextValues.navCategoryItem,
    children: jsxs(state.root, {
      children: [
        state.icon && jsx(state.icon, {}),
        state.root.children,
        getExpandIcon(state)
      ]
    })
  });
};

// node_modules/@fluentui/react-nav/lib/components/sharedNavStyles.styles.js
var navItemTokens = {
  defaultDrawerWidth: 260,
  indicatorOffset: 16,
  indicatorWidth: 4,
  indicatorHeight: 20,
  backgroundColor: tokens.colorNeutralBackground4,
  backgroundColorHover: tokens.colorNeutralBackground4Hover,
  backgroundColorPressed: tokens.colorNeutralBackground4Pressed,
  animationTokens: {
    animationDuration: tokens.durationFaster,
    animationFillMode: "both",
    animationTimingFunction: tokens.curveLinear
  },
  transitionTokens: {
    transitionDuration: tokens.durationFaster,
    transitionTimingFunction: tokens.curveLinear,
    transitionProperty: "background"
  }
};
var useRootDefaultClassName = __resetStyles("rdi7s9k", "r94071", [".rdi7s9k{display:flex;text-transform:none;position:relative;justify-content:start;align-items:flex-start;text-align:left;gap:var(--spacingVerticalL);padding:var(--spacingVerticalMNudge) var(--spacingHorizontalS) var(--spacingVerticalMNudge) var(--spacingHorizontalMNudge);background-color:var(--colorNeutralBackground4);border-radius:var(--borderRadiusMedium);color:var(--colorNeutralForeground2);text-decoration-line:none;border:none;box-sizing:border-box;cursor:pointer;transition-duration:var(--durationFaster);transition-timing-function:var(--curveLinear);transition-property:background;width:100%;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);}", ".rdi7s9k:hover{background-color:var(--colorNeutralBackground4Hover);}", ".rdi7s9k:focus-visible{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);outline-offset:calc(var(--strokeWidthThick) * -1);}", ".r94071{display:flex;text-transform:none;position:relative;justify-content:start;align-items:flex-start;text-align:right;gap:var(--spacingVerticalL);padding:var(--spacingVerticalMNudge) var(--spacingHorizontalMNudge) var(--spacingVerticalMNudge) var(--spacingHorizontalS);background-color:var(--colorNeutralBackground4);border-radius:var(--borderRadiusMedium);color:var(--colorNeutralForeground2);text-decoration-line:none;border:none;box-sizing:border-box;cursor:pointer;transition-duration:var(--durationFaster);transition-timing-function:var(--curveLinear);transition-property:background;width:100%;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);}", ".r94071:hover{background-color:var(--colorNeutralBackground4Hover);}", ".r94071:focus-visible{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);outline-offset:calc(var(--strokeWidthThick) * -1);}"]);
var useSmallStyles = __styles2({
  root: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1434i56", "f1jkyjtc"]
  }
}, {
  d: [[".f1434i56{padding:var(--spacingVerticalXS) var(--spacingHorizontalS) var(--spacingVerticalXS) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".f1jkyjtc{padding:var(--spacingVerticalXS) var(--spacingHorizontalMNudge) var(--spacingVerticalXS) var(--spacingHorizontalS);}", {
    p: -1
  }]]
});
var useContentStyles4 = __styles2({
  selected: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});
var useIndicatorStyles4 = __styles2({
  base: {
    E3zdtr: "f1mdlcz9",
    xr36ep: "fpil94b",
    B67388b: "f90z1up",
    Bitv4sc: "f2ic3ny",
    Br128sd: "f1xz7mvd",
    rjyhj6: "f3i5gj0",
    Bjyk6c5: "fi4v1pz",
    Dlnsje: "f1tvrmnx",
    a2br6o: "f1p1ggug",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "f3b9emi",
    Bsft5z2: "f13zj6fq",
    faxfa8: 0,
    bj685l: 0,
    Bovfycw: 0,
    B8cfl5i: "fl9mdp8",
    Bg7zzdw: "f6174p6"
  }
}, {
  d: [".f1mdlcz9::after{position:absolute;}", ".fpil94b::after{animation-duration:var(--durationFaster);}", ".f90z1up::after{animation-fill-mode:both;}", ".f2ic3ny::after{animation-timing-function:var(--curveLinear);}", ".f1xz7mvd::after{animation-name:f1ayorr4;}", ".f3i5gj0::after{-webkit-margin-start:-16px;margin-inline-start:-16px;}", ".fi4v1pz::after{background-color:var(--colorCompoundBrandForeground1);}", ".f1tvrmnx::after{height:20px;}", ".f1p1ggug::after{width:4px;}", [".f3b9emi::after{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], '.f13zj6fq::after{content:"";}'],
  k: ["@keyframes f1ayorr4{0%{background:transparent;}100%{background:var(--colorCompoundBrandForeground1);}}"],
  m: [["@media (forced-colors: active){.fl9mdp8::after{outline:solid 2px var(--colorTransparentStroke);}}", {
    p: -1,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f6174p6::after{outline-offset:-2px;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useIconStyles13 = __styles2({
  base: {
    mc9l5x: "f13qh94s",
    zoa1oz: "fngvled",
    sshi5w: "f16gbxbe",
    Bf4jedk: "f11u7vat",
    Bt984gj: "f1w4ww9t",
    Brf1p80: "f4d9j23",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    B9gejnh: 0,
    yr4pdu: 0,
    Bvkmzld: 0,
    mqdk8l: 0,
    Gbjhqp: "f1uiug86",
    obb2bi: "fwrh02z",
    D0sxk3: "f16u1re",
    Esdz9e: 0,
    Bqil8sh: 0,
    Bbom3er: 0,
    djjtid: 0,
    mz70lj: "f1jsjwoh",
    t6yez3: "f8bsbmo"
  },
  selected: {
    C9vb3z: "f5rs5gh",
    ux3ctl: "f1ioc1t6",
    Ba906uv: "fey0lwf",
    D0sxk3: "fxoiby5",
    hndn0g: "fnh0dvc",
    cw2nnk: "fp7jrvw",
    Bkztwl0: "fdt4y6x",
    H8nmoi: "fvl64og",
    ipgedg: "ffh1t26"
  }
}, {
  d: [".f13qh94s{display:grid;}", ".fngvled{grid-template-areas:overlay-area;}", ".f16gbxbe{min-height:20px;}", ".f11u7vat{min-width:20px;}", ".f1w4ww9t{align-items:top;}", ".f4d9j23{justify-content:center;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], [".f1uiug86 .fui-Icon-filled{grid-area:overlay-area;}", {
    p: -1
  }], ".fwrh02z .fui-Icon-filled{color:transparent;}", ".f16u1re .fui-Icon-filled{display:none;}", [".f1jsjwoh .fui-Icon-regular{grid-area:overlay-area;}", {
    p: -1
  }], ".f8bsbmo .fui-Icon-regular{display:inline;}", ".f5rs5gh .fui-Icon-filled{animation-duration:var(--durationFaster);}", ".f1ioc1t6 .fui-Icon-filled{animation-fill-mode:both;}", ".fey0lwf .fui-Icon-filled{animation-timing-function:var(--curveLinear);}", ".fxoiby5 .fui-Icon-filled{display:inline;}", ".fnh0dvc .fui-Icon-filled{animation-name:f9t3kp0;}", ".fp7jrvw .fui-Icon-regular{animation-duration:var(--durationFaster);}", ".fdt4y6x .fui-Icon-regular{animation-fill-mode:both;}", ".fvl64og .fui-Icon-regular{animation-timing-function:var(--curveLinear);}", ".ffh1t26 .fui-Icon-regular{animation-name:fvunsy5;}"],
  k: ["@keyframes f9t3kp0{0%{opacity:0;color:transparent;}100%{opacity:1;color:var(--colorNeutralForeground2BrandSelected);}}", "@keyframes fvunsy5{0%{opacity:1;color:var(--colorNeutralForeground2);}100%{opacity:0;color:transparent;}}"]
});

// node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/useNavCategoryItem.styles.js
var navCategoryItemClassNames = {
  root: "fui-NavCategoryItem",
  icon: "fui-NavCategoryItem__icon",
  expandIcon: "fui-NavCategoryItem__expandIcon",
  expandIconMotion: "fui-NavCategoryItem__expandIconMotion"
};
var useExpandIconStyles = __styles2({
  base: {
    Jyy4pa: "f1lfeew",
    Bqenvij: "fjamq6b"
  },
  open: {
    Bz10aip: ["f93bgaf", "fcxki7x"]
  },
  selected: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".f1lfeew{-webkit-margin-start:auto;margin-inline-start:auto;}", ".fjamq6b{height:20px;}", ".f93bgaf{transform:rotate(90deg);}", ".fcxki7x{transform:rotate(-90deg);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});
var useRootStyles29 = __styles2({
  base: {
    a9b677: "fly5x3f"
  }
}, {
  d: [".fly5x3f{width:100%;}"]
});
var useNavCategoryItemStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles29();
  const smallStyles = useSmallStyles();
  const defaultRootClassName = useRootDefaultClassName();
  const contentStyles = useContentStyles4();
  const indicatorStyles = useIndicatorStyles4();
  const iconStyles = useIconStyles13();
  const expandIconStyles = useExpandIconStyles();
  const {
    selected,
    open,
    density
  } = state;
  state.root.className = mergeClasses(navCategoryItemClassNames.root, defaultRootClassName, rootStyles.base, density === "small" && smallStyles.root, selected && open === false && indicatorStyles.base, selected && open === false && contentStyles.selected, state.root.className);
  state.expandIcon.className = mergeClasses(navCategoryItemClassNames.expandIcon, expandIconStyles.base, state.open && expandIconStyles.open, state.expandIcon.className);
  if (state.icon) {
    state.icon.className = mergeClasses(navCategoryItemClassNames.icon, iconStyles.base, selected && iconStyles.selected, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/useNavCategoryItemContextValues_unstable.js
var React639 = __toESM(require_react());
function useNavCategoryItemContextValues_unstable(state) {
  const { open, value } = state;
  const navCategoryItem = React639.useMemo(() => ({
    open,
    value
  }), [
    open,
    value
  ]);
  return {
    navCategoryItem
  };
}

// node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/NavCategoryItem.js
var NavCategoryItem = React640.forwardRef((props, ref) => {
  const state = useNavCategoryItem_unstable(props, ref);
  const contextValues = useNavCategoryItemContextValues_unstable(state);
  useNavCategoryItemStyles_unstable(state);
  useCustomStyleHook("useNavCategoryItemStyles")(state);
  return renderNavCategoryItem_unstable(state, contextValues);
});
NavCategoryItem.displayName = "NavCategoryItem";

// node_modules/@fluentui/react-nav/lib/components/NavItem/NavItem.js
var React642 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavItem/useNavItem.js
var React641 = __toESM(require_react());
var useNavItem_unstable = (props, ref) => {
  const { onClick, value, icon, as, href } = props;
  const { selectedValue, onRegister, onUnregister, onSelect, density = "medium" } = useNavContext_unstable();
  const rootElementType = as || (href ? "a" : "button");
  const selected = selectedValue === value;
  const innerRef = React641.useRef(null);
  const onNavItemClick = useEventCallback((event) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
    if (!event.defaultPrevented && isHTMLElement(event.target)) {
      onSelect(event, {
        type: "click",
        event,
        value
      });
    }
  });
  const root = slot_exports.always(getIntrinsicElementProps(rootElementType, useARIAButtonProps(rootElementType, {
    "aria-current": selected ? "page" : "false",
    ...props
  })), {
    elementType: rootElementType,
    defaultProps: {
      ref,
      type: rootElementType
    }
  });
  root.onClick = onNavItemClick;
  React641.useEffect(() => {
    onRegister({
      value,
      ref: innerRef
    });
    return () => {
      onUnregister({
        value,
        ref: innerRef
      });
    };
  }, [
    onRegister,
    onUnregister,
    innerRef,
    value
  ]);
  return {
    components: {
      root: rootElementType,
      icon: "span"
    },
    root,
    icon: slot_exports.optional(icon, {
      elementType: "span"
    }),
    selected,
    value,
    density
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavItem/renderNavItem.js
var renderNavItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-nav/lib/components/NavItem/useNavItemStyles.styles.js
var navItemClassNames = {
  root: "fui-NavItem",
  icon: "fui-NavItem__icon"
};
var useNavItemStyles_unstable = (state) => {
  "use no memo";
  const rootDefaultClassName = useRootDefaultClassName();
  const smallStyles = useSmallStyles();
  const contentStyles = useContentStyles4();
  const indicatorStyles = useIndicatorStyles4();
  const iconStyles = useIconStyles13();
  const {
    selected,
    density
  } = state;
  state.root.className = mergeClasses(navItemClassNames.root, rootDefaultClassName, density === "small" && smallStyles.root, selected && indicatorStyles.base, selected && contentStyles.selected, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(navItemClassNames.icon, iconStyles.base, selected && iconStyles.selected, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavItem/NavItem.js
var NavItem = React642.forwardRef((props, ref) => {
  const state = useNavItem_unstable(props, ref);
  useNavItemStyles_unstable(state);
  useCustomStyleHook("useNavItemStyles_unstable")(state);
  return renderNavItem_unstable(state);
});
NavItem.displayName = "NavItem";

// node_modules/@fluentui/react-nav/lib/components/NavSubItem/NavSubItem.js
var React644 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavSubItem/useNavSubItem.js
var React643 = __toESM(require_react());
var useNavSubItem_unstable = (props, ref) => {
  const { onClick, value: subItemValue, as, href } = props;
  const { selectedValue, onRegister, onUnregister, onSelect, density = "medium" } = useNavContext_unstable();
  const { value: parentCategoryValue } = useNavCategoryContext_unstable();
  const rootElementType = as || (href ? "a" : "button");
  const selected = selectedValue === subItemValue;
  const innerRef = React643.useRef(null);
  const onNavSubItemClick = useEventCallback((event) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
    if (!event.defaultPrevented && isHTMLElement(event.target)) {
      onSelect(event, {
        type: "click",
        event,
        value: subItemValue,
        categoryValue: parentCategoryValue
      });
    }
  });
  const root = slot_exports.always(getIntrinsicElementProps(rootElementType, useARIAButtonProps(rootElementType, {
    "aria-current": selected ? "page" : "false",
    ...props
  })), {
    elementType: rootElementType,
    defaultProps: {
      ref,
      type: rootElementType
    }
  });
  root.onClick = onNavSubItemClick;
  React643.useEffect(() => {
    onRegister({
      value: subItemValue,
      ref: innerRef
    });
    return () => {
      onUnregister({
        value: subItemValue,
        ref: innerRef
      });
    };
  }, [
    onRegister,
    onUnregister,
    innerRef,
    subItemValue
  ]);
  return {
    components: {
      root: rootElementType
    },
    root,
    selected,
    value: subItemValue,
    density
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavSubItem/renderNavSubItem.js
var renderNavSubItem_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-nav/lib/components/NavSubItem/useNavSubItemStyles.styles.js
var navSubItemClassNames = {
  root: "fui-NavSubItem"
};
var useNavSubItemSpecificStyles = __styles2({
  base: {
    B1hrpyx: "fqo71ku"
  },
  smallBase: {
    B1hrpyx: "f17f9sv1"
  },
  selectedIndicator: {
    rjyhj6: "f1f74g36"
  }
}, {
  d: [".fqo71ku{-webkit-padding-start:46px;padding-inline-start:46px;}", ".f17f9sv1{-webkit-padding-start:40px;padding-inline-start:40px;}", ".f1f74g36::after{-webkit-margin-start:-52px;margin-inline-start:-52px;}"]
});
var useNavSubItemStyles_unstable = (state) => {
  "use no memo";
  const rootDefaultClassName = useRootDefaultClassName();
  const smallStyles = useSmallStyles();
  const contentStyles = useContentStyles4();
  const indicatorStyles = useIndicatorStyles4();
  const navSubItemSpecificStyles = useNavSubItemSpecificStyles();
  const {
    selected,
    density
  } = state;
  const isSmallDensity = density === "small";
  state.root.className = mergeClasses(navSubItemClassNames.root, rootDefaultClassName, isSmallDensity && smallStyles.root, isSmallDensity && navSubItemSpecificStyles.smallBase, navSubItemSpecificStyles.base, selected && indicatorStyles.base, selected && contentStyles.selected, selected && navSubItemSpecificStyles.selectedIndicator, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavSubItem/NavSubItem.js
var NavSubItem = React644.forwardRef((props, ref) => {
  const state = useNavSubItem_unstable(props, ref);
  useNavSubItemStyles_unstable(state);
  useCustomStyleHook("useNavSubItemStyles_unstable")(state);
  return renderNavSubItem_unstable(state);
});
NavSubItem.displayName = "NavSubItem";

// node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/NavSubItemGroup.js
var React646 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/useNavSubItemGroup.js
var React645 = __toESM(require_react());
var smallSize = 28;
var largeSize = 40;
var NavGroupMotion = createPresenceComponent(({ items, density }) => {
  const isSmallDensity = density === "small";
  const height = items ? isSmallDensity ? items * smallSize : items * largeSize : 0;
  const durationPerItem = isSmallDensity ? 15 : 25;
  const keyframes = [
    {
      opacity: 0,
      minHeight: 0,
      height: 0
    },
    {
      opacity: 1,
      minHeight: `${height}px`,
      height: `${height}px`
    }
  ];
  const baseDuration = motionTokens.durationFast + (items || 0) * durationPerItem;
  const maxDuration = motionTokens.durationUltraSlow;
  const duration = baseDuration > maxDuration ? maxDuration : baseDuration;
  return {
    enter: {
      keyframes,
      duration,
      easing: motionTokens.curveDecelerateMid
    },
    exit: {
      keyframes: [
        ...keyframes
      ].reverse(),
      duration,
      easing: motionTokens.curveAccelerateMin
    }
  };
});
var useNavSubItemGroup_unstable = (props, ref) => {
  const { open } = useNavCategoryContext_unstable();
  const { density } = useNavContext_unstable();
  return {
    open,
    components: {
      root: "div",
      collapseMotion: NavGroupMotion
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ...props,
      ref
    }), {
      elementType: "div"
    }),
    collapseMotion: presenceMotionSlot(props.collapseMotion, {
      elementType: NavGroupMotion,
      defaultProps: {
        visible: open,
        unmountOnExit: true,
        items: React645.Children.count(props.children),
        density
      }
    })
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/renderNavSubItemGroup.js
var renderNavSubItemGroup_unstable = (state) => {
  assertSlots(state);
  return state.collapseMotion ? jsx(state.collapseMotion, {
    children: jsx(state.root, {})
  }) : jsx(state.root, {});
};

// node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/useNavSubItemGroupStyles.styles.js
var navSubItemGroupClassNames = {
  root: "fui-NavSubItemGroup"
};
var useStyles101 = __styles2({
  root: {
    Bz10aip: "f1yj8dow",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp"
  }
}, {
  d: [".f1yj8dow{transform:translateZ(0);}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }]]
});
var useNavSubItemGroupStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles101();
  state.root.className = mergeClasses(navSubItemGroupClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/NavSubItemGroup.js
var NavSubItemGroup = React646.forwardRef((props, ref) => {
  const state = useNavSubItemGroup_unstable(props, ref);
  useNavSubItemGroupStyles_unstable(state);
  useCustomStyleHook("useNavSubItemGroupStyles_unstable")(state);
  return renderNavSubItemGroup_unstable(state);
});
NavSubItemGroup.displayName = "NavSubItemGroup";

// node_modules/@fluentui/react-nav/lib/components/NavDrawer/NavDrawer.js
var React648 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavDrawer/useNavDrawer.js
var React647 = __toESM(require_react());
var useNavDrawer_unstable = (props, ref) => {
  const { tabbable = false, size: size3 = void 0 } = props;
  const focusAttributes = useArrowNavigationGroup({
    axis: "vertical",
    circular: true,
    tabbable
  });
  const navState = useNav_unstable({
    ...props
  }, ref);
  return {
    ...navState,
    size: size3,
    components: {
      // TODO: remove once React v18 slot API is modified
      // this is a problem with the lack of support for union types on React v18
      // ComponentState is using React.ComponentType which will try to infer propType
      // propTypes WeakValidator signature will break distributive unions making this type invalid
      root: Drawer
    },
    root: slot_exports.always({
      ref,
      role: "navigation",
      ...props,
      ...focusAttributes
    }, {
      // TODO: remove once React v18 slot API is modified
      // this is a problem with the lack of support for union types on React v18
      // ComponentState is using React.ComponentType which will try to infer propType
      // propTypes WeakValidator signature will break distributive unions making this type invalid
      elementType: Drawer
    })
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawer/renderNavDrawer.js
var renderNavDrawer_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(NavProvider, {
    value: contextValues.nav,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawer/useNavDrawerStyles.styles.js
var navDrawerClassNames = {
  root: "fui-NavDrawer"
};
var useStyles102 = __styles2({
  root: {
    De3pzq: "f1ctqxl6",
    Bt984gj: "f3gca8"
  },
  defaultWidth: {
    a9b677: "f12j6lm0"
  }
}, {
  d: [".f1ctqxl6{background-color:var(--colorNeutralBackground4);}", ".f3gca8{align-items:unset;}", ".f12j6lm0{width:260px;}"]
});
var useNavDrawerStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3
  } = state;
  const styles = useStyles102();
  state.root.className = mergeClasses(navDrawerClassNames.root, styles.root, !size3 && styles.defaultWidth, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawer/NavDrawer.js
var NavDrawer = React648.forwardRef((props, ref) => {
  const state = useNavDrawer_unstable(props, ref);
  const contextValues = useNavContextValues_unstable(state);
  useNavDrawerStyles_unstable(state);
  useCustomStyleHook("useNavDrawerStyles_unstable")(state);
  return renderNavDrawer_unstable(state, contextValues);
});
NavDrawer.displayName = "NavDrawer";

// node_modules/@fluentui/react-nav/lib/components/NavDrawerFooter/NavDrawerFooter.js
var React650 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavDrawerFooter/useNavDrawerFooter.js
var React649 = __toESM(require_react());
var useNavDrawerFooter_unstable = (props, ref) => {
  return useDrawerFooter_unstable(props, ref);
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawerFooter/useNavDrawerFooterStyles.styles.js
var navDrawerFooterClassNames = {
  root: "fui-NavDrawerFooter"
};
var useStyles103 = __styles2({
  root: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1j1cbdv",
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    Belr9w4: "f1j0q4x9"
  }
}, {
  d: [[".f1j1cbdv{padding:var(--spacingVerticalXXS) var(--spacingHorizontalXS) var(--spacingVerticalXXS) var(--spacingVerticalXS) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".f1j0q4x9{row-gap:var(--spacingVerticalXXS);}"]
});
var useNavDrawerFooterStyles_unstable = (state) => {
  "use no memo";
  useDrawerFooterStyles_unstable(state);
  const styles = useStyles103();
  state.root.className = mergeClasses(navDrawerFooterClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawerFooter/NavDrawerFooter.js
var NavDrawerFooter = React650.forwardRef((props, ref) => {
  const state = useNavDrawerFooter_unstable(props, ref);
  useNavDrawerFooterStyles_unstable(state);
  useCustomStyleHook("useNavDrawerFooterStyles_unstable")(state);
  return renderDrawerFooter_unstable(state);
});
NavDrawerFooter.displayName = "NavDrawerFooter";

// node_modules/@fluentui/react-nav/lib/components/NavDrawerHeader/NavDrawerHeader.js
var React652 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavDrawerHeader/useNavDrawerHeaderStyles.styles.js
var navDrawerHeaderClassNames = {
  root: "fui-NavDrawerHeader"
};
var useStyles104 = __styles2({
  root: {
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1r2n0t9",
    B1hrpyx: "f80d8h0",
    Dbcxam: 0,
    rjzwhg: 0,
    Bblux5w: "fesrmp8"
  }
}, {
  d: [[".f1r2n0t9{margin:unset;}", {
    p: -1
  }], ".f80d8h0{-webkit-padding-start:14px;padding-inline-start:14px;}", [".fesrmp8{padding-block:5px;}", {
    p: -1
  }]]
});
var useNavDrawerHeaderStyles_unstable = (state) => {
  "use no memo";
  useDrawerHeaderStyles_unstable(state);
  const styles = useStyles104();
  state.root.className = mergeClasses(navDrawerHeaderClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawerHeader/useNavDrawerHeader.js
var React651 = __toESM(require_react());
var useNavDrawerHeader_unstable = (props, ref) => {
  return useDrawerHeader_unstable(props, ref);
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawerHeader/NavDrawerHeader.js
var NavDrawerHeader = React652.forwardRef((props, ref) => {
  const state = useNavDrawerHeader_unstable(props, ref);
  useNavDrawerHeaderStyles_unstable(state);
  useCustomStyleHook("useNavDrawerHeaderStyles_unstable")(state);
  return renderDrawerHeader_unstable(state);
});
NavDrawerHeader.displayName = "NavDrawerHeader";

// node_modules/@fluentui/react-nav/lib/components/NavDrawerBody/NavDrawerBody.js
var React654 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavDrawerBody/useNavDrawerBody.js
var React653 = __toESM(require_react());
var useNavDrawerBody_unstable = (props, ref) => {
  return useDrawerBody_unstable(props, ref);
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawerBody/useNavDrawerBodyStyles.styles.js
var navDrawerBodyClassNames = {
  root: "fui-NavDrawerBody"
};
var useStyles105 = __styles2({
  root: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["fif7vu7", "f1htewbf"],
    Bt984gj: "f3gca8",
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    Belr9w4: "f1j0q4x9"
  }
}, {
  d: [[".fif7vu7{padding:0 var(--spacingHorizontalXS) 0 var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".f1htewbf{padding:0 var(--spacingHorizontalMNudge) 0 var(--spacingHorizontalXS);}", {
    p: -1
  }], ".f3gca8{align-items:unset;}", ".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".f1j0q4x9{row-gap:var(--spacingVerticalXXS);}"]
});
var useNavDrawerBodyStyles_unstable = (state) => {
  "use no memo";
  useDrawerBodyStyles_unstable(state);
  const styles = useStyles105();
  state.root.className = mergeClasses(navDrawerBodyClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawerBody/NavDrawerBody.js
var NavDrawerBody = React654.forwardRef((props, ref) => {
  const state = useNavDrawerBody_unstable(props, ref);
  useNavDrawerBodyStyles_unstable(state);
  useCustomStyleHook("useNavDrawerBodyStyles_unstable")(state);
  return renderDrawerBody_unstable(state);
});
NavDrawerBody.displayName = "NavDrawerBody";

// node_modules/@fluentui/react-nav/lib/components/Hamburger/Hamburger.js
var React656 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/Hamburger/useHamburger.js
var React655 = __toESM(require_react());
var useHamburger_unstable = (props, ref) => {
  return useButton_unstable({
    icon: React655.createElement(Navigation20Filled, null),
    appearance: "transparent",
    ...props
  }, ref);
};

// node_modules/@fluentui/react-nav/lib/components/Hamburger/useHamburgerStyles.styles.js
var hamburgerClassNames = {
  root: "fui-Hamburger",
  icon: "fui-Hamburger__icon"
};
var useStyles106 = __styles2({
  root: {
    w71qe1: "f1iuv45f",
    De3pzq: "f1ctqxl6",
    icvyot: "f1ern45e",
    vrafjx: ["f1n71otn", "f1deefiw"],
    oivjwe: "f1h8hb77",
    wvpqe5: ["f1deefiw", "f1n71otn"],
    Jwef8y: "f11oyicx",
    ecr2s2: "f9fof1w"
  }
}, {
  d: [".f1iuv45f{text-decoration-line:none;}", ".f1ctqxl6{background-color:var(--colorNeutralBackground4);}", ".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1h8hb77{border-bottom-style:none;}"],
  h: [".f11oyicx:hover{background-color:var(--colorNeutralBackground4Hover);}"],
  a: [".f9fof1w:active{background-color:var(--colorNeutralBackground4Pressed);}"]
});
var useHamburgerStyles_unstable = (state) => {
  "use no memo";
  useButtonStyles_unstable(state);
  const styles = useStyles106();
  state.root.className = mergeClasses(hamburgerClassNames.root, styles.root, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(hamburgerClassNames.icon, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/Hamburger/Hamburger.js
var Hamburger = React656.forwardRef((props, ref) => {
  const state = useHamburger_unstable(props, ref);
  useHamburgerStyles_unstable(state);
  useCustomStyleHook("useHamburgerStyles_unstable")(state);
  return renderButton_unstable(state);
});
Hamburger.displayName = "Hamburger";

// node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/NavSectionHeader.js
var React658 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/useNavSectionHeader.js
var React657 = __toESM(require_react());
var useNavSectionHeader_unstable = (props, ref) => {
  return {
    components: {
      root: "h3"
    },
    root: slot_exports.always(getIntrinsicElementProps("h3", {
      ref,
      ...props
    }), {
      elementType: "h3"
    })
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/renderNavSectionHeader.js
var renderNavSectionHeader_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/useNavSectionHeaderStyles.styles.js
var navSectionHeaderClassNames = {
  root: "fui-NavSectionHeader"
};
var useStyles107 = __styles2({
  root: {
    Jyy4pa: "f1gr6hdk",
    Bo78w4l: 0,
    Cgygva: 0,
    yil37a: "f1ulrxyd",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fwrc4pm"
  }
}, {
  d: [".f1gr6hdk{-webkit-margin-start:10px;margin-inline-start:10px;}", [".f1ulrxyd{margin-block:8px;}", {
    p: -1
  }], ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}"]
});
var useNavSectionHeaderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles107();
  state.root.className = mergeClasses(navSectionHeaderClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/NavSectionHeader.js
var NavSectionHeader = React658.forwardRef((props, ref) => {
  const state = useNavSectionHeader_unstable(props, ref);
  useNavSectionHeaderStyles_unstable(state);
  useCustomStyleHook("useNavSectionHeaderStyles_unstable")(state);
  return renderNavSectionHeader_unstable(state);
});
NavSectionHeader.displayName = "NavSectionHeader";

// node_modules/@fluentui/react-nav/lib/components/NavDivider/NavDivider.js
var React660 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavDivider/useNavDivider.js
var React659 = __toESM(require_react());
var useNavDivider_unstable = (props, ref) => {
  return useDivider_unstable({
    appearance: "strong",
    ...props
  }, ref);
};

// node_modules/@fluentui/react-nav/lib/components/NavDivider/useNavDividerStyles.styles.js
var navDividerClassNames = {
  root: "fui-NavDivider",
  wrapper: "fui-NavDivider__wrapper"
};
var useStyles108 = __styles2({
  root: {
    Bh6795r: "f1jhi6b8",
    B6of3ja: "fvjh0tl",
    jrapky: "fd1gkq"
  }
}, {
  d: [".f1jhi6b8{flex-grow:0;}", ".fvjh0tl{margin-top:4px;}", ".fd1gkq{margin-bottom:4px;}"]
});
var useNavDividerStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles108();
  state.root.className = mergeClasses(navDividerClassNames.root, styles.root, state.root.className);
  state.wrapper.className = mergeClasses(navDividerClassNames.wrapper, state.wrapper.className);
  useDividerStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavDivider/NavDivider.js
var NavDivider = React660.forwardRef((props, ref) => {
  const state = useNavDivider_unstable(props, ref);
  useNavDividerStyles_unstable(state);
  useCustomStyleHook("useNavDividerStyles_unstable")(state);
  return renderDivider_unstable(state);
});
NavDivider.displayName = "NavDivider";

// node_modules/@fluentui/react-nav/lib/components/AppItem/AppItem.js
var React662 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/AppItem/useAppItem.js
var React661 = __toESM(require_react());
var useAppItem_unstable = (props, ref) => {
  const { icon, as, href } = props;
  const rootElementType = as || (href ? "a" : "button");
  const { density = "medium" } = useNavContext_unstable();
  const root = slot_exports.always(getIntrinsicElementProps(rootElementType, useARIAButtonProps(rootElementType, {
    ...props
  })), {
    elementType: rootElementType,
    defaultProps: {
      ref,
      type: rootElementType
    }
  });
  return {
    components: {
      root: rootElementType,
      icon: "span"
    },
    root,
    icon: slot_exports.optional(icon, {
      elementType: "span"
    }),
    density
  };
};

// node_modules/@fluentui/react-nav/lib/components/AppItem/renderAppItem.js
var renderAppItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-nav/lib/components/AppItem/useAppItemStyles.styles.js
var appItemClassNames = {
  root: "fui-AppItem",
  icon: "fui-AppItem__icon"
};
var useAppItemStyles = __styles2({
  root: {
    Bokbzmb: "f1x6gvzo",
    Jyy4pa: "f1djyvue",
    B1u1w3b: "feysv1g",
    a9b677: "f1jd6clc",
    Bt984gj: "f122n59",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1ga9sj3",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1fdqhks", "fnlwq4f"],
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  small: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1m1l4b8", "f1yxbtnt"],
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1let0xu"
  },
  absentIconRootAdjustment: {
    B1hrpyx: "ft8721j"
  }
}, {
  d: [[".feysv1g{margin-inline:4px;}", {
    p: -1
  }], ".f1jd6clc{width:revert;}", ".f122n59{align-items:center;}", [".f1ga9sj3{gap:10px;}", {
    p: -1
  }], ".f1djyvue{-webkit-margin-start:-6px;margin-inline-start:-6px;}", ".f1x6gvzo{-webkit-margin-end:0px;margin-inline-end:0px;}", [".f1fdqhks{padding:var(--spacingVerticalS) var(--spacingHorizontalS) var(--spacingVerticalS) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".fnlwq4f{padding:var(--spacingVerticalS) var(--spacingHorizontalMNudge) var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f1m1l4b8{padding:var(--spacingVerticalS) var(--spacingHorizontalS) var(--spacingVerticalS) 14px;}", {
    p: -1
  }], [".f1yxbtnt{padding:var(--spacingVerticalS) 14px var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], [".f1let0xu{gap:14px;}", {
    p: -1
  }], ".ft8721j{-webkit-padding-start:16px;padding-inline-start:16px;}"]
});
var useAppItemStyles_unstable = (state) => {
  "use no memo";
  const rootDefaultClassName = useRootDefaultClassName();
  const iconStyles = useIconStyles13();
  const appItemSpecificStyles = useAppItemStyles();
  const {
    density,
    icon
  } = state;
  state.root.className = mergeClasses(rootDefaultClassName, appItemClassNames.root, appItemSpecificStyles.root, density === "small" && appItemSpecificStyles.small, !icon && appItemSpecificStyles.absentIconRootAdjustment, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(appItemClassNames.icon, iconStyles.base, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/AppItem/AppItem.js
var AppItem = React662.forwardRef((props, ref) => {
  const state = useAppItem_unstable(props, ref);
  useAppItemStyles_unstable(state);
  useCustomStyleHook("useAppItemStyles_unstable")(state);
  return renderAppItem_unstable(state);
});
AppItem.displayName = "AppItem";

// node_modules/@fluentui/react-nav/lib/components/AppItemStatic/AppItemStatic.js
var React664 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/AppItemStatic/useAppItemStatic.js
var React663 = __toESM(require_react());
var useAppItemStatic_unstable = (props, ref) => {
  const { icon } = props;
  const { density = "medium" } = useNavContext_unstable();
  return {
    components: {
      root: "div",
      icon: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    icon: slot_exports.optional(icon, {
      elementType: "span"
    }),
    density
  };
};

// node_modules/@fluentui/react-nav/lib/components/AppItemStatic/renderAppItemStatic.js
var renderAppItemStatic_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-nav/lib/components/AppItemStatic/useAppItemStaticStyles.styles.js
var appItemStaticClassNames = {
  root: "fui-AppItemStatic",
  icon: "fui-AppItemStatic__icon"
};
var useAppItemStaticStyles = __styles2({
  root: {
    Bceei9c: "f158kwzp",
    Jwef8y: "fmaajru",
    ecr2s2: "f11z5bqc"
  }
}, {
  d: [".f158kwzp{cursor:default;}"],
  h: [".fmaajru:hover{background-color:unset;}"],
  a: [".f11z5bqc:active{background-color:unset;}"]
});
var useAppItemStaticStyles_unstable = (state) => {
  "use no memo";
  const rootDefaultClassName = useRootDefaultClassName();
  const iconStyles = useIconStyles13();
  const appItemSpecificStyles = useAppItemStyles();
  const appItemStaticStyles = useAppItemStaticStyles();
  const {
    density,
    icon
  } = state;
  state.root.className = mergeClasses(rootDefaultClassName, appItemStaticClassNames.root, appItemSpecificStyles.root, appItemStaticStyles.root, density === "small" && appItemSpecificStyles.small, !icon && appItemSpecificStyles.absentIconRootAdjustment, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(appItemStaticClassNames.icon, iconStyles.base, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/AppItemStatic/AppItemStatic.js
var AppItemStatic = React664.forwardRef((props, ref) => {
  const state = useAppItemStatic_unstable(props, ref);
  useAppItemStaticStyles_unstable(state);
  useCustomStyleHook("useAppItemStaticStyles_unstable")(state);
  return renderAppItemStatic_unstable(state);
});
AppItemStatic.displayName = "AppItemStatic";

// node_modules/@fluentui/react-nav/lib/components/SplitNavItem/SplitNavItem.js
var React667 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/SplitNavItem/useSplitNavItem.js
var React665 = __toESM(require_react());
var useSplitNavItem_unstable = (props, ref) => {
  const { navItem, actionButton: actionButton2, toggleButton: toggleButton2, menuButton: menuButton2, actionButtonTooltip, toggleButtonTooltip, menuButtonTooltip, children: children2 } = props;
  const { density = "medium" } = useNavContext_unstable();
  const { value: potentialParenValue } = useNavCategoryContext_unstable();
  const isSubNav = potentialParenValue.length > 0 ? true : false;
  const navItemShorthand = slot_exports.always(navItem, {
    defaultProps: {
      children: children2
    },
    elementType: isSubNav ? NavSubItem : NavItem
  });
  const actionButtonShorthand = slot_exports.optional(actionButton2, {
    defaultProps: {
      icon: React665.createElement(Pin20Regular, null),
      size: "small",
      appearance: "transparent"
    },
    elementType: Button
  });
  const toggleButtonShorthand = slot_exports.optional(toggleButton2, {
    defaultProps: {
      icon: React665.createElement(Pin20Regular, null),
      size: "small",
      appearance: "transparent"
    },
    elementType: ToggleButton
  });
  const menuButtonShorthand = slot_exports.optional(menuButton2, {
    defaultProps: {
      icon: React665.createElement(MoreHorizontalFilled, null),
      size: "small",
      appearance: "transparent"
    },
    elementType: MenuButton
  });
  const actionButtonTooltipShorthand = slot_exports.optional(actionButtonTooltip, {
    defaultProps: {
      relationship: "label"
    },
    elementType: Tooltip
  });
  const toggleButtonTooltipShorthand = slot_exports.optional(toggleButtonTooltip, {
    defaultProps: {
      relationship: "label"
    },
    elementType: Tooltip
  });
  const menuButtonTooltipShorthand = slot_exports.optional(menuButtonTooltip, {
    defaultProps: {
      relationship: "label"
    },
    elementType: Tooltip
  });
  return {
    components: {
      root: "div",
      navItem: isSubNav ? NavSubItem : NavItem,
      actionButton: Button,
      toggleButton: ToggleButton,
      menuButton: MenuButton,
      actionButtonTooltip: Tooltip,
      toggleButtonTooltip: Tooltip,
      menuButtonTooltip: Tooltip
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props,
      // because we're passing in children to the NavItem,
      // We can be explicit about the children prop here
      children: null
    }), {
      elementType: "div"
    }),
    navItem: navItemShorthand,
    actionButton: actionButtonShorthand,
    toggleButton: toggleButtonShorthand,
    menuButton: menuButtonShorthand,
    actionButtonTooltip: actionButtonTooltipShorthand,
    toggleButtonTooltip: toggleButtonTooltipShorthand,
    menuButtonTooltip: menuButtonTooltipShorthand,
    density,
    isSubNav
  };
};

// node_modules/@fluentui/react-nav/lib/components/SplitNavItem/renderSplitNavItem.js
var React666 = __toESM(require_react());
var renderButtonSlot = (Button2, ButtonTooltip) => {
  if (!Button2) {
    return null;
  }
  if (ButtonTooltip) {
    return jsx(ButtonTooltip, {
      children: jsx(Button2, {})
    });
  }
  return jsx(Button2, {});
};
var renderSplitNavItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.navItem && jsx(state.navItem, {}),
      renderButtonSlot(state.actionButton, state.actionButtonTooltip),
      renderButtonSlot(state.menuButton, state.menuButtonTooltip),
      renderButtonSlot(state.toggleButton, state.toggleButtonTooltip)
    ]
  });
};

// node_modules/@fluentui/react-nav/lib/components/SplitNavItem/useSplitNavItemStyles.styles.js
var splitNavItemClassNames = {
  root: "fui-SplitNavItem",
  navItem: "fui-SplitNavItem__navItem",
  actionButton: "fui-SplitNavItem__actionButton",
  toggleButton: "fui-SplitNavItem__toggleButton",
  menuButton: "fui-SplitNavItem__menuButton",
  /**
  * Tooltips don't have a class name prop, so this is just to satisfy the linter.
  */
  actionButtonTooltip: "fui-SplitNavItem__actionButtonTooltip",
  toggleButtonTooltip: "fui-SplitNavItem__toggleButtonTooltip",
  menuButtonTooltip: "fui-SplitNavItem__menuButtonTooltip"
};
var {
  actionButton,
  toggleButton,
  menuButton
} = splitNavItemClassNames;
var buttonHoverStyles = {
  [`& .${actionButton}, & .${toggleButton}, & .${menuButton}`]: {
    opacity: 1,
    pointerEvents: "auto"
  }
};
var useSplitNaveItemStyles = __styles2({
  baseRoot: {
    mc9l5x: "f22iagw",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "fx80lhs",
    Bt984gj: "f1q9h2pe",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f19jm9xf",
    fsow6f: "fgusgyc",
    De3pzq: "f1ctqxl6",
    B3o57yi: "fnsygzv",
    Bkqvd7p: "f1e9ux7i",
    Bmy1vo4: "f1xfaukr",
    Jwef8y: "f11oyicx",
    xwko9w: "f8z0t4e",
    mcc9px: "f9ueil3",
    B02v5zz: "f1g2hb8n",
    i4x37a: "fpq6je",
    ecr2s2: "f9fof1w"
  },
  baseNavItem: {
    mc9l5x: "f22iagw",
    B9bfxx9: "f1cxpek8",
    qb2dma: "f1ub7u0d",
    fsow6f: ["f1o700av", "fes3tcz"],
    qhf8xq: "f10pi13n",
    Brf1p80: "f1s9ku6b",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1u2hskj",
    De3pzq: "f3rmtva"
  },
  baseSecondary: {
    Bf4jedk: "f107v6xj",
    Bnt446c: "f1y335lp",
    B1hrpyx: "f12pses1",
    rjzwhg: "fibmr9j",
    Bt984gj: "f1s2louj"
  },
  baseMedium: {
    rjzwhg: "fjtod8q"
  },
  baseLarge: {
    rjzwhg: "f16gijt3"
  },
  hoverAction: {
    abs64n: "fk73vx1",
    Bkecrkj: "f1aehjj5",
    Bn62ygk: 0,
    Cwk7ip: 0,
    B3o57yi: 0,
    Bmy1vo4: 0,
    Bkqvd7p: 0,
    Bi2q7bf: ["fr12795", "fcl876f"],
    Es3by: "f1gqqdtu"
  }
}, {
  d: [".f22iagw{display:flex;}", [".fx80lhs{gap:unset;}", {
    p: -1
  }], ".f1q9h2pe{align-items:stretch;}", [".f19jm9xf{padding:unset;}", {
    p: -1
  }], ".fgusgyc{text-align:unset;}", ".f1ctqxl6{background-color:var(--colorNeutralBackground4);}", ".fnsygzv{transition-duration:var(--durationFaster);}", ".f1e9ux7i{transition-timing-function:var(--curveLinear);}", ".f1xfaukr{transition-property:background;}", ".f1cxpek8{text-transform:none;}", ".f1ub7u0d{align-self:stretch;}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".f10pi13n{position:relative;}", ".f1s9ku6b{justify-content:start;}", [".f1u2hskj{gap:var(--spacingVerticalL);}", {
    p: -1
  }], ".f3rmtva{background-color:transparent;}", ".f107v6xj{min-width:28px;}", ".f1y335lp{-webkit-padding-end:12px;padding-inline-end:12px;}", ".f12pses1{-webkit-padding-start:5px;padding-inline-start:5px;}", ".fibmr9j{padding-block-start:5px;}", ".f1s2louj{align-items:start;}", ".fjtod8q{padding-block-start:9px;}", ".f16gijt3{padding-block-start:12px;}", ".fk73vx1{opacity:0;}", ".f1aehjj5{pointer-events:none;}", [".fr12795{transition:opacity 150ms cubic-bezier(0.33,0,0.67,1);}", {
    p: -1
  }], [".fcl876f{transition:opacity 150ms cubic-bezier(0.33, 0, 0.67, 1);}", {
    p: -1
  }], ".f1gqqdtu{will-change:opacity;}"],
  h: [".f11oyicx:hover{background-color:var(--colorNeutralBackground4Hover);}", ".f8z0t4e:hover .fui-SplitNavItem__actionButton,.f8z0t4e:hover .fui-SplitNavItem__toggleButton,.f8z0t4e:hover .fui-SplitNavItem__menuButton{opacity:1;}", ".f9ueil3:hover .fui-SplitNavItem__actionButton,.f9ueil3:hover .fui-SplitNavItem__toggleButton,.f9ueil3:hover .fui-SplitNavItem__menuButton{pointer-events:auto;}"],
  w: [".f1g2hb8n:focus-within .fui-SplitNavItem__actionButton,.f1g2hb8n:focus-within .fui-SplitNavItem__toggleButton,.f1g2hb8n:focus-within .fui-SplitNavItem__menuButton{opacity:1;}", ".fpq6je:focus-within .fui-SplitNavItem__actionButton,.fpq6je:focus-within .fui-SplitNavItem__toggleButton,.fpq6je:focus-within .fui-SplitNavItem__menuButton{pointer-events:auto;}"],
  a: [".f9fof1w:active{background-color:var(--colorNeutralBackground4Pressed);}"]
});
var useSplitNavItemStyles_unstable = (state) => {
  "use no memo";
  const splitNavItemStyles = useSplitNaveItemStyles();
  const sharedRootClassNames = useRootDefaultClassName();
  state.root.className = mergeClasses(splitNavItemClassNames.root, sharedRootClassNames, splitNavItemStyles.baseRoot, state.root.className);
  if (state.navItem) {
    state.navItem.className = mergeClasses(splitNavItemClassNames.navItem, splitNavItemStyles.baseNavItem, state.navItem.className);
  }
  if (state.actionButton) {
    state.actionButton.className = mergeClasses(splitNavItemClassNames.actionButton, splitNavItemStyles.baseSecondary, splitNavItemStyles.hoverAction, state.density === "medium" && splitNavItemStyles.baseMedium, state.actionButton.className);
  }
  if (state.toggleButton) {
    state.toggleButton.className = mergeClasses(splitNavItemClassNames.toggleButton, splitNavItemStyles.baseSecondary, splitNavItemStyles.hoverAction, state.density === "medium" && splitNavItemStyles.baseMedium, state.toggleButton.className);
  }
  if (state.menuButton) {
    state.menuButton.className = mergeClasses(splitNavItemClassNames.menuButton, splitNavItemStyles.baseSecondary, splitNavItemStyles.hoverAction, state.density === "medium" && splitNavItemStyles.baseMedium, state.menuButton.className);
  }
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/SplitNavItem/SplitNavItem.js
var SplitNavItem = React667.forwardRef((props, ref) => {
  const state = useSplitNavItem_unstable(props, ref);
  useSplitNavItemStyles_unstable(state);
  useCustomStyleHook("useSplitNavItemStyles_unstable")(state);
  return renderSplitNavItem_unstable(state);
});
SplitNavItem.displayName = "SplitNavItem";
export {
  Accordion,
  AccordionHeader,
  AccordionItem,
  AccordionItemProvider,
  AccordionPanel,
  AccordionProvider,
  AlphaSlider,
  AnnounceProvider,
  AppItem,
  AppItemStatic,
  AriaLiveAnnouncer,
  Avatar,
  AvatarGroup,
  AvatarGroupItem,
  AvatarGroupPopover,
  AvatarGroupProvider,
  Badge,
  Body1,
  Body1Strong,
  Body1Stronger,
  Body2,
  Breadcrumb,
  BreadcrumbButton,
  BreadcrumbDivider,
  BreadcrumbItem,
  BreadcrumbProvider,
  Button,
  Caption1,
  Caption1Strong,
  Caption1Stronger,
  Caption2,
  Caption2Strong,
  Card,
  CardFooter,
  CardHeader,
  CardPreview,
  Carousel,
  CarouselAutoplayButton,
  CarouselButton,
  CarouselCard,
  CarouselNav,
  CarouselNavButton,
  CarouselNavContainer,
  CarouselNavImageButton,
  CarouselProvider2 as CarouselProvider,
  CarouselSlider,
  CarouselViewport,
  Checkbox,
  ColorArea,
  ColorPicker,
  ColorSlider,
  ColorSwatch,
  ColumnIdContextProvider,
  Combobox,
  ComboboxProvider,
  CompoundButton,
  CounterBadge,
  DATA_OVERFLOWING2 as DATA_OVERFLOWING,
  DATA_OVERFLOW_DIVIDER,
  DATA_OVERFLOW_ITEM,
  DATA_OVERFLOW_MENU,
  DataGrid,
  DataGridBody,
  DataGridCell,
  DataGridContextProvider,
  DataGridHeader,
  DataGridHeaderCell,
  DataGridRow,
  DataGridSelectionCell,
  Dialog,
  DialogActions,
  DialogBody,
  DialogContent,
  DialogProvider,
  DialogSurface,
  DialogTitle,
  DialogTrigger,
  Display,
  Divider,
  Drawer,
  DrawerBody,
  DrawerFooter,
  DrawerHeader,
  DrawerHeaderNavigation,
  DrawerHeaderTitle,
  DrawerProvider,
  Dropdown,
  EmptySwatch,
  Field,
  FieldContextProvider,
  FlatTree,
  FlatTreeItem,
  FluentProvider,
  Hamburger,
  IdPrefixProvider,
  Image,
  ImageSwatch,
  InfoButton,
  InfoLabel,
  InlineDrawer,
  Input,
  InteractionTag,
  InteractionTagPrimary,
  InteractionTagSecondary,
  Label,
  LargeTitle,
  Link2 as Link,
  List,
  ListItem,
  Listbox,
  ListboxProvider,
  Menu,
  MenuButton,
  MenuDivider,
  MenuGroup,
  MenuGroupContextProvider,
  MenuGroupHeader,
  MenuItem,
  MenuItemCheckbox,
  MenuItemLink,
  MenuItemRadio,
  MenuItemSwitch,
  MenuList,
  MenuListProvider,
  MenuPopover,
  MenuProvider,
  MenuSplitGroup,
  MenuTrigger,
  MenuTriggerContextProvider,
  MessageBar,
  MessageBarActions,
  MessageBarBody,
  MessageBarContextProvider,
  MessageBarGroup,
  MessageBarTitle,
  Nav,
  NavCategory,
  NavCategoryItem,
  NavCategoryItemProvider,
  NavCategoryProvider,
  NavDivider,
  NavDrawer,
  NavDrawerBody,
  NavDrawerFooter,
  NavDrawerHeader,
  NavItem,
  NavProvider,
  NavSectionHeader,
  NavSubItem,
  NavSubItemGroup,
  Option,
  OptionGroup,
  Overflow,
  OverflowDivider,
  OverflowItem,
  OverlayDrawer,
  Persona,
  Popover,
  PopoverProvider,
  PopoverSurface,
  PopoverTrigger,
  Portal,
  PortalMountNodeProvider,
  PositioningConfigurationProvider,
  PresenceBadge,
  PresenceGroup,
  ProgressBar,
  Radio,
  RadioGroup,
  RadioGroupProvider,
  Rating,
  RatingDisplay,
  RatingItem,
  RatingItemProvider,
  RendererProvider,
  SSRProvider,
  SearchBox,
  Select2 as Select,
  Skeleton,
  SkeletonContextProvider,
  SkeletonItem,
  Slider,
  SpinButton,
  Spinner,
  SplitButton,
  SplitNavItem,
  Subtitle1,
  Subtitle2,
  Subtitle2Stronger,
  SwatchPicker,
  SwatchPickerProvider,
  SwatchPickerRow,
  Switch,
  Tab2 as Tab,
  TabList,
  TabListProvider,
  Table,
  TableBody,
  TableCell,
  TableCellActions,
  TableCellLayout,
  TableContextProvider,
  TableHeader,
  TableHeaderCell,
  TableHeaderContextProvider,
  TableResizeHandle,
  TableRow,
  TableRowIdContextProvider,
  TableSelectionCell,
  Tag,
  TagGroup,
  TagPicker,
  TagPickerButton,
  TagPickerControl,
  TagPickerGroup,
  TagPickerInput,
  TagPickerList,
  TagPickerOption,
  TagPickerOptionGroup,
  TeachingPopover,
  TeachingPopoverBody,
  TeachingPopoverCarousel,
  TeachingPopoverCarouselCard,
  TeachingPopoverCarouselFooter,
  TeachingPopoverCarouselNav,
  TeachingPopoverCarouselNavButton,
  TeachingPopoverCarouselPageCount,
  TeachingPopoverFooter,
  TeachingPopoverHeader,
  TeachingPopoverSurface,
  TeachingPopoverTitle,
  TeachingPopoverTrigger,
  Text,
  Textarea,
  Title1,
  Title2,
  Title3,
  Toast,
  ToastBody,
  ToastFooter,
  ToastTitle,
  ToastTrigger,
  Toaster,
  ToggleButton,
  Toolbar,
  ToolbarButton,
  ToolbarDivider,
  ToolbarGroup,
  ToolbarRadioButton,
  ToolbarRadioGroup,
  ToolbarToggleButton,
  Tooltip,
  Tree,
  TreeItem,
  TreeItemLayout,
  TreeItemPersonaLayout,
  TreeItemProvider,
  TreeProvider,
  TreeRootReset,
  __css,
  __resetCSS,
  __resetStyles,
  __styles2 as __styles,
  accordionClassNames,
  accordionHeaderClassNames,
  accordionItemClassNames,
  accordionPanelClassNames,
  alphaSliderClassNames,
  appItemClassNames,
  appItemStaticClassNames,
  arrowHeights,
  assertSlots,
  avatarClassNames,
  avatarGroupClassNames,
  avatarGroupItemClassNames,
  avatarGroupPopoverClassNames,
  badgeClassNames,
  body1ClassNames,
  body1StrongClassNames,
  body1StrongerClassNames,
  body2ClassNames,
  breadcrumbButtonClassNames,
  breadcrumbClassNames,
  breadcrumbDividerClassNames,
  breadcrumbItemClassNames,
  buttonClassNames,
  caption1ClassNames,
  caption1StrongClassNames,
  caption1StrongerClassNames,
  caption2ClassNames,
  caption2StrongClassNames,
  cardCSSVars,
  cardClassNames,
  cardFooterClassNames,
  cardHeaderCSSVars,
  cardHeaderClassNames,
  cardPreviewClassNames,
  carouselAutoplayButtonClassNames,
  carouselButtonClassNames,
  carouselCardClassNames,
  carouselClassNames,
  carouselContextDefaultValue2 as carouselContextDefaultValue,
  carouselNavButtonClassNames,
  carouselNavClassNames,
  carouselNavContainerClassNames,
  carouselNavImageButtonClassNames,
  carouselSliderClassNames,
  carouselViewportClassNames,
  checkboxClassNames,
  colorAreaClassNames,
  colorPickerClassNames,
  colorSliderClassNames,
  colorSwatchClassNames,
  comboboxClassNames,
  compoundButtonClassNames,
  counterBadgeClassNames,
  createCSSRuleFromTheme,
  createCustomFocusIndicatorStyle,
  createDOMRenderer,
  createDarkTheme,
  createFocusOutlineStyle,
  createHighContrastTheme,
  createLightTheme,
  createMotionComponent,
  createPresenceComponent,
  createPresenceComponentVariant,
  createTableColumn,
  createTeamsDarkTheme,
  dataGridBodyClassNames,
  dataGridCellClassNames,
  dataGridClassNames,
  dataGridHeaderCellClassNames,
  dataGridHeaderClassNames,
  dataGridRowClassNames,
  dataGridSelectionCellClassNames,
  dialogActionsClassNames,
  dialogBodyClassNames,
  dialogContentClassNames,
  dialogSurfaceClassNames,
  dialogTitleClassNames,
  displayClassNames,
  dividerClassNames,
  drawerBodyClassNames,
  drawerFooterClassNames,
  drawerHeaderClassNames,
  drawerHeaderNavigationClassNames,
  drawerHeaderTitleClassNames,
  dropdownClassNames,
  emptySwatchClassNames,
  fieldClassNames,
  flatTreeClassNames,
  flattenTree_unstable,
  fluentProviderClassNames,
  getIntrinsicElementProps,
  getNativeElementProps,
  getPartitionedNativeProps,
  getSlotClassNameProp as getSlotClassNameProp_unstable,
  getSlots,
  hamburgerClassNames,
  imageClassNames,
  imageSwatchClassNames,
  infoButtonClassNames,
  infoLabelClassNames,
  inlineDrawerClassNames,
  inputClassNames,
  interactionTagClassNames,
  interactionTagPrimaryClassNames,
  interactionTagSecondaryClassNames,
  isHTMLElement,
  isTruncatableBreadcrumbContent,
  labelClassNames,
  largeTitleClassNames,
  linkClassNames,
  listClassNames,
  listItemClassNames,
  listboxClassNames,
  makeResetStyles,
  makeStaticStyles,
  makeStyles,
  menuButtonClassNames,
  menuDividerClassNames,
  menuGroupClassNames,
  menuGroupHeaderClassNames,
  menuItemCheckboxClassNames,
  menuItemClassNames,
  menuItemLinkClassNames,
  menuItemRadioClassNames,
  menuItemSwitchClassNames,
  menuListClassNames,
  menuPopoverClassNames,
  menuSplitGroupClassNames,
  mergeCallbacks,
  mergeClasses,
  messageBarActionsClassNames,
  messageBarBodyClassNames,
  messageBarClassNames,
  messageBarGroupClassNames,
  messageBarTitleClassNames,
  motionTokens,
  navCategoryItemClassNames,
  navClassNames,
  navDividerClassNames,
  navDrawerBodyClassNames,
  navDrawerClassNames,
  navDrawerFooterClassNames,
  navDrawerHeaderClassNames,
  navItemClassNames,
  navSectionHeaderClassNames,
  navSubItemClassNames,
  navSubItemGroupClassNames,
  optionClassNames,
  optionGroupClassNames,
  overlayDrawerClassNames,
  partitionAvatarGroupItems,
  partitionBreadcrumbItems,
  personaClassNames,
  popoverSurfaceClassNames,
  presenceAvailableFilled,
  presenceAvailableRegular,
  presenceAwayFilled,
  presenceAwayRegular,
  presenceBadgeClassNames,
  presenceBlockedRegular,
  presenceBusyFilled,
  presenceDndFilled,
  presenceDndRegular,
  presenceOfflineRegular,
  presenceOofRegular,
  presenceUnknownRegular,
  progressBarClassNames,
  radioClassNames,
  radioGroupClassNames,
  ratingClassNames,
  ratingDisplayClassNames,
  ratingItemClassNames,
  renderAccordionHeader_unstable,
  renderAccordionItem_unstable,
  renderAccordionPanel_unstable,
  renderAccordion_unstable,
  renderAlphaSlider_unstable,
  renderAppItemStatic_unstable,
  renderAppItem_unstable,
  renderAriaLiveAnnouncer_unstable,
  renderAvatarGroupItem_unstable,
  renderAvatarGroupPopover_unstable,
  renderAvatarGroup_unstable,
  renderAvatar_unstable,
  renderBadge_unstable,
  renderBreadcrumbButton_unstable,
  renderBreadcrumbDivider_unstable,
  renderBreadcrumbItem_unstable,
  renderBreadcrumb_unstable,
  renderButton_unstable,
  renderCardFooter_unstable,
  renderCardHeader_unstable,
  renderCardPreview_unstable,
  renderCard_unstable,
  renderCarouselAutoplayButton_unstable,
  renderCarouselButton_unstable,
  renderCarouselCard_unstable,
  renderCarouselNavButton_unstable,
  renderCarouselNavContainer_unstable,
  renderCarouselNavImageButton_unstable,
  renderCarouselNav_unstable,
  renderCarouselSlider_unstable,
  renderCarouselViewport_unstable,
  renderCarousel_unstable,
  renderCheckbox_unstable,
  renderColorArea_unstable,
  renderColorPicker_unstable,
  renderColorSlider_unstable,
  renderColorSwatch_unstable,
  renderCombobox_unstable,
  renderCompoundButton_unstable,
  renderDataGridBody_unstable,
  renderDataGridCell_unstable,
  renderDataGridHeaderCell_unstable,
  renderDataGridHeader_unstable,
  renderDataGridRow_unstable,
  renderDataGridSelectionCell_unstable,
  renderDataGrid_unstable,
  renderDialogActions_unstable,
  renderDialogBody_unstable,
  renderDialogContent_unstable,
  renderDialogSurface_unstable,
  renderDialogTitle_unstable,
  renderDialogTrigger_unstable,
  renderDialog_unstable,
  renderDivider_unstable,
  renderDrawerBody_unstable,
  renderDrawerFooter_unstable,
  renderDrawerHeaderNavigation_unstable,
  renderDrawerHeaderTitle_unstable,
  renderDrawerHeader_unstable,
  renderDrawer_unstable,
  renderDropdown_unstable,
  renderEmptySwatch_unstable,
  renderField_unstable,
  renderFlatTree_unstable,
  renderFluentProvider_unstable,
  renderImageSwatch_unstable,
  renderImage_unstable,
  renderInfoButton_unstable,
  renderInfoLabel_unstable,
  renderInlineDrawer_unstable,
  renderInput_unstable,
  renderInteractionTagPrimary_unstable,
  renderInteractionTagSecondary_unstable,
  renderInteractionTag_unstable,
  renderLabel_unstable,
  renderLink_unstable,
  renderListItem_unstable,
  renderList_unstable,
  renderListbox_unstable,
  renderMenuButton_unstable,
  renderMenuDivider_unstable,
  renderMenuGroupHeader_unstable,
  renderMenuGroup_unstable,
  renderMenuItemCheckbox_unstable,
  renderMenuItemLink_unstable,
  renderMenuItemRadio_unstable,
  renderMenuItemSwitch_unstable,
  renderMenuItem_unstable,
  renderMenuList_unstable,
  renderMenuPopover_unstable,
  renderMenuSplitGroup_unstable,
  renderMenuTrigger_unstable,
  renderMenu_unstable,
  renderMessageBarActions_unstable,
  renderMessageBarBody_unstable,
  renderMessageBarGroup_unstable,
  renderMessageBarTitle_unstable,
  renderMessageBar_unstable,
  renderNavCategoryItem_unstable,
  renderNavCategory_unstable,
  renderNavDrawer_unstable,
  renderNavItem_unstable,
  renderNavSectionHeader_unstable,
  renderNavSubItemGroup_unstable,
  renderNavSubItem_unstable,
  renderNav_unstable,
  renderOptionGroup_unstable,
  renderOption_unstable,
  renderOverlayDrawer_unstable,
  renderPersona_unstable,
  renderPopoverSurface_unstable,
  renderPopoverTrigger_unstable,
  renderPopover_unstable,
  renderPortal_unstable,
  renderProgressBar_unstable,
  renderRadioGroup_unstable,
  renderRadio_unstable,
  renderRatingDisplay_unstable,
  renderRatingItem_unstable,
  renderRating_unstable,
  renderSearchBox_unstable,
  renderSelect_unstable,
  renderSkeletonItem_unstable,
  renderSkeleton_unstable,
  renderSlider_unstable,
  renderSpinButton_unstable,
  renderSpinner_unstable,
  renderSplitButton_unstable,
  renderSplitNavItem_unstable,
  renderSwatchPickerGrid,
  renderSwatchPickerRow_unstable,
  renderSwatchPicker_unstable,
  renderSwitch_unstable,
  renderTabList_unstable,
  renderTab_unstable,
  renderTableBody_unstable,
  renderTableCellActions_unstable,
  renderTableCellLayout_unstable,
  renderTableCell_unstable,
  renderTableHeaderCell_unstable,
  renderTableHeader_unstable,
  renderTableResizeHandle_unstable,
  renderTableRow_unstable,
  renderTableSelectionCell_unstable,
  renderTable_unstable,
  renderTagGroup_unstable,
  renderTagPickerButton_unstable,
  renderTagPickerControl_unstable,
  renderTagPickerGroup_unstable,
  renderTagPickerInput_unstable,
  renderTagPickerList_unstable,
  renderTagPickerOptionGroup,
  renderTagPickerOption_unstable,
  renderTagPicker_unstable,
  renderTag_unstable,
  renderTeachingPopoverBody_unstable,
  renderTeachingPopoverCarouselCard_unstable,
  renderTeachingPopoverCarouselFooter_unstable,
  renderTeachingPopoverCarouselNavButton_unstable,
  renderTeachingPopoverCarouselNav_unstable,
  renderTeachingPopoverCarouselPageCount_unstable,
  renderTeachingPopoverCarousel_unstable,
  renderTeachingPopoverFooter_unstable,
  renderTeachingPopoverHeader_unstable,
  renderTeachingPopoverSurface_unstable,
  renderTeachingPopoverTitle_unstable,
  renderTeachingPopoverTrigger_unstable,
  renderTeachingPopover_unstable,
  renderText_unstable,
  renderTextarea_unstable,
  renderToStyleElements,
  renderToastBody_unstable,
  renderToastFooter_unstable,
  renderToastTitle_unstable,
  renderToastTrigger_unstable,
  renderToast_unstable,
  renderToaster_unstable,
  renderButton_unstable as renderToggleButton_unstable,
  renderToolbarGroup_unstable,
  renderToolbar_unstable,
  renderTooltip_unstable,
  renderTreeItemLayout_unstable,
  renderTreeItemPersonaLayout_unstable,
  renderTreeItem_unstable,
  renderTree_unstable,
  resetIdsForTests,
  resolvePositioningShorthand,
  resolveShorthand2 as resolveShorthand,
  searchBoxClassNames,
  selectClassNames,
  shorthands,
  skeletonClassNames,
  skeletonItemClassNames,
  sliderCSSVars,
  sliderClassNames,
  slot_exports as slot,
  spinButtonClassNames,
  spinnerClassNames,
  splitButtonClassNames,
  splitNavItemClassNames,
  subtitle1ClassNames,
  subtitle2ClassNames,
  subtitle2StrongerClassNames,
  swatchCSSVars,
  swatchPickerClassNames,
  swatchPickerContextDefaultValue,
  swatchPickerRowClassNames,
  switchClassNames,
  tabClassNames,
  tabListClassNames,
  tableBodyClassName,
  tableBodyClassNames,
  tableCellActionsClassNames,
  tableCellClassName,
  tableCellClassNames,
  tableCellLayoutClassNames,
  tableClassName,
  tableClassNames,
  tableHeaderCellClassName,
  tableHeaderCellClassNames,
  tableHeaderClassName,
  tableHeaderClassNames,
  tableResizeHandleClassNames,
  tableRowClassName,
  tableRowClassNames,
  tableSelectionCellClassNames,
  tagClassNames,
  tagGroupClassNames,
  tagPickerButtonClassNames,
  tagPickerControlClassNames,
  tagPickerGroupClassNames,
  tagPickerInputClassNames,
  tagPickerListClassNames,
  tagPickerOptionClassNames,
  tagPickerOptionGroupClassNames,
  teachingPopoverBodyClassNames,
  teachingPopoverCarouselCardClassNames,
  teachingPopoverCarouselClassNames,
  teachingPopoverCarouselFooterClassNames,
  teachingPopoverCarouselNavButtonClassNames,
  teachingPopoverCarouselNavClassNames,
  teachingPopoverCarouselPageCountClassNames,
  teachingPopoverFooterClassNames,
  teachingPopoverHeaderClassNames,
  teachingPopoverSurfaceClassNames,
  teachingPopoverTitleClassNames,
  teamsDarkTheme,
  teamsDarkV21Theme,
  teamsHighContrastTheme,
  teamsLightTheme,
  teamsLightV21Theme,
  textClassNames,
  textareaClassNames,
  themeToTokensObject,
  title1ClassNames,
  title2ClassNames,
  title3ClassNames,
  toMountNodeProps,
  toastBodyClassNames,
  toastFooterClassNames,
  toastTitleClassNames,
  toasterClassNames,
  toggleButtonClassNames,
  tokens,
  toolbarClassNames,
  toolbarGroupClassNames,
  tooltipClassNames,
  treeClassNames,
  treeItemClassNames,
  treeItemLayoutClassNames,
  treeItemLevelToken,
  treeItemPersonaLayoutClassNames,
  truncateBreadcrumLongTooltip,
  truncateBreadcrumbLongName,
  typographyStyles,
  useAccordionContextValues_unstable,
  useAccordionContext_unstable,
  useAccordionHeaderContextValues_unstable,
  useAccordionHeaderStyles_unstable,
  useAccordionHeader_unstable,
  useAccordionItemContextValues_unstable,
  useAccordionItemContext_unstable,
  useAccordionItemStyles_unstable,
  useAccordionItem_unstable,
  useAccordionPanelStyles_unstable,
  useAccordionPanel_unstable,
  useAccordionStyles_unstable,
  useAccordion_unstable,
  useAlphaSliderStyles_unstable,
  useAlphaSlider_unstable,
  useAnimationFrame,
  useAnnounce,
  useAppItemStaticStyles_unstable,
  useAppItemStatic_unstable,
  useAppItemStyles_unstable,
  useAppItem_unstable,
  useAriaLiveAnnouncerContextValues_unstable,
  useAriaLiveAnnouncer_unstable,
  useArrowNavigationGroup,
  useAvatarGroupContextValues,
  useAvatarGroupContext_unstable,
  useAvatarGroupItemStyles_unstable,
  useAvatarGroupItem_unstable,
  useAvatarGroupPopoverContextValues_unstable,
  useAvatarGroupPopoverStyles_unstable,
  useAvatarGroupPopover_unstable,
  useAvatarGroupStyles_unstable,
  useAvatarGroup_unstable,
  useAvatarStyles_unstable,
  useAvatar_unstable,
  useBadgeStyles_unstable,
  useBadge_unstable,
  useBreadcrumbButtonStyles_unstable,
  useBreadcrumbButton_unstable,
  useBreadcrumbContext_unstable,
  useBreadcrumbDividerStyles_unstable,
  useBreadcrumbDivider_unstable,
  useBreadcrumbItemStyles_unstable,
  useBreadcrumbItem_unstable,
  useBreadcrumbStyles_unstable,
  useBreadcrumb_unstable,
  useButtonStyles_unstable,
  useButton_unstable,
  useCardFooterStyles_unstable,
  useCardFooter_unstable,
  useCardHeaderStyles_unstable,
  useCardHeader_unstable,
  useCardPreviewStyles_unstable,
  useCardPreview_unstable,
  useCardStyles_unstable,
  useCard_unstable,
  useCarouselAutoplayButtonStyles_unstable,
  useCarouselAutoplayButton_unstable,
  useCarouselButtonStyles_unstable,
  useCarouselButton_unstable,
  useCarouselCardStyles_unstable,
  useCarouselCard_unstable,
  useCarouselContext_unstable2 as useCarouselContext_unstable,
  useCarouselNavButtonStyles_unstable,
  useCarouselNavButton_unstable,
  useCarouselNavContainerStyles_unstable,
  useCarouselNavContainer_unstable,
  useCarouselNavImageButtonStyles_unstable,
  useCarouselNavImageButton_unstable,
  useCarouselNavStyles_unstable,
  useCarouselNav_unstable,
  useCarouselSliderStyles_unstable,
  useCarouselSlider_unstable,
  useCarouselStyles_unstable,
  useCarouselViewportStyles_unstable,
  useCarouselViewport_unstable,
  useCarousel_unstable2 as useCarousel_unstable,
  useCheckboxStyles_unstable,
  useCheckbox_unstable,
  useCheckmarkStyles_unstable,
  useColorAreaStyles_unstable,
  useColorArea_unstable,
  useColorPickerStyles_unstable,
  useColorPicker_unstable,
  useColorSliderStyles_unstable,
  useColorSlider_unstable,
  useColorSwatchStyles_unstable,
  useColorSwatch_unstable,
  useColumnIdContext,
  useComboboxContextValues,
  useComboboxFilter,
  useComboboxStyles_unstable,
  useCombobox_unstable,
  useCompoundButtonStyles_unstable,
  useCompoundButton_unstable,
  useCounterBadgeStyles_unstable,
  useCounterBadge_unstable,
  useDataGridBodyStyles_unstable,
  useDataGridBody_unstable,
  useDataGridCellStyles_unstable,
  useDataGridCell_unstable,
  useDataGridContextValues_unstable,
  useDataGridContext_unstable,
  useDataGridHeaderCellStyles_unstable,
  useDataGridHeaderCell_unstable,
  useDataGridHeaderStyles_unstable,
  useDataGridHeader_unstable,
  useDataGridRowStyles_unstable,
  useDataGridRow_unstable,
  useDataGridSelectionCellStyles_unstable,
  useDataGridSelectionCell_unstable,
  useDataGridStyles_unstable,
  useDataGrid_unstable,
  useDialogActionsStyles_unstable,
  useDialogActions_unstable,
  useDialogBodyStyles_unstable,
  useDialogBody_unstable,
  useDialogContentStyles_unstable,
  useDialogContent_unstable,
  useDialogContext_unstable,
  useDialogSurfaceContextValues_unstable,
  useDialogSurfaceContext_unstable,
  useDialogSurfaceStyles_unstable,
  useDialogSurface_unstable,
  useDialogTitleStyles_unstable,
  useDialogTitle_unstable,
  useDialogTrigger_unstable,
  useDialog_unstable,
  useDividerStyles_unstable,
  useDivider_unstable,
  useDrawerBodyStyles_unstable,
  useDrawerBody_unstable,
  useDrawerContextValue,
  useDrawerContext_unstable,
  useDrawerFooterStyles_unstable,
  useDrawerFooter_unstable,
  useDrawerHeaderNavigationStyles_unstable,
  useDrawerHeaderNavigation_unstable,
  useDrawerHeaderStyles_unstable,
  useDrawerHeaderTitleStyles_unstable,
  useDrawerHeaderTitle_unstable,
  useDrawerHeader_unstable,
  useDrawerStyles_unstable,
  useDrawer_unstable,
  useDropdownStyles_unstable,
  useDropdown_unstable,
  useEmptySwatchStyles_unstable,
  useEmptySwatch_unstable,
  useEventCallback,
  useFieldContextValues_unstable,
  useFieldContext_unstable,
  useFieldControlProps_unstable,
  useFieldStyles_unstable,
  useField_unstable,
  useFlatTreeContextValues_unstable,
  useFlatTreeStyles_unstable,
  useFlatTree_unstable,
  useFluent,
  useFluentProviderContextValues_unstable,
  useFluentProviderStyles_unstable,
  useFluentProviderThemeStyleTag,
  useFluentProvider_unstable,
  useFocusFinders,
  useFocusObserved,
  useFocusVisible,
  useFocusWithin,
  useFocusableGroup,
  useHamburgerStyles_unstable,
  useHamburger_unstable,
  useHeadlessFlatTree_unstable,
  useId2 as useId,
  useImageStyles_unstable,
  useImageSwatchStyles_unstable,
  useImageSwatch_unstable,
  useImage_unstable,
  useInfoButtonStyles_unstable,
  useInfoButton_unstable,
  useInfoLabelStyles_unstable,
  useInfoLabel_unstable,
  useInlineDrawerStyles_unstable,
  useInlineDrawer_unstable,
  useInputStyles_unstable,
  useInput_unstable,
  useInteractionTagContextValues_unstable,
  useInteractionTagPrimaryStyles_unstable,
  useInteractionTagPrimary_unstable,
  useInteractionTagSecondaryStyles_unstable,
  useInteractionTagSecondary_unstable,
  useInteractionTagStyles_unstable,
  useInteractionTag_unstable,
  useIsInTableHeader,
  useIsOverflowGroupVisible,
  useIsOverflowItemVisible,
  useIsSSR,
  useIsomorphicLayoutEffect,
  useKeyboardNavAttribute,
  useLabelStyles_unstable,
  useLabel_unstable,
  useLinkState_unstable,
  useLinkStyles_unstable,
  useLink_unstable,
  useListItemStyles_unstable,
  useListItem_unstable,
  useListStyles_unstable,
  useList_unstable,
  useListboxContextValues,
  useListboxContext_unstable,
  useListboxStyles_unstable,
  useListbox_unstable,
  useMenuButtonStyles_unstable,
  useMenuButton_unstable,
  useMenuContextValues_unstable,
  useMenuContext_unstable,
  useMenuDividerStyles_unstable,
  useMenuDivider_unstable,
  useMenuGroupContextValues_unstable,
  useMenuGroupContext_unstable,
  useMenuGroupHeaderStyles_unstable,
  useMenuGroupHeader_unstable,
  useMenuGroupStyles_unstable,
  useMenuGroup_unstable,
  useMenuItemCheckboxStyles_unstable,
  useMenuItemCheckbox_unstable,
  useMenuItemLinkStyles_unstable,
  useMenuItemLink_unstable,
  useMenuItemRadioStyles_unstable,
  useMenuItemRadio_unstable,
  useMenuItemStyles_unstable,
  useMenuItemSwitchStyles_unstable,
  useMenuItemSwitch_unstable,
  useMenuItem_unstable,
  useMenuListContextValues_unstable,
  useMenuListContext_unstable,
  useMenuListStyles_unstable,
  useMenuList_unstable,
  useMenuPopoverStyles_unstable,
  useMenuPopover_unstable,
  useMenuSplitGroupStyles_unstable,
  useMenuSplitGroup_unstable,
  useMenuTriggerContext_unstable,
  useMenuTrigger_unstable,
  useMenu_unstable,
  useMergedRefs,
  useMessageBarActionsContextValue_unstable,
  useMessageBarActionsStyles_unstable,
  useMessageBarActions_unstable,
  useMessageBarBodyStyles_unstable,
  useMessageBarBody_unstable,
  useMessageBarContext,
  useMessageBarContextValue_unstable,
  useMessageBarGroupStyles_unstable,
  useMessageBarGroup_unstable,
  useMessageBarStyles_unstable,
  useMessageBarTitleStyles_unstable,
  useMessageBarTitle_unstable,
  useMessageBar_unstable,
  useModalAttributes,
  useNavCategoryContextValues_unstable,
  useNavCategoryContext_unstable,
  useNavCategoryItemContextValues_unstable,
  useNavCategoryItemContext_unstable,
  useNavCategoryItemStyles_unstable,
  useNavCategoryItem_unstable,
  useNavCategory_unstable,
  useNavContextValues_unstable,
  useNavContext_unstable,
  useNavDividerStyles_unstable,
  useNavDivider_unstable,
  useNavDrawerBodyStyles_unstable,
  useNavDrawerBody_unstable,
  useNavDrawerFooterStyles_unstable,
  useNavDrawerFooter_unstable,
  useNavDrawerHeaderStyles_unstable,
  useNavDrawerHeader_unstable,
  useNavDrawerStyles_unstable,
  useNavDrawer_unstable,
  useNavItemStyles_unstable,
  useNavItem_unstable,
  useNavSectionHeaderStyles_unstable,
  useNavSectionHeader_unstable,
  useNavStyles_unstable,
  useNavSubItemGroupStyles_unstable,
  useNavSubItemGroup_unstable,
  useNavSubItemStyles_unstable,
  useNavSubItem_unstable,
  useNav_unstable,
  useObservedElement,
  useOptionGroupStyles_unstable,
  useOptionGroup_unstable,
  useOptionStyles_unstable,
  useOption_unstable,
  useOverflowCount,
  useOverflowMenu,
  useOverflowVisibility,
  useOverlayDrawerStyles_unstable,
  useOverlayDrawer_unstable,
  usePersonaStyles_unstable,
  usePersona_unstable,
  usePopoverContext_unstable,
  usePopoverSurfaceStyles_unstable,
  usePopoverSurface_unstable,
  usePopoverTrigger_unstable,
  usePopover_unstable,
  usePortalMountNode,
  usePortal_unstable,
  usePositioning,
  usePresenceBadgeStyles_unstable,
  usePresenceBadge_unstable,
  useProgressBarStyles_unstable,
  useProgressBar_unstable,
  useRadioGroupContextValue_unstable,
  useRadioGroupContextValues,
  useRadioGroupContext_unstable,
  useRadioGroupStyles_unstable,
  useRadioGroup_unstable,
  useRadioStyles_unstable,
  useRadio_unstable,
  useRatingContextValues,
  useRatingDisplayContextValues,
  useRatingDisplayStyles_unstable,
  useRatingDisplay_unstable,
  useRatingItemContextValue_unstable,
  useRatingItemStyles_unstable,
  useRatingItem_unstable,
  useRatingStyles_unstable,
  useRating_unstable,
  useRestoreFocusSource,
  useRestoreFocusTarget,
  useSafeZoneArea,
  useScrollbarWidth,
  useSearchBoxStyles_unstable,
  useSearchBox_unstable,
  useSelectStyles_unstable,
  useSelect_unstable,
  useSelection,
  useSkeletonContext,
  useSkeletonItemStyles_unstable,
  useSkeletonItem_unstable,
  useSkeletonStyles_unstable,
  useSkeleton_unstable,
  useSliderState_unstable,
  useSliderStyles_unstable,
  useSlider_unstable,
  useSpinButtonStyles_unstable,
  useSpinButton_unstable,
  useSpinnerStyles_unstable,
  useSpinner_unstable,
  useSplitButtonStyles_unstable,
  useSplitButton_unstable,
  useSplitNavItemStyles_unstable,
  useSplitNavItem_unstable,
  useSubtreeContext_unstable,
  useSwatchPickerContextValue_unstable,
  useSwatchPickerContextValues,
  useSwatchPickerRowStyles_unstable,
  useSwatchPickerRow_unstable,
  useSwatchPickerStyles_unstable,
  useSwatchPicker_unstable,
  useSwitchStyles_unstable,
  useSwitch_unstable,
  useTabListContextValues_unstable,
  useTabListContext_unstable,
  useTabListStyles_unstable,
  useTabList_unstable,
  useTabStyles_unstable,
  useTab_unstable,
  useTableBodyStyles_unstable,
  useTableBody_unstable,
  useTableCellActionsStyles_unstable,
  useTableCellActions_unstable,
  useTableCellLayoutStyles_unstable,
  useTableCellLayout_unstable,
  useTableCellStyles_unstable,
  useTableCell_unstable,
  useTableColumnSizing_unstable,
  useTableCompositeNavigation,
  useTableContext,
  useTableFeatures,
  useTableHeaderCellStyles_unstable,
  useTableHeaderCell_unstable,
  useTableHeaderStyles_unstable,
  useTableHeader_unstable,
  useTableResizeHandleStyles_unstable,
  useTableResizeHandle_unstable,
  useTableRowIdContext,
  useTableRowStyles_unstable,
  useTableRow_unstable,
  useTableSelection,
  useTableSelectionCellStyles_unstable,
  useTableSelectionCell_unstable,
  useTableSort,
  useTableStyles_unstable,
  useTable_unstable,
  useTagAvatarContextValues_unstable,
  useTagGroupContextValues_unstable,
  useTagGroupStyles_unstable,
  useTagGroup_unstable,
  useTagPickerButtonStyles_unstable,
  useTagPickerButton_unstable,
  useTagPickerContext_unstable,
  useTagPickerControlStyles_unstable,
  useTagPickerControl_unstable,
  useTagPickerFilter,
  useTagPickerGroupStyles_unstable,
  useTagPickerGroup_unstable,
  useTagPickerInputStyles_unstable,
  useTagPickerInput_unstable,
  useTagPickerListStyles_unstable,
  useTagPickerList_unstable,
  useTagPickerOptionGroup,
  useTagPickerOptionGroupStyles,
  useTagPickerOptionStyles_unstable,
  useTagPickerOption_unstable,
  useTagPicker_unstable,
  useTagStyles_unstable,
  useTag_unstable,
  useTeachingPopoverBodyStyles_unstable,
  useTeachingPopoverBody_unstable,
  useTeachingPopoverCarouselCardStyles_unstable,
  useTeachingPopoverCarouselCard_unstable,
  useTeachingPopoverCarouselContextValues_unstable,
  useTeachingPopoverCarouselFooterStyles_unstable,
  useTeachingPopoverCarouselFooter_unstable,
  useTeachingPopoverCarouselNavButtonStyles_unstable,
  useTeachingPopoverCarouselNavButton_unstable,
  useTeachingPopoverCarouselNavStyles_unstable,
  useTeachingPopoverCarouselNav_unstable,
  useTeachingPopoverCarouselPageCountStyles_unstable,
  useTeachingPopoverCarouselPageCount_unstable,
  useTeachingPopoverCarouselStyles_unstable,
  useTeachingPopoverCarousel_unstable,
  useTeachingPopoverFooter_unstable,
  useTeachingPopoverHeaderStyles_unstable,
  useTeachingPopoverHeader_unstable,
  useTeachingPopoverSurfaceStyles_unstable,
  useTeachingPopoverSurface_unstable,
  useTeachingPopoverTitleStyles_unstable,
  useTeachingPopoverTitle_unstable,
  useTeachingPopoverTrigger_unstable,
  useTeachingPopover_unstable,
  useTextStyles_unstable,
  useText_unstable,
  useTextareaStyles_unstable,
  useTextarea_unstable,
  useThemeClassName,
  useTimeout,
  useToastBodyStyles_unstable,
  useToastBody_unstable,
  useToastController,
  useToastFooterStyles_unstable,
  useToastFooter_unstable,
  useToastStyles_unstable,
  useToastTitleStyles_unstable,
  useToastTitle_unstable,
  useToastTrigger_unstable,
  useToast_unstable,
  useToasterStyles_unstable,
  useToaster_unstable,
  useToggleButtonStyles_unstable,
  useToggleButton_unstable,
  useToggleState,
  useToolbarButtonStyles_unstable,
  useToolbarButton_unstable,
  useToolbarDividerStyles_unstable,
  useToolbarDivider_unstable,
  useToolbarGroupStyles_unstable,
  useToolbarGroup_unstable,
  useToolbarRadioButtonStyles_unstable,
  useToolbarRadioButton_unstable,
  useToolbarStyles_unstable,
  useToolbarToggleButtonStyles_unstable,
  useToolbarToggleButton_unstable,
  useToolbar_unstable,
  useTooltipStyles_unstable,
  useTooltipVisibility,
  useTooltip_unstable,
  useTreeContextValues_unstable,
  useTreeContext_unstable,
  useTreeItemContextValues_unstable,
  useTreeItemContext_unstable,
  useTreeItemLayoutStyles_unstable,
  useTreeItemLayout_unstable,
  useTreeItemPersonaLayoutStyles_unstable,
  useTreeItemPersonaLayout_unstable,
  useTreeItemStyles_unstable,
  useTreeItem_unstable,
  useTreeStyles_unstable,
  useTree_unstable,
  useTypingAnnounce,
  useUncontrolledFocus,
  webDarkTheme,
  webLightTheme
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v17.0.2
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

keyborg/dist/esm/index.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

@fluentui/react-tabster/lib/tabster-types-6.0.1-do-not-use.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)
*/
//# sourceMappingURL=@fluentui_react-components.js.map
